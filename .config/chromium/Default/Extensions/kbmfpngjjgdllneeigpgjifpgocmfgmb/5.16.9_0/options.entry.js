/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 265);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var before=__webpack_require__(146);function once(func){return before(2,func);}module.exports=once;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache=__webpack_require__(147);var FUNC_ERROR_TEXT='Expected a function';function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}memoize.Cache=MapCache;module.exports=memoize;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('flow',__webpack_require__(194));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var isObject=__webpack_require__(10),now=__webpack_require__(151),toNumber=__webpack_require__(96);var FUNC_ERROR_TEXT='Expected a function';var nativeMax=Math.max,nativeMin=Math.min;function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){lastInvokeTime=time;timerId=setTimeout(timerExpired,wait);return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}module.exports=debounce;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

var isArray=Array.isArray;module.exports=isArray;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(15),pullAll=__webpack_require__(148);var pull=baseRest(pullAll);module.exports=pull;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}module.exports=last;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports={};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?module.exports=n():undefined;}(this,function(){"use strict";var t="millisecond",n="second",e="minute",i="hour",r="day",s="week",u="month",a="quarter",o="year",h=/^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,f=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,n,e){var i=String(t);return!i||i.length>=n?t:""+Array(n+1-i.length).join(e)+t;},$={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},l="en",m={};m[l]=$;var y=function(t){return t instanceof S;},M=function(t,n,e){var i;if(!t)return null;if("string"==typeof t)m[t]&&(i=t),n&&(m[t]=n,i=t);else{var r=t.name;m[r]=t,i=r;}return e||(l=i),i;},g=function(t,n,e){if(y(t))return t.clone();var i=n?"string"==typeof n?{format:n,pl:e}:n:{};return i.date=t,new S(i);},D={s:c,z:function(t){var n=-t.utcOffset(),e=Math.abs(n),i=Math.floor(e/60);return(n<=0?"+":"-")+c(i,2,"0")+":"+c(e%60,2,"0");},m:function(t,n){var e=12*(n.year()-t.year())+(n.month()-t.month()),i=t.clone().add(e,u),r=n-i<0,s=t.clone().add(e+(r?-1:1),u);return Number(-(e+(n-i)/(r?i-s:s-i))||0);},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t);},p:function(h){return{M:u,y:o,w:s,d:r,h:i,m:e,s:n,ms:t,Q:a}[h]||String(h||"").toLowerCase().replace(/s$/,"");},u:function(t){return void 0===t;}};D.l=M,D.i=y,D.w=function(t,n){return g(t,{locale:n.$L,utc:n.$u});};var S=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0)||l,this.parse(t);}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var n=t.date,e=t.utc;if(null===n)return new Date(NaN);if(D.u(n))return new Date();if(n instanceof Date)return new Date(n);if("string"==typeof n&&!/Z$/i.test(n)){var i=n.match(h);if(i)return e?new Date(Date.UTC(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0)):new Date(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0);}return new Date(n);}(t),this.init();},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},d.$utils=function(){return D;},d.isValid=function(){return!("Invalid Date"===this.$d.toString());},d.isSame=function(t,n){var e=g(t);return this.startOf(n)<=e&&e<=this.endOf(n);},d.isAfter=function(t,n){return g(t)<this.startOf(n);},d.isBefore=function(t,n){return this.endOf(n)<g(t);},d.$g=function(t,n,e){return D.u(t)?this[n]:this.set(e,t);},d.year=function(t){return this.$g(t,"$y",o);},d.month=function(t){return this.$g(t,"$M",u);},d.day=function(t){return this.$g(t,"$W",r);},d.date=function(t){return this.$g(t,"$D","date");},d.hour=function(t){return this.$g(t,"$H",i);},d.minute=function(t){return this.$g(t,"$m",e);},d.second=function(t){return this.$g(t,"$s",n);},d.millisecond=function(n){return this.$g(n,"$ms",t);},d.unix=function(){return Math.floor(this.valueOf()/1e3);},d.valueOf=function(){return this.$d.getTime();},d.startOf=function(t,a){var h=this,f=!!D.u(a)||a,c=D.p(t),d=function(t,n){var e=D.w(h.$u?Date.UTC(h.$y,n,t):new Date(h.$y,n,t),h);return f?e:e.endOf(r);},$=function(t,n){return D.w(h.toDate()[t].apply(h.toDate(),(f?[0,0,0,0]:[23,59,59,999]).slice(n)),h);},l=this.$W,m=this.$M,y=this.$D,M="set"+(this.$u?"UTC":"");switch(c){case o:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,S=(l<g?l+7:l)-g;return d(f?y-S:y+(6-S),m);case r:case"date":return $(M+"Hours",0);case i:return $(M+"Minutes",1);case e:return $(M+"Seconds",2);case n:return $(M+"Milliseconds",3);default:return this.clone();}},d.endOf=function(t){return this.startOf(t,!1);},d.$set=function(s,a){var h,f=D.p(s),c="set"+(this.$u?"UTC":""),d=(h={},h[r]=c+"Date",h.date=c+"Date",h[u]=c+"Month",h[o]=c+"FullYear",h[i]=c+"Hours",h[e]=c+"Minutes",h[n]=c+"Seconds",h[t]=c+"Milliseconds",h)[f],$=f===r?this.$D+(a-this.$W):a;if(f===u||f===o){var l=this.clone().set("date",1);l.$d[d]($),l.init(),this.$d=l.set("date",Math.min(this.$D,l.daysInMonth())).toDate();}else d&&this.$d[d]($);return this.init(),this;},d.set=function(t,n){return this.clone().$set(t,n);},d.get=function(t){return this[D.p(t)]();},d.add=function(t,a){var h,f=this;t=Number(t);var c=D.p(a),d=function(n){var e=new Date(f.$d);return e.setDate(e.getDate()+n*t),D.w(e,f);};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===r)return d(1);if(c===s)return d(7);var $=(h={},h[e]=6e4,h[i]=36e5,h[n]=1e3,h)[c]||1,l=this.valueOf()+t*$;return D.w(l,this);},d.subtract=function(t,n){return this.add(-1*t,n);},d.format=function(t){var n=this;if(!this.isValid())return"Invalid Date";var i=D.z(this),r=this.$locale(),s=r.weekdays,u=r.months,a=function(t,n,e,i){return t&&t[n]||e[n].substr(0,i);},o=function(t){return D.s(n.$H%12||12,t,"0");},h={YY:String(this.$y).slice(-2),YYYY:String(this.$y),M:String(this.$M+1),MM:D.s(this.$M+1,2,"0"),MMM:a(r.monthsShort,this.$M,u,3),MMMM:u[this.$M],D:String(this.$D),DD:D.s(this.$D,2,"0"),d:String(this.$W),dd:a(r.weekdaysMin,this.$W,s,2),ddd:a(r.weekdaysShort,this.$W,s,3),dddd:s[this.$W],H:String(this.$H),HH:D.s(this.$H,2,"0"),h:o(1),hh:o(2),a:this.$H<12?"am":"pm",A:this.$H<12?"AM":"PM",m:String(this.$m),mm:D.s(this.$m,2,"0"),s:String(this.$s),ss:D.s(this.$s,2,"0"),SSS:D.s(this.$ms,3,"0"),Z:i};return(t||"YYYY-MM-DDTHH:mm:ssZ").replace(f,function(t,n){return n||h[t]||i.replace(":","");});},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15);},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[o]=y/12,c[u]=y,c[a]=y/3,c[s]=(m-l)/6048e5,c[r]=(m-l)/864e5,c[i]=m/36e5,c[e]=m/6e4,c[n]=m/1e3,c)[d]||m,f?y:D.a(y);},d.daysInMonth=function(){return this.endOf(u).$D;},d.$locale=function(){return m[this.$L];},d.locale=function(t,n){if(!t)return this.$L;var e=this.clone();return e.$L=M(t,n,!0),e;},d.clone=function(){return D.w(this.toDate(),this);},d.toDate=function(){return new Date(this.$d);},d.toJSON=function(){return this.toISOString();},d.toISOString=function(){return this.$d.toISOString();},d.toString=function(){return this.$d.toUTCString();},c;}();return g.prototype=S.prototype,g.extend=function(t,n){return t(n,S,g),g;},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t);},g.en=m[l],g.Ls=m,g;});

/***/ }),
/* 10 */
/***/ (function(module, exports) {

function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}module.exports=isObject;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(47),baseOrderBy=__webpack_require__(217),baseRest=__webpack_require__(15),isIterateeCall=__webpack_require__(46);var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});module.exports=sortBy;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference=__webpack_require__(117),baseFlatten=__webpack_require__(47),baseRest=__webpack_require__(15),isArrayLikeObject=__webpack_require__(35);var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});module.exports=difference;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual=__webpack_require__(118);function isEqual(value,other){return baseIsEqual(value,other);}module.exports=isEqual;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys=__webpack_require__(115),getTag=__webpack_require__(73),isArguments=__webpack_require__(71),isArray=__webpack_require__(5),isArrayLike=__webpack_require__(74),isBuffer=__webpack_require__(66),isPrototype=__webpack_require__(234),isTypedArray=__webpack_require__(69);var mapTag='[object Map]',setTag='[object Set]';var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}module.exports=isEmpty;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var identity=__webpack_require__(93),overRest=__webpack_require__(94),setToString=__webpack_require__(95);function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}module.exports=baseRest;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var baseConvert=__webpack_require__(181),util=__webpack_require__(183);function convert(name,func,options){return baseConvert(util,name,func,options);}module.exports=convert;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(47);function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}module.exports=flatten;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('map',__webpack_require__(235));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('filter',__webpack_require__(243));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(26),createAggregator=__webpack_require__(70);var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});module.exports=groupBy;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(16),baseIteratee=__webpack_require__(4),basePickBy=__webpack_require__(112),getAllKeysIn=__webpack_require__(226);function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=baseIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}module.exports=pickBy;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

(function (window, $) {
  'use strict';

  var Pasteurizer = {};
  module.exports.Pasteurizer = Pasteurizer;
  var SCHEME_FILTER = /(:(?!$)|[^:a-z0-9\.\-\+])/ig;
  Pasteurizer.DEFAULT_CONFIG = {
    elemWhitelist: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'span', 'div', 'code', 'br', 'hr', 'p', 'a', 'img', 'pre', 'blockquote', 'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td', 'strong', 'em', 'i', 'b', 'u', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'font', 'center', 'small', 's', 'q', 'sub', 'sup', 'del'],
    attrWhitelist: ['title', 'colspan', 'rowspan', 'cellspacing', 'cellpadding', 'scope', 'face', 'color', 'size', 'bgcolor', 'align'],
    tagAttrWhitelist: {
      'img': ['src', 'alt'],
      'a': ['href']
    },
    schemeWhitelist: ['http:', 'https:', 'ftp:', 'mailto:', 'git:', 'steam:', 'irc:', 'news:', 'mumble:', 'ssh:', 'ircs:', 'ts3server:', ':'],
    hoistOrphanedContents: true,
    hoistBlacklist: ['script', 'style']
  };

  Pasteurizer.scrubNode = function (node, config) {
    var jNode = $(node);
    var nodeName = node.nodeName.toLowerCase();
    var nodeType = node.nodeType;
    var validNode = false;

    if (nodeType === 1) {
      validNode = config.elemWhitelist.indexOf(nodeName) !== -1;
    } else if (nodeType < 6 || nodeType === 9 || nodeType === 11) {
      validNode = true;
    }

    if (validNode && node.nodeType === 1) {
      if (nodeName === 'a') {
        if (node.protocol !== undefined) {
          var scrubbedProto = node.protocol.replace(SCHEME_FILTER, '');

          if (config.schemeWhitelist.indexOf(scrubbedProto) === -1 && scrubbedProto !== document.location.protocol) {
            validNode = false;
          }
        } else {
          throw 'Pasteurizer: a.protocol unsupported.';
        }
      }
    }

    if (validNode && node.nodeType === 1) {
      var attrs = $.map(node.attributes, function (attr) {
        return attr.nodeName;
      });
      attrs.forEach(function (attrName) {
        if (config.attrWhitelist.indexOf(attrName) !== -1) {
          return;
        }

        if (nodeName in config.tagAttrWhitelist && config.tagAttrWhitelist[nodeName].indexOf(attrName) !== -1) {
          return;
        }

        node.removeAttribute(attrName);
      });
    }

    var canHoist = config.hoistOrphanedContents && config.hoistBlacklist.indexOf(nodeName) === -1;

    if (!validNode && !canHoist) {
      jNode.remove();
      return;
    }

    jNode.contents().each(function (i, child) {
      Pasteurizer.scrubNode(child, config);
    });

    if (!validNode) {
      jNode.contents().detach().insertAfter(jNode);
      jNode.remove();
    }
  };

  Pasteurizer.safeParseHTML = function (html, config) {
    if (!config || $.isEmptyObject(config)) {
      config = Pasteurizer.DEFAULT_CONFIG;
    }

    var parser = new DOMParser();
    var parsed = parser.parseFromString(html, 'text/html');
    var body = $(parsed).find('body').first();
    body.contents().each(function (i, node) {
      Pasteurizer.scrubNode(node, config);
    });
    return body.contents();
  };
})(window, jQuery);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal=__webpack_require__(152);var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;var root=freeGlobal||freeSelf||Function('return this')();module.exports=root;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty=__webpack_require__(170);function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}module.exports=baseAssignValue;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(15),unzipWith=__webpack_require__(198);var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});module.exports=zipWith;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('keyBy',__webpack_require__(78));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var baseClamp=__webpack_require__(238),toNumber=__webpack_require__(96);function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}module.exports=clamp;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),baseUniq=__webpack_require__(77);function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,baseIteratee(iteratee,2)):[];}module.exports=uniqBy;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach=__webpack_require__(108),baseCreate=__webpack_require__(97),baseForOwn=__webpack_require__(64),baseIteratee=__webpack_require__(4),getPrototype=__webpack_require__(109),isArray=__webpack_require__(5),isBuffer=__webpack_require__(66),isFunction=__webpack_require__(67),isObject=__webpack_require__(10),isTypedArray=__webpack_require__(69);function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=baseIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}module.exports=transform;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(5),isKey=__webpack_require__(106),stringToPath=__webpack_require__(107),toString=__webpack_require__(61);function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}module.exports=castPath;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

function isObjectLike(value){return value!=null&&typeof value=='object';}module.exports=isObjectLike;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike=__webpack_require__(74),isObjectLike=__webpack_require__(34);function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}module.exports=isArrayLikeObject;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(26),baseForOwn=__webpack_require__(64),baseIteratee=__webpack_require__(4);function mapValues(object,iteratee){var result={};iteratee=baseIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}module.exports=mapValues;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var debounce=__webpack_require__(3),isObject=__webpack_require__(10);var FUNC_ERROR_TEXT='Expected a function';function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}module.exports=throttle;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var eq=__webpack_require__(89);function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}module.exports=assocIndexOf;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}module.exports=apply;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

function baseUnary(func){return function(value){return func(value);};}module.exports=baseUnary;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetData=__webpack_require__(153),createBind=__webpack_require__(154),createCurry=__webpack_require__(155),createHybrid=__webpack_require__(98),createPartial=__webpack_require__(160),getData=__webpack_require__(105),mergeData=__webpack_require__(161),setData=__webpack_require__(101),setWrapToString=__webpack_require__(102),toInteger=__webpack_require__(32);var FUNC_ERROR_TEXT='Expected a function';var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64;var nativeMax=Math.max;function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}module.exports=createWrap;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate=__webpack_require__(97),isObject=__webpack_require__(10);function createCtor(Ctor){return function(){var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);return isObject(result)?result:thisBinding;};}module.exports=createCtor;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

var MAX_SAFE_INTEGER=9007199254740991;var reIsUint=/^(?:0|[1-9]\d*)$/;function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}module.exports=isIndex;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

function overArg(func,transform){return function(arg){return func(transform(arg));};}module.exports=overArg;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush=__webpack_require__(178),isFlattenable=__webpack_require__(179);function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}module.exports=baseFlatten;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(5);function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}module.exports=castArray;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf=__webpack_require__(59);function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}module.exports=arrayIncludes;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(41);var WRAP_CURRY_RIGHT_FLAG=16;function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}curryRight.placeholder={};module.exports=curryRight;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),basePullAt=__webpack_require__(162);function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=baseIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}module.exports=remove;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum=__webpack_require__(239),baseGt=__webpack_require__(240),baseIteratee=__webpack_require__(4);function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,baseIteratee(iteratee,2),baseGt):undefined;}module.exports=maxBy;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('sortBy',__webpack_require__(11));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}module.exports=compact;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference=__webpack_require__(117),baseRest=__webpack_require__(15),isArrayLikeObject=__webpack_require__(35);var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});module.exports=without;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(16),baseIntersection=__webpack_require__(244),baseRest=__webpack_require__(15),castArrayLikeObject=__webpack_require__(245);var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});module.exports=intersection;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(26),baseForOwn=__webpack_require__(64),baseIteratee=__webpack_require__(4);function mapKeys(object,iteratee){var result={};iteratee=baseIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}module.exports=mapKeys;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}module.exports=strictIndexOf;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}module.exports=copyArray;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(33),toKey=__webpack_require__(25);function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}module.exports=baseGet;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}module.exports=baseSlice;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor=__webpack_require__(166),keys=__webpack_require__(65);function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}module.exports=baseForOwn;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(45);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(68),isObject=__webpack_require__(10);var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';function isFunction(value){if(!isObject(value)){return false;}var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}module.exports=isFunction;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

var objectProto=Object.prototype;var nativeObjectToString=objectProto.toString;function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var arrayAggregator=__webpack_require__(168),baseAggregator=__webpack_require__(169),baseIteratee=__webpack_require__(4),isArray=__webpack_require__(5);function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,baseIteratee(iteratee,2),accumulator);};}module.exports=createAggregator;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var flatten=__webpack_require__(18),overRest=__webpack_require__(94),setToString=__webpack_require__(95);function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}module.exports=flatRest;

/***/ }),
/* 73 */
/***/ (function(module, exports) {

var objectProto=Object.prototype;var nativeObjectToString=objectProto.toString;function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction=__webpack_require__(67),isLength=__webpack_require__(114);function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}module.exports=isArrayLike;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf=__webpack_require__(59);function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}module.exports=arrayIncludes;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}module.exports=arrayIncludesWith;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(49),arrayIncludes=__webpack_require__(75),arrayIncludesWith=__webpack_require__(76),cacheHas=__webpack_require__(50),createSet=__webpack_require__(241),setToArray=__webpack_require__(242);var LARGE_ARRAY_SIZE=200;function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}module.exports=baseUniq;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(26),createAggregator=__webpack_require__(70);var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});module.exports=keyBy;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

function head(array){return array&&array.length?array[0]:undefined;}module.exports=head;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var createAggregator=__webpack_require__(70);var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});module.exports=partition;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function(Math){var trimLeft=/^\s+/,trimRight=/\s+$/,tinyCounter=0,mathRound=Math.round,mathMin=Math.min,mathMax=Math.max,mathRandom=Math.random;function tinycolor(color,opts){color=color?color:'';opts=opts||{};if(color instanceof tinycolor){return color;}if(!(this instanceof tinycolor)){return new tinycolor(color,opts);}var rgb=inputToRGB(color);this._originalInput=color,this._r=rgb.r,this._g=rgb.g,this._b=rgb.b,this._a=rgb.a,this._roundA=mathRound(100*this._a)/100,this._format=opts.format||rgb.format;this._gradientType=opts.gradientType;if(this._r<1){this._r=mathRound(this._r);}if(this._g<1){this._g=mathRound(this._g);}if(this._b<1){this._b=mathRound(this._b);}this._ok=rgb.ok;this._tc_id=tinyCounter++;}tinycolor.prototype={isDark:function(){return this.getBrightness()<128;},isLight:function(){return!this.isDark();},isValid:function(){return this._ok;},getOriginalInput:function(){return this._originalInput;},getFormat:function(){return this._format;},getAlpha:function(){return this._a;},getBrightness:function(){var rgb=this.toRgb();return(rgb.r*299+rgb.g*587+rgb.b*114)/1000;},getLuminance:function(){var rgb=this.toRgb();var RsRGB,GsRGB,BsRGB,R,G,B;RsRGB=rgb.r/255;GsRGB=rgb.g/255;BsRGB=rgb.b/255;if(RsRGB<=0.03928){R=RsRGB/12.92;}else{R=Math.pow((RsRGB+0.055)/1.055,2.4);}if(GsRGB<=0.03928){G=GsRGB/12.92;}else{G=Math.pow((GsRGB+0.055)/1.055,2.4);}if(BsRGB<=0.03928){B=BsRGB/12.92;}else{B=Math.pow((BsRGB+0.055)/1.055,2.4);}return 0.2126*R+0.7152*G+0.0722*B;},setAlpha:function(value){this._a=boundAlpha(value);this._roundA=mathRound(100*this._a)/100;return this;},toHsv:function(){var hsv=rgbToHsv(this._r,this._g,this._b);return{h:hsv.h*360,s:hsv.s,v:hsv.v,a:this._a};},toHsvString:function(){var hsv=rgbToHsv(this._r,this._g,this._b);var h=mathRound(hsv.h*360),s=mathRound(hsv.s*100),v=mathRound(hsv.v*100);return this._a==1?"hsv("+h+", "+s+"%, "+v+"%)":"hsva("+h+", "+s+"%, "+v+"%, "+this._roundA+")";},toHsl:function(){var hsl=rgbToHsl(this._r,this._g,this._b);return{h:hsl.h*360,s:hsl.s,l:hsl.l,a:this._a};},toHslString:function(){var hsl=rgbToHsl(this._r,this._g,this._b);var h=mathRound(hsl.h*360),s=mathRound(hsl.s*100),l=mathRound(hsl.l*100);return this._a==1?"hsl("+h+", "+s+"%, "+l+"%)":"hsla("+h+", "+s+"%, "+l+"%, "+this._roundA+")";},toHex:function(allow3Char){return rgbToHex(this._r,this._g,this._b,allow3Char);},toHexString:function(allow3Char){return'#'+this.toHex(allow3Char);},toHex8:function(allow4Char){return rgbaToHex(this._r,this._g,this._b,this._a,allow4Char);},toHex8String:function(allow4Char){return'#'+this.toHex8(allow4Char);},toRgb:function(){return{r:mathRound(this._r),g:mathRound(this._g),b:mathRound(this._b),a:this._a};},toRgbString:function(){return this._a==1?"rgb("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+")":"rgba("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+", "+this._roundA+")";},toPercentageRgb:function(){return{r:mathRound(bound01(this._r,255)*100)+"%",g:mathRound(bound01(this._g,255)*100)+"%",b:mathRound(bound01(this._b,255)*100)+"%",a:this._a};},toPercentageRgbString:function(){return this._a==1?"rgb("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%)":"rgba("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%, "+this._roundA+")";},toName:function(){if(this._a===0){return"transparent";}if(this._a<1){return false;}return hexNames[rgbToHex(this._r,this._g,this._b,true)]||false;},toFilter:function(secondColor){var hex8String='#'+rgbaToArgbHex(this._r,this._g,this._b,this._a);var secondHex8String=hex8String;var gradientType=this._gradientType?"GradientType = 1, ":"";if(secondColor){var s=tinycolor(secondColor);secondHex8String='#'+rgbaToArgbHex(s._r,s._g,s._b,s._a);}return"progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";},toString:function(format){var formatSet=!!format;format=format||this._format;var formattedString=false;var hasAlpha=this._a<1&&this._a>=0;var needsAlphaFormat=!formatSet&&hasAlpha&&(format==="hex"||format==="hex6"||format==="hex3"||format==="hex4"||format==="hex8"||format==="name");if(needsAlphaFormat){if(format==="name"&&this._a===0){return this.toName();}return this.toRgbString();}if(format==="rgb"){formattedString=this.toRgbString();}if(format==="prgb"){formattedString=this.toPercentageRgbString();}if(format==="hex"||format==="hex6"){formattedString=this.toHexString();}if(format==="hex3"){formattedString=this.toHexString(true);}if(format==="hex4"){formattedString=this.toHex8String(true);}if(format==="hex8"){formattedString=this.toHex8String();}if(format==="name"){formattedString=this.toName();}if(format==="hsl"){formattedString=this.toHslString();}if(format==="hsv"){formattedString=this.toHsvString();}return formattedString||this.toHexString();},clone:function(){return tinycolor(this.toString());},_applyModification:function(fn,args){var color=fn.apply(null,[this].concat([].slice.call(args)));this._r=color._r;this._g=color._g;this._b=color._b;this.setAlpha(color._a);return this;},lighten:function(){return this._applyModification(lighten,arguments);},brighten:function(){return this._applyModification(brighten,arguments);},darken:function(){return this._applyModification(darken,arguments);},desaturate:function(){return this._applyModification(desaturate,arguments);},saturate:function(){return this._applyModification(saturate,arguments);},greyscale:function(){return this._applyModification(greyscale,arguments);},spin:function(){return this._applyModification(spin,arguments);},_applyCombination:function(fn,args){return fn.apply(null,[this].concat([].slice.call(args)));},analogous:function(){return this._applyCombination(analogous,arguments);},complement:function(){return this._applyCombination(complement,arguments);},monochromatic:function(){return this._applyCombination(monochromatic,arguments);},splitcomplement:function(){return this._applyCombination(splitcomplement,arguments);},triad:function(){return this._applyCombination(triad,arguments);},tetrad:function(){return this._applyCombination(tetrad,arguments);}};tinycolor.fromRatio=function(color,opts){if(typeof color=="object"){var newColor={};for(var i in color){if(color.hasOwnProperty(i)){if(i==="a"){newColor[i]=color[i];}else{newColor[i]=convertToPercentage(color[i]);}}}color=newColor;}return tinycolor(color,opts);};function inputToRGB(color){var rgb={r:0,g:0,b:0};var a=1;var s=null;var v=null;var l=null;var ok=false;var format=false;if(typeof color=="string"){color=stringInputToObject(color);}if(typeof color=="object"){if(isValidCSSUnit(color.r)&&isValidCSSUnit(color.g)&&isValidCSSUnit(color.b)){rgb=rgbToRgb(color.r,color.g,color.b);ok=true;format=String(color.r).substr(-1)==="%"?"prgb":"rgb";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.v)){s=convertToPercentage(color.s);v=convertToPercentage(color.v);rgb=hsvToRgb(color.h,s,v);ok=true;format="hsv";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.l)){s=convertToPercentage(color.s);l=convertToPercentage(color.l);rgb=hslToRgb(color.h,s,l);ok=true;format="hsl";}if(color.hasOwnProperty("a")){a=color.a;}}a=boundAlpha(a);return{ok:ok,format:color.format||format,r:mathMin(255,mathMax(rgb.r,0)),g:mathMin(255,mathMax(rgb.g,0)),b:mathMin(255,mathMax(rgb.b,0)),a:a};}function rgbToRgb(r,g,b){return{r:bound01(r,255)*255,g:bound01(g,255)*255,b:bound01(b,255)*255};}function rgbToHsl(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s,l=(max+min)/2;if(max==min){h=s=0;}else{var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,l:l};}function hslToRgb(h,s,l){var r,g,b;h=bound01(h,360);s=bound01(s,100);l=bound01(l,100);function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}if(s===0){r=g=b=l;}else{var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return{r:r*255,g:g*255,b:b*255};}function rgbToHsv(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s;var d=max-min;s=max===0?0:d/max;if(max==min){h=0;}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,v:max};}function hsvToRgb(h,s,v){h=bound01(h,360)*6;s=bound01(s,100);v=bound01(v,100);var i=Math.floor(h),f=h-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s),mod=i%6,r=[v,q,p,p,t,v][mod],g=[t,v,v,q,p,p][mod],b=[p,p,t,v,v,q][mod];return{r:r*255,g:g*255,b:b*255};}function rgbToHex(r,g,b,allow3Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];if(allow3Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0);}return hex.join("");}function rgbaToHex(r,g,b,a,allow4Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16)),pad2(convertDecimalToHex(a))];if(allow4Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)&&hex[3].charAt(0)==hex[3].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0)+hex[3].charAt(0);}return hex.join("");}function rgbaToArgbHex(r,g,b,a){var hex=[pad2(convertDecimalToHex(a)),pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return hex.join("");}tinycolor.equals=function(color1,color2){if(!color1||!color2){return false;}return tinycolor(color1).toRgbString()==tinycolor(color2).toRgbString();};tinycolor.random=function(){return tinycolor.fromRatio({r:mathRandom(),g:mathRandom(),b:mathRandom()});};function desaturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s-=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function saturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s+=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function greyscale(color){return tinycolor(color).desaturate(100);}function lighten(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l+=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function brighten(color,amount){amount=amount===0?0:amount||10;var rgb=tinycolor(color).toRgb();rgb.r=mathMax(0,mathMin(255,rgb.r-mathRound(255*-(amount/100))));rgb.g=mathMax(0,mathMin(255,rgb.g-mathRound(255*-(amount/100))));rgb.b=mathMax(0,mathMin(255,rgb.b-mathRound(255*-(amount/100))));return tinycolor(rgb);}function darken(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l-=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function spin(color,amount){var hsl=tinycolor(color).toHsl();var hue=(hsl.h+amount)%360;hsl.h=hue<0?360+hue:hue;return tinycolor(hsl);}function complement(color){var hsl=tinycolor(color).toHsl();hsl.h=(hsl.h+180)%360;return tinycolor(hsl);}function triad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+120)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+240)%360,s:hsl.s,l:hsl.l})];}function tetrad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+90)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+180)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+270)%360,s:hsl.s,l:hsl.l})];}function splitcomplement(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+72)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+216)%360,s:hsl.s,l:hsl.l})];}function analogous(color,results,slices){results=results||6;slices=slices||30;var hsl=tinycolor(color).toHsl();var part=360/slices;var ret=[tinycolor(color)];for(hsl.h=(hsl.h-(part*results>>1)+720)%360;--results;){hsl.h=(hsl.h+part)%360;ret.push(tinycolor(hsl));}return ret;}function monochromatic(color,results){results=results||6;var hsv=tinycolor(color).toHsv();var h=hsv.h,s=hsv.s,v=hsv.v;var ret=[];var modification=1/results;while(results--){ret.push(tinycolor({h:h,s:s,v:v}));v=(v+modification)%1;}return ret;}tinycolor.mix=function(color1,color2,amount){amount=amount===0?0:amount||50;var rgb1=tinycolor(color1).toRgb();var rgb2=tinycolor(color2).toRgb();var p=amount/100;var rgba={r:(rgb2.r-rgb1.r)*p+rgb1.r,g:(rgb2.g-rgb1.g)*p+rgb1.g,b:(rgb2.b-rgb1.b)*p+rgb1.b,a:(rgb2.a-rgb1.a)*p+rgb1.a};return tinycolor(rgba);};tinycolor.readability=function(color1,color2){var c1=tinycolor(color1);var c2=tinycolor(color2);return(Math.max(c1.getLuminance(),c2.getLuminance())+0.05)/(Math.min(c1.getLuminance(),c2.getLuminance())+0.05);};tinycolor.isReadable=function(color1,color2,wcag2){var readability=tinycolor.readability(color1,color2);var wcag2Parms,out;out=false;wcag2Parms=validateWCAG2Parms(wcag2);switch(wcag2Parms.level+wcag2Parms.size){case"AAsmall":case"AAAlarge":out=readability>=4.5;break;case"AAlarge":out=readability>=3;break;case"AAAsmall":out=readability>=7;break;}return out;};tinycolor.mostReadable=function(baseColor,colorList,args){var bestColor=null;var bestScore=0;var readability;var includeFallbackColors,level,size;args=args||{};includeFallbackColors=args.includeFallbackColors;level=args.level;size=args.size;for(var i=0;i<colorList.length;i++){readability=tinycolor.readability(baseColor,colorList[i]);if(readability>bestScore){bestScore=readability;bestColor=tinycolor(colorList[i]);}}if(tinycolor.isReadable(baseColor,bestColor,{"level":level,"size":size})||!includeFallbackColors){return bestColor;}else{args.includeFallbackColors=false;return tinycolor.mostReadable(baseColor,["#fff","#000"],args);}};var names=tinycolor.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"};var hexNames=tinycolor.hexNames=function(o){var flipped={};for(var i in o){if(o.hasOwnProperty(i)){flipped[o[i]]=i;}}return flipped;}(names);function boundAlpha(a){a=parseFloat(a);if(isNaN(a)||a<0||a>1){a=1;}return a;}function bound01(n,max){if(isOnePointZero(n)){n="100%";}var processPercent=isPercentage(n);n=mathMin(max,mathMax(0,parseFloat(n)));if(processPercent){n=parseInt(n*max,10)/100;}if(Math.abs(n-max)<0.000001){return 1;}return n%max/parseFloat(max);}function clamp01(val){return mathMin(1,mathMax(0,val));}function parseIntFromHex(val){return parseInt(val,16);}function isOnePointZero(n){return typeof n=="string"&&n.indexOf('.')!=-1&&parseFloat(n)===1;}function isPercentage(n){return typeof n==="string"&&n.indexOf('%')!=-1;}function pad2(c){return c.length==1?'0'+c:''+c;}function convertToPercentage(n){if(n<=1){n=n*100+"%";}return n;}function convertDecimalToHex(d){return Math.round(parseFloat(d)*255).toString(16);}function convertHexToDecimal(h){return parseIntFromHex(h)/255;}var matchers=function(){var CSS_UNIT="(?:"+"[-\\+]?\\d*\\.\\d+%?"+")|(?:"+"[-\\+]?\\d+%?"+")";var PERMISSIVE_MATCH3="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";var PERMISSIVE_MATCH4="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";return{CSS_UNIT:new RegExp(CSS_UNIT),rgb:new RegExp("rgb"+PERMISSIVE_MATCH3),rgba:new RegExp("rgba"+PERMISSIVE_MATCH4),hsl:new RegExp("hsl"+PERMISSIVE_MATCH3),hsla:new RegExp("hsla"+PERMISSIVE_MATCH4),hsv:new RegExp("hsv"+PERMISSIVE_MATCH3),hsva:new RegExp("hsva"+PERMISSIVE_MATCH4),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};}();function isValidCSSUnit(color){return!!matchers.CSS_UNIT.exec(color);}function stringInputToObject(color){color=color.replace(trimLeft,'').replace(trimRight,'').toLowerCase();var named=false;if(names[color]){color=names[color];named=true;}else if(color=='transparent'){return{r:0,g:0,b:0,a:0,format:"name"};}var match;if(match=matchers.rgb.exec(color)){return{r:match[1],g:match[2],b:match[3]};}if(match=matchers.rgba.exec(color)){return{r:match[1],g:match[2],b:match[3],a:match[4]};}if(match=matchers.hsl.exec(color)){return{h:match[1],s:match[2],l:match[3]};}if(match=matchers.hsla.exec(color)){return{h:match[1],s:match[2],l:match[3],a:match[4]};}if(match=matchers.hsv.exec(color)){return{h:match[1],s:match[2],v:match[3]};}if(match=matchers.hsva.exec(color)){return{h:match[1],s:match[2],v:match[3],a:match[4]};}if(match=matchers.hex8.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),a:convertHexToDecimal(match[4]),format:named?"name":"hex8"};}if(match=matchers.hex6.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),format:named?"name":"hex"};}if(match=matchers.hex4.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),a:convertHexToDecimal(match[4]+''+match[4]),format:named?"name":"hex8"};}if(match=matchers.hex3.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),format:named?"name":"hex"};}return false;}function validateWCAG2Parms(parms){var level,size;parms=parms||{"level":"AA","size":"small"};level=(parms.level||"AA").toUpperCase();size=(parms.size||"small").toLowerCase();if(level!=="AA"&&level!=="AAA"){level="AA";}if(size!=="small"&&size!=="large"){size="small";}return{"level":level,"size":size};}if( true&&module.exports){module.exports=tinycolor;}else if(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{}})(Math);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq=__webpack_require__(77);function uniq(array){return array&&array.length?baseUniq(array):[];}module.exports=uniq;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var toString=__webpack_require__(61);var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}module.exports=escapeRegExp;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var elementResizeDetectorMaker=__webpack_require__(246);var ResizeObserverLite=function(){function ResizeObserverLite(handler){var _this=this;this.handler=handler;this.listenedElement=null;this.hasResizeObserver=typeof window.ResizeObserver!=='undefined';if(this.hasResizeObserver){this.rz=new ResizeObserver(function(entries){_this.handler(getSize(entries[0].target));});}else{this.erd=elementResizeDetectorMaker({strategy:'object'});}}ResizeObserverLite.prototype.observe=function(element){var _this=this;if(this.listenedElement!==element){if(this.listenedElement){this.disconnect();}if(element){if(this.hasResizeObserver){this.rz.observe(element);}else{this.erd.listenTo(element,function(element){_this.handler(getSize(element));});}}this.listenedElement=element;}};ResizeObserverLite.prototype.disconnect=function(){if(this.listenedElement){if(this.hasResizeObserver){this.rz.disconnect();}else{this.erd.uninstall(this.listenedElement);}this.listenedElement=null;}};return ResizeObserverLite;}();exports.default=ResizeObserverLite;function getSize(element){return{width:getNumber(window.getComputedStyle(element)['width']),height:getNumber(window.getComputedStyle(element)['height'])};}function getNumber(str){var m=/^([0-9\.]+)px$/.exec(str);return m?parseFloat(m[1]):0;}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(48),baseMatchesProperty=__webpack_require__(258);var CLONE_DEEP_FLAG=1;function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}module.exports=matchesProperty;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var createFind=__webpack_require__(262),findIndex=__webpack_require__(263);var find=createFind(findIndex);module.exports=find;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

function listCacheClear(){this.__data__=[];this.size=0;}module.exports=listCacheClear;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(38);var arrayProto=Array.prototype;var splice=arrayProto.splice;function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}module.exports=listCacheDelete;

/***/ }),
/* 89 */
/***/ (function(module, exports) {

function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(38);function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}module.exports=listCacheGet;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(38);function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}module.exports=listCacheHas;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(38);function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}module.exports=listCacheSet;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39);var nativeMax=Math.max;function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}module.exports=overRest;

/***/ }),
/* 95 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 96 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var isObject=__webpack_require__(10);var objectCreate=Object.create;var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();module.exports=baseCreate;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var composeArgs=__webpack_require__(156),composeArgsRight=__webpack_require__(157),countHolders=__webpack_require__(158),createCtor=__webpack_require__(42),createRecurry=__webpack_require__(99),getHolder=__webpack_require__(103),reorder=__webpack_require__(159),replaceHolders=__webpack_require__(104),root=__webpack_require__(24);var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_ARY_FLAG=128,WRAP_FLIP_FLAG=512;function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=bitmask&WRAP_BIND_FLAG?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(bitmask&WRAP_FLIP_FLAG&&length>1){args.reverse();}if(bitmask&WRAP_ARY_FLAG&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}module.exports=createHybrid;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var isLaziable=__webpack_require__(100),setData=__webpack_require__(101),setWrapToString=__webpack_require__(102);var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64;function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}module.exports=createRecurry;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 102 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

function stubArray(){return[];}module.exports=stubArray;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(5),isSymbol=__webpack_require__(44);var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}module.exports=isKey;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped=__webpack_require__(164);var rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;var reEscapeChar=/\\(\\)?/g;var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});module.exports=stringToPath;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}module.exports=arrayEach;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(45);var getPrototype=overArg(Object.getPrototypeOf,Object);module.exports=getPrototype;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue=__webpack_require__(111),baseAssignValue=__webpack_require__(26);function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}module.exports=copyObject;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(26),eq=__webpack_require__(89);var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}module.exports=assignValue;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet=__webpack_require__(62),baseSet=__webpack_require__(175),castPath=__webpack_require__(33);function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}module.exports=basePickBy;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn=__webpack_require__(176),hasPath=__webpack_require__(177);function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}module.exports=hasIn;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

var MAX_SAFE_INTEGER=9007199254740991;function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}module.exports=isLength;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(45);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter=__webpack_require__(199),arrayMap=__webpack_require__(16),baseProperty=__webpack_require__(200),baseTimes=__webpack_require__(201),isArrayLikeObject=__webpack_require__(35);var nativeMax=Math.max;function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}module.exports=unzip;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(49),arrayIncludes=__webpack_require__(75),arrayIncludesWith=__webpack_require__(76),arrayMap=__webpack_require__(16),baseUnary=__webpack_require__(40),cacheHas=__webpack_require__(50);var LARGE_ARRAY_SIZE=200;function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}module.exports=baseDifference;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep=__webpack_require__(227),isObjectLike=__webpack_require__(34);function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}module.exports=baseIsEqual;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var utils=module.exports={};utils.forEach=function(collection,callback){for(var i=0;i<collection.length;i++){var result=callback(collection[i]);if(result){return result;}}};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var detector=module.exports={};detector.isIE=function(version){if(!function(){var agent=navigator.userAgent.toLowerCase();return agent.indexOf("msie")!==-1||agent.indexOf("trident")!==-1||agent.indexOf(" edge/")!==-1;}()){return false;}if(!version){return true;}var ieVersion=function(){var undef,v=3,div=document.createElement("div"),all=div.getElementsByTagName("i");do{div.innerHTML="<!--[if gt IE "+ ++v+"]><i></i><![endif]-->";}while(all[0]);return v>4?v:undef;}();return version===ieVersion;};detector.isLegacyOpera=function(){return!!window.opera;};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice=__webpack_require__(63);function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}module.exports=baseWhile;

/***/ }),
/* 122 */
/***/ (function(module, exports) {

function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}module.exports=fromPairs;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject=__webpack_require__(110),createAssigner=__webpack_require__(172),keysIn=__webpack_require__(173);var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});module.exports=assignIn;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var basePick=__webpack_require__(174),flatRest=__webpack_require__(72);var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});module.exports=pick;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;(function(){'use strict';var collator;try{collator=typeof Intl!=="undefined"&&typeof Intl.Collator!=="undefined"?Intl.Collator("generic",{sensitivity:"base"}):null;}catch(err){console.log("Collator could not be initialized and wouldn't be used");}var prevRow=[],str2Char=[];var Levenshtein={get:function(str1,str2,options){var useCollator=options&&collator&&options.useCollator;var str1Len=str1.length,str2Len=str2.length;if(str1Len===0)return str2Len;if(str2Len===0)return str1Len;var curCol,nextCol,i,j,tmp;for(i=0;i<str2Len;++i){prevRow[i]=i;str2Char[i]=str2.charCodeAt(i);}prevRow[str2Len]=str2Len;var strCmp;if(useCollator){for(i=0;i<str1Len;++i){nextCol=i+1;for(j=0;j<str2Len;++j){curCol=nextCol;strCmp=0===collator.compare(str1.charAt(i),String.fromCharCode(str2Char[j]));nextCol=prevRow[j]+(strCmp?0:1);tmp=curCol+1;if(nextCol>tmp){nextCol=tmp;}tmp=prevRow[j+1]+1;if(nextCol>tmp){nextCol=tmp;}prevRow[j]=curCol;}prevRow[j]=nextCol;}}else{for(i=0;i<str1Len;++i){nextCol=i+1;for(j=0;j<str2Len;++j){curCol=nextCol;strCmp=str1.charCodeAt(i)===str2Char[j];nextCol=prevRow[j]+(strCmp?0:1);tmp=curCol+1;if(nextCol>tmp){nextCol=tmp;}tmp=prevRow[j+1]+1;if(nextCol>tmp){nextCol=tmp;}prevRow[j]=curCol;}prevRow[j]=nextCol;}}return nextCol;}};if( true&&__webpack_require__(203)!==null&&__webpack_require__(204)){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Levenshtein;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if( true&&module!==null&&typeof exports!=="undefined"&&module.exports===exports){module.exports=Levenshtein;}else if(typeof self!=="undefined"&&typeof self.postMessage==='function'&&typeof self.importScripts==='function'){self.Levenshtein=Levenshtein;}else if(typeof window!=="undefined"&&window!==null){window.Levenshtein=Levenshtein;}})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(202)(module)))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('once',__webpack_require__(0),__webpack_require__(205));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(global,factory){"use strict";if( true&&typeof module.exports==="object"){module.exports=global.document?factory(global,true):function(w){if(!w.document){throw new Error("jQuery requires a window with a document");}return factory(w);};}else{factory(global);}})(typeof window!=="undefined"?window:this,function(window,noGlobal){"use strict";var arr=[];var document=window.document;var getProto=Object.getPrototypeOf;var slice=arr.slice;var concat=arr.concat;var push=arr.push;var indexOf=arr.indexOf;var class2type={};var toString=class2type.toString;var hasOwn=class2type.hasOwnProperty;var fnToString=hasOwn.toString;var ObjectFunctionString=fnToString.call(Object);var support={};var isFunction=function(obj){return typeof obj==="function"&&typeof obj.nodeType!=="number";};var isWindow=function(obj){return obj!=null&&obj===obj.window;};var preservedScriptAttributes={type:true,src:true,nonce:true,noModule:true};function DOMEval(code,node,doc){doc=doc||document;var i,val,script=doc.createElement("script");script.text=code;if(node){for(i in preservedScriptAttributes){val=node[i]||node.getAttribute&&node.getAttribute(i);if(val){script.setAttribute(i,val);}}}doc.head.appendChild(script).parentNode.removeChild(script);}function toType(obj){if(obj==null){return obj+"";}return typeof obj==="object"||typeof obj==="function"?class2type[toString.call(obj)]||"object":typeof obj;}var version="3.4.0",jQuery=function(selector,context){return new jQuery.fn.init(selector,context);},rtrim=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;jQuery.fn=jQuery.prototype={jquery:version,constructor:jQuery,length:0,toArray:function(){return slice.call(this);},get:function(num){if(num==null){return slice.call(this);}return num<0?this[num+this.length]:this[num];},pushStack:function(elems){var ret=jQuery.merge(this.constructor(),elems);ret.prevObject=this;return ret;},each:function(callback){return jQuery.each(this,callback);},map:function(callback){return this.pushStack(jQuery.map(this,function(elem,i){return callback.call(elem,i,elem);}));},slice:function(){return this.pushStack(slice.apply(this,arguments));},first:function(){return this.eq(0);},last:function(){return this.eq(-1);},eq:function(i){var len=this.length,j=+i+(i<0?len:0);return this.pushStack(j>=0&&j<len?[this[j]]:[]);},end:function(){return this.prevObject||this.constructor();},push:push,sort:arr.sort,splice:arr.splice};jQuery.extend=jQuery.fn.extend=function(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length,deep=false;if(typeof target==="boolean"){deep=target;target=arguments[i]||{};i++;}if(typeof target!=="object"&&!isFunction(target)){target={};}if(i===length){target=this;i--;}for(;i<length;i++){if((options=arguments[i])!=null){for(name in options){copy=options[name];if(name==="__proto__"||target===copy){continue;}if(deep&&copy&&(jQuery.isPlainObject(copy)||(copyIsArray=Array.isArray(copy)))){src=target[name];if(copyIsArray&&!Array.isArray(src)){clone=[];}else if(!copyIsArray&&!jQuery.isPlainObject(src)){clone={};}else{clone=src;}copyIsArray=false;target[name]=jQuery.extend(deep,clone,copy);}else if(copy!==undefined){target[name]=copy;}}}}return target;};jQuery.extend({expando:"jQuery"+(version+Math.random()).replace(/\D/g,""),isReady:true,error:function(msg){throw new Error(msg);},noop:function(){},isPlainObject:function(obj){var proto,Ctor;if(!obj||toString.call(obj)!=="[object Object]"){return false;}proto=getProto(obj);if(!proto){return true;}Ctor=hasOwn.call(proto,"constructor")&&proto.constructor;return typeof Ctor==="function"&&fnToString.call(Ctor)===ObjectFunctionString;},isEmptyObject:function(obj){for(var name in obj){return false;}return true;},globalEval:function(code,options){DOMEval(code,{nonce:options&&options.nonce});},each:function(obj,callback){var length,i=0;if(isArrayLike(obj)){length=obj.length;for(;i<length;i++){if(callback.call(obj[i],i,obj[i])===false){break;}}}else{for(i in obj){if(callback.call(obj[i],i,obj[i])===false){break;}}}return obj;},trim:function(text){return text==null?"":(text+"").replace(rtrim,"");},makeArray:function(arr,results){var ret=results||[];if(arr!=null){if(isArrayLike(Object(arr))){jQuery.merge(ret,typeof arr==="string"?[arr]:arr);}else{push.call(ret,arr);}}return ret;},inArray:function(elem,arr,i){return arr==null?-1:indexOf.call(arr,elem,i);},merge:function(first,second){var len=+second.length,j=0,i=first.length;for(;j<len;j++){first[i++]=second[j];}first.length=i;return first;},grep:function(elems,callback,invert){var callbackInverse,matches=[],i=0,length=elems.length;for(;i<length;i++){callbackInverse=!callback(elems[i],i);if(callbackInverse!==!invert){matches.push(elems[i]);}}return matches;},map:function(elems,callback,arg){var length,value,i=0,ret=[];if(isArrayLike(elems)){length=elems.length;for(;i<length;i++){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}else{for(i in elems){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}return concat.apply([],ret);},guid:1,support:support});if(typeof Symbol==="function"){jQuery.fn[Symbol.iterator]=arr[Symbol.iterator];}jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(i,name){class2type["[object "+name+"]"]=name.toLowerCase();});function isArrayLike(obj){var length=!!obj&&"length"in obj&&obj.length,type=toType(obj);if(isFunction(obj)||isWindow(obj)){return false;}return type==="array"||length===0||typeof length==="number"&&length>0&&length-1 in obj;}var Sizzle=function(window){var i,support,Expr,getText,isXML,tokenize,compile,select,outermostContext,sortInput,hasDuplicate,setDocument,document,docElem,documentIsHTML,rbuggyQSA,rbuggyMatches,matches,contains,expando="sizzle"+1*new Date(),preferredDoc=window.document,dirruns=0,done=0,classCache=createCache(),tokenCache=createCache(),compilerCache=createCache(),nonnativeSelectorCache=createCache(),sortOrder=function(a,b){if(a===b){hasDuplicate=true;}return 0;},hasOwn={}.hasOwnProperty,arr=[],pop=arr.pop,push_native=arr.push,push=arr.push,slice=arr.slice,indexOf=function(list,elem){var i=0,len=list.length;for(;i<len;i++){if(list[i]===elem){return i;}}return-1;},booleans="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",whitespace="[\\x20\\t\\r\\n\\f]",identifier="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",attributes="\\["+whitespace+"*("+identifier+")(?:"+whitespace+"*([*^$|!~]?=)"+whitespace+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+identifier+"))|)"+whitespace+"*\\]",pseudos=":("+identifier+")(?:\\(("+"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"+"((?:\\\\.|[^\\\\()[\\]]|"+attributes+")*)|"+".*"+")\\)|)",rwhitespace=new RegExp(whitespace+"+","g"),rtrim=new RegExp("^"+whitespace+"+|((?:^|[^\\\\])(?:\\\\.)*)"+whitespace+"+$","g"),rcomma=new RegExp("^"+whitespace+"*,"+whitespace+"*"),rcombinators=new RegExp("^"+whitespace+"*([>+~]|"+whitespace+")"+whitespace+"*"),rdescend=new RegExp(whitespace+"|>"),rpseudo=new RegExp(pseudos),ridentifier=new RegExp("^"+identifier+"$"),matchExpr={"ID":new RegExp("^#("+identifier+")"),"CLASS":new RegExp("^\\.("+identifier+")"),"TAG":new RegExp("^("+identifier+"|[*])"),"ATTR":new RegExp("^"+attributes),"PSEUDO":new RegExp("^"+pseudos),"CHILD":new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+whitespace+"*(even|odd|(([+-]|)(\\d*)n|)"+whitespace+"*(?:([+-]|)"+whitespace+"*(\\d+)|))"+whitespace+"*\\)|)","i"),"bool":new RegExp("^(?:"+booleans+")$","i"),"needsContext":new RegExp("^"+whitespace+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+whitespace+"*((?:-\\d)?\\d*)"+whitespace+"*\\)|)(?=[^-]|$)","i")},rhtml=/HTML$/i,rinputs=/^(?:input|select|textarea|button)$/i,rheader=/^h\d$/i,rnative=/^[^{]+\{\s*\[native \w/,rquickExpr=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rsibling=/[+~]/,runescape=new RegExp("\\\\([\\da-f]{1,6}"+whitespace+"?|("+whitespace+")|.)","ig"),funescape=function(_,escaped,escapedWhitespace){var high="0x"+escaped-0x10000;return high!==high||escapedWhitespace?escaped:high<0?String.fromCharCode(high+0x10000):String.fromCharCode(high>>10|0xD800,high&0x3FF|0xDC00);},rcssescape=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,fcssescape=function(ch,asCodePoint){if(asCodePoint){if(ch==="\0"){return"\uFFFD";}return ch.slice(0,-1)+"\\"+ch.charCodeAt(ch.length-1).toString(16)+" ";}return"\\"+ch;},unloadHandler=function(){setDocument();},inDisabledFieldset=addCombinator(function(elem){return elem.disabled===true&&elem.nodeName.toLowerCase()==="fieldset";},{dir:"parentNode",next:"legend"});try{push.apply(arr=slice.call(preferredDoc.childNodes),preferredDoc.childNodes);arr[preferredDoc.childNodes.length].nodeType;}catch(e){push={apply:arr.length?function(target,els){push_native.apply(target,slice.call(els));}:function(target,els){var j=target.length,i=0;while(target[j++]=els[i++]){}target.length=j-1;}};}function Sizzle(selector,context,results,seed){var m,i,elem,nid,match,groups,newSelector,newContext=context&&context.ownerDocument,nodeType=context?context.nodeType:9;results=results||[];if(typeof selector!=="string"||!selector||nodeType!==1&&nodeType!==9&&nodeType!==11){return results;}if(!seed){if((context?context.ownerDocument||context:preferredDoc)!==document){setDocument(context);}context=context||document;if(documentIsHTML){if(nodeType!==11&&(match=rquickExpr.exec(selector))){if(m=match[1]){if(nodeType===9){if(elem=context.getElementById(m)){if(elem.id===m){results.push(elem);return results;}}else{return results;}}else{if(newContext&&(elem=newContext.getElementById(m))&&contains(context,elem)&&elem.id===m){results.push(elem);return results;}}}else if(match[2]){push.apply(results,context.getElementsByTagName(selector));return results;}else if((m=match[3])&&support.getElementsByClassName&&context.getElementsByClassName){push.apply(results,context.getElementsByClassName(m));return results;}}if(support.qsa&&!nonnativeSelectorCache[selector+" "]&&(!rbuggyQSA||!rbuggyQSA.test(selector))&&(nodeType!==1||context.nodeName.toLowerCase()!=="object")){newSelector=selector;newContext=context;if(nodeType===1&&rdescend.test(selector)){if(nid=context.getAttribute("id")){nid=nid.replace(rcssescape,fcssescape);}else{context.setAttribute("id",nid=expando);}groups=tokenize(selector);i=groups.length;while(i--){groups[i]="#"+nid+" "+toSelector(groups[i]);}newSelector=groups.join(",");newContext=rsibling.test(selector)&&testContext(context.parentNode)||context;}try{push.apply(results,newContext.querySelectorAll(newSelector));return results;}catch(qsaError){nonnativeSelectorCache(selector,true);}finally{if(nid===expando){context.removeAttribute("id");}}}}}return select(selector.replace(rtrim,"$1"),context,results,seed);}function createCache(){var keys=[];function cache(key,value){if(keys.push(key+" ")>Expr.cacheLength){delete cache[keys.shift()];}return cache[key+" "]=value;}return cache;}function markFunction(fn){fn[expando]=true;return fn;}function assert(fn){var el=document.createElement("fieldset");try{return!!fn(el);}catch(e){return false;}finally{if(el.parentNode){el.parentNode.removeChild(el);}el=null;}}function addHandle(attrs,handler){var arr=attrs.split("|"),i=arr.length;while(i--){Expr.attrHandle[arr[i]]=handler;}}function siblingCheck(a,b){var cur=b&&a,diff=cur&&a.nodeType===1&&b.nodeType===1&&a.sourceIndex-b.sourceIndex;if(diff){return diff;}if(cur){while(cur=cur.nextSibling){if(cur===b){return-1;}}}return a?1:-1;}function createInputPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type===type;};}function createButtonPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return(name==="input"||name==="button")&&elem.type===type;};}function createDisabledPseudo(disabled){return function(elem){if("form"in elem){if(elem.parentNode&&elem.disabled===false){if("label"in elem){if("label"in elem.parentNode){return elem.parentNode.disabled===disabled;}else{return elem.disabled===disabled;}}return elem.isDisabled===disabled||elem.isDisabled!==!disabled&&inDisabledFieldset(elem)===disabled;}return elem.disabled===disabled;}else if("label"in elem){return elem.disabled===disabled;}return false;};}function createPositionalPseudo(fn){return markFunction(function(argument){argument=+argument;return markFunction(function(seed,matches){var j,matchIndexes=fn([],seed.length,argument),i=matchIndexes.length;while(i--){if(seed[j=matchIndexes[i]]){seed[j]=!(matches[j]=seed[j]);}}});});}function testContext(context){return context&&typeof context.getElementsByTagName!=="undefined"&&context;}support=Sizzle.support={};isXML=Sizzle.isXML=function(elem){var namespace=elem.namespaceURI,docElem=(elem.ownerDocument||elem).documentElement;return!rhtml.test(namespace||docElem&&docElem.nodeName||"HTML");};setDocument=Sizzle.setDocument=function(node){var hasCompare,subWindow,doc=node?node.ownerDocument||node:preferredDoc;if(doc===document||doc.nodeType!==9||!doc.documentElement){return document;}document=doc;docElem=document.documentElement;documentIsHTML=!isXML(document);if(preferredDoc!==document&&(subWindow=document.defaultView)&&subWindow.top!==subWindow){if(subWindow.addEventListener){subWindow.addEventListener("unload",unloadHandler,false);}else if(subWindow.attachEvent){subWindow.attachEvent("onunload",unloadHandler);}}support.attributes=assert(function(el){el.className="i";return!el.getAttribute("className");});support.getElementsByTagName=assert(function(el){el.appendChild(document.createComment(""));return!el.getElementsByTagName("*").length;});support.getElementsByClassName=rnative.test(document.getElementsByClassName);support.getById=assert(function(el){docElem.appendChild(el).id=expando;return!document.getElementsByName||!document.getElementsByName(expando).length;});if(support.getById){Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){return elem.getAttribute("id")===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var elem=context.getElementById(id);return elem?[elem]:[];}};}else{Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){var node=typeof elem.getAttributeNode!=="undefined"&&elem.getAttributeNode("id");return node&&node.value===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var node,i,elems,elem=context.getElementById(id);if(elem){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}elems=context.getElementsByName(id);i=0;while(elem=elems[i++]){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}}}return[];}};}Expr.find["TAG"]=support.getElementsByTagName?function(tag,context){if(typeof context.getElementsByTagName!=="undefined"){return context.getElementsByTagName(tag);}else if(support.qsa){return context.querySelectorAll(tag);}}:function(tag,context){var elem,tmp=[],i=0,results=context.getElementsByTagName(tag);if(tag==="*"){while(elem=results[i++]){if(elem.nodeType===1){tmp.push(elem);}}return tmp;}return results;};Expr.find["CLASS"]=support.getElementsByClassName&&function(className,context){if(typeof context.getElementsByClassName!=="undefined"&&documentIsHTML){return context.getElementsByClassName(className);}};rbuggyMatches=[];rbuggyQSA=[];if(support.qsa=rnative.test(document.querySelectorAll)){assert(function(el){docElem.appendChild(el).innerHTML="<a id='"+expando+"'></a>"+"<select id='"+expando+"-\r\\' msallowcapture=''>"+"<option selected=''></option></select>";if(el.querySelectorAll("[msallowcapture^='']").length){rbuggyQSA.push("[*^$]="+whitespace+"*(?:''|\"\")");}if(!el.querySelectorAll("[selected]").length){rbuggyQSA.push("\\["+whitespace+"*(?:value|"+booleans+")");}if(!el.querySelectorAll("[id~="+expando+"-]").length){rbuggyQSA.push("~=");}if(!el.querySelectorAll(":checked").length){rbuggyQSA.push(":checked");}if(!el.querySelectorAll("a#"+expando+"+*").length){rbuggyQSA.push(".#.+[+~]");}});assert(function(el){el.innerHTML="<a href='' disabled='disabled'></a>"+"<select disabled='disabled'><option/></select>";var input=document.createElement("input");input.setAttribute("type","hidden");el.appendChild(input).setAttribute("name","D");if(el.querySelectorAll("[name=d]").length){rbuggyQSA.push("name"+whitespace+"*[*^$|!~]?=");}if(el.querySelectorAll(":enabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}docElem.appendChild(el).disabled=true;if(el.querySelectorAll(":disabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}el.querySelectorAll("*,:x");rbuggyQSA.push(",.*:");});}if(support.matchesSelector=rnative.test(matches=docElem.matches||docElem.webkitMatchesSelector||docElem.mozMatchesSelector||docElem.oMatchesSelector||docElem.msMatchesSelector)){assert(function(el){support.disconnectedMatch=matches.call(el,"*");matches.call(el,"[s!='']:x");rbuggyMatches.push("!=",pseudos);});}rbuggyQSA=rbuggyQSA.length&&new RegExp(rbuggyQSA.join("|"));rbuggyMatches=rbuggyMatches.length&&new RegExp(rbuggyMatches.join("|"));hasCompare=rnative.test(docElem.compareDocumentPosition);contains=hasCompare||rnative.test(docElem.contains)?function(a,b){var adown=a.nodeType===9?a.documentElement:a,bup=b&&b.parentNode;return a===bup||!!(bup&&bup.nodeType===1&&(adown.contains?adown.contains(bup):a.compareDocumentPosition&&a.compareDocumentPosition(bup)&16));}:function(a,b){if(b){while(b=b.parentNode){if(b===a){return true;}}}return false;};sortOrder=hasCompare?function(a,b){if(a===b){hasDuplicate=true;return 0;}var compare=!a.compareDocumentPosition-!b.compareDocumentPosition;if(compare){return compare;}compare=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1;if(compare&1||!support.sortDetached&&b.compareDocumentPosition(a)===compare){if(a===document||a.ownerDocument===preferredDoc&&contains(preferredDoc,a)){return-1;}if(b===document||b.ownerDocument===preferredDoc&&contains(preferredDoc,b)){return 1;}return sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}return compare&4?-1:1;}:function(a,b){if(a===b){hasDuplicate=true;return 0;}var cur,i=0,aup=a.parentNode,bup=b.parentNode,ap=[a],bp=[b];if(!aup||!bup){return a===document?-1:b===document?1:aup?-1:bup?1:sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}else if(aup===bup){return siblingCheck(a,b);}cur=a;while(cur=cur.parentNode){ap.unshift(cur);}cur=b;while(cur=cur.parentNode){bp.unshift(cur);}while(ap[i]===bp[i]){i++;}return i?siblingCheck(ap[i],bp[i]):ap[i]===preferredDoc?-1:bp[i]===preferredDoc?1:0;};return document;};Sizzle.matches=function(expr,elements){return Sizzle(expr,null,null,elements);};Sizzle.matchesSelector=function(elem,expr){if((elem.ownerDocument||elem)!==document){setDocument(elem);}if(support.matchesSelector&&documentIsHTML&&!nonnativeSelectorCache[expr+" "]&&(!rbuggyMatches||!rbuggyMatches.test(expr))&&(!rbuggyQSA||!rbuggyQSA.test(expr))){try{var ret=matches.call(elem,expr);if(ret||support.disconnectedMatch||elem.document&&elem.document.nodeType!==11){return ret;}}catch(e){nonnativeSelectorCache(expr,true);}}return Sizzle(expr,document,null,[elem]).length>0;};Sizzle.contains=function(context,elem){if((context.ownerDocument||context)!==document){setDocument(context);}return contains(context,elem);};Sizzle.attr=function(elem,name){if((elem.ownerDocument||elem)!==document){setDocument(elem);}var fn=Expr.attrHandle[name.toLowerCase()],val=fn&&hasOwn.call(Expr.attrHandle,name.toLowerCase())?fn(elem,name,!documentIsHTML):undefined;return val!==undefined?val:support.attributes||!documentIsHTML?elem.getAttribute(name):(val=elem.getAttributeNode(name))&&val.specified?val.value:null;};Sizzle.escape=function(sel){return(sel+"").replace(rcssescape,fcssescape);};Sizzle.error=function(msg){throw new Error("Syntax error, unrecognized expression: "+msg);};Sizzle.uniqueSort=function(results){var elem,duplicates=[],j=0,i=0;hasDuplicate=!support.detectDuplicates;sortInput=!support.sortStable&&results.slice(0);results.sort(sortOrder);if(hasDuplicate){while(elem=results[i++]){if(elem===results[i]){j=duplicates.push(i);}}while(j--){results.splice(duplicates[j],1);}}sortInput=null;return results;};getText=Sizzle.getText=function(elem){var node,ret="",i=0,nodeType=elem.nodeType;if(!nodeType){while(node=elem[i++]){ret+=getText(node);}}else if(nodeType===1||nodeType===9||nodeType===11){if(typeof elem.textContent==="string"){return elem.textContent;}else{for(elem=elem.firstChild;elem;elem=elem.nextSibling){ret+=getText(elem);}}}else if(nodeType===3||nodeType===4){return elem.nodeValue;}return ret;};Expr=Sizzle.selectors={cacheLength:50,createPseudo:markFunction,match:matchExpr,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:true}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:true},"~":{dir:"previousSibling"}},preFilter:{"ATTR":function(match){match[1]=match[1].replace(runescape,funescape);match[3]=(match[3]||match[4]||match[5]||"").replace(runescape,funescape);if(match[2]==="~="){match[3]=" "+match[3]+" ";}return match.slice(0,4);},"CHILD":function(match){match[1]=match[1].toLowerCase();if(match[1].slice(0,3)==="nth"){if(!match[3]){Sizzle.error(match[0]);}match[4]=+(match[4]?match[5]+(match[6]||1):2*(match[3]==="even"||match[3]==="odd"));match[5]=+(match[7]+match[8]||match[3]==="odd");}else if(match[3]){Sizzle.error(match[0]);}return match;},"PSEUDO":function(match){var excess,unquoted=!match[6]&&match[2];if(matchExpr["CHILD"].test(match[0])){return null;}if(match[3]){match[2]=match[4]||match[5]||"";}else if(unquoted&&rpseudo.test(unquoted)&&(excess=tokenize(unquoted,true))&&(excess=unquoted.indexOf(")",unquoted.length-excess)-unquoted.length)){match[0]=match[0].slice(0,excess);match[2]=unquoted.slice(0,excess);}return match.slice(0,3);}},filter:{"TAG":function(nodeNameSelector){var nodeName=nodeNameSelector.replace(runescape,funescape).toLowerCase();return nodeNameSelector==="*"?function(){return true;}:function(elem){return elem.nodeName&&elem.nodeName.toLowerCase()===nodeName;};},"CLASS":function(className){var pattern=classCache[className+" "];return pattern||(pattern=new RegExp("(^|"+whitespace+")"+className+"("+whitespace+"|$)"))&&classCache(className,function(elem){return pattern.test(typeof elem.className==="string"&&elem.className||typeof elem.getAttribute!=="undefined"&&elem.getAttribute("class")||"");});},"ATTR":function(name,operator,check){return function(elem){var result=Sizzle.attr(elem,name);if(result==null){return operator==="!=";}if(!operator){return true;}result+="";return operator==="="?result===check:operator==="!="?result!==check:operator==="^="?check&&result.indexOf(check)===0:operator==="*="?check&&result.indexOf(check)>-1:operator==="$="?check&&result.slice(-check.length)===check:operator==="~="?(" "+result.replace(rwhitespace," ")+" ").indexOf(check)>-1:operator==="|="?result===check||result.slice(0,check.length+1)===check+"-":false;};},"CHILD":function(type,what,argument,first,last){var simple=type.slice(0,3)!=="nth",forward=type.slice(-4)!=="last",ofType=what==="of-type";return first===1&&last===0?function(elem){return!!elem.parentNode;}:function(elem,context,xml){var cache,uniqueCache,outerCache,node,nodeIndex,start,dir=simple!==forward?"nextSibling":"previousSibling",parent=elem.parentNode,name=ofType&&elem.nodeName.toLowerCase(),useCache=!xml&&!ofType,diff=false;if(parent){if(simple){while(dir){node=elem;while(node=node[dir]){if(ofType?node.nodeName.toLowerCase()===name:node.nodeType===1){return false;}}start=dir=type==="only"&&!start&&"nextSibling";}return true;}start=[forward?parent.firstChild:parent.lastChild];if(forward&&useCache){node=parent;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex&&cache[2];node=nodeIndex&&parent.childNodes[nodeIndex];while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if(node.nodeType===1&&++diff&&node===elem){uniqueCache[type]=[dirruns,nodeIndex,diff];break;}}}else{if(useCache){node=elem;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex;}if(diff===false){while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if((ofType?node.nodeName.toLowerCase()===name:node.nodeType===1)&&++diff){if(useCache){outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});uniqueCache[type]=[dirruns,diff];}if(node===elem){break;}}}}}diff-=last;return diff===first||diff%first===0&&diff/first>=0;}};},"PSEUDO":function(pseudo,argument){var args,fn=Expr.pseudos[pseudo]||Expr.setFilters[pseudo.toLowerCase()]||Sizzle.error("unsupported pseudo: "+pseudo);if(fn[expando]){return fn(argument);}if(fn.length>1){args=[pseudo,pseudo,"",argument];return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())?markFunction(function(seed,matches){var idx,matched=fn(seed,argument),i=matched.length;while(i--){idx=indexOf(seed,matched[i]);seed[idx]=!(matches[idx]=matched[i]);}}):function(elem){return fn(elem,0,args);};}return fn;}},pseudos:{"not":markFunction(function(selector){var input=[],results=[],matcher=compile(selector.replace(rtrim,"$1"));return matcher[expando]?markFunction(function(seed,matches,context,xml){var elem,unmatched=matcher(seed,null,xml,[]),i=seed.length;while(i--){if(elem=unmatched[i]){seed[i]=!(matches[i]=elem);}}}):function(elem,context,xml){input[0]=elem;matcher(input,null,xml,results);input[0]=null;return!results.pop();};}),"has":markFunction(function(selector){return function(elem){return Sizzle(selector,elem).length>0;};}),"contains":markFunction(function(text){text=text.replace(runescape,funescape);return function(elem){return(elem.textContent||getText(elem)).indexOf(text)>-1;};}),"lang":markFunction(function(lang){if(!ridentifier.test(lang||"")){Sizzle.error("unsupported lang: "+lang);}lang=lang.replace(runescape,funescape).toLowerCase();return function(elem){var elemLang;do{if(elemLang=documentIsHTML?elem.lang:elem.getAttribute("xml:lang")||elem.getAttribute("lang")){elemLang=elemLang.toLowerCase();return elemLang===lang||elemLang.indexOf(lang+"-")===0;}}while((elem=elem.parentNode)&&elem.nodeType===1);return false;};}),"target":function(elem){var hash=window.location&&window.location.hash;return hash&&hash.slice(1)===elem.id;},"root":function(elem){return elem===docElem;},"focus":function(elem){return elem===document.activeElement&&(!document.hasFocus||document.hasFocus())&&!!(elem.type||elem.href||~elem.tabIndex);},"enabled":createDisabledPseudo(false),"disabled":createDisabledPseudo(true),"checked":function(elem){var nodeName=elem.nodeName.toLowerCase();return nodeName==="input"&&!!elem.checked||nodeName==="option"&&!!elem.selected;},"selected":function(elem){if(elem.parentNode){elem.parentNode.selectedIndex;}return elem.selected===true;},"empty":function(elem){for(elem=elem.firstChild;elem;elem=elem.nextSibling){if(elem.nodeType<6){return false;}}return true;},"parent":function(elem){return!Expr.pseudos["empty"](elem);},"header":function(elem){return rheader.test(elem.nodeName);},"input":function(elem){return rinputs.test(elem.nodeName);},"button":function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type==="button"||name==="button";},"text":function(elem){var attr;return elem.nodeName.toLowerCase()==="input"&&elem.type==="text"&&((attr=elem.getAttribute("type"))==null||attr.toLowerCase()==="text");},"first":createPositionalPseudo(function(){return[0];}),"last":createPositionalPseudo(function(matchIndexes,length){return[length-1];}),"eq":createPositionalPseudo(function(matchIndexes,length,argument){return[argument<0?argument+length:argument];}),"even":createPositionalPseudo(function(matchIndexes,length){var i=0;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"odd":createPositionalPseudo(function(matchIndexes,length){var i=1;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"lt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument>length?length:argument;for(;--i>=0;){matchIndexes.push(i);}return matchIndexes;}),"gt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument;for(;++i<length;){matchIndexes.push(i);}return matchIndexes;})}};Expr.pseudos["nth"]=Expr.pseudos["eq"];for(i in{radio:true,checkbox:true,file:true,password:true,image:true}){Expr.pseudos[i]=createInputPseudo(i);}for(i in{submit:true,reset:true}){Expr.pseudos[i]=createButtonPseudo(i);}function setFilters(){}setFilters.prototype=Expr.filters=Expr.pseudos;Expr.setFilters=new setFilters();tokenize=Sizzle.tokenize=function(selector,parseOnly){var matched,match,tokens,type,soFar,groups,preFilters,cached=tokenCache[selector+" "];if(cached){return parseOnly?0:cached.slice(0);}soFar=selector;groups=[];preFilters=Expr.preFilter;while(soFar){if(!matched||(match=rcomma.exec(soFar))){if(match){soFar=soFar.slice(match[0].length)||soFar;}groups.push(tokens=[]);}matched=false;if(match=rcombinators.exec(soFar)){matched=match.shift();tokens.push({value:matched,type:match[0].replace(rtrim," ")});soFar=soFar.slice(matched.length);}for(type in Expr.filter){if((match=matchExpr[type].exec(soFar))&&(!preFilters[type]||(match=preFilters[type](match)))){matched=match.shift();tokens.push({value:matched,type:type,matches:match});soFar=soFar.slice(matched.length);}}if(!matched){break;}}return parseOnly?soFar.length:soFar?Sizzle.error(selector):tokenCache(selector,groups).slice(0);};function toSelector(tokens){var i=0,len=tokens.length,selector="";for(;i<len;i++){selector+=tokens[i].value;}return selector;}function addCombinator(matcher,combinator,base){var dir=combinator.dir,skip=combinator.next,key=skip||dir,checkNonElements=base&&key==="parentNode",doneName=done++;return combinator.first?function(elem,context,xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){return matcher(elem,context,xml);}}return false;}:function(elem,context,xml){var oldCache,uniqueCache,outerCache,newCache=[dirruns,doneName];if(xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){if(matcher(elem,context,xml)){return true;}}}}else{while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){outerCache=elem[expando]||(elem[expando]={});uniqueCache=outerCache[elem.uniqueID]||(outerCache[elem.uniqueID]={});if(skip&&skip===elem.nodeName.toLowerCase()){elem=elem[dir]||elem;}else if((oldCache=uniqueCache[key])&&oldCache[0]===dirruns&&oldCache[1]===doneName){return newCache[2]=oldCache[2];}else{uniqueCache[key]=newCache;if(newCache[2]=matcher(elem,context,xml)){return true;}}}}}return false;};}function elementMatcher(matchers){return matchers.length>1?function(elem,context,xml){var i=matchers.length;while(i--){if(!matchers[i](elem,context,xml)){return false;}}return true;}:matchers[0];}function multipleContexts(selector,contexts,results){var i=0,len=contexts.length;for(;i<len;i++){Sizzle(selector,contexts[i],results);}return results;}function condense(unmatched,map,filter,context,xml){var elem,newUnmatched=[],i=0,len=unmatched.length;for(;i<len;i++){if(elem=unmatched[i]){if(!filter||filter(elem,context,xml)){newUnmatched.push(elem);if(map!=null){map.push(i);}}}}return newUnmatched;}function setMatcher(preFilter,selector,matcher,postFilter,postFinder,postSelector){if(postFilter&&!postFilter[expando]){postFilter=setMatcher(postFilter);}if(postFinder&&!postFinder[expando]){postFinder=setMatcher(postFinder,postSelector);}return markFunction(function(seed,results,context,xml){var temp,i,elem,preMap=[],postMap=[],preexisting=results.length,elems=seed||multipleContexts(selector||"*",context.nodeType?[context]:context,[]),matcherIn=preFilter&&(seed||!selector)?condense(elems,preMap,preFilter,context,xml):elems,matcherOut=matcher?postFinder||(seed?preFilter:preexisting||postFilter)?[]:results:matcherIn;if(matcher){matcher(matcherIn,matcherOut,context,xml);}if(postFilter){temp=condense(matcherOut,postMap);postFilter(temp,[],context,xml);i=temp.length;while(i--){if(elem=temp[i]){matcherOut[postMap[i]]=!(matcherIn[postMap[i]]=elem);}}}if(seed){if(postFinder||preFilter){if(postFinder){temp=[];i=matcherOut.length;while(i--){if(elem=matcherOut[i]){temp.push(matcherIn[i]=elem);}}postFinder(null,matcherOut=[],temp,xml);}i=matcherOut.length;while(i--){if((elem=matcherOut[i])&&(temp=postFinder?indexOf(seed,elem):preMap[i])>-1){seed[temp]=!(results[temp]=elem);}}}}else{matcherOut=condense(matcherOut===results?matcherOut.splice(preexisting,matcherOut.length):matcherOut);if(postFinder){postFinder(null,results,matcherOut,xml);}else{push.apply(results,matcherOut);}}});}function matcherFromTokens(tokens){var checkContext,matcher,j,len=tokens.length,leadingRelative=Expr.relative[tokens[0].type],implicitRelative=leadingRelative||Expr.relative[" "],i=leadingRelative?1:0,matchContext=addCombinator(function(elem){return elem===checkContext;},implicitRelative,true),matchAnyContext=addCombinator(function(elem){return indexOf(checkContext,elem)>-1;},implicitRelative,true),matchers=[function(elem,context,xml){var ret=!leadingRelative&&(xml||context!==outermostContext)||((checkContext=context).nodeType?matchContext(elem,context,xml):matchAnyContext(elem,context,xml));checkContext=null;return ret;}];for(;i<len;i++){if(matcher=Expr.relative[tokens[i].type]){matchers=[addCombinator(elementMatcher(matchers),matcher)];}else{matcher=Expr.filter[tokens[i].type].apply(null,tokens[i].matches);if(matcher[expando]){j=++i;for(;j<len;j++){if(Expr.relative[tokens[j].type]){break;}}return setMatcher(i>1&&elementMatcher(matchers),i>1&&toSelector(tokens.slice(0,i-1).concat({value:tokens[i-2].type===" "?"*":""})).replace(rtrim,"$1"),matcher,i<j&&matcherFromTokens(tokens.slice(i,j)),j<len&&matcherFromTokens(tokens=tokens.slice(j)),j<len&&toSelector(tokens));}matchers.push(matcher);}}return elementMatcher(matchers);}function matcherFromGroupMatchers(elementMatchers,setMatchers){var bySet=setMatchers.length>0,byElement=elementMatchers.length>0,superMatcher=function(seed,context,xml,results,outermost){var elem,j,matcher,matchedCount=0,i="0",unmatched=seed&&[],setMatched=[],contextBackup=outermostContext,elems=seed||byElement&&Expr.find["TAG"]("*",outermost),dirrunsUnique=dirruns+=contextBackup==null?1:Math.random()||0.1,len=elems.length;if(outermost){outermostContext=context===document||context||outermost;}for(;i!==len&&(elem=elems[i])!=null;i++){if(byElement&&elem){j=0;if(!context&&elem.ownerDocument!==document){setDocument(elem);xml=!documentIsHTML;}while(matcher=elementMatchers[j++]){if(matcher(elem,context||document,xml)){results.push(elem);break;}}if(outermost){dirruns=dirrunsUnique;}}if(bySet){if(elem=!matcher&&elem){matchedCount--;}if(seed){unmatched.push(elem);}}}matchedCount+=i;if(bySet&&i!==matchedCount){j=0;while(matcher=setMatchers[j++]){matcher(unmatched,setMatched,context,xml);}if(seed){if(matchedCount>0){while(i--){if(!(unmatched[i]||setMatched[i])){setMatched[i]=pop.call(results);}}}setMatched=condense(setMatched);}push.apply(results,setMatched);if(outermost&&!seed&&setMatched.length>0&&matchedCount+setMatchers.length>1){Sizzle.uniqueSort(results);}}if(outermost){dirruns=dirrunsUnique;outermostContext=contextBackup;}return unmatched;};return bySet?markFunction(superMatcher):superMatcher;}compile=Sizzle.compile=function(selector,match){var i,setMatchers=[],elementMatchers=[],cached=compilerCache[selector+" "];if(!cached){if(!match){match=tokenize(selector);}i=match.length;while(i--){cached=matcherFromTokens(match[i]);if(cached[expando]){setMatchers.push(cached);}else{elementMatchers.push(cached);}}cached=compilerCache(selector,matcherFromGroupMatchers(elementMatchers,setMatchers));cached.selector=selector;}return cached;};select=Sizzle.select=function(selector,context,results,seed){var i,tokens,token,type,find,compiled=typeof selector==="function"&&selector,match=!seed&&tokenize(selector=compiled.selector||selector);results=results||[];if(match.length===1){tokens=match[0]=match[0].slice(0);if(tokens.length>2&&(token=tokens[0]).type==="ID"&&context.nodeType===9&&documentIsHTML&&Expr.relative[tokens[1].type]){context=(Expr.find["ID"](token.matches[0].replace(runescape,funescape),context)||[])[0];if(!context){return results;}else if(compiled){context=context.parentNode;}selector=selector.slice(tokens.shift().value.length);}i=matchExpr["needsContext"].test(selector)?0:tokens.length;while(i--){token=tokens[i];if(Expr.relative[type=token.type]){break;}if(find=Expr.find[type]){if(seed=find(token.matches[0].replace(runescape,funescape),rsibling.test(tokens[0].type)&&testContext(context.parentNode)||context)){tokens.splice(i,1);selector=seed.length&&toSelector(tokens);if(!selector){push.apply(results,seed);return results;}break;}}}}(compiled||compile(selector,match))(seed,context,!documentIsHTML,results,!context||rsibling.test(selector)&&testContext(context.parentNode)||context);return results;};support.sortStable=expando.split("").sort(sortOrder).join("")===expando;support.detectDuplicates=!!hasDuplicate;setDocument();support.sortDetached=assert(function(el){return el.compareDocumentPosition(document.createElement("fieldset"))&1;});if(!assert(function(el){el.innerHTML="<a href='#'></a>";return el.firstChild.getAttribute("href")==="#";})){addHandle("type|href|height|width",function(elem,name,isXML){if(!isXML){return elem.getAttribute(name,name.toLowerCase()==="type"?1:2);}});}if(!support.attributes||!assert(function(el){el.innerHTML="<input/>";el.firstChild.setAttribute("value","");return el.firstChild.getAttribute("value")==="";})){addHandle("value",function(elem,name,isXML){if(!isXML&&elem.nodeName.toLowerCase()==="input"){return elem.defaultValue;}});}if(!assert(function(el){return el.getAttribute("disabled")==null;})){addHandle(booleans,function(elem,name,isXML){var val;if(!isXML){return elem[name]===true?name.toLowerCase():(val=elem.getAttributeNode(name))&&val.specified?val.value:null;}});}return Sizzle;}(window);jQuery.find=Sizzle;jQuery.expr=Sizzle.selectors;jQuery.expr[":"]=jQuery.expr.pseudos;jQuery.uniqueSort=jQuery.unique=Sizzle.uniqueSort;jQuery.text=Sizzle.getText;jQuery.isXMLDoc=Sizzle.isXML;jQuery.contains=Sizzle.contains;jQuery.escapeSelector=Sizzle.escape;var dir=function(elem,dir,until){var matched=[],truncate=until!==undefined;while((elem=elem[dir])&&elem.nodeType!==9){if(elem.nodeType===1){if(truncate&&jQuery(elem).is(until)){break;}matched.push(elem);}}return matched;};var siblings=function(n,elem){var matched=[];for(;n;n=n.nextSibling){if(n.nodeType===1&&n!==elem){matched.push(n);}}return matched;};var rneedsContext=jQuery.expr.match.needsContext;function nodeName(elem,name){return elem.nodeName&&elem.nodeName.toLowerCase()===name.toLowerCase();}var rsingleTag=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function winnow(elements,qualifier,not){if(isFunction(qualifier)){return jQuery.grep(elements,function(elem,i){return!!qualifier.call(elem,i,elem)!==not;});}if(qualifier.nodeType){return jQuery.grep(elements,function(elem){return elem===qualifier!==not;});}if(typeof qualifier!=="string"){return jQuery.grep(elements,function(elem){return indexOf.call(qualifier,elem)>-1!==not;});}return jQuery.filter(qualifier,elements,not);}jQuery.filter=function(expr,elems,not){var elem=elems[0];if(not){expr=":not("+expr+")";}if(elems.length===1&&elem.nodeType===1){return jQuery.find.matchesSelector(elem,expr)?[elem]:[];}return jQuery.find.matches(expr,jQuery.grep(elems,function(elem){return elem.nodeType===1;}));};jQuery.fn.extend({find:function(selector){var i,ret,len=this.length,self=this;if(typeof selector!=="string"){return this.pushStack(jQuery(selector).filter(function(){for(i=0;i<len;i++){if(jQuery.contains(self[i],this)){return true;}}}));}ret=this.pushStack([]);for(i=0;i<len;i++){jQuery.find(selector,self[i],ret);}return len>1?jQuery.uniqueSort(ret):ret;},filter:function(selector){return this.pushStack(winnow(this,selector||[],false));},not:function(selector){return this.pushStack(winnow(this,selector||[],true));},is:function(selector){return!!winnow(this,typeof selector==="string"&&rneedsContext.test(selector)?jQuery(selector):selector||[],false).length;}});var rootjQuery,rquickExpr=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,init=jQuery.fn.init=function(selector,context,root){var match,elem;if(!selector){return this;}root=root||rootjQuery;if(typeof selector==="string"){if(selector[0]==="<"&&selector[selector.length-1]===">"&&selector.length>=3){match=[null,selector,null];}else{match=rquickExpr.exec(selector);}if(match&&(match[1]||!context)){if(match[1]){context=context instanceof jQuery?context[0]:context;jQuery.merge(this,jQuery.parseHTML(match[1],context&&context.nodeType?context.ownerDocument||context:document,true));if(rsingleTag.test(match[1])&&jQuery.isPlainObject(context)){for(match in context){if(isFunction(this[match])){this[match](context[match]);}else{this.attr(match,context[match]);}}}return this;}else{elem=document.getElementById(match[2]);if(elem){this[0]=elem;this.length=1;}return this;}}else if(!context||context.jquery){return(context||root).find(selector);}else{return this.constructor(context).find(selector);}}else if(selector.nodeType){this[0]=selector;this.length=1;return this;}else if(isFunction(selector)){return root.ready!==undefined?root.ready(selector):selector(jQuery);}return jQuery.makeArray(selector,this);};init.prototype=jQuery.fn;rootjQuery=jQuery(document);var rparentsprev=/^(?:parents|prev(?:Until|All))/,guaranteedUnique={children:true,contents:true,next:true,prev:true};jQuery.fn.extend({has:function(target){var targets=jQuery(target,this),l=targets.length;return this.filter(function(){var i=0;for(;i<l;i++){if(jQuery.contains(this,targets[i])){return true;}}});},closest:function(selectors,context){var cur,i=0,l=this.length,matched=[],targets=typeof selectors!=="string"&&jQuery(selectors);if(!rneedsContext.test(selectors)){for(;i<l;i++){for(cur=this[i];cur&&cur!==context;cur=cur.parentNode){if(cur.nodeType<11&&(targets?targets.index(cur)>-1:cur.nodeType===1&&jQuery.find.matchesSelector(cur,selectors))){matched.push(cur);break;}}}}return this.pushStack(matched.length>1?jQuery.uniqueSort(matched):matched);},index:function(elem){if(!elem){return this[0]&&this[0].parentNode?this.first().prevAll().length:-1;}if(typeof elem==="string"){return indexOf.call(jQuery(elem),this[0]);}return indexOf.call(this,elem.jquery?elem[0]:elem);},add:function(selector,context){return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(),jQuery(selector,context))));},addBack:function(selector){return this.add(selector==null?this.prevObject:this.prevObject.filter(selector));}});function sibling(cur,dir){while((cur=cur[dir])&&cur.nodeType!==1){}return cur;}jQuery.each({parent:function(elem){var parent=elem.parentNode;return parent&&parent.nodeType!==11?parent:null;},parents:function(elem){return dir(elem,"parentNode");},parentsUntil:function(elem,i,until){return dir(elem,"parentNode",until);},next:function(elem){return sibling(elem,"nextSibling");},prev:function(elem){return sibling(elem,"previousSibling");},nextAll:function(elem){return dir(elem,"nextSibling");},prevAll:function(elem){return dir(elem,"previousSibling");},nextUntil:function(elem,i,until){return dir(elem,"nextSibling",until);},prevUntil:function(elem,i,until){return dir(elem,"previousSibling",until);},siblings:function(elem){return siblings((elem.parentNode||{}).firstChild,elem);},children:function(elem){return siblings(elem.firstChild);},contents:function(elem){if(typeof elem.contentDocument!=="undefined"){return elem.contentDocument;}if(nodeName(elem,"template")){elem=elem.content||elem;}return jQuery.merge([],elem.childNodes);}},function(name,fn){jQuery.fn[name]=function(until,selector){var matched=jQuery.map(this,fn,until);if(name.slice(-5)!=="Until"){selector=until;}if(selector&&typeof selector==="string"){matched=jQuery.filter(selector,matched);}if(this.length>1){if(!guaranteedUnique[name]){jQuery.uniqueSort(matched);}if(rparentsprev.test(name)){matched.reverse();}}return this.pushStack(matched);};});var rnothtmlwhite=/[^\x20\t\r\n\f]+/g;function createOptions(options){var object={};jQuery.each(options.match(rnothtmlwhite)||[],function(_,flag){object[flag]=true;});return object;}jQuery.Callbacks=function(options){options=typeof options==="string"?createOptions(options):jQuery.extend({},options);var firing,memory,fired,locked,list=[],queue=[],firingIndex=-1,fire=function(){locked=locked||options.once;fired=firing=true;for(;queue.length;firingIndex=-1){memory=queue.shift();while(++firingIndex<list.length){if(list[firingIndex].apply(memory[0],memory[1])===false&&options.stopOnFalse){firingIndex=list.length;memory=false;}}}if(!options.memory){memory=false;}firing=false;if(locked){if(memory){list=[];}else{list="";}}},self={add:function(){if(list){if(memory&&!firing){firingIndex=list.length-1;queue.push(memory);}(function add(args){jQuery.each(args,function(_,arg){if(isFunction(arg)){if(!options.unique||!self.has(arg)){list.push(arg);}}else if(arg&&arg.length&&toType(arg)!=="string"){add(arg);}});})(arguments);if(memory&&!firing){fire();}}return this;},remove:function(){jQuery.each(arguments,function(_,arg){var index;while((index=jQuery.inArray(arg,list,index))>-1){list.splice(index,1);if(index<=firingIndex){firingIndex--;}}});return this;},has:function(fn){return fn?jQuery.inArray(fn,list)>-1:list.length>0;},empty:function(){if(list){list=[];}return this;},disable:function(){locked=queue=[];list=memory="";return this;},disabled:function(){return!list;},lock:function(){locked=queue=[];if(!memory&&!firing){list=memory="";}return this;},locked:function(){return!!locked;},fireWith:function(context,args){if(!locked){args=args||[];args=[context,args.slice?args.slice():args];queue.push(args);if(!firing){fire();}}return this;},fire:function(){self.fireWith(this,arguments);return this;},fired:function(){return!!fired;}};return self;};function Identity(v){return v;}function Thrower(ex){throw ex;}function adoptValue(value,resolve,reject,noValue){var method;try{if(value&&isFunction(method=value.promise)){method.call(value).done(resolve).fail(reject);}else if(value&&isFunction(method=value.then)){method.call(value,resolve,reject);}else{resolve.apply(undefined,[value].slice(noValue));}}catch(value){reject.apply(undefined,[value]);}}jQuery.extend({Deferred:function(func){var tuples=[["notify","progress",jQuery.Callbacks("memory"),jQuery.Callbacks("memory"),2],["resolve","done",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),0,"resolved"],["reject","fail",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),1,"rejected"]],state="pending",promise={state:function(){return state;},always:function(){deferred.done(arguments).fail(arguments);return this;},"catch":function(fn){return promise.then(null,fn);},pipe:function(){var fns=arguments;return jQuery.Deferred(function(newDefer){jQuery.each(tuples,function(i,tuple){var fn=isFunction(fns[tuple[4]])&&fns[tuple[4]];deferred[tuple[1]](function(){var returned=fn&&fn.apply(this,arguments);if(returned&&isFunction(returned.promise)){returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);}else{newDefer[tuple[0]+"With"](this,fn?[returned]:arguments);}});});fns=null;}).promise();},then:function(onFulfilled,onRejected,onProgress){var maxDepth=0;function resolve(depth,deferred,handler,special){return function(){var that=this,args=arguments,mightThrow=function(){var returned,then;if(depth<maxDepth){return;}returned=handler.apply(that,args);if(returned===deferred.promise()){throw new TypeError("Thenable self-resolution");}then=returned&&(typeof returned==="object"||typeof returned==="function")&&returned.then;if(isFunction(then)){if(special){then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special));}else{maxDepth++;then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special),resolve(maxDepth,deferred,Identity,deferred.notifyWith));}}else{if(handler!==Identity){that=undefined;args=[returned];}(special||deferred.resolveWith)(that,args);}},process=special?mightThrow:function(){try{mightThrow();}catch(e){if(jQuery.Deferred.exceptionHook){jQuery.Deferred.exceptionHook(e,process.stackTrace);}if(depth+1>=maxDepth){if(handler!==Thrower){that=undefined;args=[e];}deferred.rejectWith(that,args);}}};if(depth){process();}else{if(jQuery.Deferred.getStackHook){process.stackTrace=jQuery.Deferred.getStackHook();}window.setTimeout(process);}};}return jQuery.Deferred(function(newDefer){tuples[0][3].add(resolve(0,newDefer,isFunction(onProgress)?onProgress:Identity,newDefer.notifyWith));tuples[1][3].add(resolve(0,newDefer,isFunction(onFulfilled)?onFulfilled:Identity));tuples[2][3].add(resolve(0,newDefer,isFunction(onRejected)?onRejected:Thrower));}).promise();},promise:function(obj){return obj!=null?jQuery.extend(obj,promise):promise;}},deferred={};jQuery.each(tuples,function(i,tuple){var list=tuple[2],stateString=tuple[5];promise[tuple[1]]=list.add;if(stateString){list.add(function(){state=stateString;},tuples[3-i][2].disable,tuples[3-i][3].disable,tuples[0][2].lock,tuples[0][3].lock);}list.add(tuple[3].fire);deferred[tuple[0]]=function(){deferred[tuple[0]+"With"](this===deferred?undefined:this,arguments);return this;};deferred[tuple[0]+"With"]=list.fireWith;});promise.promise(deferred);if(func){func.call(deferred,deferred);}return deferred;},when:function(singleValue){var remaining=arguments.length,i=remaining,resolveContexts=Array(i),resolveValues=slice.call(arguments),master=jQuery.Deferred(),updateFunc=function(i){return function(value){resolveContexts[i]=this;resolveValues[i]=arguments.length>1?slice.call(arguments):value;if(! --remaining){master.resolveWith(resolveContexts,resolveValues);}};};if(remaining<=1){adoptValue(singleValue,master.done(updateFunc(i)).resolve,master.reject,!remaining);if(master.state()==="pending"||isFunction(resolveValues[i]&&resolveValues[i].then)){return master.then();}}while(i--){adoptValue(resolveValues[i],updateFunc(i),master.reject);}return master.promise();}});var rerrorNames=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;jQuery.Deferred.exceptionHook=function(error,stack){if(window.console&&window.console.warn&&error&&rerrorNames.test(error.name)){window.console.warn("jQuery.Deferred exception: "+error.message,error.stack,stack);}};jQuery.readyException=function(error){window.setTimeout(function(){throw error;});};var readyList=jQuery.Deferred();jQuery.fn.ready=function(fn){readyList.then(fn).catch(function(error){jQuery.readyException(error);});return this;};jQuery.extend({isReady:false,readyWait:1,ready:function(wait){if(wait===true?--jQuery.readyWait:jQuery.isReady){return;}jQuery.isReady=true;if(wait!==true&&--jQuery.readyWait>0){return;}readyList.resolveWith(document,[jQuery]);}});jQuery.ready.then=readyList.then;function completed(){document.removeEventListener("DOMContentLoaded",completed);window.removeEventListener("load",completed);jQuery.ready();}if(document.readyState==="complete"||document.readyState!=="loading"&&!document.documentElement.doScroll){window.setTimeout(jQuery.ready);}else{document.addEventListener("DOMContentLoaded",completed);window.addEventListener("load",completed);}var access=function(elems,fn,key,value,chainable,emptyGet,raw){var i=0,len=elems.length,bulk=key==null;if(toType(key)==="object"){chainable=true;for(i in key){access(elems,fn,i,key[i],true,emptyGet,raw);}}else if(value!==undefined){chainable=true;if(!isFunction(value)){raw=true;}if(bulk){if(raw){fn.call(elems,value);fn=null;}else{bulk=fn;fn=function(elem,key,value){return bulk.call(jQuery(elem),value);};}}if(fn){for(;i<len;i++){fn(elems[i],key,raw?value:value.call(elems[i],i,fn(elems[i],key)));}}}if(chainable){return elems;}if(bulk){return fn.call(elems);}return len?fn(elems[0],key):emptyGet;};var rmsPrefix=/^-ms-/,rdashAlpha=/-([a-z])/g;function fcamelCase(all,letter){return letter.toUpperCase();}function camelCase(string){return string.replace(rmsPrefix,"ms-").replace(rdashAlpha,fcamelCase);}var acceptData=function(owner){return owner.nodeType===1||owner.nodeType===9||!+owner.nodeType;};function Data(){this.expando=jQuery.expando+Data.uid++;}Data.uid=1;Data.prototype={cache:function(owner){var value=owner[this.expando];if(!value){value={};if(acceptData(owner)){if(owner.nodeType){owner[this.expando]=value;}else{Object.defineProperty(owner,this.expando,{value:value,configurable:true});}}}return value;},set:function(owner,data,value){var prop,cache=this.cache(owner);if(typeof data==="string"){cache[camelCase(data)]=value;}else{for(prop in data){cache[camelCase(prop)]=data[prop];}}return cache;},get:function(owner,key){return key===undefined?this.cache(owner):owner[this.expando]&&owner[this.expando][camelCase(key)];},access:function(owner,key,value){if(key===undefined||key&&typeof key==="string"&&value===undefined){return this.get(owner,key);}this.set(owner,key,value);return value!==undefined?value:key;},remove:function(owner,key){var i,cache=owner[this.expando];if(cache===undefined){return;}if(key!==undefined){if(Array.isArray(key)){key=key.map(camelCase);}else{key=camelCase(key);key=key in cache?[key]:key.match(rnothtmlwhite)||[];}i=key.length;while(i--){delete cache[key[i]];}}if(key===undefined||jQuery.isEmptyObject(cache)){if(owner.nodeType){owner[this.expando]=undefined;}else{delete owner[this.expando];}}},hasData:function(owner){var cache=owner[this.expando];return cache!==undefined&&!jQuery.isEmptyObject(cache);}};var dataPriv=new Data();var dataUser=new Data();var rbrace=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,rmultiDash=/[A-Z]/g;function getData(data){if(data==="true"){return true;}if(data==="false"){return false;}if(data==="null"){return null;}if(data===+data+""){return+data;}if(rbrace.test(data)){return JSON.parse(data);}return data;}function dataAttr(elem,key,data){var name;if(data===undefined&&elem.nodeType===1){name="data-"+key.replace(rmultiDash,"-$&").toLowerCase();data=elem.getAttribute(name);if(typeof data==="string"){try{data=getData(data);}catch(e){}dataUser.set(elem,key,data);}else{data=undefined;}}return data;}jQuery.extend({hasData:function(elem){return dataUser.hasData(elem)||dataPriv.hasData(elem);},data:function(elem,name,data){return dataUser.access(elem,name,data);},removeData:function(elem,name){dataUser.remove(elem,name);},_data:function(elem,name,data){return dataPriv.access(elem,name,data);},_removeData:function(elem,name){dataPriv.remove(elem,name);}});jQuery.fn.extend({data:function(key,value){var i,name,data,elem=this[0],attrs=elem&&elem.attributes;if(key===undefined){if(this.length){data=dataUser.get(elem);if(elem.nodeType===1&&!dataPriv.get(elem,"hasDataAttrs")){i=attrs.length;while(i--){if(attrs[i]){name=attrs[i].name;if(name.indexOf("data-")===0){name=camelCase(name.slice(5));dataAttr(elem,name,data[name]);}}}dataPriv.set(elem,"hasDataAttrs",true);}}return data;}if(typeof key==="object"){return this.each(function(){dataUser.set(this,key);});}return access(this,function(value){var data;if(elem&&value===undefined){data=dataUser.get(elem,key);if(data!==undefined){return data;}data=dataAttr(elem,key);if(data!==undefined){return data;}return;}this.each(function(){dataUser.set(this,key,value);});},null,value,arguments.length>1,null,true);},removeData:function(key){return this.each(function(){dataUser.remove(this,key);});}});jQuery.extend({queue:function(elem,type,data){var queue;if(elem){type=(type||"fx")+"queue";queue=dataPriv.get(elem,type);if(data){if(!queue||Array.isArray(data)){queue=dataPriv.access(elem,type,jQuery.makeArray(data));}else{queue.push(data);}}return queue||[];}},dequeue:function(elem,type){type=type||"fx";var queue=jQuery.queue(elem,type),startLength=queue.length,fn=queue.shift(),hooks=jQuery._queueHooks(elem,type),next=function(){jQuery.dequeue(elem,type);};if(fn==="inprogress"){fn=queue.shift();startLength--;}if(fn){if(type==="fx"){queue.unshift("inprogress");}delete hooks.stop;fn.call(elem,next,hooks);}if(!startLength&&hooks){hooks.empty.fire();}},_queueHooks:function(elem,type){var key=type+"queueHooks";return dataPriv.get(elem,key)||dataPriv.access(elem,key,{empty:jQuery.Callbacks("once memory").add(function(){dataPriv.remove(elem,[type+"queue",key]);})});}});jQuery.fn.extend({queue:function(type,data){var setter=2;if(typeof type!=="string"){data=type;type="fx";setter--;}if(arguments.length<setter){return jQuery.queue(this[0],type);}return data===undefined?this:this.each(function(){var queue=jQuery.queue(this,type,data);jQuery._queueHooks(this,type);if(type==="fx"&&queue[0]!=="inprogress"){jQuery.dequeue(this,type);}});},dequeue:function(type){return this.each(function(){jQuery.dequeue(this,type);});},clearQueue:function(type){return this.queue(type||"fx",[]);},promise:function(type,obj){var tmp,count=1,defer=jQuery.Deferred(),elements=this,i=this.length,resolve=function(){if(! --count){defer.resolveWith(elements,[elements]);}};if(typeof type!=="string"){obj=type;type=undefined;}type=type||"fx";while(i--){tmp=dataPriv.get(elements[i],type+"queueHooks");if(tmp&&tmp.empty){count++;tmp.empty.add(resolve);}}resolve();return defer.promise(obj);}});var pnum=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;var rcssNum=new RegExp("^(?:([+-])=|)("+pnum+")([a-z%]*)$","i");var cssExpand=["Top","Right","Bottom","Left"];var documentElement=document.documentElement;var isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem);},composed={composed:true};if(documentElement.attachShadow){isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem)||elem.getRootNode(composed)===elem.ownerDocument;};}var isHiddenWithinTree=function(elem,el){elem=el||elem;return elem.style.display==="none"||elem.style.display===""&&isAttached(elem)&&jQuery.css(elem,"display")==="none";};var swap=function(elem,options,callback,args){var ret,name,old={};for(name in options){old[name]=elem.style[name];elem.style[name]=options[name];}ret=callback.apply(elem,args||[]);for(name in options){elem.style[name]=old[name];}return ret;};function adjustCSS(elem,prop,valueParts,tween){var adjusted,scale,maxIterations=20,currentValue=tween?function(){return tween.cur();}:function(){return jQuery.css(elem,prop,"");},initial=currentValue(),unit=valueParts&&valueParts[3]||(jQuery.cssNumber[prop]?"":"px"),initialInUnit=elem.nodeType&&(jQuery.cssNumber[prop]||unit!=="px"&&+initial)&&rcssNum.exec(jQuery.css(elem,prop));if(initialInUnit&&initialInUnit[3]!==unit){initial=initial/2;unit=unit||initialInUnit[3];initialInUnit=+initial||1;while(maxIterations--){jQuery.style(elem,prop,initialInUnit+unit);if((1-scale)*(1-(scale=currentValue()/initial||0.5))<=0){maxIterations=0;}initialInUnit=initialInUnit/scale;}initialInUnit=initialInUnit*2;jQuery.style(elem,prop,initialInUnit+unit);valueParts=valueParts||[];}if(valueParts){initialInUnit=+initialInUnit||+initial||0;adjusted=valueParts[1]?initialInUnit+(valueParts[1]+1)*valueParts[2]:+valueParts[2];if(tween){tween.unit=unit;tween.start=initialInUnit;tween.end=adjusted;}}return adjusted;}var defaultDisplayMap={};function getDefaultDisplay(elem){var temp,doc=elem.ownerDocument,nodeName=elem.nodeName,display=defaultDisplayMap[nodeName];if(display){return display;}temp=doc.body.appendChild(doc.createElement(nodeName));display=jQuery.css(temp,"display");temp.parentNode.removeChild(temp);if(display==="none"){display="block";}defaultDisplayMap[nodeName]=display;return display;}function showHide(elements,show){var display,elem,values=[],index=0,length=elements.length;for(;index<length;index++){elem=elements[index];if(!elem.style){continue;}display=elem.style.display;if(show){if(display==="none"){values[index]=dataPriv.get(elem,"display")||null;if(!values[index]){elem.style.display="";}}if(elem.style.display===""&&isHiddenWithinTree(elem)){values[index]=getDefaultDisplay(elem);}}else{if(display!=="none"){values[index]="none";dataPriv.set(elem,"display",display);}}}for(index=0;index<length;index++){if(values[index]!=null){elements[index].style.display=values[index];}}return elements;}jQuery.fn.extend({show:function(){return showHide(this,true);},hide:function(){return showHide(this);},toggle:function(state){if(typeof state==="boolean"){return state?this.show():this.hide();}return this.each(function(){if(isHiddenWithinTree(this)){jQuery(this).show();}else{jQuery(this).hide();}});}});var rcheckableType=/^(?:checkbox|radio)$/i;var rtagName=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i;var rscriptType=/^$|^module$|\/(?:java|ecma)script/i;var wrapMap={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};wrapMap.optgroup=wrapMap.option;wrapMap.tbody=wrapMap.tfoot=wrapMap.colgroup=wrapMap.caption=wrapMap.thead;wrapMap.th=wrapMap.td;function getAll(context,tag){var ret;if(typeof context.getElementsByTagName!=="undefined"){ret=context.getElementsByTagName(tag||"*");}else if(typeof context.querySelectorAll!=="undefined"){ret=context.querySelectorAll(tag||"*");}else{ret=[];}if(tag===undefined||tag&&nodeName(context,tag)){return jQuery.merge([context],ret);}return ret;}function setGlobalEval(elems,refElements){var i=0,l=elems.length;for(;i<l;i++){dataPriv.set(elems[i],"globalEval",!refElements||dataPriv.get(refElements[i],"globalEval"));}}var rhtml=/<|&#?\w+;/;function buildFragment(elems,context,scripts,selection,ignored){var elem,tmp,tag,wrap,attached,j,fragment=context.createDocumentFragment(),nodes=[],i=0,l=elems.length;for(;i<l;i++){elem=elems[i];if(elem||elem===0){if(toType(elem)==="object"){jQuery.merge(nodes,elem.nodeType?[elem]:elem);}else if(!rhtml.test(elem)){nodes.push(context.createTextNode(elem));}else{tmp=tmp||fragment.appendChild(context.createElement("div"));tag=(rtagName.exec(elem)||["",""])[1].toLowerCase();wrap=wrapMap[tag]||wrapMap._default;tmp.innerHTML=wrap[1]+jQuery.htmlPrefilter(elem)+wrap[2];j=wrap[0];while(j--){tmp=tmp.lastChild;}jQuery.merge(nodes,tmp.childNodes);tmp=fragment.firstChild;tmp.textContent="";}}}fragment.textContent="";i=0;while(elem=nodes[i++]){if(selection&&jQuery.inArray(elem,selection)>-1){if(ignored){ignored.push(elem);}continue;}attached=isAttached(elem);tmp=getAll(fragment.appendChild(elem),"script");if(attached){setGlobalEval(tmp);}if(scripts){j=0;while(elem=tmp[j++]){if(rscriptType.test(elem.type||"")){scripts.push(elem);}}}}return fragment;}(function(){var fragment=document.createDocumentFragment(),div=fragment.appendChild(document.createElement("div")),input=document.createElement("input");input.setAttribute("type","radio");input.setAttribute("checked","checked");input.setAttribute("name","t");div.appendChild(input);support.checkClone=div.cloneNode(true).cloneNode(true).lastChild.checked;div.innerHTML="<textarea>x</textarea>";support.noCloneChecked=!!div.cloneNode(true).lastChild.defaultValue;})();var rkeyEvent=/^key/,rmouseEvent=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,rtypenamespace=/^([^.]*)(?:\.(.+)|)/;function returnTrue(){return true;}function returnFalse(){return false;}function expectSync(elem,type){return elem===safeActiveElement()===(type==="focus");}function safeActiveElement(){try{return document.activeElement;}catch(err){}}function on(elem,types,selector,data,fn,one){var origFn,type;if(typeof types==="object"){if(typeof selector!=="string"){data=data||selector;selector=undefined;}for(type in types){on(elem,type,selector,data,types[type],one);}return elem;}if(data==null&&fn==null){fn=selector;data=selector=undefined;}else if(fn==null){if(typeof selector==="string"){fn=data;data=undefined;}else{fn=data;data=selector;selector=undefined;}}if(fn===false){fn=returnFalse;}else if(!fn){return elem;}if(one===1){origFn=fn;fn=function(event){jQuery().off(event);return origFn.apply(this,arguments);};fn.guid=origFn.guid||(origFn.guid=jQuery.guid++);}return elem.each(function(){jQuery.event.add(this,types,fn,data,selector);});}jQuery.event={global:{},add:function(elem,types,handler,data,selector){var handleObjIn,eventHandle,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.get(elem);if(!elemData){return;}if(handler.handler){handleObjIn=handler;handler=handleObjIn.handler;selector=handleObjIn.selector;}if(selector){jQuery.find.matchesSelector(documentElement,selector);}if(!handler.guid){handler.guid=jQuery.guid++;}if(!(events=elemData.events)){events=elemData.events={};}if(!(eventHandle=elemData.handle)){eventHandle=elemData.handle=function(e){return typeof jQuery!=="undefined"&&jQuery.event.triggered!==e.type?jQuery.event.dispatch.apply(elem,arguments):undefined;};}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;special=jQuery.event.special[type]||{};handleObj=jQuery.extend({type:type,origType:origType,data:data,handler:handler,guid:handler.guid,selector:selector,needsContext:selector&&jQuery.expr.match.needsContext.test(selector),namespace:namespaces.join(".")},handleObjIn);if(!(handlers=events[type])){handlers=events[type]=[];handlers.delegateCount=0;if(!special.setup||special.setup.call(elem,data,namespaces,eventHandle)===false){if(elem.addEventListener){elem.addEventListener(type,eventHandle);}}}if(special.add){special.add.call(elem,handleObj);if(!handleObj.handler.guid){handleObj.handler.guid=handler.guid;}}if(selector){handlers.splice(handlers.delegateCount++,0,handleObj);}else{handlers.push(handleObj);}jQuery.event.global[type]=true;}},remove:function(elem,types,handler,selector,mappedTypes){var j,origCount,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.hasData(elem)&&dataPriv.get(elem);if(!elemData||!(events=elemData.events)){return;}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){for(type in events){jQuery.event.remove(elem,type+types[t],handler,selector,true);}continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;handlers=events[type]||[];tmp=tmp[2]&&new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)");origCount=j=handlers.length;while(j--){handleObj=handlers[j];if((mappedTypes||origType===handleObj.origType)&&(!handler||handler.guid===handleObj.guid)&&(!tmp||tmp.test(handleObj.namespace))&&(!selector||selector===handleObj.selector||selector==="**"&&handleObj.selector)){handlers.splice(j,1);if(handleObj.selector){handlers.delegateCount--;}if(special.remove){special.remove.call(elem,handleObj);}}}if(origCount&&!handlers.length){if(!special.teardown||special.teardown.call(elem,namespaces,elemData.handle)===false){jQuery.removeEvent(elem,type,elemData.handle);}delete events[type];}}if(jQuery.isEmptyObject(events)){dataPriv.remove(elem,"handle events");}},dispatch:function(nativeEvent){var event=jQuery.event.fix(nativeEvent);var i,j,ret,matched,handleObj,handlerQueue,args=new Array(arguments.length),handlers=(dataPriv.get(this,"events")||{})[event.type]||[],special=jQuery.event.special[event.type]||{};args[0]=event;for(i=1;i<arguments.length;i++){args[i]=arguments[i];}event.delegateTarget=this;if(special.preDispatch&&special.preDispatch.call(this,event)===false){return;}handlerQueue=jQuery.event.handlers.call(this,event,handlers);i=0;while((matched=handlerQueue[i++])&&!event.isPropagationStopped()){event.currentTarget=matched.elem;j=0;while((handleObj=matched.handlers[j++])&&!event.isImmediatePropagationStopped()){if(!event.rnamespace||handleObj.namespace===false||event.rnamespace.test(handleObj.namespace)){event.handleObj=handleObj;event.data=handleObj.data;ret=((jQuery.event.special[handleObj.origType]||{}).handle||handleObj.handler).apply(matched.elem,args);if(ret!==undefined){if((event.result=ret)===false){event.preventDefault();event.stopPropagation();}}}}}if(special.postDispatch){special.postDispatch.call(this,event);}return event.result;},handlers:function(event,handlers){var i,handleObj,sel,matchedHandlers,matchedSelectors,handlerQueue=[],delegateCount=handlers.delegateCount,cur=event.target;if(delegateCount&&cur.nodeType&&!(event.type==="click"&&event.button>=1)){for(;cur!==this;cur=cur.parentNode||this){if(cur.nodeType===1&&!(event.type==="click"&&cur.disabled===true)){matchedHandlers=[];matchedSelectors={};for(i=0;i<delegateCount;i++){handleObj=handlers[i];sel=handleObj.selector+" ";if(matchedSelectors[sel]===undefined){matchedSelectors[sel]=handleObj.needsContext?jQuery(sel,this).index(cur)>-1:jQuery.find(sel,this,null,[cur]).length;}if(matchedSelectors[sel]){matchedHandlers.push(handleObj);}}if(matchedHandlers.length){handlerQueue.push({elem:cur,handlers:matchedHandlers});}}}}cur=this;if(delegateCount<handlers.length){handlerQueue.push({elem:cur,handlers:handlers.slice(delegateCount)});}return handlerQueue;},addProp:function(name,hook){Object.defineProperty(jQuery.Event.prototype,name,{enumerable:true,configurable:true,get:isFunction(hook)?function(){if(this.originalEvent){return hook(this.originalEvent);}}:function(){if(this.originalEvent){return this.originalEvent[name];}},set:function(value){Object.defineProperty(this,name,{enumerable:true,configurable:true,writable:true,value:value});}});},fix:function(originalEvent){return originalEvent[jQuery.expando]?originalEvent:new jQuery.Event(originalEvent);},special:{load:{noBubble:true},click:{setup:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")&&dataPriv.get(el,"click")===undefined){leverageNative(el,"click",returnTrue);}return false;},trigger:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")&&dataPriv.get(el,"click")===undefined){leverageNative(el,"click");}return true;},_default:function(event){var target=event.target;return rcheckableType.test(target.type)&&target.click&&nodeName(target,"input")&&dataPriv.get(target,"click")||nodeName(target,"a");}},beforeunload:{postDispatch:function(event){if(event.result!==undefined&&event.originalEvent){event.originalEvent.returnValue=event.result;}}}}};function leverageNative(el,type,expectSync){if(!expectSync){jQuery.event.add(el,type,returnTrue);return;}dataPriv.set(el,type,false);jQuery.event.add(el,type,{namespace:false,handler:function(event){var notAsync,result,saved=dataPriv.get(this,type);if(event.isTrigger&1&&this[type]){if(!saved){saved=slice.call(arguments);dataPriv.set(this,type,saved);notAsync=expectSync(this,type);this[type]();result=dataPriv.get(this,type);if(saved!==result||notAsync){dataPriv.set(this,type,false);}else{result=undefined;}if(saved!==result){event.stopImmediatePropagation();event.preventDefault();return result;}}else if((jQuery.event.special[type]||{}).delegateType){event.stopPropagation();}}else if(saved){dataPriv.set(this,type,jQuery.event.trigger(jQuery.extend(saved.shift(),jQuery.Event.prototype),saved,this));event.stopImmediatePropagation();}}});}jQuery.removeEvent=function(elem,type,handle){if(elem.removeEventListener){elem.removeEventListener(type,handle);}};jQuery.Event=function(src,props){if(!(this instanceof jQuery.Event)){return new jQuery.Event(src,props);}if(src&&src.type){this.originalEvent=src;this.type=src.type;this.isDefaultPrevented=src.defaultPrevented||src.defaultPrevented===undefined&&src.returnValue===false?returnTrue:returnFalse;this.target=src.target&&src.target.nodeType===3?src.target.parentNode:src.target;this.currentTarget=src.currentTarget;this.relatedTarget=src.relatedTarget;}else{this.type=src;}if(props){jQuery.extend(this,props);}this.timeStamp=src&&src.timeStamp||Date.now();this[jQuery.expando]=true;};jQuery.Event.prototype={constructor:jQuery.Event,isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,isSimulated:false,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue;if(e&&!this.isSimulated){e.preventDefault();}},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopPropagation();}},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopImmediatePropagation();}this.stopPropagation();}};jQuery.each({altKey:true,bubbles:true,cancelable:true,changedTouches:true,ctrlKey:true,detail:true,eventPhase:true,metaKey:true,pageX:true,pageY:true,shiftKey:true,view:true,"char":true,code:true,charCode:true,key:true,keyCode:true,button:true,buttons:true,clientX:true,clientY:true,offsetX:true,offsetY:true,pointerId:true,pointerType:true,screenX:true,screenY:true,targetTouches:true,toElement:true,touches:true,which:function(event){var button=event.button;if(event.which==null&&rkeyEvent.test(event.type)){return event.charCode!=null?event.charCode:event.keyCode;}if(!event.which&&button!==undefined&&rmouseEvent.test(event.type)){if(button&1){return 1;}if(button&2){return 3;}if(button&4){return 2;}return 0;}return event.which;}},jQuery.event.addProp);jQuery.each({focus:"focusin",blur:"focusout"},function(type,delegateType){jQuery.event.special[type]={setup:function(){leverageNative(this,type,expectSync);return false;},trigger:function(){leverageNative(this,type);return true;},delegateType:delegateType};});jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(orig,fix){jQuery.event.special[orig]={delegateType:fix,bindType:fix,handle:function(event){var ret,target=this,related=event.relatedTarget,handleObj=event.handleObj;if(!related||related!==target&&!jQuery.contains(target,related)){event.type=handleObj.origType;ret=handleObj.handler.apply(this,arguments);event.type=fix;}return ret;}};});jQuery.fn.extend({on:function(types,selector,data,fn){return on(this,types,selector,data,fn);},one:function(types,selector,data,fn){return on(this,types,selector,data,fn,1);},off:function(types,selector,fn){var handleObj,type;if(types&&types.preventDefault&&types.handleObj){handleObj=types.handleObj;jQuery(types.delegateTarget).off(handleObj.namespace?handleObj.origType+"."+handleObj.namespace:handleObj.origType,handleObj.selector,handleObj.handler);return this;}if(typeof types==="object"){for(type in types){this.off(type,selector,types[type]);}return this;}if(selector===false||typeof selector==="function"){fn=selector;selector=undefined;}if(fn===false){fn=returnFalse;}return this.each(function(){jQuery.event.remove(this,types,fn,selector);});}});var rxhtmlTag=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,rnoInnerhtml=/<script|<style|<link/i,rchecked=/checked\s*(?:[^=]|=\s*.checked.)/i,rcleanScript=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function manipulationTarget(elem,content){if(nodeName(elem,"table")&&nodeName(content.nodeType!==11?content:content.firstChild,"tr")){return jQuery(elem).children("tbody")[0]||elem;}return elem;}function disableScript(elem){elem.type=(elem.getAttribute("type")!==null)+"/"+elem.type;return elem;}function restoreScript(elem){if((elem.type||"").slice(0,5)==="true/"){elem.type=elem.type.slice(5);}else{elem.removeAttribute("type");}return elem;}function cloneCopyEvent(src,dest){var i,l,type,pdataOld,pdataCur,udataOld,udataCur,events;if(dest.nodeType!==1){return;}if(dataPriv.hasData(src)){pdataOld=dataPriv.access(src);pdataCur=dataPriv.set(dest,pdataOld);events=pdataOld.events;if(events){delete pdataCur.handle;pdataCur.events={};for(type in events){for(i=0,l=events[type].length;i<l;i++){jQuery.event.add(dest,type,events[type][i]);}}}}if(dataUser.hasData(src)){udataOld=dataUser.access(src);udataCur=jQuery.extend({},udataOld);dataUser.set(dest,udataCur);}}function fixInput(src,dest){var nodeName=dest.nodeName.toLowerCase();if(nodeName==="input"&&rcheckableType.test(src.type)){dest.checked=src.checked;}else if(nodeName==="input"||nodeName==="textarea"){dest.defaultValue=src.defaultValue;}}function domManip(collection,args,callback,ignored){args=concat.apply([],args);var fragment,first,scripts,hasScripts,node,doc,i=0,l=collection.length,value=args[0],valueIsFunction=isFunction(value);if(valueIsFunction||l>1&&typeof value==="string"&&!support.checkClone&&rchecked.test(value)){return collection.each(function(index){var self=collection.eq(index);if(valueIsFunction){args[0]=value.call(this,index,self.html());}domManip(self,args,callback,ignored);});}if(l){fragment=buildFragment(args,collection[0].ownerDocument,false,collection,ignored);first=fragment.firstChild;if(fragment.childNodes.length===1){fragment=first;}if(first||ignored){scripts=jQuery.map(getAll(fragment,"script"),disableScript);hasScripts=scripts.length;for(;i<l;i++){node=fragment;if(i!==l-1){node=jQuery.clone(node,true,true);if(hasScripts){jQuery.merge(scripts,getAll(node,"script"));}}callback.call(collection[i],node,i);}if(hasScripts){doc=scripts[scripts.length-1].ownerDocument;jQuery.map(scripts,restoreScript);for(i=0;i<hasScripts;i++){node=scripts[i];if(rscriptType.test(node.type||"")&&!dataPriv.access(node,"globalEval")&&jQuery.contains(doc,node)){if(node.src&&(node.type||"").toLowerCase()!=="module"){if(jQuery._evalUrl&&!node.noModule){jQuery._evalUrl(node.src,{nonce:node.nonce||node.getAttribute("nonce")});}}else{DOMEval(node.textContent.replace(rcleanScript,""),node,doc);}}}}}}return collection;}function remove(elem,selector,keepData){var node,nodes=selector?jQuery.filter(selector,elem):elem,i=0;for(;(node=nodes[i])!=null;i++){if(!keepData&&node.nodeType===1){jQuery.cleanData(getAll(node));}if(node.parentNode){if(keepData&&isAttached(node)){setGlobalEval(getAll(node,"script"));}node.parentNode.removeChild(node);}}return elem;}jQuery.extend({htmlPrefilter:function(html){return html.replace(rxhtmlTag,"<$1></$2>");},clone:function(elem,dataAndEvents,deepDataAndEvents){var i,l,srcElements,destElements,clone=elem.cloneNode(true),inPage=isAttached(elem);if(!support.noCloneChecked&&(elem.nodeType===1||elem.nodeType===11)&&!jQuery.isXMLDoc(elem)){destElements=getAll(clone);srcElements=getAll(elem);for(i=0,l=srcElements.length;i<l;i++){fixInput(srcElements[i],destElements[i]);}}if(dataAndEvents){if(deepDataAndEvents){srcElements=srcElements||getAll(elem);destElements=destElements||getAll(clone);for(i=0,l=srcElements.length;i<l;i++){cloneCopyEvent(srcElements[i],destElements[i]);}}else{cloneCopyEvent(elem,clone);}}destElements=getAll(clone,"script");if(destElements.length>0){setGlobalEval(destElements,!inPage&&getAll(elem,"script"));}return clone;},cleanData:function(elems){var data,elem,type,special=jQuery.event.special,i=0;for(;(elem=elems[i])!==undefined;i++){if(acceptData(elem)){if(data=elem[dataPriv.expando]){if(data.events){for(type in data.events){if(special[type]){jQuery.event.remove(elem,type);}else{jQuery.removeEvent(elem,type,data.handle);}}}elem[dataPriv.expando]=undefined;}if(elem[dataUser.expando]){elem[dataUser.expando]=undefined;}}}}});jQuery.fn.extend({detach:function(selector){return remove(this,selector,true);},remove:function(selector){return remove(this,selector);},text:function(value){return access(this,function(value){return value===undefined?jQuery.text(this):this.empty().each(function(){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){this.textContent=value;}});},null,value,arguments.length);},append:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.appendChild(elem);}});},prepend:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.insertBefore(elem,target.firstChild);}});},before:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this);}});},after:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this.nextSibling);}});},empty:function(){var elem,i=0;for(;(elem=this[i])!=null;i++){if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.textContent="";}}return this;},clone:function(dataAndEvents,deepDataAndEvents){dataAndEvents=dataAndEvents==null?false:dataAndEvents;deepDataAndEvents=deepDataAndEvents==null?dataAndEvents:deepDataAndEvents;return this.map(function(){return jQuery.clone(this,dataAndEvents,deepDataAndEvents);});},html:function(value){return access(this,function(value){var elem=this[0]||{},i=0,l=this.length;if(value===undefined&&elem.nodeType===1){return elem.innerHTML;}if(typeof value==="string"&&!rnoInnerhtml.test(value)&&!wrapMap[(rtagName.exec(value)||["",""])[1].toLowerCase()]){value=jQuery.htmlPrefilter(value);try{for(;i<l;i++){elem=this[i]||{};if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.innerHTML=value;}}elem=0;}catch(e){}}if(elem){this.empty().append(value);}},null,value,arguments.length);},replaceWith:function(){var ignored=[];return domManip(this,arguments,function(elem){var parent=this.parentNode;if(jQuery.inArray(this,ignored)<0){jQuery.cleanData(getAll(this));if(parent){parent.replaceChild(elem,this);}}},ignored);}});jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(name,original){jQuery.fn[name]=function(selector){var elems,ret=[],insert=jQuery(selector),last=insert.length-1,i=0;for(;i<=last;i++){elems=i===last?this:this.clone(true);jQuery(insert[i])[original](elems);push.apply(ret,elems.get());}return this.pushStack(ret);};});var rnumnonpx=new RegExp("^("+pnum+")(?!px)[a-z%]+$","i");var getStyles=function(elem){var view=elem.ownerDocument.defaultView;if(!view||!view.opener){view=window;}return view.getComputedStyle(elem);};var rboxStyle=new RegExp(cssExpand.join("|"),"i");(function(){function computeStyleTests(){if(!div){return;}container.style.cssText="position:absolute;left:-11111px;width:60px;"+"margin-top:1px;padding:0;border:0";div.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;"+"margin:auto;border:1px;padding:1px;"+"width:60%;top:1%";documentElement.appendChild(container).appendChild(div);var divStyle=window.getComputedStyle(div);pixelPositionVal=divStyle.top!=="1%";reliableMarginLeftVal=roundPixelMeasures(divStyle.marginLeft)===12;div.style.right="60%";pixelBoxStylesVal=roundPixelMeasures(divStyle.right)===36;boxSizingReliableVal=roundPixelMeasures(divStyle.width)===36;div.style.position="absolute";scrollboxSizeVal=roundPixelMeasures(div.offsetWidth/3)===12;documentElement.removeChild(container);div=null;}function roundPixelMeasures(measure){return Math.round(parseFloat(measure));}var pixelPositionVal,boxSizingReliableVal,scrollboxSizeVal,pixelBoxStylesVal,reliableMarginLeftVal,container=document.createElement("div"),div=document.createElement("div");if(!div.style){return;}div.style.backgroundClip="content-box";div.cloneNode(true).style.backgroundClip="";support.clearCloneStyle=div.style.backgroundClip==="content-box";jQuery.extend(support,{boxSizingReliable:function(){computeStyleTests();return boxSizingReliableVal;},pixelBoxStyles:function(){computeStyleTests();return pixelBoxStylesVal;},pixelPosition:function(){computeStyleTests();return pixelPositionVal;},reliableMarginLeft:function(){computeStyleTests();return reliableMarginLeftVal;},scrollboxSize:function(){computeStyleTests();return scrollboxSizeVal;}});})();function curCSS(elem,name,computed){var width,minWidth,maxWidth,ret,style=elem.style;computed=computed||getStyles(elem);if(computed){ret=computed.getPropertyValue(name)||computed[name];if(ret===""&&!isAttached(elem)){ret=jQuery.style(elem,name);}if(!support.pixelBoxStyles()&&rnumnonpx.test(ret)&&rboxStyle.test(name)){width=style.width;minWidth=style.minWidth;maxWidth=style.maxWidth;style.minWidth=style.maxWidth=style.width=ret;ret=computed.width;style.width=width;style.minWidth=minWidth;style.maxWidth=maxWidth;}}return ret!==undefined?ret+"":ret;}function addGetHookIf(conditionFn,hookFn){return{get:function(){if(conditionFn()){delete this.get;return;}return(this.get=hookFn).apply(this,arguments);}};}var cssPrefixes=["Webkit","Moz","ms"],emptyStyle=document.createElement("div").style,vendorProps={};function vendorPropName(name){var capName=name[0].toUpperCase()+name.slice(1),i=cssPrefixes.length;while(i--){name=cssPrefixes[i]+capName;if(name in emptyStyle){return name;}}}function finalPropName(name){var final=jQuery.cssProps[name]||vendorProps[name];if(final){return final;}if(name in emptyStyle){return name;}return vendorProps[name]=vendorPropName(name)||name;}var rdisplayswap=/^(none|table(?!-c[ea]).+)/,rcustomProp=/^--/,cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:"0",fontWeight:"400"};function setPositiveNumber(elem,value,subtract){var matches=rcssNum.exec(value);return matches?Math.max(0,matches[2]-(subtract||0))+(matches[3]||"px"):value;}function boxModelAdjustment(elem,dimension,box,isBorderBox,styles,computedVal){var i=dimension==="width"?1:0,extra=0,delta=0;if(box===(isBorderBox?"border":"content")){return 0;}for(;i<4;i+=2){if(box==="margin"){delta+=jQuery.css(elem,box+cssExpand[i],true,styles);}if(!isBorderBox){delta+=jQuery.css(elem,"padding"+cssExpand[i],true,styles);if(box!=="padding"){delta+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}else{extra+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}else{if(box==="content"){delta-=jQuery.css(elem,"padding"+cssExpand[i],true,styles);}if(box!=="margin"){delta-=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}}if(!isBorderBox&&computedVal>=0){delta+=Math.max(0,Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-computedVal-delta-extra-0.5))||0;}return delta;}function getWidthOrHeight(elem,dimension,extra){var styles=getStyles(elem),boxSizingNeeded=!support.boxSizingReliable()||extra,isBorderBox=boxSizingNeeded&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",valueIsBorderBox=isBorderBox,val=curCSS(elem,dimension,styles),offsetProp="offset"+dimension[0].toUpperCase()+dimension.slice(1);if(rnumnonpx.test(val)){if(!extra){return val;}val="auto";}if((!support.boxSizingReliable()&&isBorderBox||val==="auto"||!parseFloat(val)&&jQuery.css(elem,"display",false,styles)==="inline")&&elem.getClientRects().length){isBorderBox=jQuery.css(elem,"boxSizing",false,styles)==="border-box";valueIsBorderBox=offsetProp in elem;if(valueIsBorderBox){val=elem[offsetProp];}}val=parseFloat(val)||0;return val+boxModelAdjustment(elem,dimension,extra||(isBorderBox?"border":"content"),valueIsBorderBox,styles,val)+"px";}jQuery.extend({cssHooks:{opacity:{get:function(elem,computed){if(computed){var ret=curCSS(elem,"opacity");return ret===""?"1":ret;}}}},cssNumber:{"animationIterationCount":true,"columnCount":true,"fillOpacity":true,"flexGrow":true,"flexShrink":true,"fontWeight":true,"gridArea":true,"gridColumn":true,"gridColumnEnd":true,"gridColumnStart":true,"gridRow":true,"gridRowEnd":true,"gridRowStart":true,"lineHeight":true,"opacity":true,"order":true,"orphans":true,"widows":true,"zIndex":true,"zoom":true},cssProps:{},style:function(elem,name,value,extra){if(!elem||elem.nodeType===3||elem.nodeType===8||!elem.style){return;}var ret,type,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name),style=elem.style;if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(value!==undefined){type=typeof value;if(type==="string"&&(ret=rcssNum.exec(value))&&ret[1]){value=adjustCSS(elem,name,ret);type="number";}if(value==null||value!==value){return;}if(type==="number"&&!isCustomProp){value+=ret&&ret[3]||(jQuery.cssNumber[origName]?"":"px");}if(!support.clearCloneStyle&&value===""&&name.indexOf("background")===0){style[name]="inherit";}if(!hooks||!("set"in hooks)||(value=hooks.set(elem,value,extra))!==undefined){if(isCustomProp){style.setProperty(name,value);}else{style[name]=value;}}}else{if(hooks&&"get"in hooks&&(ret=hooks.get(elem,false,extra))!==undefined){return ret;}return style[name];}},css:function(elem,name,extra,styles){var val,num,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name);if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(hooks&&"get"in hooks){val=hooks.get(elem,true,extra);}if(val===undefined){val=curCSS(elem,name,styles);}if(val==="normal"&&name in cssNormalTransform){val=cssNormalTransform[name];}if(extra===""||extra){num=parseFloat(val);return extra===true||isFinite(num)?num||0:val;}return val;}});jQuery.each(["height","width"],function(i,dimension){jQuery.cssHooks[dimension]={get:function(elem,computed,extra){if(computed){return rdisplayswap.test(jQuery.css(elem,"display"))&&(!elem.getClientRects().length||!elem.getBoundingClientRect().width)?swap(elem,cssShow,function(){return getWidthOrHeight(elem,dimension,extra);}):getWidthOrHeight(elem,dimension,extra);}},set:function(elem,value,extra){var matches,styles=getStyles(elem),scrollboxSizeBuggy=!support.scrollboxSize()&&styles.position==="absolute",isBorderBox=(scrollboxSizeBuggy||extra)&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",subtract=extra?boxModelAdjustment(elem,dimension,extra,isBorderBox,styles):0;if(isBorderBox&&scrollboxSizeBuggy){subtract-=Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-parseFloat(styles[dimension])-boxModelAdjustment(elem,dimension,"border",false,styles)-0.5);}if(subtract&&(matches=rcssNum.exec(value))&&(matches[3]||"px")!=="px"){elem.style[dimension]=value;value=jQuery.css(elem,dimension);}return setPositiveNumber(elem,value,subtract);}};});jQuery.cssHooks.marginLeft=addGetHookIf(support.reliableMarginLeft,function(elem,computed){if(computed){return(parseFloat(curCSS(elem,"marginLeft"))||elem.getBoundingClientRect().left-swap(elem,{marginLeft:0},function(){return elem.getBoundingClientRect().left;}))+"px";}});jQuery.each({margin:"",padding:"",border:"Width"},function(prefix,suffix){jQuery.cssHooks[prefix+suffix]={expand:function(value){var i=0,expanded={},parts=typeof value==="string"?value.split(" "):[value];for(;i<4;i++){expanded[prefix+cssExpand[i]+suffix]=parts[i]||parts[i-2]||parts[0];}return expanded;}};if(prefix!=="margin"){jQuery.cssHooks[prefix+suffix].set=setPositiveNumber;}});jQuery.fn.extend({css:function(name,value){return access(this,function(elem,name,value){var styles,len,map={},i=0;if(Array.isArray(name)){styles=getStyles(elem);len=name.length;for(;i<len;i++){map[name[i]]=jQuery.css(elem,name[i],false,styles);}return map;}return value!==undefined?jQuery.style(elem,name,value):jQuery.css(elem,name);},name,value,arguments.length>1);}});function Tween(elem,options,prop,end,easing){return new Tween.prototype.init(elem,options,prop,end,easing);}jQuery.Tween=Tween;Tween.prototype={constructor:Tween,init:function(elem,options,prop,end,easing,unit){this.elem=elem;this.prop=prop;this.easing=easing||jQuery.easing._default;this.options=options;this.start=this.now=this.cur();this.end=end;this.unit=unit||(jQuery.cssNumber[prop]?"":"px");},cur:function(){var hooks=Tween.propHooks[this.prop];return hooks&&hooks.get?hooks.get(this):Tween.propHooks._default.get(this);},run:function(percent){var eased,hooks=Tween.propHooks[this.prop];if(this.options.duration){this.pos=eased=jQuery.easing[this.easing](percent,this.options.duration*percent,0,1,this.options.duration);}else{this.pos=eased=percent;}this.now=(this.end-this.start)*eased+this.start;if(this.options.step){this.options.step.call(this.elem,this.now,this);}if(hooks&&hooks.set){hooks.set(this);}else{Tween.propHooks._default.set(this);}return this;}};Tween.prototype.init.prototype=Tween.prototype;Tween.propHooks={_default:{get:function(tween){var result;if(tween.elem.nodeType!==1||tween.elem[tween.prop]!=null&&tween.elem.style[tween.prop]==null){return tween.elem[tween.prop];}result=jQuery.css(tween.elem,tween.prop,"");return!result||result==="auto"?0:result;},set:function(tween){if(jQuery.fx.step[tween.prop]){jQuery.fx.step[tween.prop](tween);}else if(tween.elem.nodeType===1&&(jQuery.cssHooks[tween.prop]||tween.elem.style[finalPropName(tween.prop)]!=null)){jQuery.style(tween.elem,tween.prop,tween.now+tween.unit);}else{tween.elem[tween.prop]=tween.now;}}}};Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(tween){if(tween.elem.nodeType&&tween.elem.parentNode){tween.elem[tween.prop]=tween.now;}}};jQuery.easing={linear:function(p){return p;},swing:function(p){return 0.5-Math.cos(p*Math.PI)/2;},_default:"swing"};jQuery.fx=Tween.prototype.init;jQuery.fx.step={};var fxNow,inProgress,rfxtypes=/^(?:toggle|show|hide)$/,rrun=/queueHooks$/;function schedule(){if(inProgress){if(document.hidden===false&&window.requestAnimationFrame){window.requestAnimationFrame(schedule);}else{window.setTimeout(schedule,jQuery.fx.interval);}jQuery.fx.tick();}}function createFxNow(){window.setTimeout(function(){fxNow=undefined;});return fxNow=Date.now();}function genFx(type,includeWidth){var which,i=0,attrs={height:type};includeWidth=includeWidth?1:0;for(;i<4;i+=2-includeWidth){which=cssExpand[i];attrs["margin"+which]=attrs["padding"+which]=type;}if(includeWidth){attrs.opacity=attrs.width=type;}return attrs;}function createTween(value,prop,animation){var tween,collection=(Animation.tweeners[prop]||[]).concat(Animation.tweeners["*"]),index=0,length=collection.length;for(;index<length;index++){if(tween=collection[index].call(animation,prop,value)){return tween;}}}function defaultPrefilter(elem,props,opts){var prop,value,toggle,hooks,oldfire,propTween,restoreDisplay,display,isBox="width"in props||"height"in props,anim=this,orig={},style=elem.style,hidden=elem.nodeType&&isHiddenWithinTree(elem),dataShow=dataPriv.get(elem,"fxshow");if(!opts.queue){hooks=jQuery._queueHooks(elem,"fx");if(hooks.unqueued==null){hooks.unqueued=0;oldfire=hooks.empty.fire;hooks.empty.fire=function(){if(!hooks.unqueued){oldfire();}};}hooks.unqueued++;anim.always(function(){anim.always(function(){hooks.unqueued--;if(!jQuery.queue(elem,"fx").length){hooks.empty.fire();}});});}for(prop in props){value=props[prop];if(rfxtypes.test(value)){delete props[prop];toggle=toggle||value==="toggle";if(value===(hidden?"hide":"show")){if(value==="show"&&dataShow&&dataShow[prop]!==undefined){hidden=true;}else{continue;}}orig[prop]=dataShow&&dataShow[prop]||jQuery.style(elem,prop);}}propTween=!jQuery.isEmptyObject(props);if(!propTween&&jQuery.isEmptyObject(orig)){return;}if(isBox&&elem.nodeType===1){opts.overflow=[style.overflow,style.overflowX,style.overflowY];restoreDisplay=dataShow&&dataShow.display;if(restoreDisplay==null){restoreDisplay=dataPriv.get(elem,"display");}display=jQuery.css(elem,"display");if(display==="none"){if(restoreDisplay){display=restoreDisplay;}else{showHide([elem],true);restoreDisplay=elem.style.display||restoreDisplay;display=jQuery.css(elem,"display");showHide([elem]);}}if(display==="inline"||display==="inline-block"&&restoreDisplay!=null){if(jQuery.css(elem,"float")==="none"){if(!propTween){anim.done(function(){style.display=restoreDisplay;});if(restoreDisplay==null){display=style.display;restoreDisplay=display==="none"?"":display;}}style.display="inline-block";}}}if(opts.overflow){style.overflow="hidden";anim.always(function(){style.overflow=opts.overflow[0];style.overflowX=opts.overflow[1];style.overflowY=opts.overflow[2];});}propTween=false;for(prop in orig){if(!propTween){if(dataShow){if("hidden"in dataShow){hidden=dataShow.hidden;}}else{dataShow=dataPriv.access(elem,"fxshow",{display:restoreDisplay});}if(toggle){dataShow.hidden=!hidden;}if(hidden){showHide([elem],true);}anim.done(function(){if(!hidden){showHide([elem]);}dataPriv.remove(elem,"fxshow");for(prop in orig){jQuery.style(elem,prop,orig[prop]);}});}propTween=createTween(hidden?dataShow[prop]:0,prop,anim);if(!(prop in dataShow)){dataShow[prop]=propTween.start;if(hidden){propTween.end=propTween.start;propTween.start=0;}}}}function propFilter(props,specialEasing){var index,name,easing,value,hooks;for(index in props){name=camelCase(index);easing=specialEasing[name];value=props[index];if(Array.isArray(value)){easing=value[1];value=props[index]=value[0];}if(index!==name){props[name]=value;delete props[index];}hooks=jQuery.cssHooks[name];if(hooks&&"expand"in hooks){value=hooks.expand(value);delete props[name];for(index in value){if(!(index in props)){props[index]=value[index];specialEasing[index]=easing;}}}else{specialEasing[name]=easing;}}}function Animation(elem,properties,options){var result,stopped,index=0,length=Animation.prefilters.length,deferred=jQuery.Deferred().always(function(){delete tick.elem;}),tick=function(){if(stopped){return false;}var currentTime=fxNow||createFxNow(),remaining=Math.max(0,animation.startTime+animation.duration-currentTime),temp=remaining/animation.duration||0,percent=1-temp,index=0,length=animation.tweens.length;for(;index<length;index++){animation.tweens[index].run(percent);}deferred.notifyWith(elem,[animation,percent,remaining]);if(percent<1&&length){return remaining;}if(!length){deferred.notifyWith(elem,[animation,1,0]);}deferred.resolveWith(elem,[animation]);return false;},animation=deferred.promise({elem:elem,props:jQuery.extend({},properties),opts:jQuery.extend(true,{specialEasing:{},easing:jQuery.easing._default},options),originalProperties:properties,originalOptions:options,startTime:fxNow||createFxNow(),duration:options.duration,tweens:[],createTween:function(prop,end){var tween=jQuery.Tween(elem,animation.opts,prop,end,animation.opts.specialEasing[prop]||animation.opts.easing);animation.tweens.push(tween);return tween;},stop:function(gotoEnd){var index=0,length=gotoEnd?animation.tweens.length:0;if(stopped){return this;}stopped=true;for(;index<length;index++){animation.tweens[index].run(1);}if(gotoEnd){deferred.notifyWith(elem,[animation,1,0]);deferred.resolveWith(elem,[animation,gotoEnd]);}else{deferred.rejectWith(elem,[animation,gotoEnd]);}return this;}}),props=animation.props;propFilter(props,animation.opts.specialEasing);for(;index<length;index++){result=Animation.prefilters[index].call(animation,elem,props,animation.opts);if(result){if(isFunction(result.stop)){jQuery._queueHooks(animation.elem,animation.opts.queue).stop=result.stop.bind(result);}return result;}}jQuery.map(props,createTween,animation);if(isFunction(animation.opts.start)){animation.opts.start.call(elem,animation);}animation.progress(animation.opts.progress).done(animation.opts.done,animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);jQuery.fx.timer(jQuery.extend(tick,{elem:elem,anim:animation,queue:animation.opts.queue}));return animation;}jQuery.Animation=jQuery.extend(Animation,{tweeners:{"*":[function(prop,value){var tween=this.createTween(prop,value);adjustCSS(tween.elem,prop,rcssNum.exec(value),tween);return tween;}]},tweener:function(props,callback){if(isFunction(props)){callback=props;props=["*"];}else{props=props.match(rnothtmlwhite);}var prop,index=0,length=props.length;for(;index<length;index++){prop=props[index];Animation.tweeners[prop]=Animation.tweeners[prop]||[];Animation.tweeners[prop].unshift(callback);}},prefilters:[defaultPrefilter],prefilter:function(callback,prepend){if(prepend){Animation.prefilters.unshift(callback);}else{Animation.prefilters.push(callback);}}});jQuery.speed=function(speed,easing,fn){var opt=speed&&typeof speed==="object"?jQuery.extend({},speed):{complete:fn||!fn&&easing||isFunction(speed)&&speed,duration:speed,easing:fn&&easing||easing&&!isFunction(easing)&&easing};if(jQuery.fx.off){opt.duration=0;}else{if(typeof opt.duration!=="number"){if(opt.duration in jQuery.fx.speeds){opt.duration=jQuery.fx.speeds[opt.duration];}else{opt.duration=jQuery.fx.speeds._default;}}}if(opt.queue==null||opt.queue===true){opt.queue="fx";}opt.old=opt.complete;opt.complete=function(){if(isFunction(opt.old)){opt.old.call(this);}if(opt.queue){jQuery.dequeue(this,opt.queue);}};return opt;};jQuery.fn.extend({fadeTo:function(speed,to,easing,callback){return this.filter(isHiddenWithinTree).css("opacity",0).show().end().animate({opacity:to},speed,easing,callback);},animate:function(prop,speed,easing,callback){var empty=jQuery.isEmptyObject(prop),optall=jQuery.speed(speed,easing,callback),doAnimation=function(){var anim=Animation(this,jQuery.extend({},prop),optall);if(empty||dataPriv.get(this,"finish")){anim.stop(true);}};doAnimation.finish=doAnimation;return empty||optall.queue===false?this.each(doAnimation):this.queue(optall.queue,doAnimation);},stop:function(type,clearQueue,gotoEnd){var stopQueue=function(hooks){var stop=hooks.stop;delete hooks.stop;stop(gotoEnd);};if(typeof type!=="string"){gotoEnd=clearQueue;clearQueue=type;type=undefined;}if(clearQueue&&type!==false){this.queue(type||"fx",[]);}return this.each(function(){var dequeue=true,index=type!=null&&type+"queueHooks",timers=jQuery.timers,data=dataPriv.get(this);if(index){if(data[index]&&data[index].stop){stopQueue(data[index]);}}else{for(index in data){if(data[index]&&data[index].stop&&rrun.test(index)){stopQueue(data[index]);}}}for(index=timers.length;index--;){if(timers[index].elem===this&&(type==null||timers[index].queue===type)){timers[index].anim.stop(gotoEnd);dequeue=false;timers.splice(index,1);}}if(dequeue||!gotoEnd){jQuery.dequeue(this,type);}});},finish:function(type){if(type!==false){type=type||"fx";}return this.each(function(){var index,data=dataPriv.get(this),queue=data[type+"queue"],hooks=data[type+"queueHooks"],timers=jQuery.timers,length=queue?queue.length:0;data.finish=true;jQuery.queue(this,type,[]);if(hooks&&hooks.stop){hooks.stop.call(this,true);}for(index=timers.length;index--;){if(timers[index].elem===this&&timers[index].queue===type){timers[index].anim.stop(true);timers.splice(index,1);}}for(index=0;index<length;index++){if(queue[index]&&queue[index].finish){queue[index].finish.call(this);}}delete data.finish;});}});jQuery.each(["toggle","show","hide"],function(i,name){var cssFn=jQuery.fn[name];jQuery.fn[name]=function(speed,easing,callback){return speed==null||typeof speed==="boolean"?cssFn.apply(this,arguments):this.animate(genFx(name,true),speed,easing,callback);};});jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(name,props){jQuery.fn[name]=function(speed,easing,callback){return this.animate(props,speed,easing,callback);};});jQuery.timers=[];jQuery.fx.tick=function(){var timer,i=0,timers=jQuery.timers;fxNow=Date.now();for(;i<timers.length;i++){timer=timers[i];if(!timer()&&timers[i]===timer){timers.splice(i--,1);}}if(!timers.length){jQuery.fx.stop();}fxNow=undefined;};jQuery.fx.timer=function(timer){jQuery.timers.push(timer);jQuery.fx.start();};jQuery.fx.interval=13;jQuery.fx.start=function(){if(inProgress){return;}inProgress=true;schedule();};jQuery.fx.stop=function(){inProgress=null;};jQuery.fx.speeds={slow:600,fast:200,_default:400};jQuery.fn.delay=function(time,type){time=jQuery.fx?jQuery.fx.speeds[time]||time:time;type=type||"fx";return this.queue(type,function(next,hooks){var timeout=window.setTimeout(next,time);hooks.stop=function(){window.clearTimeout(timeout);};});};(function(){var input=document.createElement("input"),select=document.createElement("select"),opt=select.appendChild(document.createElement("option"));input.type="checkbox";support.checkOn=input.value!=="";support.optSelected=opt.selected;input=document.createElement("input");input.value="t";input.type="radio";support.radioValue=input.value==="t";})();var boolHook,attrHandle=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(name,value){return access(this,jQuery.attr,name,value,arguments.length>1);},removeAttr:function(name){return this.each(function(){jQuery.removeAttr(this,name);});}});jQuery.extend({attr:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(typeof elem.getAttribute==="undefined"){return jQuery.prop(elem,name,value);}if(nType!==1||!jQuery.isXMLDoc(elem)){hooks=jQuery.attrHooks[name.toLowerCase()]||(jQuery.expr.match.bool.test(name)?boolHook:undefined);}if(value!==undefined){if(value===null){jQuery.removeAttr(elem,name);return;}if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}elem.setAttribute(name,value+"");return value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}ret=jQuery.find.attr(elem,name);return ret==null?undefined:ret;},attrHooks:{type:{set:function(elem,value){if(!support.radioValue&&value==="radio"&&nodeName(elem,"input")){var val=elem.value;elem.setAttribute("type",value);if(val){elem.value=val;}return value;}}}},removeAttr:function(elem,value){var name,i=0,attrNames=value&&value.match(rnothtmlwhite);if(attrNames&&elem.nodeType===1){while(name=attrNames[i++]){elem.removeAttribute(name);}}}});boolHook={set:function(elem,value,name){if(value===false){jQuery.removeAttr(elem,name);}else{elem.setAttribute(name,name);}return name;}};jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),function(i,name){var getter=attrHandle[name]||jQuery.find.attr;attrHandle[name]=function(elem,name,isXML){var ret,handle,lowercaseName=name.toLowerCase();if(!isXML){handle=attrHandle[lowercaseName];attrHandle[lowercaseName]=ret;ret=getter(elem,name,isXML)!=null?lowercaseName:null;attrHandle[lowercaseName]=handle;}return ret;};});var rfocusable=/^(?:input|select|textarea|button)$/i,rclickable=/^(?:a|area)$/i;jQuery.fn.extend({prop:function(name,value){return access(this,jQuery.prop,name,value,arguments.length>1);},removeProp:function(name){return this.each(function(){delete this[jQuery.propFix[name]||name];});}});jQuery.extend({prop:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(nType!==1||!jQuery.isXMLDoc(elem)){name=jQuery.propFix[name]||name;hooks=jQuery.propHooks[name];}if(value!==undefined){if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}return elem[name]=value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}return elem[name];},propHooks:{tabIndex:{get:function(elem){var tabindex=jQuery.find.attr(elem,"tabindex");if(tabindex){return parseInt(tabindex,10);}if(rfocusable.test(elem.nodeName)||rclickable.test(elem.nodeName)&&elem.href){return 0;}return-1;}}},propFix:{"for":"htmlFor","class":"className"}});if(!support.optSelected){jQuery.propHooks.selected={get:function(elem){var parent=elem.parentNode;if(parent&&parent.parentNode){parent.parentNode.selectedIndex;}return null;},set:function(elem){var parent=elem.parentNode;if(parent){parent.selectedIndex;if(parent.parentNode){parent.parentNode.selectedIndex;}}}};}jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){jQuery.propFix[this.toLowerCase()]=this;});function stripAndCollapse(value){var tokens=value.match(rnothtmlwhite)||[];return tokens.join(" ");}function getClass(elem){return elem.getAttribute&&elem.getAttribute("class")||"";}function classesToArray(value){if(Array.isArray(value)){return value;}if(typeof value==="string"){return value.match(rnothtmlwhite)||[];}return[];}jQuery.fn.extend({addClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).addClass(value.call(this,j,getClass(this)));});}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){if(cur.indexOf(" "+clazz+" ")<0){cur+=clazz+" ";}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},removeClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).removeClass(value.call(this,j,getClass(this)));});}if(!arguments.length){return this.attr("class","");}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){while(cur.indexOf(" "+clazz+" ")>-1){cur=cur.replace(" "+clazz+" "," ");}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},toggleClass:function(value,stateVal){var type=typeof value,isValidValue=type==="string"||Array.isArray(value);if(typeof stateVal==="boolean"&&isValidValue){return stateVal?this.addClass(value):this.removeClass(value);}if(isFunction(value)){return this.each(function(i){jQuery(this).toggleClass(value.call(this,i,getClass(this),stateVal),stateVal);});}return this.each(function(){var className,i,self,classNames;if(isValidValue){i=0;self=jQuery(this);classNames=classesToArray(value);while(className=classNames[i++]){if(self.hasClass(className)){self.removeClass(className);}else{self.addClass(className);}}}else if(value===undefined||type==="boolean"){className=getClass(this);if(className){dataPriv.set(this,"__className__",className);}if(this.setAttribute){this.setAttribute("class",className||value===false?"":dataPriv.get(this,"__className__")||"");}}});},hasClass:function(selector){var className,elem,i=0;className=" "+selector+" ";while(elem=this[i++]){if(elem.nodeType===1&&(" "+stripAndCollapse(getClass(elem))+" ").indexOf(className)>-1){return true;}}return false;}});var rreturn=/\r/g;jQuery.fn.extend({val:function(value){var hooks,ret,valueIsFunction,elem=this[0];if(!arguments.length){if(elem){hooks=jQuery.valHooks[elem.type]||jQuery.valHooks[elem.nodeName.toLowerCase()];if(hooks&&"get"in hooks&&(ret=hooks.get(elem,"value"))!==undefined){return ret;}ret=elem.value;if(typeof ret==="string"){return ret.replace(rreturn,"");}return ret==null?"":ret;}return;}valueIsFunction=isFunction(value);return this.each(function(i){var val;if(this.nodeType!==1){return;}if(valueIsFunction){val=value.call(this,i,jQuery(this).val());}else{val=value;}if(val==null){val="";}else if(typeof val==="number"){val+="";}else if(Array.isArray(val)){val=jQuery.map(val,function(value){return value==null?"":value+"";});}hooks=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()];if(!hooks||!("set"in hooks)||hooks.set(this,val,"value")===undefined){this.value=val;}});}});jQuery.extend({valHooks:{option:{get:function(elem){var val=jQuery.find.attr(elem,"value");return val!=null?val:stripAndCollapse(jQuery.text(elem));}},select:{get:function(elem){var value,option,i,options=elem.options,index=elem.selectedIndex,one=elem.type==="select-one",values=one?null:[],max=one?index+1:options.length;if(index<0){i=max;}else{i=one?index:0;}for(;i<max;i++){option=options[i];if((option.selected||i===index)&&!option.disabled&&(!option.parentNode.disabled||!nodeName(option.parentNode,"optgroup"))){value=jQuery(option).val();if(one){return value;}values.push(value);}}return values;},set:function(elem,value){var optionSet,option,options=elem.options,values=jQuery.makeArray(value),i=options.length;while(i--){option=options[i];if(option.selected=jQuery.inArray(jQuery.valHooks.option.get(option),values)>-1){optionSet=true;}}if(!optionSet){elem.selectedIndex=-1;}return values;}}}});jQuery.each(["radio","checkbox"],function(){jQuery.valHooks[this]={set:function(elem,value){if(Array.isArray(value)){return elem.checked=jQuery.inArray(jQuery(elem).val(),value)>-1;}}};if(!support.checkOn){jQuery.valHooks[this].get=function(elem){return elem.getAttribute("value")===null?"on":elem.value;};}});support.focusin="onfocusin"in window;var rfocusMorph=/^(?:focusinfocus|focusoutblur)$/,stopPropagationCallback=function(e){e.stopPropagation();};jQuery.extend(jQuery.event,{trigger:function(event,data,elem,onlyHandlers){var i,cur,tmp,bubbleType,ontype,handle,special,lastElement,eventPath=[elem||document],type=hasOwn.call(event,"type")?event.type:event,namespaces=hasOwn.call(event,"namespace")?event.namespace.split("."):[];cur=lastElement=tmp=elem=elem||document;if(elem.nodeType===3||elem.nodeType===8){return;}if(rfocusMorph.test(type+jQuery.event.triggered)){return;}if(type.indexOf(".")>-1){namespaces=type.split(".");type=namespaces.shift();namespaces.sort();}ontype=type.indexOf(":")<0&&"on"+type;event=event[jQuery.expando]?event:new jQuery.Event(type,typeof event==="object"&&event);event.isTrigger=onlyHandlers?2:3;event.namespace=namespaces.join(".");event.rnamespace=event.namespace?new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"):null;event.result=undefined;if(!event.target){event.target=elem;}data=data==null?[event]:jQuery.makeArray(data,[event]);special=jQuery.event.special[type]||{};if(!onlyHandlers&&special.trigger&&special.trigger.apply(elem,data)===false){return;}if(!onlyHandlers&&!special.noBubble&&!isWindow(elem)){bubbleType=special.delegateType||type;if(!rfocusMorph.test(bubbleType+type)){cur=cur.parentNode;}for(;cur;cur=cur.parentNode){eventPath.push(cur);tmp=cur;}if(tmp===(elem.ownerDocument||document)){eventPath.push(tmp.defaultView||tmp.parentWindow||window);}}i=0;while((cur=eventPath[i++])&&!event.isPropagationStopped()){lastElement=cur;event.type=i>1?bubbleType:special.bindType||type;handle=(dataPriv.get(cur,"events")||{})[event.type]&&dataPriv.get(cur,"handle");if(handle){handle.apply(cur,data);}handle=ontype&&cur[ontype];if(handle&&handle.apply&&acceptData(cur)){event.result=handle.apply(cur,data);if(event.result===false){event.preventDefault();}}}event.type=type;if(!onlyHandlers&&!event.isDefaultPrevented()){if((!special._default||special._default.apply(eventPath.pop(),data)===false)&&acceptData(elem)){if(ontype&&isFunction(elem[type])&&!isWindow(elem)){tmp=elem[ontype];if(tmp){elem[ontype]=null;}jQuery.event.triggered=type;if(event.isPropagationStopped()){lastElement.addEventListener(type,stopPropagationCallback);}elem[type]();if(event.isPropagationStopped()){lastElement.removeEventListener(type,stopPropagationCallback);}jQuery.event.triggered=undefined;if(tmp){elem[ontype]=tmp;}}}}return event.result;},simulate:function(type,elem,event){var e=jQuery.extend(new jQuery.Event(),event,{type:type,isSimulated:true});jQuery.event.trigger(e,null,elem);}});jQuery.fn.extend({trigger:function(type,data){return this.each(function(){jQuery.event.trigger(type,data,this);});},triggerHandler:function(type,data){var elem=this[0];if(elem){return jQuery.event.trigger(type,data,elem,true);}}});if(!support.focusin){jQuery.each({focus:"focusin",blur:"focusout"},function(orig,fix){var handler=function(event){jQuery.event.simulate(fix,event.target,jQuery.event.fix(event));};jQuery.event.special[fix]={setup:function(){var doc=this.ownerDocument||this,attaches=dataPriv.access(doc,fix);if(!attaches){doc.addEventListener(orig,handler,true);}dataPriv.access(doc,fix,(attaches||0)+1);},teardown:function(){var doc=this.ownerDocument||this,attaches=dataPriv.access(doc,fix)-1;if(!attaches){doc.removeEventListener(orig,handler,true);dataPriv.remove(doc,fix);}else{dataPriv.access(doc,fix,attaches);}}};});}var location=window.location;var nonce=Date.now();var rquery=/\?/;jQuery.parseXML=function(data){var xml;if(!data||typeof data!=="string"){return null;}try{xml=new window.DOMParser().parseFromString(data,"text/xml");}catch(e){xml=undefined;}if(!xml||xml.getElementsByTagName("parsererror").length){jQuery.error("Invalid XML: "+data);}return xml;};var rbracket=/\[\]$/,rCRLF=/\r?\n/g,rsubmitterTypes=/^(?:submit|button|image|reset|file)$/i,rsubmittable=/^(?:input|select|textarea|keygen)/i;function buildParams(prefix,obj,traditional,add){if(Array.isArray(obj)){jQuery.each(obj,function(i,v){if(traditional||rbracket.test(prefix)){add(prefix,v);}else{buildParams(prefix+"["+(typeof v==="object"&&v!=null?i:"")+"]",v,traditional,add);}});}else if(!traditional&&toType(obj)==="object"){for(var name in obj){buildParams(prefix+"["+name+"]",obj[name],traditional,add);}}else{add(prefix,obj);}}jQuery.param=function(a,traditional){var prefix,s=[],add=function(key,valueOrFunction){var value=isFunction(valueOrFunction)?valueOrFunction():valueOrFunction;s[s.length]=encodeURIComponent(key)+"="+encodeURIComponent(value==null?"":value);};if(a==null){return"";}if(Array.isArray(a)||a.jquery&&!jQuery.isPlainObject(a)){jQuery.each(a,function(){add(this.name,this.value);});}else{for(prefix in a){buildParams(prefix,a[prefix],traditional,add);}}return s.join("&");};jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray());},serializeArray:function(){return this.map(function(){var elements=jQuery.prop(this,"elements");return elements?jQuery.makeArray(elements):this;}).filter(function(){var type=this.type;return this.name&&!jQuery(this).is(":disabled")&&rsubmittable.test(this.nodeName)&&!rsubmitterTypes.test(type)&&(this.checked||!rcheckableType.test(type));}).map(function(i,elem){var val=jQuery(this).val();if(val==null){return null;}if(Array.isArray(val)){return jQuery.map(val,function(val){return{name:elem.name,value:val.replace(rCRLF,"\r\n")};});}return{name:elem.name,value:val.replace(rCRLF,"\r\n")};}).get();}});var r20=/%20/g,rhash=/#.*$/,rantiCache=/([?&])_=[^&]*/,rheaders=/^(.*?):[ \t]*([^\r\n]*)$/mg,rlocalProtocol=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,rnoContent=/^(?:GET|HEAD)$/,rprotocol=/^\/\//,prefilters={},transports={},allTypes="*/".concat("*"),originAnchor=document.createElement("a");originAnchor.href=location.href;function addToPrefiltersOrTransports(structure){return function(dataTypeExpression,func){if(typeof dataTypeExpression!=="string"){func=dataTypeExpression;dataTypeExpression="*";}var dataType,i=0,dataTypes=dataTypeExpression.toLowerCase().match(rnothtmlwhite)||[];if(isFunction(func)){while(dataType=dataTypes[i++]){if(dataType[0]==="+"){dataType=dataType.slice(1)||"*";(structure[dataType]=structure[dataType]||[]).unshift(func);}else{(structure[dataType]=structure[dataType]||[]).push(func);}}}};}function inspectPrefiltersOrTransports(structure,options,originalOptions,jqXHR){var inspected={},seekingTransport=structure===transports;function inspect(dataType){var selected;inspected[dataType]=true;jQuery.each(structure[dataType]||[],function(_,prefilterOrFactory){var dataTypeOrTransport=prefilterOrFactory(options,originalOptions,jqXHR);if(typeof dataTypeOrTransport==="string"&&!seekingTransport&&!inspected[dataTypeOrTransport]){options.dataTypes.unshift(dataTypeOrTransport);inspect(dataTypeOrTransport);return false;}else if(seekingTransport){return!(selected=dataTypeOrTransport);}});return selected;}return inspect(options.dataTypes[0])||!inspected["*"]&&inspect("*");}function ajaxExtend(target,src){var key,deep,flatOptions=jQuery.ajaxSettings.flatOptions||{};for(key in src){if(src[key]!==undefined){(flatOptions[key]?target:deep||(deep={}))[key]=src[key];}}if(deep){jQuery.extend(true,target,deep);}return target;}function ajaxHandleResponses(s,jqXHR,responses){var ct,type,finalDataType,firstDataType,contents=s.contents,dataTypes=s.dataTypes;while(dataTypes[0]==="*"){dataTypes.shift();if(ct===undefined){ct=s.mimeType||jqXHR.getResponseHeader("Content-Type");}}if(ct){for(type in contents){if(contents[type]&&contents[type].test(ct)){dataTypes.unshift(type);break;}}}if(dataTypes[0]in responses){finalDataType=dataTypes[0];}else{for(type in responses){if(!dataTypes[0]||s.converters[type+" "+dataTypes[0]]){finalDataType=type;break;}if(!firstDataType){firstDataType=type;}}finalDataType=finalDataType||firstDataType;}if(finalDataType){if(finalDataType!==dataTypes[0]){dataTypes.unshift(finalDataType);}return responses[finalDataType];}}function ajaxConvert(s,response,jqXHR,isSuccess){var conv2,current,conv,tmp,prev,converters={},dataTypes=s.dataTypes.slice();if(dataTypes[1]){for(conv in s.converters){converters[conv.toLowerCase()]=s.converters[conv];}}current=dataTypes.shift();while(current){if(s.responseFields[current]){jqXHR[s.responseFields[current]]=response;}if(!prev&&isSuccess&&s.dataFilter){response=s.dataFilter(response,s.dataType);}prev=current;current=dataTypes.shift();if(current){if(current==="*"){current=prev;}else if(prev!=="*"&&prev!==current){conv=converters[prev+" "+current]||converters["* "+current];if(!conv){for(conv2 in converters){tmp=conv2.split(" ");if(tmp[1]===current){conv=converters[prev+" "+tmp[0]]||converters["* "+tmp[0]];if(conv){if(conv===true){conv=converters[conv2];}else if(converters[conv2]!==true){current=tmp[0];dataTypes.unshift(tmp[1]);}break;}}}}if(conv!==true){if(conv&&s.throws){response=conv(response);}else{try{response=conv(response);}catch(e){return{state:"parsererror",error:conv?e:"No conversion from "+prev+" to "+current};}}}}}}return{state:"success",data:response};}jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:location.href,type:"GET",isLocal:rlocalProtocol.test(location.protocol),global:true,processData:true,async:true,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":true,"text json":JSON.parse,"text xml":jQuery.parseXML},flatOptions:{url:true,context:true}},ajaxSetup:function(target,settings){return settings?ajaxExtend(ajaxExtend(target,jQuery.ajaxSettings),settings):ajaxExtend(jQuery.ajaxSettings,target);},ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports),ajax:function(url,options){if(typeof url==="object"){options=url;url=undefined;}options=options||{};var transport,cacheURL,responseHeadersString,responseHeaders,timeoutTimer,urlAnchor,completed,fireGlobals,i,uncached,s=jQuery.ajaxSetup({},options),callbackContext=s.context||s,globalEventContext=s.context&&(callbackContext.nodeType||callbackContext.jquery)?jQuery(callbackContext):jQuery.event,deferred=jQuery.Deferred(),completeDeferred=jQuery.Callbacks("once memory"),statusCode=s.statusCode||{},requestHeaders={},requestHeadersNames={},strAbort="canceled",jqXHR={readyState:0,getResponseHeader:function(key){var match;if(completed){if(!responseHeaders){responseHeaders={};while(match=rheaders.exec(responseHeadersString)){responseHeaders[match[1].toLowerCase()+" "]=(responseHeaders[match[1].toLowerCase()+" "]||[]).concat(match[2]);}}match=responseHeaders[key.toLowerCase()+" "];}return match==null?null:match.join(", ");},getAllResponseHeaders:function(){return completed?responseHeadersString:null;},setRequestHeader:function(name,value){if(completed==null){name=requestHeadersNames[name.toLowerCase()]=requestHeadersNames[name.toLowerCase()]||name;requestHeaders[name]=value;}return this;},overrideMimeType:function(type){if(completed==null){s.mimeType=type;}return this;},statusCode:function(map){if(map){if(completed){jqXHR.always(map[jqXHR.status]);}else{for(var code in map){statusCode[code]=[statusCode[code],map[code]];}}}return this;},abort:function(statusText){var finalText=statusText||strAbort;if(transport){transport.abort(finalText);}done(0,finalText);return this;}};deferred.promise(jqXHR);s.url=((url||s.url||location.href)+"").replace(rprotocol,location.protocol+"//");s.type=options.method||options.type||s.method||s.type;s.dataTypes=(s.dataType||"*").toLowerCase().match(rnothtmlwhite)||[""];if(s.crossDomain==null){urlAnchor=document.createElement("a");try{urlAnchor.href=s.url;urlAnchor.href=urlAnchor.href;s.crossDomain=originAnchor.protocol+"//"+originAnchor.host!==urlAnchor.protocol+"//"+urlAnchor.host;}catch(e){s.crossDomain=true;}}if(s.data&&s.processData&&typeof s.data!=="string"){s.data=jQuery.param(s.data,s.traditional);}inspectPrefiltersOrTransports(prefilters,s,options,jqXHR);if(completed){return jqXHR;}fireGlobals=jQuery.event&&s.global;if(fireGlobals&&jQuery.active++===0){jQuery.event.trigger("ajaxStart");}s.type=s.type.toUpperCase();s.hasContent=!rnoContent.test(s.type);cacheURL=s.url.replace(rhash,"");if(!s.hasContent){uncached=s.url.slice(cacheURL.length);if(s.data&&(s.processData||typeof s.data==="string")){cacheURL+=(rquery.test(cacheURL)?"&":"?")+s.data;delete s.data;}if(s.cache===false){cacheURL=cacheURL.replace(rantiCache,"$1");uncached=(rquery.test(cacheURL)?"&":"?")+"_="+nonce++ +uncached;}s.url=cacheURL+uncached;}else if(s.data&&s.processData&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0){s.data=s.data.replace(r20,"+");}if(s.ifModified){if(jQuery.lastModified[cacheURL]){jqXHR.setRequestHeader("If-Modified-Since",jQuery.lastModified[cacheURL]);}if(jQuery.etag[cacheURL]){jqXHR.setRequestHeader("If-None-Match",jQuery.etag[cacheURL]);}}if(s.data&&s.hasContent&&s.contentType!==false||options.contentType){jqXHR.setRequestHeader("Content-Type",s.contentType);}jqXHR.setRequestHeader("Accept",s.dataTypes[0]&&s.accepts[s.dataTypes[0]]?s.accepts[s.dataTypes[0]]+(s.dataTypes[0]!=="*"?", "+allTypes+"; q=0.01":""):s.accepts["*"]);for(i in s.headers){jqXHR.setRequestHeader(i,s.headers[i]);}if(s.beforeSend&&(s.beforeSend.call(callbackContext,jqXHR,s)===false||completed)){return jqXHR.abort();}strAbort="abort";completeDeferred.add(s.complete);jqXHR.done(s.success);jqXHR.fail(s.error);transport=inspectPrefiltersOrTransports(transports,s,options,jqXHR);if(!transport){done(-1,"No Transport");}else{jqXHR.readyState=1;if(fireGlobals){globalEventContext.trigger("ajaxSend",[jqXHR,s]);}if(completed){return jqXHR;}if(s.async&&s.timeout>0){timeoutTimer=window.setTimeout(function(){jqXHR.abort("timeout");},s.timeout);}try{completed=false;transport.send(requestHeaders,done);}catch(e){if(completed){throw e;}done(-1,e);}}function done(status,nativeStatusText,responses,headers){var isSuccess,success,error,response,modified,statusText=nativeStatusText;if(completed){return;}completed=true;if(timeoutTimer){window.clearTimeout(timeoutTimer);}transport=undefined;responseHeadersString=headers||"";jqXHR.readyState=status>0?4:0;isSuccess=status>=200&&status<300||status===304;if(responses){response=ajaxHandleResponses(s,jqXHR,responses);}response=ajaxConvert(s,response,jqXHR,isSuccess);if(isSuccess){if(s.ifModified){modified=jqXHR.getResponseHeader("Last-Modified");if(modified){jQuery.lastModified[cacheURL]=modified;}modified=jqXHR.getResponseHeader("etag");if(modified){jQuery.etag[cacheURL]=modified;}}if(status===204||s.type==="HEAD"){statusText="nocontent";}else if(status===304){statusText="notmodified";}else{statusText=response.state;success=response.data;error=response.error;isSuccess=!error;}}else{error=statusText;if(status||!statusText){statusText="error";if(status<0){status=0;}}}jqXHR.status=status;jqXHR.statusText=(nativeStatusText||statusText)+"";if(isSuccess){deferred.resolveWith(callbackContext,[success,statusText,jqXHR]);}else{deferred.rejectWith(callbackContext,[jqXHR,statusText,error]);}jqXHR.statusCode(statusCode);statusCode=undefined;if(fireGlobals){globalEventContext.trigger(isSuccess?"ajaxSuccess":"ajaxError",[jqXHR,s,isSuccess?success:error]);}completeDeferred.fireWith(callbackContext,[jqXHR,statusText]);if(fireGlobals){globalEventContext.trigger("ajaxComplete",[jqXHR,s]);if(! --jQuery.active){jQuery.event.trigger("ajaxStop");}}}return jqXHR;},getJSON:function(url,data,callback){return jQuery.get(url,data,callback,"json");},getScript:function(url,callback){return jQuery.get(url,undefined,callback,"script");}});jQuery.each(["get","post"],function(i,method){jQuery[method]=function(url,data,callback,type){if(isFunction(data)){type=type||callback;callback=data;data=undefined;}return jQuery.ajax(jQuery.extend({url:url,type:method,dataType:type,data:data,success:callback},jQuery.isPlainObject(url)&&url));};});jQuery._evalUrl=function(url,options){return jQuery.ajax({url:url,type:"GET",dataType:"script",cache:true,async:false,global:false,converters:{"text script":function(){}},dataFilter:function(response){jQuery.globalEval(response,options);}});};jQuery.fn.extend({wrapAll:function(html){var wrap;if(this[0]){if(isFunction(html)){html=html.call(this[0]);}wrap=jQuery(html,this[0].ownerDocument).eq(0).clone(true);if(this[0].parentNode){wrap.insertBefore(this[0]);}wrap.map(function(){var elem=this;while(elem.firstElementChild){elem=elem.firstElementChild;}return elem;}).append(this);}return this;},wrapInner:function(html){if(isFunction(html)){return this.each(function(i){jQuery(this).wrapInner(html.call(this,i));});}return this.each(function(){var self=jQuery(this),contents=self.contents();if(contents.length){contents.wrapAll(html);}else{self.append(html);}});},wrap:function(html){var htmlIsFunction=isFunction(html);return this.each(function(i){jQuery(this).wrapAll(htmlIsFunction?html.call(this,i):html);});},unwrap:function(selector){this.parent(selector).not("body").each(function(){jQuery(this).replaceWith(this.childNodes);});return this;}});jQuery.expr.pseudos.hidden=function(elem){return!jQuery.expr.pseudos.visible(elem);};jQuery.expr.pseudos.visible=function(elem){return!!(elem.offsetWidth||elem.offsetHeight||elem.getClientRects().length);};jQuery.ajaxSettings.xhr=function(){try{return new window.XMLHttpRequest();}catch(e){}};var xhrSuccessStatus={0:200,1223:204},xhrSupported=jQuery.ajaxSettings.xhr();support.cors=!!xhrSupported&&"withCredentials"in xhrSupported;support.ajax=xhrSupported=!!xhrSupported;jQuery.ajaxTransport(function(options){var callback,errorCallback;if(support.cors||xhrSupported&&!options.crossDomain){return{send:function(headers,complete){var i,xhr=options.xhr();xhr.open(options.type,options.url,options.async,options.username,options.password);if(options.xhrFields){for(i in options.xhrFields){xhr[i]=options.xhrFields[i];}}if(options.mimeType&&xhr.overrideMimeType){xhr.overrideMimeType(options.mimeType);}if(!options.crossDomain&&!headers["X-Requested-With"]){headers["X-Requested-With"]="XMLHttpRequest";}for(i in headers){xhr.setRequestHeader(i,headers[i]);}callback=function(type){return function(){if(callback){callback=errorCallback=xhr.onload=xhr.onerror=xhr.onabort=xhr.ontimeout=xhr.onreadystatechange=null;if(type==="abort"){xhr.abort();}else if(type==="error"){if(typeof xhr.status!=="number"){complete(0,"error");}else{complete(xhr.status,xhr.statusText);}}else{complete(xhrSuccessStatus[xhr.status]||xhr.status,xhr.statusText,(xhr.responseType||"text")!=="text"||typeof xhr.responseText!=="string"?{binary:xhr.response}:{text:xhr.responseText},xhr.getAllResponseHeaders());}}};};xhr.onload=callback();errorCallback=xhr.onerror=xhr.ontimeout=callback("error");if(xhr.onabort!==undefined){xhr.onabort=errorCallback;}else{xhr.onreadystatechange=function(){if(xhr.readyState===4){window.setTimeout(function(){if(callback){errorCallback();}});}};}callback=callback("abort");try{xhr.send(options.hasContent&&options.data||null);}catch(e){if(callback){throw e;}}},abort:function(){if(callback){callback();}}};}});jQuery.ajaxPrefilter(function(s){if(s.crossDomain){s.contents.script=false;}});jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, "+"application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(text){jQuery.globalEval(text);return text;}}});jQuery.ajaxPrefilter("script",function(s){if(s.cache===undefined){s.cache=false;}if(s.crossDomain){s.type="GET";}});jQuery.ajaxTransport("script",function(s){if(s.crossDomain||s.scriptAttrs){var script,callback;return{send:function(_,complete){script=jQuery("<script>").attr(s.scriptAttrs||{}).prop({charset:s.scriptCharset,src:s.url}).on("load error",callback=function(evt){script.remove();callback=null;if(evt){complete(evt.type==="error"?404:200,evt.type);}});document.head.appendChild(script[0]);},abort:function(){if(callback){callback();}}};}});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var callback=oldCallbacks.pop()||jQuery.expando+"_"+nonce++;this[callback]=true;return callback;}});jQuery.ajaxPrefilter("json jsonp",function(s,originalSettings,jqXHR){var callbackName,overwritten,responseContainer,jsonProp=s.jsonp!==false&&(rjsonp.test(s.url)?"url":typeof s.data==="string"&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0&&rjsonp.test(s.data)&&"data");if(jsonProp||s.dataTypes[0]==="jsonp"){callbackName=s.jsonpCallback=isFunction(s.jsonpCallback)?s.jsonpCallback():s.jsonpCallback;if(jsonProp){s[jsonProp]=s[jsonProp].replace(rjsonp,"$1"+callbackName);}else if(s.jsonp!==false){s.url+=(rquery.test(s.url)?"&":"?")+s.jsonp+"="+callbackName;}s.converters["script json"]=function(){if(!responseContainer){jQuery.error(callbackName+" was not called");}return responseContainer[0];};s.dataTypes[0]="json";overwritten=window[callbackName];window[callbackName]=function(){responseContainer=arguments;};jqXHR.always(function(){if(overwritten===undefined){jQuery(window).removeProp(callbackName);}else{window[callbackName]=overwritten;}if(s[callbackName]){s.jsonpCallback=originalSettings.jsonpCallback;oldCallbacks.push(callbackName);}if(responseContainer&&isFunction(overwritten)){overwritten(responseContainer[0]);}responseContainer=overwritten=undefined;});return"script";}});support.createHTMLDocument=function(){var body=document.implementation.createHTMLDocument("").body;body.innerHTML="<form></form><form></form>";return body.childNodes.length===2;}();jQuery.parseHTML=function(data,context,keepScripts){if(typeof data!=="string"){return[];}if(typeof context==="boolean"){keepScripts=context;context=false;}var base,parsed,scripts;if(!context){if(support.createHTMLDocument){context=document.implementation.createHTMLDocument("");base=context.createElement("base");base.href=document.location.href;context.head.appendChild(base);}else{context=document;}}parsed=rsingleTag.exec(data);scripts=!keepScripts&&[];if(parsed){return[context.createElement(parsed[1])];}parsed=buildFragment([data],context,scripts);if(scripts&&scripts.length){jQuery(scripts).remove();}return jQuery.merge([],parsed.childNodes);};jQuery.fn.load=function(url,params,callback){var selector,type,response,self=this,off=url.indexOf(" ");if(off>-1){selector=stripAndCollapse(url.slice(off));url=url.slice(0,off);}if(isFunction(params)){callback=params;params=undefined;}else if(params&&typeof params==="object"){type="POST";}if(self.length>0){jQuery.ajax({url:url,type:type||"GET",dataType:"html",data:params}).done(function(responseText){response=arguments;self.html(selector?jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector):responseText);}).always(callback&&function(jqXHR,status){self.each(function(){callback.apply(this,response||[jqXHR.responseText,status,jqXHR]);});});}return this;};jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(i,type){jQuery.fn[type]=function(fn){return this.on(type,fn);};});jQuery.expr.pseudos.animated=function(elem){return jQuery.grep(jQuery.timers,function(fn){return elem===fn.elem;}).length;};jQuery.offset={setOffset:function(elem,options,i){var curPosition,curLeft,curCSSTop,curTop,curOffset,curCSSLeft,calculatePosition,position=jQuery.css(elem,"position"),curElem=jQuery(elem),props={};if(position==="static"){elem.style.position="relative";}curOffset=curElem.offset();curCSSTop=jQuery.css(elem,"top");curCSSLeft=jQuery.css(elem,"left");calculatePosition=(position==="absolute"||position==="fixed")&&(curCSSTop+curCSSLeft).indexOf("auto")>-1;if(calculatePosition){curPosition=curElem.position();curTop=curPosition.top;curLeft=curPosition.left;}else{curTop=parseFloat(curCSSTop)||0;curLeft=parseFloat(curCSSLeft)||0;}if(isFunction(options)){options=options.call(elem,i,jQuery.extend({},curOffset));}if(options.top!=null){props.top=options.top-curOffset.top+curTop;}if(options.left!=null){props.left=options.left-curOffset.left+curLeft;}if("using"in options){options.using.call(elem,props);}else{curElem.css(props);}}};jQuery.fn.extend({offset:function(options){if(arguments.length){return options===undefined?this:this.each(function(i){jQuery.offset.setOffset(this,options,i);});}var rect,win,elem=this[0];if(!elem){return;}if(!elem.getClientRects().length){return{top:0,left:0};}rect=elem.getBoundingClientRect();win=elem.ownerDocument.defaultView;return{top:rect.top+win.pageYOffset,left:rect.left+win.pageXOffset};},position:function(){if(!this[0]){return;}var offsetParent,offset,doc,elem=this[0],parentOffset={top:0,left:0};if(jQuery.css(elem,"position")==="fixed"){offset=elem.getBoundingClientRect();}else{offset=this.offset();doc=elem.ownerDocument;offsetParent=elem.offsetParent||doc.documentElement;while(offsetParent&&(offsetParent===doc.body||offsetParent===doc.documentElement)&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.parentNode;}if(offsetParent&&offsetParent!==elem&&offsetParent.nodeType===1){parentOffset=jQuery(offsetParent).offset();parentOffset.top+=jQuery.css(offsetParent,"borderTopWidth",true);parentOffset.left+=jQuery.css(offsetParent,"borderLeftWidth",true);}}return{top:offset.top-parentOffset.top-jQuery.css(elem,"marginTop",true),left:offset.left-parentOffset.left-jQuery.css(elem,"marginLeft",true)};},offsetParent:function(){return this.map(function(){var offsetParent=this.offsetParent;while(offsetParent&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.offsetParent;}return offsetParent||documentElement;});}});jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(method,prop){var top="pageYOffset"===prop;jQuery.fn[method]=function(val){return access(this,function(elem,method,val){var win;if(isWindow(elem)){win=elem;}else if(elem.nodeType===9){win=elem.defaultView;}if(val===undefined){return win?win[prop]:elem[method];}if(win){win.scrollTo(!top?val:win.pageXOffset,top?val:win.pageYOffset);}else{elem[method]=val;}},method,val,arguments.length);};});jQuery.each(["top","left"],function(i,prop){jQuery.cssHooks[prop]=addGetHookIf(support.pixelPosition,function(elem,computed){if(computed){computed=curCSS(elem,prop);return rnumnonpx.test(computed)?jQuery(elem).position()[prop]+"px":computed;}});});jQuery.each({Height:"height",Width:"width"},function(name,type){jQuery.each({padding:"inner"+name,content:type,"":"outer"+name},function(defaultExtra,funcName){jQuery.fn[funcName]=function(margin,value){var chainable=arguments.length&&(defaultExtra||typeof margin!=="boolean"),extra=defaultExtra||(margin===true||value===true?"margin":"border");return access(this,function(elem,type,value){var doc;if(isWindow(elem)){return funcName.indexOf("outer")===0?elem["inner"+name]:elem.document.documentElement["client"+name];}if(elem.nodeType===9){doc=elem.documentElement;return Math.max(elem.body["scroll"+name],doc["scroll"+name],elem.body["offset"+name],doc["offset"+name],doc["client"+name]);}return value===undefined?jQuery.css(elem,type,extra):jQuery.style(elem,type,value,extra);},type,chainable?margin:undefined,chainable);};});});jQuery.each(("blur focus focusin focusout resize scroll click dblclick "+"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "+"change select submit keydown keypress keyup contextmenu").split(" "),function(i,name){jQuery.fn[name]=function(data,fn){return arguments.length>0?this.on(name,null,data,fn):this.trigger(name);};});jQuery.fn.extend({hover:function(fnOver,fnOut){return this.mouseenter(fnOver).mouseleave(fnOut||fnOver);}});jQuery.fn.extend({bind:function(types,data,fn){return this.on(types,null,data,fn);},unbind:function(types,fn){return this.off(types,null,fn);},delegate:function(selector,types,data,fn){return this.on(types,selector,data,fn);},undelegate:function(selector,types,fn){return arguments.length===1?this.off(selector,"**"):this.off(types,selector||"**",fn);}});jQuery.proxy=function(fn,context){var tmp,args,proxy;if(typeof context==="string"){tmp=fn[context];context=fn;fn=tmp;}if(!isFunction(fn)){return undefined;}args=slice.call(arguments,2);proxy=function(){return fn.apply(context||this,args.concat(slice.call(arguments)));};proxy.guid=fn.guid=fn.guid||jQuery.guid++;return proxy;};jQuery.holdReady=function(hold){if(hold){jQuery.readyWait++;}else{jQuery.ready(true);}};jQuery.isArray=Array.isArray;jQuery.parseJSON=JSON.parse;jQuery.nodeName=nodeName;jQuery.isFunction=isFunction;jQuery.isWindow=isWindow;jQuery.camelCase=camelCase;jQuery.type=toType;jQuery.now=Date.now;jQuery.isNumeric=function(obj){var type=jQuery.type(obj);return(type==="number"||type==="string")&&!isNaN(obj-parseFloat(obj));};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return jQuery;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}var _jQuery=window.jQuery,_$=window.$;jQuery.noConflict=function(deep){if(window.$===jQuery){window.$=_$;}if(deep&&window.jQuery===jQuery){window.jQuery=_jQuery;}return jQuery;};if(!noGlobal){window.jQuery=window.$=jQuery;}return jQuery;});

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

(function(global,factory){ true?module.exports=factory():undefined;})(this,function(){'use strict';var freeze$1=Object.freeze||function(x){return x;};var html=freeze$1(['a','abbr','acronym','address','area','article','aside','audio','b','bdi','bdo','big','blink','blockquote','body','br','button','canvas','caption','center','cite','code','col','colgroup','content','data','datalist','dd','decorator','del','details','dfn','dir','div','dl','dt','element','em','fieldset','figcaption','figure','font','footer','form','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i','img','input','ins','kbd','label','legend','li','main','map','mark','marquee','menu','menuitem','meter','nav','nobr','ol','optgroup','option','output','p','pre','progress','q','rp','rt','ruby','s','samp','section','select','shadow','small','source','spacer','span','strike','strong','style','sub','summary','sup','table','tbody','td','template','textarea','tfoot','th','thead','time','tr','track','tt','u','ul','var','video','wbr']);var svg=freeze$1(['svg','a','altglyph','altglyphdef','altglyphitem','animatecolor','animatemotion','animatetransform','audio','canvas','circle','clippath','defs','desc','ellipse','filter','font','g','glyph','glyphref','hkern','image','line','lineargradient','marker','mask','metadata','mpath','path','pattern','polygon','polyline','radialgradient','rect','stop','style','switch','symbol','text','textpath','title','tref','tspan','video','view','vkern']);var svgFilters=freeze$1(['feBlend','feColorMatrix','feComponentTransfer','feComposite','feConvolveMatrix','feDiffuseLighting','feDisplacementMap','feDistantLight','feFlood','feFuncA','feFuncB','feFuncG','feFuncR','feGaussianBlur','feMerge','feMergeNode','feMorphology','feOffset','fePointLight','feSpecularLighting','feSpotLight','feTile','feTurbulence']);var mathMl=freeze$1(['math','menclose','merror','mfenced','mfrac','mglyph','mi','mlabeledtr','mmultiscripts','mn','mo','mover','mpadded','mphantom','mroot','mrow','ms','mspace','msqrt','mstyle','msub','msup','msubsup','mtable','mtd','mtext','mtr','munder','munderover']);var text=freeze$1(['#text']);var freeze$2=Object.freeze||function(x){return x;};var html$1=freeze$2(['accept','action','align','alt','autocomplete','background','bgcolor','border','cellpadding','cellspacing','checked','cite','class','clear','color','cols','colspan','coords','crossorigin','datetime','default','dir','disabled','download','enctype','face','for','headers','height','hidden','high','href','hreflang','id','integrity','ismap','label','lang','list','loop','low','max','maxlength','media','method','min','multiple','name','noshade','novalidate','nowrap','open','optimum','pattern','placeholder','poster','preload','pubdate','radiogroup','readonly','rel','required','rev','reversed','role','rows','rowspan','spellcheck','scope','selected','shape','size','sizes','span','srclang','start','src','srcset','step','style','summary','tabindex','title','type','usemap','valign','value','width','xmlns']);var svg$1=freeze$2(['accent-height','accumulate','additive','alignment-baseline','ascent','attributename','attributetype','azimuth','basefrequency','baseline-shift','begin','bias','by','class','clip','clip-path','clip-rule','color','color-interpolation','color-interpolation-filters','color-profile','color-rendering','cx','cy','d','dx','dy','diffuseconstant','direction','display','divisor','dur','edgemode','elevation','end','fill','fill-opacity','fill-rule','filter','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','fx','fy','g1','g2','glyph-name','glyphref','gradientunits','gradienttransform','height','href','id','image-rendering','in','in2','k','k1','k2','k3','k4','kerning','keypoints','keysplines','keytimes','lang','lengthadjust','letter-spacing','kernelmatrix','kernelunitlength','lighting-color','local','marker-end','marker-mid','marker-start','markerheight','markerunits','markerwidth','maskcontentunits','maskunits','max','mask','media','method','mode','min','name','numoctaves','offset','operator','opacity','order','orient','orientation','origin','overflow','paint-order','path','pathlength','patterncontentunits','patterntransform','patternunits','points','preservealpha','preserveaspectratio','r','rx','ry','radius','refx','refy','repeatcount','repeatdur','restart','result','rotate','scale','seed','shape-rendering','specularconstant','specularexponent','spreadmethod','stddeviation','stitchtiles','stop-color','stop-opacity','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke','stroke-width','style','surfacescale','tabindex','targetx','targety','transform','text-anchor','text-decoration','text-rendering','textlength','type','u1','u2','unicode','values','viewbox','visibility','version','vert-adv-y','vert-origin-x','vert-origin-y','width','word-spacing','wrap','writing-mode','xchannelselector','ychannelselector','x','x1','x2','xmlns','y','y1','y2','z','zoomandpan']);var mathMl$1=freeze$2(['accent','accentunder','align','bevelled','close','columnsalign','columnlines','columnspan','denomalign','depth','dir','display','displaystyle','fence','frame','height','href','id','largeop','length','linethickness','lspace','lquote','mathbackground','mathcolor','mathsize','mathvariant','maxsize','minsize','movablelimits','notation','numalign','open','rowalign','rowlines','rowspacing','rowspan','rspace','rquote','scriptlevel','scriptminsize','scriptsizemultiplier','selection','separator','separators','stretchy','subscriptshift','supscriptshift','symmetric','voffset','width','xmlns']);var xml=freeze$2(['xlink:href','xml:id','xlink:title','xml:space','xmlns:xlink']);var hasOwnProperty=Object.hasOwnProperty;var setPrototypeOf=Object.setPrototypeOf;var _ref$1=typeof Reflect!=='undefined'&&Reflect;var apply$1=_ref$1.apply;if(!apply$1){apply$1=function(fun,thisValue,args){return fun.apply(thisValue,args);};}function addToSet(set,array){if(setPrototypeOf){setPrototypeOf(set,null);}var l=array.length;while(l--){var element=array[l];if(typeof element==='string'){var lcElement=element.toLowerCase();if(lcElement!==element){if(!Object.isFrozen(array)){array[l]=lcElement;}element=lcElement;}}set[element]=true;}return set;}function clone(object){var newObject={};var property=void 0;for(property in object){if(apply$1(hasOwnProperty,object,[property])){newObject[property]=object[property];}}return newObject;}var seal=Object.seal||function(x){return x;};var MUSTACHE_EXPR=seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);var ERB_EXPR=seal(/<%[\s\S]*|[\s\S]*%>/gm);var DATA_ATTR=seal(/^data-[\-\w.\u00B7-\uFFFF]/);var ARIA_ATTR=seal(/^aria-[\-\w]+$/);var IS_ALLOWED_URI=seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);var IS_SCRIPT_OR_DATA=seal(/^(?:\w+script|data):/i);var ATTR_WHITESPACE=seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g);var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}var _ref=typeof Reflect!=='undefined'&&Reflect;var apply=_ref.apply;var arraySlice=Array.prototype.slice;var freeze=Object.freeze;var getGlobal=function(){return typeof window==='undefined'?null:window;};if(!apply){apply=function(fun,thisValue,args){return fun.apply(thisValue,args);};}var _createTrustedTypesPolicy=function(trustedTypes,document){if((typeof trustedTypes==='undefined'?'undefined':_typeof(trustedTypes))!=='object'||typeof trustedTypes.createPolicy!=='function'){return null;}var suffix=null;var ATTR_NAME='data-tt-policy-suffix';if(document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)){suffix=document.currentScript.getAttribute(ATTR_NAME);}var policyName='dompurify'+(suffix?'#'+suffix:'');try{return trustedTypes.createPolicy(policyName,{createHTML:function(html$$1){return html$$1;}});}catch(error){console.warn('TrustedTypes policy '+policyName+' could not be created.');return null;}};function createDOMPurify(){var window=arguments.length>0&&arguments[0]!==undefined?arguments[0]:getGlobal();var DOMPurify=function(root){return createDOMPurify(root);};DOMPurify.version='1.0.10';DOMPurify.removed=[];if(!window||!window.document||window.document.nodeType!==9){DOMPurify.isSupported=false;return DOMPurify;}var originalDocument=window.document;var useDOMParser=false;var removeTitle=false;var document=window.document;var DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=_window$NamedNodeMap===undefined?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,Text=window.Text,Comment=window.Comment,DOMParser=window.DOMParser,TrustedTypes=window.TrustedTypes;if(typeof HTMLTemplateElement==='function'){var template=document.createElement('template');if(template.content&&template.content.ownerDocument){document=template.content.ownerDocument;}}var trustedTypesPolicy=_createTrustedTypesPolicy(TrustedTypes,originalDocument);var emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(''):'';var _document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,getElementsByTagName=_document.getElementsByTagName,createDocumentFragment=_document.createDocumentFragment;var importNode=originalDocument.importNode;var hooks={};DOMPurify.isSupported=implementation&&typeof implementation.createHTMLDocument!=='undefined'&&document.documentMode!==9;var MUSTACHE_EXPR$$1=MUSTACHE_EXPR,ERB_EXPR$$1=ERB_EXPR,ATTR_WHITESPACE$$1=ATTR_WHITESPACE;var IS_ALLOWED_URI$$1=IS_ALLOWED_URI;var ALLOWED_TAGS=null;var DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(html),_toConsumableArray(svg),_toConsumableArray(svgFilters),_toConsumableArray(mathMl),_toConsumableArray(text)));var ALLOWED_ATTR=null;var DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray(html$1),_toConsumableArray(svg$1),_toConsumableArray(mathMl$1),_toConsumableArray(xml)));var FORBID_TAGS=null;var FORBID_ATTR=null;var ALLOW_ARIA_ATTR=true;var ALLOW_DATA_ATTR=true;var ALLOW_UNKNOWN_PROTOCOLS=false;var SAFE_FOR_JQUERY=false;var SAFE_FOR_TEMPLATES=false;var WHOLE_DOCUMENT=false;var SET_CONFIG=false;var FORCE_BODY=false;var RETURN_DOM=false;var RETURN_DOM_FRAGMENT=false;var RETURN_DOM_IMPORT=false;var SANITIZE_DOM=true;var KEEP_CONTENT=true;var IN_PLACE=false;var USE_PROFILES={};var FORBID_CONTENTS=addToSet({},['audio','head','math','script','style','template','svg','video']);var DATA_URI_TAGS=addToSet({},['audio','video','img','source','image']);var URI_SAFE_ATTRIBUTES=addToSet({},['alt','class','for','id','label','name','pattern','placeholder','summary','title','value','style','xmlns']);var CONFIG=null;var formElement=document.createElement('form');var _parseConfig=function(cfg){if(CONFIG&&CONFIG===cfg){return;}if(!cfg||(typeof cfg==='undefined'?'undefined':_typeof(cfg))!=='object'){cfg={};}ALLOWED_TAGS='ALLOWED_TAGS'in cfg?addToSet({},cfg.ALLOWED_TAGS):DEFAULT_ALLOWED_TAGS;ALLOWED_ATTR='ALLOWED_ATTR'in cfg?addToSet({},cfg.ALLOWED_ATTR):DEFAULT_ALLOWED_ATTR;FORBID_TAGS='FORBID_TAGS'in cfg?addToSet({},cfg.FORBID_TAGS):{};FORBID_ATTR='FORBID_ATTR'in cfg?addToSet({},cfg.FORBID_ATTR):{};USE_PROFILES='USE_PROFILES'in cfg?cfg.USE_PROFILES:false;ALLOW_ARIA_ATTR=cfg.ALLOW_ARIA_ATTR!==false;ALLOW_DATA_ATTR=cfg.ALLOW_DATA_ATTR!==false;ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||false;SAFE_FOR_JQUERY=cfg.SAFE_FOR_JQUERY||false;SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||false;WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||false;RETURN_DOM=cfg.RETURN_DOM||false;RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||false;RETURN_DOM_IMPORT=cfg.RETURN_DOM_IMPORT||false;FORCE_BODY=cfg.FORCE_BODY||false;SANITIZE_DOM=cfg.SANITIZE_DOM!==false;KEEP_CONTENT=cfg.KEEP_CONTENT!==false;IN_PLACE=cfg.IN_PLACE||false;IS_ALLOWED_URI$$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$$1;if(SAFE_FOR_TEMPLATES){ALLOW_DATA_ATTR=false;}if(RETURN_DOM_FRAGMENT){RETURN_DOM=true;}if(USE_PROFILES){ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(text)));ALLOWED_ATTR=[];if(USE_PROFILES.html===true){addToSet(ALLOWED_TAGS,html);addToSet(ALLOWED_ATTR,html$1);}if(USE_PROFILES.svg===true){addToSet(ALLOWED_TAGS,svg);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.svgFilters===true){addToSet(ALLOWED_TAGS,svgFilters);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.mathMl===true){addToSet(ALLOWED_TAGS,mathMl);addToSet(ALLOWED_ATTR,mathMl$1);addToSet(ALLOWED_ATTR,xml);}}if(cfg.ADD_TAGS){if(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS){ALLOWED_TAGS=clone(ALLOWED_TAGS);}addToSet(ALLOWED_TAGS,cfg.ADD_TAGS);}if(cfg.ADD_ATTR){if(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR){ALLOWED_ATTR=clone(ALLOWED_ATTR);}addToSet(ALLOWED_ATTR,cfg.ADD_ATTR);}if(cfg.ADD_URI_SAFE_ATTR){addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR);}if(KEEP_CONTENT){ALLOWED_TAGS['#text']=true;}if(WHOLE_DOCUMENT){addToSet(ALLOWED_TAGS,['html','head','body']);}if(ALLOWED_TAGS.table){addToSet(ALLOWED_TAGS,['tbody']);}if(freeze){freeze(cfg);}CONFIG=cfg;};var _forceRemove=function(node){DOMPurify.removed.push({element:node});try{node.parentNode.removeChild(node);}catch(error){node.outerHTML=emptyHTML;}};var _removeAttribute=function(name,node){try{DOMPurify.removed.push({attribute:node.getAttributeNode(name),from:node});}catch(error){DOMPurify.removed.push({attribute:null,from:node});}node.removeAttribute(name);};var _initDocument=function(dirty){var doc=void 0;var leadingWhitespace=void 0;if(FORCE_BODY){dirty='<remove></remove>'+dirty;}else{var matches=dirty.match(/^[\s]+/);leadingWhitespace=matches&&matches[0];if(leadingWhitespace){dirty=dirty.slice(leadingWhitespace.length);}}if(useDOMParser){try{doc=new DOMParser().parseFromString(dirty,'text/html');}catch(error){}}if(removeTitle){addToSet(FORBID_TAGS,['title']);}if(!doc||!doc.documentElement){doc=implementation.createHTMLDocument('');var _doc=doc,body=_doc.body;body.parentNode.removeChild(body.parentNode.firstElementChild);body.outerHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;}if(leadingWhitespace){doc.body.insertBefore(document.createTextNode(leadingWhitespace),doc.body.childNodes[0]||null);}return getElementsByTagName.call(doc,WHOLE_DOCUMENT?'html':'body')[0];};if(DOMPurify.isSupported){(function(){try{var doc=_initDocument('<svg><p><style><img src="</style><img src=x onerror=1//">');if(doc.querySelector('svg img')){useDOMParser=true;}}catch(error){}})();(function(){try{var doc=_initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');if(doc.querySelector('title').innerHTML.match(/<\/title/)){removeTitle=true;}}catch(error){}})();}var _createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,function(){return NodeFilter.FILTER_ACCEPT;},false);};var _isClobbered=function(elm){if(elm instanceof Text||elm instanceof Comment){return false;}if(typeof elm.nodeName!=='string'||typeof elm.textContent!=='string'||typeof elm.removeChild!=='function'||!(elm.attributes instanceof NamedNodeMap)||typeof elm.removeAttribute!=='function'||typeof elm.setAttribute!=='function'){return true;}return false;};var _isNode=function(obj){return(typeof Node==='undefined'?'undefined':_typeof(Node))==='object'?obj instanceof Node:obj&&(typeof obj==='undefined'?'undefined':_typeof(obj))==='object'&&typeof obj.nodeType==='number'&&typeof obj.nodeName==='string';};var _executeHook=function(entryPoint,currentNode,data){if(!hooks[entryPoint]){return;}hooks[entryPoint].forEach(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG);});};var _sanitizeElements=function(currentNode){var content=void 0;_executeHook('beforeSanitizeElements',currentNode,null);if(_isClobbered(currentNode)){_forceRemove(currentNode);return true;}var tagName=currentNode.nodeName.toLowerCase();_executeHook('uponSanitizeElement',currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS});if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]&&typeof currentNode.insertAdjacentHTML==='function'){try{var htmlToInsert=currentNode.innerHTML;currentNode.insertAdjacentHTML('AfterEnd',trustedTypesPolicy?trustedTypesPolicy.createHTML(htmlToInsert):htmlToInsert);}catch(error){}}_forceRemove(currentNode);return true;}if(tagName==='noscript'&&currentNode.innerHTML.match(/<\/noscript/i)){_forceRemove(currentNode);return true;}if(tagName==='noembed'&&currentNode.innerHTML.match(/<\/noembed/i)){_forceRemove(currentNode);return true;}if(SAFE_FOR_JQUERY&&!currentNode.firstElementChild&&(!currentNode.content||!currentNode.content.firstElementChild)&&/</g.test(currentNode.textContent)){DOMPurify.removed.push({element:currentNode.cloneNode()});if(currentNode.innerHTML){currentNode.innerHTML=currentNode.innerHTML.replace(/</g,'&lt;');}else{currentNode.innerHTML=currentNode.textContent.replace(/</g,'&lt;');}}if(SAFE_FOR_TEMPLATES&&currentNode.nodeType===3){content=currentNode.textContent;content=content.replace(MUSTACHE_EXPR$$1,' ');content=content.replace(ERB_EXPR$$1,' ');if(currentNode.textContent!==content){DOMPurify.removed.push({element:currentNode.cloneNode()});currentNode.textContent=content;}}_executeHook('afterSanitizeElements',currentNode,null);return false;};var _isValidAttribute=function(lcTag,lcName,value){if(SANITIZE_DOM&&(lcName==='id'||lcName==='name')&&(value in document||value in formElement)){return false;}if(ALLOW_DATA_ATTR&&DATA_ATTR.test(lcName)){}else if(ALLOW_ARIA_ATTR&&ARIA_ATTR.test(lcName)){}else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){return false;}else if(URI_SAFE_ATTRIBUTES[lcName]){}else if(IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1,''))){}else if((lcName==='src'||lcName==='xlink:href')&&lcTag!=='script'&&value.indexOf('data:')===0&&DATA_URI_TAGS[lcTag]){}else if(ALLOW_UNKNOWN_PROTOCOLS&&!IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE$$1,''))){}else if(!!value){return false;}return true;};var _sanitizeAttributes=function(currentNode){var attr=void 0;var value=void 0;var lcName=void 0;var idAttr=void 0;var l=void 0;_executeHook('beforeSanitizeAttributes',currentNode,null);var attributes=currentNode.attributes;if(!attributes){return;}var hookEvent={attrName:'',attrValue:'',keepAttr:true,allowedAttributes:ALLOWED_ATTR};l=attributes.length;while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;value=attr.value.trim();lcName=name.toLowerCase();hookEvent.attrName=lcName;hookEvent.attrValue=value;hookEvent.keepAttr=true;_executeHook('uponSanitizeAttribute',currentNode,hookEvent);value=hookEvent.attrValue;if(lcName==='name'&&currentNode.nodeName==='IMG'&&attributes.id){idAttr=attributes.id;attributes=apply(arraySlice,attributes,[]);_removeAttribute('id',currentNode);_removeAttribute(name,currentNode);if(attributes.indexOf(idAttr)>l){currentNode.setAttribute('id',idAttr.value);}}else if(currentNode.nodeName==='INPUT'&&lcName==='type'&&value==='file'&&(ALLOWED_ATTR[lcName]||!FORBID_ATTR[lcName])){continue;}else{if(name==='id'){currentNode.setAttribute(name,'');}_removeAttribute(name,currentNode);}if(!hookEvent.keepAttr){continue;}if(SAFE_FOR_TEMPLATES){value=value.replace(MUSTACHE_EXPR$$1,' ');value=value.replace(ERB_EXPR$$1,' ');}var lcTag=currentNode.nodeName.toLowerCase();if(!_isValidAttribute(lcTag,lcName,value)){continue;}try{if(namespaceURI){currentNode.setAttributeNS(namespaceURI,name,value);}else{currentNode.setAttribute(name,value);}DOMPurify.removed.pop();}catch(error){}}_executeHook('afterSanitizeAttributes',currentNode,null);};var _sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode=void 0;var shadowIterator=_createIterator(fragment);_executeHook('beforeSanitizeShadowDOM',fragment,null);while(shadowNode=shadowIterator.nextNode()){_executeHook('uponSanitizeShadowNode',shadowNode,null);if(_sanitizeElements(shadowNode)){continue;}if(shadowNode.content instanceof DocumentFragment){_sanitizeShadowDOM(shadowNode.content);}_sanitizeAttributes(shadowNode);}_executeHook('afterSanitizeShadowDOM',fragment,null);};DOMPurify.sanitize=function(dirty,cfg){var body=void 0;var importedNode=void 0;var currentNode=void 0;var oldNode=void 0;var returnNode=void 0;if(!dirty){dirty='<!-->';}if(typeof dirty!=='string'&&!_isNode(dirty)){if(typeof dirty.toString!=='function'){throw new TypeError('toString is not a function');}else{dirty=dirty.toString();if(typeof dirty!=='string'){throw new TypeError('dirty is not a string, aborting');}}}if(!DOMPurify.isSupported){if(_typeof(window.toStaticHTML)==='object'||typeof window.toStaticHTML==='function'){if(typeof dirty==='string'){return window.toStaticHTML(dirty);}if(_isNode(dirty)){return window.toStaticHTML(dirty.outerHTML);}}return dirty;}if(!SET_CONFIG){_parseConfig(cfg);}DOMPurify.removed=[];if(IN_PLACE){}else if(dirty instanceof Node){body=_initDocument('<!-->');importedNode=body.ownerDocument.importNode(dirty,true);if(importedNode.nodeType===1&&importedNode.nodeName==='BODY'){body=importedNode;}else{body.appendChild(importedNode);}}else{if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&dirty.indexOf('<')===-1){return trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;}body=_initDocument(dirty);if(!body){return RETURN_DOM?null:emptyHTML;}}if(body&&FORCE_BODY){_forceRemove(body.firstChild);}var nodeIterator=_createIterator(IN_PLACE?dirty:body);while(currentNode=nodeIterator.nextNode()){if(currentNode.nodeType===3&&currentNode===oldNode){continue;}if(_sanitizeElements(currentNode)){continue;}if(currentNode.content instanceof DocumentFragment){_sanitizeShadowDOM(currentNode.content);}_sanitizeAttributes(currentNode);oldNode=currentNode;}oldNode=null;if(IN_PLACE){return dirty;}if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild){returnNode.appendChild(body.firstChild);}}else{returnNode=body;}if(RETURN_DOM_IMPORT){returnNode=importNode.call(originalDocument,returnNode,true);}return returnNode;}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;if(SAFE_FOR_TEMPLATES){serializedHTML=serializedHTML.replace(MUSTACHE_EXPR$$1,' ');serializedHTML=serializedHTML.replace(ERB_EXPR$$1,' ');}return trustedTypesPolicy?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML;};DOMPurify.setConfig=function(cfg){_parseConfig(cfg);SET_CONFIG=true;};DOMPurify.clearConfig=function(){CONFIG=null;SET_CONFIG=false;};DOMPurify.isValidAttribute=function(tag,attr,value){if(!CONFIG){_parseConfig({});}var lcTag=tag.toLowerCase();var lcName=attr.toLowerCase();return _isValidAttribute(lcTag,lcName,value);};DOMPurify.addHook=function(entryPoint,hookFunction){if(typeof hookFunction!=='function'){return;}hooks[entryPoint]=hooks[entryPoint]||[];hooks[entryPoint].push(hookFunction);};DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint]){hooks[entryPoint].pop();}};DOMPurify.removeHooks=function(entryPoint){if(hooks[entryPoint]){hooks[entryPoint]=[];}};DOMPurify.removeAllHooks=function(){hooks={};};return DOMPurify;}var purify=createDOMPurify();return purify;});

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),negate=__webpack_require__(225),pickBy=__webpack_require__(22);function omitBy(object,predicate){return pickBy(object,negate(baseIteratee(predicate)));}module.exports=omitBy;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom=__webpack_require__(236),isIterateeCall=__webpack_require__(46),toFinite=__webpack_require__(237);var freeParseFloat=parseFloat;var nativeMin=Math.min,nativeRandom=Math.random;function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}module.exports=random;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAAAkCAYAAACQePQGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABcVJREFUeNrsmr9LZFcUx4+bZKIJrBKbUZKMEAgSAo5sYzcjbGGzaBGCndoskkZh/wC1SRfUzq1U0lgEVLaRbRybXTu1SBAbFULUBLO6wiKSZPI+1xxz5857b96M4zor78D13Xd/nnO+55x77hvrRCTrlVWJqWboXqyCGJSYYlBiUGKKQbm79H5Y59TUt5JOfxZ5sYsf9yTx+4VsHh/L6IsXJccnk0np6ekpaFtfX5ft7W2pr683fel02rSfnJzIysqKHB4eSl9fn3nyzrj+/v6ree3t7dLV1SWbm5tmfYpNc3NzMjg4WNCmazc1NRXxwzrsZbefn5+b/fb29kJloZ+x8KT8tbW1STabNX25XK58UAAkk/kyMij7Px1LqiUReTwKhUmUAvMIxvvMzIxRPO8wT0HRKH9hYcHM4x1BGU9hPkIDIu8omTproFSbdE8Uzjr6zj7UGc96Lp/aTh1FT01NmXn2GNZkjPIxOztrQEAexgMcPMFfRZ7y3cXf8mb/WJKHr6Vn5eeSSu47bZBUQ0LSzc2Se/TItGWfPSs5D0GwGhhHmNbWVsM4SgYEiPrw8LDpZzzCoRgEh6gzhyfKUyBQmlqkrWht58m+rKOWr96h4/AgCEUqcHgbvPhZO/toOTo6MvPYA/5ZizmuoUQG5ZfEeyKpZo+RY1kfL63cLEA0NEljIiGZlpbIHqNWpQq23V9JhcAiXVAQXsOdKtUOKxquWI/wZbdreAN0JTsMoUCbD5cvP1lsY4M3niojcgSFrUigVIPGHzy4jOU7O7J3duY7BuuhwLAdqzUWa8hRy9VQRT+0tLRkFKljbAXbQPhZM2AyXkOhnju24l1jIeS5nmefWcy1PUm9krZSgLwVUMb+AyV3cBAICoy6zKrSR0dHjVDqEQoS1ke/AkQ/yqKucV4VOj4+XqA0BZfQiKLsMAjZiYB9INvt6gEuqZepBwK6awy3Csqr849l649L5hL3mr2/vxUxiNC2EpVQGAekKgsFAIiGMZTPXPUK+lCErSi/uK17ah/7kEAAqF+o0sPdbqfOfraC3THwZZ9N2h8FlLrQD5K5JyJkX2s73qgfygYl3dQnn9Z3mPqv51uyebIUX0Kue0+5DSIO66GooQ2L8/Omu0x4St635J7kJf/08hk0JqS033+Y//7rXVOoh431zo685955P/IAyXvnQsF43m2y+0uRB7LZL+p6QevSxlo2IYOXtBTM89Lhorne+RSoixv9zPJP/i9p/rDNFOpBxOE7OTkpqVTKt7+xsVHGxsZ8D9ZKqKOjw+xXjfXcrwPIQHJiZ5ZcGm1aW1vzzQhr5tsXDA8MDEQaWy1QbHDszKwSgqeJiYnCjNMzIL2vsL5tbKenp0VA1hQonBsjIyMFbcvLy9LZ2Sl1dXUyNDRkrAqan58vKUwQoTQtW1tboZZe0V3MU/z+/n6RsZE9uvIxNuzyeesHvasQAOBzhB3WKPYnkEqVZq+5u7tbEG6qJcvq6v9JbCaTMZdaVz43lNWcp2BJ7tmiGZheKCm0a70alh3p0uuFIM5yu4QRvE1PTxedheWErZpMidUbOByxtCDhr+MptieaL9tO2LluGGN9P++LErZq9p5yU1YflvlVi7hLkXktLi5WFLZqAhT3QoiV6WWxu7v7qt2O1dUkkoeg7AtFul4ZBq4S5wjJBJmdn6fWPCgI0Nvbe/VOpoLl6u8rN0V6TwjzEvZ3lRkFFD9je6c+swAKbm0fiBsbGyYtBhgSgaCzpRwivb47374OvhB52Sby5ycij8u/ZB1+kJS5+5cH6dmrj7w/xRZFRuLGYLzH9iC/ZOAuUzgoZ1+JJDxL/dyrP/6m7MVfe+Wlvjx/E+gtXBJdj/EjUs5qHszvJihviVA04OA1+ju9AkT8J5TpWROUGtvv7mePKBS2Xrnr6r2qUu8O/z0lpluh+J/xYlBiikGJQYkpBuUOE9kX/5OZjlVRO/SvAAMADC1T3Wo5vNkAAAAASUVORK5CYII="

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),baseWhile=__webpack_require__(121);function dropWhile(array,predicate){return array&&array.length?baseWhile(array,baseIteratee(predicate,3),true):[];}module.exports=dropWhile;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('slice',__webpack_require__(257));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('mapValues',__webpack_require__(36));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(15),unzip=__webpack_require__(116);var zip=baseRest(unzip);module.exports=zip;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(48);var CLONE_DEEP_FLAG=1,CLONE_SYMBOLS_FLAG=4;function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}module.exports=cloneDeep;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(47),baseRest=__webpack_require__(15),baseUniq=__webpack_require__(77),isArrayLikeObject=__webpack_require__(35);var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});module.exports=union;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

(function(){'use strict';var PI=Math.PI,sin=Math.sin,cos=Math.cos,tan=Math.tan,asin=Math.asin,atan=Math.atan2,acos=Math.acos,rad=PI/180;var dayMs=1000*60*60*24,J1970=2440588,J2000=2451545;function toJulian(date){return date.valueOf()/dayMs-0.5+J1970;}function fromJulian(j){return new Date((j+0.5-J1970)*dayMs);}function toDays(date){return toJulian(date)-J2000;}var e=rad*23.4397;function rightAscension(l,b){return atan(sin(l)*cos(e)-tan(b)*sin(e),cos(l));}function declination(l,b){return asin(sin(b)*cos(e)+cos(b)*sin(e)*sin(l));}function azimuth(H,phi,dec){return atan(sin(H),cos(H)*sin(phi)-tan(dec)*cos(phi));}function altitude(H,phi,dec){return asin(sin(phi)*sin(dec)+cos(phi)*cos(dec)*cos(H));}function siderealTime(d,lw){return rad*(280.16+360.9856235*d)-lw;}function astroRefraction(h){if(h<0)h=0;return 0.0002967/Math.tan(h+0.00312536/(h+0.08901179));}function solarMeanAnomaly(d){return rad*(357.5291+0.98560028*d);}function eclipticLongitude(M){var C=rad*(1.9148*sin(M)+0.02*sin(2*M)+0.0003*sin(3*M));return M+C+rad*102.9372+PI;}function sunCoords(d){var M=solarMeanAnomaly(d),L=eclipticLongitude(M);return{dec:declination(L,0),ra:rightAscension(L,0)};}var SunCalc={};SunCalc.getPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=sunCoords(d),H=siderealTime(d,rad*-lng)-c.ra;return{azimuth:azimuth(H,phi,c.dec),altitude:altitude(H,phi,c.dec)};};var times=SunCalc.times=[[-0.833,'sunrise','sunset'],[-0.3,'sunriseEnd','sunsetStart'],[-6,'dawn','dusk'],[-12,'nauticalDawn','nauticalDusk'],[-18,'nightEnd','night'],[6,'goldenHourEnd','goldenHour']];SunCalc.addTime=function(angle,riseName,setName){times.push([angle,riseName,setName]);};var J0=0.0009;function julianCycle(d,lw){return Math.round(d-J0-lw/(2*PI));}function approxTransit(Ht,lw,n){return J0+(Ht+lw)/(2*PI)+n;}function solarTransitJ(ds,M,L){return J2000+ds+0.0053*sin(M)-0.0069*sin(2*L);}function hourAngle(h,phi,d){return acos((sin(h)-sin(phi)*sin(d))/(cos(phi)*cos(d)));}function getSetJ(h,lw,phi,dec,n,M,L){var w=hourAngle(h,phi,dec),a=approxTransit(w,lw,n);return solarTransitJ(a,M,L);}SunCalc.getTimes=function(date,lat,lng){var lw=rad*-lng,d=toDays(date),n=julianCycle(d,lw),ds=approxTransit(0,lw,n),M=solarMeanAnomaly(ds),L=eclipticLongitude(M),dec=declination(L,0),Jnoon=solarTransitJ(ds,M,L),i,len,time,Jset,Jrise;var result={solarNoon:fromJulian(Jnoon),nadir:fromJulian(Jnoon-0.5)};for(i=0,len=times.length;i<len;i+=1){time=times[i];Jset=getSetJ(time[0]*rad,lw,rad*lat,dec,n,M,L);Jrise=Jnoon-(Jset-Jnoon);result[time[1]]=fromJulian(Jrise);result[time[2]]=fromJulian(Jset);}return result;};function moonCoords(d){var M=rad*(134.963+13.064993*d),l=rad*(218.316+13.176396*d)+rad*6.289*sin(M),b=rad*5.128*sin(rad*(93.272+13.229350*d)),dt=385001-20905*cos(M);return{ra:rightAscension(l,b),dec:declination(l,b),dist:dt};}SunCalc.getMoonPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=moonCoords(d),H=siderealTime(d,rad*-lng)-c.ra,h=altitude(H,phi,c.dec),pa=atan(sin(H),tan(phi)*cos(c.dec)-sin(c.dec)*cos(H));h=h+astroRefraction(h);return{azimuth:azimuth(H,phi,c.dec),altitude:h,distance:c.dist,parallacticAngle:pa};};SunCalc.getMoonIllumination=function(date){var d=toDays(date||new Date()),s=sunCoords(d),m=moonCoords(d),sdist=149598000,phi=acos(sin(s.dec)*sin(m.dec)+cos(s.dec)*cos(m.dec)*cos(s.ra-m.ra)),inc=atan(sdist*sin(phi),m.dist-sdist*cos(phi)),angle=atan(cos(s.dec)*sin(s.ra-m.ra),sin(s.dec)*cos(m.dec)-cos(s.dec)*sin(m.dec)*cos(s.ra-m.ra));return{fraction:(1+cos(inc))/2,phase:0.5+0.5*inc*(angle<0?-1:1)/Math.PI,angle:angle};};function hoursLater(date,h){return new Date(date.valueOf()+h*dayMs/24);}SunCalc.getMoonTimes=function(date,lat,lng,inUTC){var t=new Date(date);if(inUTC)t.setUTCHours(0,0,0,0);else t.setHours(0,0,0,0);var hc=0.133*rad,h0=SunCalc.getMoonPosition(t,lat,lng).altitude-hc,h1,h2,rise,set,a,b,xe,ye,d,roots,x1,x2,dx;for(var i=1;i<=24;i+=2){h1=SunCalc.getMoonPosition(hoursLater(t,i),lat,lng).altitude-hc;h2=SunCalc.getMoonPosition(hoursLater(t,i+1),lat,lng).altitude-hc;a=(h0+h2)/2-h1;b=(h2-h0)/2;xe=-b/(2*a);ye=(a*xe+b)*xe+h1;d=b*b-4*a*h1;roots=0;if(d>=0){dx=Math.sqrt(d)/(Math.abs(a)*2);x1=xe-dx;x2=xe+dx;if(Math.abs(x1)<=1)roots++;if(Math.abs(x2)<=1)roots++;if(x1<-1)x1=x2;}if(roots===1){if(h0<0)rise=i+x1;else set=i+x1;}else if(roots===2){rise=i+(ye<0?x2:x1);set=i+(ye<0?x1:x2);}if(rise&&set)break;h0=h2;}var result={};if(rise)result.rise=hoursLater(t,rise);if(set)result.set=hoursLater(t,set);if(!rise&&!set)result[ye>0?'alwaysUp':'alwaysDown']=true;return result;};if(true)module.exports=SunCalc;else {}})();

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */(function(global,factory){if(true){!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else {}})(this,function(){var numeral,_,formats={},locales={},defaults={currentLocale:'en',zeroFormat:null,nullFormat:null,defaultFormat:'0,0',scalePercentBy100:true},options={currentLocale:defaults.currentLocale,zeroFormat:defaults.zeroFormat,nullFormat:defaults.nullFormat,defaultFormat:defaults.defaultFormat,scalePercentBy100:defaults.scalePercentBy100};function Numeral(input,number){this._input=input;this._value=number;}numeral=function(input){var value,kind,unformatFunction,regexp;if(numeral.isNumeral(input)){value=input.value();}else if(input===0||typeof input==='undefined'){value=0;}else if(input===null||_.isNaN(input)){value=null;}else if(typeof input==='string'){if(options.zeroFormat&&input===options.zeroFormat){value=0;}else if(options.nullFormat&&input===options.nullFormat||!input.replace(/[^0-9]+/g,'').length){value=null;}else{for(kind in formats){regexp=typeof formats[kind].regexps.unformat==='function'?formats[kind].regexps.unformat():formats[kind].regexps.unformat;if(regexp&&input.match(regexp)){unformatFunction=formats[kind].unformat;break;}}unformatFunction=unformatFunction||numeral._.stringToNumber;value=unformatFunction(input);}}else{value=Number(input)||null;}return new Numeral(input,value);};numeral.version='2.0.6';numeral.isNumeral=function(obj){return obj instanceof Numeral;};numeral._=_={numberToFormat:function(value,format,roundingFunction){var locale=locales[numeral.options.currentLocale],negP=false,optDec=false,leadingCount=0,abbr='',trillion=1000000000000,billion=1000000000,million=1000000,thousand=1000,decimal='',neg=false,abbrForce,abs,int,precision,signed,thousands,output;value=value||0;abs=Math.abs(value);if(numeral._.includes(format,'(')){negP=true;format=format.replace(/[\(|\)]/g,'');}else if(numeral._.includes(format,'+')||numeral._.includes(format,'-')){signed=numeral._.includes(format,'+')?format.indexOf('+'):value<0?format.indexOf('-'):-1;format=format.replace(/[\+|\-]/g,'');}if(numeral._.includes(format,'a')){abbrForce=format.match(/a(k|m|b|t)?/);abbrForce=abbrForce?abbrForce[1]:false;if(numeral._.includes(format,' a')){abbr=' ';}format=format.replace(new RegExp(abbr+'a[kmbt]?'),'');if(abs>=trillion&&!abbrForce||abbrForce==='t'){abbr+=locale.abbreviations.trillion;value=value/trillion;}else if(abs<trillion&&abs>=billion&&!abbrForce||abbrForce==='b'){abbr+=locale.abbreviations.billion;value=value/billion;}else if(abs<billion&&abs>=million&&!abbrForce||abbrForce==='m'){abbr+=locale.abbreviations.million;value=value/million;}else if(abs<million&&abs>=thousand&&!abbrForce||abbrForce==='k'){abbr+=locale.abbreviations.thousand;value=value/thousand;}}if(numeral._.includes(format,'[.]')){optDec=true;format=format.replace('[.]','.');}int=value.toString().split('.')[0];precision=format.split('.')[1];thousands=format.indexOf(',');leadingCount=(format.split('.')[0].split(',')[0].match(/0/g)||[]).length;if(precision){if(numeral._.includes(precision,'[')){precision=precision.replace(']','');precision=precision.split('[');decimal=numeral._.toFixed(value,precision[0].length+precision[1].length,roundingFunction,precision[1].length);}else{decimal=numeral._.toFixed(value,precision.length,roundingFunction);}int=decimal.split('.')[0];if(numeral._.includes(decimal,'.')){decimal=locale.delimiters.decimal+decimal.split('.')[1];}else{decimal='';}if(optDec&&Number(decimal.slice(1))===0){decimal='';}}else{int=numeral._.toFixed(value,0,roundingFunction);}if(abbr&&!abbrForce&&Number(int)>=1000&&abbr!==locale.abbreviations.trillion){int=String(Number(int)/1000);switch(abbr){case locale.abbreviations.thousand:abbr=locale.abbreviations.million;break;case locale.abbreviations.million:abbr=locale.abbreviations.billion;break;case locale.abbreviations.billion:abbr=locale.abbreviations.trillion;break;}}if(numeral._.includes(int,'-')){int=int.slice(1);neg=true;}if(int.length<leadingCount){for(var i=leadingCount-int.length;i>0;i--){int='0'+int;}}if(thousands>-1){int=int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g,'$1'+locale.delimiters.thousands);}if(format.indexOf('.')===0){int='';}output=int+decimal+(abbr?abbr:'');if(negP){output=(negP&&neg?'(':'')+output+(negP&&neg?')':'');}else{if(signed>=0){output=signed===0?(neg?'-':'+')+output:output+(neg?'-':'+');}else if(neg){output='-'+output;}}return output;},stringToNumber:function(string){var locale=locales[options.currentLocale],stringOriginal=string,abbreviations={thousand:3,million:6,billion:9,trillion:12},abbreviation,value,regexp;if(options.zeroFormat&&string===options.zeroFormat){value=0;}else if(options.nullFormat&&string===options.nullFormat||!string.replace(/[^0-9]+/g,'').length){value=null;}else{value=1;if(locale.delimiters.decimal!=='.'){string=string.replace(/\./g,'').replace(locale.delimiters.decimal,'.');}for(abbreviation in abbreviations){regexp=new RegExp('[^a-zA-Z]'+locale.abbreviations[abbreviation]+'(?:\\)|(\\'+locale.currency.symbol+')?(?:\\))?)?$');if(stringOriginal.match(regexp)){value*=Math.pow(10,abbreviations[abbreviation]);break;}}value*=(string.split('-').length+Math.min(string.split('(').length-1,string.split(')').length-1))%2?1:-1;string=string.replace(/[^0-9\.]+/g,'');value*=Number(string);}return value;},isNaN:function(value){return typeof value==='number'&&isNaN(value);},includes:function(string,search){return string.indexOf(search)!==-1;},insert:function(string,subString,start){return string.slice(0,start)+subString+string.slice(start);},reduce:function(array,callback){if(this===null){throw new TypeError('Array.prototype.reduce called on null or undefined');}if(typeof callback!=='function'){throw new TypeError(callback+' is not a function');}var t=Object(array),len=t.length>>>0,k=0,value;if(arguments.length===3){value=arguments[2];}else{while(k<len&&!(k in t)){k++;}if(k>=len){throw new TypeError('Reduce of empty array with no initial value');}value=t[k++];}for(;k<len;k++){if(k in t){value=callback(value,t[k],k,t);}}return value;},multiplier:function(x){var parts=x.toString().split('.');return parts.length<2?1:Math.pow(10,parts[1].length);},correctionFactor:function(){var args=Array.prototype.slice.call(arguments);return args.reduce(function(accum,next){var mn=_.multiplier(next);return accum>mn?accum:mn;},1);},toFixed:function(value,maxDecimals,roundingFunction,optionals){var splitValue=value.toString().split('.'),minDecimals=maxDecimals-(optionals||0),boundedPrecision,optionalsRegExp,power,output;if(splitValue.length===2){boundedPrecision=Math.min(Math.max(splitValue[1].length,minDecimals),maxDecimals);}else{boundedPrecision=minDecimals;}power=Math.pow(10,boundedPrecision);output=(roundingFunction(value+'e+'+boundedPrecision)/power).toFixed(boundedPrecision);if(optionals>maxDecimals-boundedPrecision){optionalsRegExp=new RegExp('\\.?0{1,'+(optionals-(maxDecimals-boundedPrecision))+'}$');output=output.replace(optionalsRegExp,'');}return output;}};numeral.options=options;numeral.formats=formats;numeral.locales=locales;numeral.locale=function(key){if(key){options.currentLocale=key.toLowerCase();}return options.currentLocale;};numeral.localeData=function(key){if(!key){return locales[options.currentLocale];}key=key.toLowerCase();if(!locales[key]){throw new Error('Unknown locale : '+key);}return locales[key];};numeral.reset=function(){for(var property in defaults){options[property]=defaults[property];}};numeral.zeroFormat=function(format){options.zeroFormat=typeof format==='string'?format:null;};numeral.nullFormat=function(format){options.nullFormat=typeof format==='string'?format:null;};numeral.defaultFormat=function(format){options.defaultFormat=typeof format==='string'?format:'0.0';};numeral.register=function(type,name,format){name=name.toLowerCase();if(this[type+'s'][name]){throw new TypeError(name+' '+type+' already registered.');}this[type+'s'][name]=format;return format;};numeral.validate=function(val,culture){var _decimalSep,_thousandSep,_currSymbol,_valArray,_abbrObj,_thousandRegEx,localeData,temp;if(typeof val!=='string'){val+='';if(console.warn){console.warn('Numeral.js: Value is not string. It has been co-erced to: ',val);}}val=val.trim();if(!!val.match(/^\d+$/)){return true;}if(val===''){return false;}try{localeData=numeral.localeData(culture);}catch(e){localeData=numeral.localeData(numeral.locale());}_currSymbol=localeData.currency.symbol;_abbrObj=localeData.abbreviations;_decimalSep=localeData.delimiters.decimal;if(localeData.delimiters.thousands==='.'){_thousandSep='\\.';}else{_thousandSep=localeData.delimiters.thousands;}temp=val.match(/^[^\d]+/);if(temp!==null){val=val.substr(1);if(temp[0]!==_currSymbol){return false;}}temp=val.match(/[^\d]+$/);if(temp!==null){val=val.slice(0,-1);if(temp[0]!==_abbrObj.thousand&&temp[0]!==_abbrObj.million&&temp[0]!==_abbrObj.billion&&temp[0]!==_abbrObj.trillion){return false;}}_thousandRegEx=new RegExp(_thousandSep+'{2}');if(!val.match(/[^\d.,]/g)){_valArray=val.split(_decimalSep);if(_valArray.length>2){return false;}else{if(_valArray.length<2){return!!_valArray[0].match(/^\d+.*\d$/)&&!_valArray[0].match(_thousandRegEx);}else{if(_valArray[0].length===1){return!!_valArray[0].match(/^\d+$/)&&!_valArray[0].match(_thousandRegEx)&&!!_valArray[1].match(/^\d+$/);}else{return!!_valArray[0].match(/^\d+.*\d$/)&&!_valArray[0].match(_thousandRegEx)&&!!_valArray[1].match(/^\d+$/);}}}}return false;};numeral.fn=Numeral.prototype={clone:function(){return numeral(this);},format:function(inputString,roundingFunction){var value=this._value,format=inputString||options.defaultFormat,kind,output,formatFunction;roundingFunction=roundingFunction||Math.round;if(value===0&&options.zeroFormat!==null){output=options.zeroFormat;}else if(value===null&&options.nullFormat!==null){output=options.nullFormat;}else{for(kind in formats){if(format.match(formats[kind].regexps.format)){formatFunction=formats[kind].format;break;}}formatFunction=formatFunction||numeral._.numberToFormat;output=formatFunction(value,format,roundingFunction);}return output;},value:function(){return this._value;},input:function(){return this._input;},set:function(value){this._value=Number(value);return this;},add:function(value){var corrFactor=_.correctionFactor.call(null,this._value,value);this._value=_.reduce([this._value,value],function(accum,curr){return accum+Math.round(corrFactor*curr);},0)/corrFactor;return this;},subtract:function(value){var corrFactor=_.correctionFactor.call(null,this._value,value);this._value=_.reduce([value],function(accum,curr){return accum-Math.round(corrFactor*curr);},Math.round(this._value*corrFactor))/corrFactor;return this;},multiply:function(value){function cback(accum,curr){var corrFactor=_.correctionFactor(accum,curr);return Math.round(accum*corrFactor)*Math.round(curr*corrFactor)/Math.round(corrFactor*corrFactor);}this._value=_.reduce([this._value,value],cback,1);return this;},divide:function(value){function cback(accum,curr){var corrFactor=_.correctionFactor(accum,curr);return Math.round(accum*corrFactor)/Math.round(curr*corrFactor);}this._value=_.reduce([this._value,value],cback);return this;},difference:function(value){return Math.abs(numeral(this._value).subtract(value).value());}};numeral.register('locale','en',{delimiters:{thousands:',',decimal:'.'},abbreviations:{thousand:'k',million:'m',billion:'b',trillion:'t'},ordinal:function(number){var b=number%10;return~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';},currency:{symbol:'$'}});(function(){numeral.register('format','bps',{regexps:{format:/(BPS)/,unformat:/(BPS)/},format:function(value,format,roundingFunction){var space=numeral._.includes(format,' BPS')?' ':'',output;value=value*10000;format=format.replace(/\s?BPS/,'');output=numeral._.numberToFormat(value,format,roundingFunction);if(numeral._.includes(output,')')){output=output.split('');output.splice(-1,0,space+'BPS');output=output.join('');}else{output=output+space+'BPS';}return output;},unformat:function(string){return+(numeral._.stringToNumber(string)*0.0001).toFixed(15);}});})();(function(){var decimal={base:1000,suffixes:['B','KB','MB','GB','TB','PB','EB','ZB','YB']},binary={base:1024,suffixes:['B','KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB']};var allSuffixes=decimal.suffixes.concat(binary.suffixes.filter(function(item){return decimal.suffixes.indexOf(item)<0;}));var unformatRegex=allSuffixes.join('|');unformatRegex='('+unformatRegex.replace('B','B(?!PS)')+')';numeral.register('format','bytes',{regexps:{format:/([0\s]i?b)/,unformat:new RegExp(unformatRegex)},format:function(value,format,roundingFunction){var output,bytes=numeral._.includes(format,'ib')?binary:decimal,suffix=numeral._.includes(format,' b')||numeral._.includes(format,' ib')?' ':'',power,min,max;format=format.replace(/\s?i?b/,'');for(power=0;power<=bytes.suffixes.length;power++){min=Math.pow(bytes.base,power);max=Math.pow(bytes.base,power+1);if(value===null||value===0||value>=min&&value<max){suffix+=bytes.suffixes[power];if(min>0){value=value/min;}break;}}output=numeral._.numberToFormat(value,format,roundingFunction);return output+suffix;},unformat:function(string){var value=numeral._.stringToNumber(string),power,bytesMultiplier;if(value){for(power=decimal.suffixes.length-1;power>=0;power--){if(numeral._.includes(string,decimal.suffixes[power])){bytesMultiplier=Math.pow(decimal.base,power);break;}if(numeral._.includes(string,binary.suffixes[power])){bytesMultiplier=Math.pow(binary.base,power);break;}}value*=bytesMultiplier||1;}return value;}});})();(function(){numeral.register('format','currency',{regexps:{format:/(\$)/},format:function(value,format,roundingFunction){var locale=numeral.locales[numeral.options.currentLocale],symbols={before:format.match(/^([\+|\-|\(|\s|\$]*)/)[0],after:format.match(/([\+|\-|\)|\s|\$]*)$/)[0]},output,symbol,i;format=format.replace(/\s?\$\s?/,'');output=numeral._.numberToFormat(value,format,roundingFunction);if(value>=0){symbols.before=symbols.before.replace(/[\-\(]/,'');symbols.after=symbols.after.replace(/[\-\)]/,'');}else if(value<0&&!numeral._.includes(symbols.before,'-')&&!numeral._.includes(symbols.before,'(')){symbols.before='-'+symbols.before;}for(i=0;i<symbols.before.length;i++){symbol=symbols.before[i];switch(symbol){case'$':output=numeral._.insert(output,locale.currency.symbol,i);break;case' ':output=numeral._.insert(output,' ',i+locale.currency.symbol.length-1);break;}}for(i=symbols.after.length-1;i>=0;i--){symbol=symbols.after[i];switch(symbol){case'$':output=i===symbols.after.length-1?output+locale.currency.symbol:numeral._.insert(output,locale.currency.symbol,-(symbols.after.length-(1+i)));break;case' ':output=i===symbols.after.length-1?output+' ':numeral._.insert(output,' ',-(symbols.after.length-(1+i)+locale.currency.symbol.length-1));break;}}return output;}});})();(function(){numeral.register('format','exponential',{regexps:{format:/(e\+|e-)/,unformat:/(e\+|e-)/},format:function(value,format,roundingFunction){var output,exponential=typeof value==='number'&&!numeral._.isNaN(value)?value.toExponential():'0e+0',parts=exponential.split('e');format=format.replace(/e[\+|\-]{1}0/,'');output=numeral._.numberToFormat(Number(parts[0]),format,roundingFunction);return output+'e'+parts[1];},unformat:function(string){var parts=numeral._.includes(string,'e+')?string.split('e+'):string.split('e-'),value=Number(parts[0]),power=Number(parts[1]);power=numeral._.includes(string,'e-')?power*=-1:power;function cback(accum,curr){var corrFactor=numeral._.correctionFactor(accum,curr);return accum*corrFactor*(curr*corrFactor)/(corrFactor*corrFactor);}return numeral._.reduce([value,Math.pow(10,power)],cback,1);}});})();(function(){numeral.register('format','ordinal',{regexps:{format:/(o)/},format:function(value,format,roundingFunction){var locale=numeral.locales[numeral.options.currentLocale],output,ordinal=numeral._.includes(format,' o')?' ':'';format=format.replace(/\s?o/,'');ordinal+=locale.ordinal(value);output=numeral._.numberToFormat(value,format,roundingFunction);return output+ordinal;}});})();(function(){numeral.register('format','percentage',{regexps:{format:/(%)/,unformat:/(%)/},format:function(value,format,roundingFunction){var space=numeral._.includes(format,' %')?' ':'',output;if(numeral.options.scalePercentBy100){value=value*100;}format=format.replace(/\s?\%/,'');output=numeral._.numberToFormat(value,format,roundingFunction);if(numeral._.includes(output,')')){output=output.split('');output.splice(-1,0,space+'%');output=output.join('');}else{output=output+space+'%';}return output;},unformat:function(string){var number=numeral._.stringToNumber(string);if(numeral.options.scalePercentBy100){return number*0.01;}return number;}});})();(function(){numeral.register('format','time',{regexps:{format:/(:)/,unformat:/(:)/},format:function(value){var hours=Math.floor(value/60/60),minutes=Math.floor((value-hours*60*60)/60),seconds=Math.round(value-hours*60*60-minutes*60);return hours+':'+(minutes<10?'0'+minutes:minutes)+':'+(seconds<10?'0'+seconds:seconds);},unformat:function(string){var timeArray=string.split(':'),seconds=0;if(timeArray.length===3){seconds=seconds+Number(timeArray[0])*60*60;seconds=seconds+Number(timeArray[1])*60;seconds=seconds+Number(timeArray[2]);}else if(timeArray.length===2){seconds=seconds+Number(timeArray[0])*60;seconds=seconds+Number(timeArray[1]);}return Number(seconds);}});})();return numeral;});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license MIT
 * @fileOverview Favico animations
 * @author Miroslav Magda, http://blog.ejci.net
 * @version 0.3.10
 */(function(){var Favico=function(opt){'use strict';opt=opt?opt:{};var _def={bgColor:'#d00',textColor:'#fff',fontFamily:'sans-serif',fontStyle:'bold',type:'circle',position:'down',animation:'slide',elementId:false,dataUrl:false,win:window};var _opt,_orig,_h,_w,_canvas,_context,_img,_ready,_lastBadge,_running,_readyCb,_stop,_browser,_animTimeout,_drawTimeout,_doc;_browser={};_browser.ff=typeof InstallTrigger!='undefined';_browser.chrome=!!window.chrome;_browser.opera=!!window.opera||navigator.userAgent.indexOf('Opera')>=0;_browser.ie=false;_browser.safari=Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor')>0;_browser.supported=_browser.chrome||_browser.ff||_browser.opera;var _queue=[];_readyCb=function(){};_ready=_stop=false;var init=function(){_opt=merge(_def,opt);_opt.bgColor=hexToRgb(_opt.bgColor);_opt.textColor=hexToRgb(_opt.textColor);_opt.position=_opt.position.toLowerCase();_opt.animation=animation.types[''+_opt.animation]?_opt.animation:_def.animation;_doc=_opt.win.document;var isUp=_opt.position.indexOf('up')>-1;var isLeft=_opt.position.indexOf('left')>-1;if(isUp||isLeft){for(var i=0;i<animation.types[''+_opt.animation].length;i++){var step=animation.types[''+_opt.animation][i];if(isUp){if(step.y<0.6){step.y=step.y-0.4;}else{step.y=step.y-2*step.y+(1-step.w);}}if(isLeft){if(step.x<0.6){step.x=step.x-0.4;}else{step.x=step.x-2*step.x+(1-step.h);}}animation.types[''+_opt.animation][i]=step;}}_opt.type=type[''+_opt.type]?_opt.type:_def.type;_orig=link.getIcon();_canvas=document.createElement('canvas');_img=document.createElement('img');if(_orig.hasAttribute('href')){_img.setAttribute('crossOrigin','anonymous');_img.onload=function(){_h=_img.height>0?_img.height:32;_w=_img.width>0?_img.width:32;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src',_orig.getAttribute('href'));}else{_img.onload=function(){_h=32;_w=32;_img.height=_h;_img.width=_w;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src','');}};var icon={};icon.ready=function(){_ready=true;icon.reset();_readyCb();};icon.reset=function(){if(!_ready){return;}_queue=[];_lastBadge=false;_running=false;_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);link.setIcon(_canvas);window.clearTimeout(_animTimeout);window.clearTimeout(_drawTimeout);};icon.start=function(){if(!_ready||_running){return;}var finished=function(){_lastBadge=_queue[0];_running=false;if(_queue.length>0){_queue.shift();icon.start();}};if(_queue.length>0){_running=true;var run=function(){['type','animation','bgColor','textColor','fontFamily','fontStyle'].forEach(function(a){if(a in _queue[0].options){_opt[a]=_queue[0].options[a];}});animation.run(_queue[0].options,function(){finished();},false);};if(_lastBadge){animation.run(_lastBadge.options,function(){run();},true);}else{run();}}};var type={};var options=function(opt){opt.n=typeof opt.n==='number'?Math.abs(opt.n|0):opt.n;opt.x=_w*opt.x;opt.y=_h*opt.y;opt.w=_w*opt.w;opt.h=_h*opt.h;opt.len=(""+opt.n).length;return opt;};type.circle=function(opt){opt=options(opt);var more=false;if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;more=true;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;more=true;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.85:1))+"px "+_opt.fontFamily;_context.textAlign='center';if(more){_context.moveTo(opt.x+opt.w/2,opt.y);_context.lineTo(opt.x+opt.w-opt.h/2,opt.y);_context.quadraticCurveTo(opt.x+opt.w,opt.y,opt.x+opt.w,opt.y+opt.h/2);_context.lineTo(opt.x+opt.w,opt.y+opt.h-opt.h/2);_context.quadraticCurveTo(opt.x+opt.w,opt.y+opt.h,opt.x+opt.w-opt.h/2,opt.y+opt.h);_context.lineTo(opt.x+opt.h/2,opt.y+opt.h);_context.quadraticCurveTo(opt.x,opt.y+opt.h,opt.x,opt.y+opt.h-opt.h/2);_context.lineTo(opt.x,opt.y+opt.h/2);_context.quadraticCurveTo(opt.x,opt.y,opt.x+opt.h/2,opt.y);}else{_context.arc(opt.x+opt.w/2,opt.y+opt.h/2,opt.h/2,0,2*Math.PI);}_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fill();_context.closePath();_context.beginPath();_context.stroke();_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};type.rectangle=function(opt){opt=options(opt);if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.9:1))+"px "+_opt.fontFamily;_context.textAlign='center';_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fillRect(opt.x,opt.y,opt.w,opt.h);_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};var badge=function(number,opts){opts=(typeof opts==='string'?{animation:opts}:opts)||{};_readyCb=function(){try{if(typeof number==='number'?number>0:number!==''){var q={type:'badge',options:{n:number}};if('animation'in opts&&animation.types[''+opts.animation]){q.options.animation=''+opts.animation;}if('type'in opts&&type[''+opts.type]){q.options.type=''+opts.type;}['bgColor','textColor'].forEach(function(o){if(o in opts){q.options[o]=hexToRgb(opts[o]);}});['fontStyle','fontFamily'].forEach(function(o){if(o in opts){q.options[o]=opts[o];}});_queue.push(q);if(_queue.length>100){throw new Error('Too many badges requests in queue.');}icon.start();}else{icon.reset();}}catch(e){throw new Error('Error setting badge. Message: '+e.message);}};if(_ready){_readyCb();}};var image=function(imageElement){_readyCb=function(){try{var w=imageElement.width;var h=imageElement.height;var newImg=document.createElement('img');var ratio=w/_w<h/_h?w/_w:h/_h;newImg.setAttribute('crossOrigin','anonymous');newImg.onload=function(){_context.clearRect(0,0,_w,_h);_context.drawImage(newImg,0,0,_w,_h);link.setIcon(_canvas);};newImg.setAttribute('src',imageElement.getAttribute('src'));newImg.height=h/ratio;newImg.width=w/ratio;}catch(e){throw new Error('Error setting image. Message: '+e.message);}};if(_ready){_readyCb();}};var video=function(videoElement){_readyCb=function(){try{if(videoElement==='stop'){_stop=true;icon.reset();_stop=false;return;}videoElement.addEventListener('play',function(){drawVideo(this);},false);}catch(e){throw new Error('Error setting video. Message: '+e.message);}};if(_ready){_readyCb();}};var webcam=function(action){if(!window.URL||!window.URL.createObjectURL){window.URL=window.URL||{};window.URL.createObjectURL=function(obj){return obj;};}if(_browser.supported){var newVideo=false;navigator.getUserMedia=navigator.getUserMedia||navigator.oGetUserMedia||navigator.msGetUserMedia||navigator.mozGetUserMedia||navigator.webkitGetUserMedia;_readyCb=function(){try{if(action==='stop'){_stop=true;icon.reset();_stop=false;return;}newVideo=document.createElement('video');newVideo.width=_w;newVideo.height=_h;navigator.getUserMedia({video:true,audio:false},function(stream){newVideo.src=URL.createObjectURL(stream);newVideo.play();drawVideo(newVideo);},function(){});}catch(e){throw new Error('Error setting webcam. Message: '+e.message);}};if(_ready){_readyCb();}}};function drawVideo(video){if(video.paused||video.ended||_stop){return false;}try{_context.clearRect(0,0,_w,_h);_context.drawImage(video,0,0,_w,_h);}catch(e){}_drawTimeout=setTimeout(function(){drawVideo(video);},animation.duration);link.setIcon(_canvas);}var link={};link.getIcon=function(){var elm=false;var getLink=function(){var link=_doc.getElementsByTagName('head')[0].getElementsByTagName('link');for(var l=link.length,i=l-1;i>=0;i--){if(/(^|\s)icon(\s|$)/i.test(link[i].getAttribute('rel'))){return link[i];}}return false;};if(_opt.element){elm=_opt.element;}else if(_opt.elementId){elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',elm.getAttribute('src'));}else{elm=getLink();if(elm===false){elm=_doc.createElement('link');elm.setAttribute('rel','icon');_doc.getElementsByTagName('head')[0].appendChild(elm);}}elm.setAttribute('type','image/png');return elm;};link.setIcon=function(canvas){var url=canvas.toDataURL('image/png');if(_opt.dataUrl){_opt.dataUrl(url);}if(_opt.element){_opt.element.setAttribute('href',url);_opt.element.setAttribute('src',url);}else if(_opt.elementId){var elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',url);elm.setAttribute('src',url);}else{if(_browser.ff||_browser.opera){var old=_orig;_orig=_doc.createElement('link');if(_browser.opera){_orig.setAttribute('rel','icon');}_orig.setAttribute('rel','icon');_orig.setAttribute('type','image/png');_doc.getElementsByTagName('head')[0].appendChild(_orig);_orig.setAttribute('href',url);if(old.parentNode){old.parentNode.removeChild(old);}}else{_orig.setAttribute('href',url);}}};function hexToRgb(hex){var shorthandRegex=/^#?([a-f\d])([a-f\d])([a-f\d])$/i;hex=hex.replace(shorthandRegex,function(m,r,g,b){return r+r+g+g+b+b;});var result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);return result?{r:parseInt(result[1],16),g:parseInt(result[2],16),b:parseInt(result[3],16)}:false;}function merge(def,opt){var mergedOpt={};for(var attrname in def){mergedOpt[attrname]=def[attrname];}for(attrname in opt){mergedOpt[attrname]=opt[attrname];}return mergedOpt;}function isPageHidden(){return _doc.hidden||_doc.msHidden||_doc.webkitHidden||_doc.mozHidden;}var animation={};animation.duration=40;animation.types={};animation.types.fade=[{x:0.4,y:0.4,w:0.6,h:0.6,o:0.0},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.1},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.2},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.3},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.4},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.5},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.6},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.7},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.8},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1.0}];animation.types.none=[{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.pop=[{x:1,y:1,w:0,h:0,o:1},{x:0.9,y:0.9,w:0.1,h:0.1,o:1},{x:0.8,y:0.8,w:0.2,h:0.2,o:1},{x:0.7,y:0.7,w:0.3,h:0.3,o:1},{x:0.6,y:0.6,w:0.4,h:0.4,o:1},{x:0.5,y:0.5,w:0.5,h:0.5,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.popFade=[{x:0.75,y:0.75,w:0,h:0,o:0},{x:0.65,y:0.65,w:0.1,h:0.1,o:0.2},{x:0.6,y:0.6,w:0.2,h:0.2,o:0.4},{x:0.55,y:0.55,w:0.3,h:0.3,o:0.6},{x:0.50,y:0.50,w:0.4,h:0.4,o:0.8},{x:0.45,y:0.45,w:0.5,h:0.5,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.slide=[{x:0.4,y:1,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.8,w:0.6,h:0.6,o:1},{x:0.4,y:0.7,w:0.6,h:0.6,o:1},{x:0.4,y:0.6,w:0.6,h:0.6,o:1},{x:0.4,y:0.5,w:0.6,h:0.6,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.run=function(opt,cb,revert,step){var animationType=animation.types[isPageHidden()?'none':_opt.animation];if(revert===true){step=typeof step!=='undefined'?step:animationType.length-1;}else{step=typeof step!=='undefined'?step:0;}cb=cb?cb:function(){};if(step<animationType.length&&step>=0){type[_opt.type](merge(opt,animationType[step]));_animTimeout=setTimeout(function(){if(revert){step=step-1;}else{step=step+1;}animation.run(opt,cb,revert,step);},animation.duration);link.setIcon(_canvas);}else{cb();}};init();return{badge:badge,video:video,image:image,webcam:webcam,reset:icon.reset,browser:{supported:_browser.supported}};};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Favico;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else {}})();

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHQElEQVRYR8WXe1BU9xXHP5dld+WxLoKKSEAeGgxqFIVRjAn4BBIVUkzBOoUqDJmojYIZtT7qI2k6VVGZBGOtWlNMpz5wTBFfqIAtAg6klVGCCvHFQ1ieA8qyC3s7966A6JpabZLz1+7vnnvO957f95zf9yfwE5sg5a8RRbGp5cdHMkALMoDSZlFsbmh/cQSCFQprBV2dXSCa+sRRqtTY2gkIVgKGDpGHbfqe5w5ONmYA1xpNYktT74P/FYmVQoG+/SEOjlpUaoHOTpGOdhGlSkB3v5b0r/bSWK9j5uxIJr71Jm0t5lzaAf1eHoC9th/nT2SwOSmOQUNewW/iZPwmvcVY/0mIJpFFEcGorTpxdnbmctE3rN+6h/cWxssg/i8ApDIujoqgtvoewaEh5F3I5m5FGQaDASuFEt+RI8i7lI9CoSB521Z+s24D567UYGNnj7294uU4oFAqMXboCRnnwqpPU4n7MIbGRmiqb6b63g2S4n7B7FnB/HHPXrnkN2/c4FUfH47nlePm6Y2N7SMSvigHbO37UXAxh8VRM8kovMXgIa4YDR1IwAY5K9i9bRc7fvtrzmfn4OHhSUL8Ir6tqCT94hU6jaDpr3w5DgwY2I/NScsoupTLkZx/92G4REylUsHmjxLIOPSl/NtpsCufHczAy8eX9gcvyAEpsEJhLTNcYnzIuOHMjVpI0qa16O4bMHV19TSRVAm1WsH1q9dobW1m5Khx2GnseNCmx0p4rAv+2xzo7mUpcltbF80NOpoadXx3/VvWLI5m484/Exg0HTv7AWgd7bESRPR6gY5282xR29igUIh0dQkYDb0g+8wBKbDEym4zGkEUQaWCu7cqyT17gpyzGdwsLaGtpRHELqwEAZVKjbGzE4OxExs7DV4+owgMmsm0sAhGjhmFSZpNIggCNDe2YG1tzQAnO/lDerqgQi+KNffaOHRgFwW5WTg4DuS92PcZNNiZ1C0byTl9HEetPUFBwQQFB+PrO4phHh5oNBoEQeBBWxu6+nquXb3KxdwccnKyuXWnkjH+gSxb+ykarQPJG1dSUpyPtbWSaW+/y4oNWxnqrjWTsKSuXYwMmkhT7V3CIyKoq60lI/OUXIzAiQGsWr2G0LAwVFI5ntMK8vPZsT2Zo8eOI4omZs2YRmLSCmru32fD+nVoBrnxdV6BGUDc8g3imcO7uVp6Ha1WS3R0NFlZWaSmfk509PznTGnZLf/SJRISElBYW5ObmyvH1+l0uLo4k/zlaTOA4b5+4pK4BSxLTCIyMpIL589TVFyMt7d3b9QbpXDkEEzwh9A5lrPdqYBj6eDnB8Eze3zaHz4kJDSUiooKysrK5K2bGDCeCdMjzQD8Jk0VZ08PZPKUNwkLC6OkpITRo0f3JqmrgdfHINQ1ymviuVMwLaQviEYdjB+HcLfG7HPhTB8QRqMRNzc3wsPD2bF9O06ODvxh3wkzgJS0THHlorkyi+Pj49myZUvf4MUFCAGTe9bE32+CVev7+vzrMsKESb0+H6+HtZv6+Jw5c4Y5c+bg5TEMoZ+WjPwiM4AqURRXxC/nb/tS5DJ5eXn1DW7Qwy/nw+Hj4DsCTp0Gdws+P4+Er0+CpxuczYLhPk9tlcuQwTgM8WTP4ZO4DnMyA7hnMomZ6TmsiouguroaG1tby3ss8cBtGNjYPZuYV4rBwxO0jhZ9Aib4yXu/8uN1dLQ/Ooxud5rEk+kXSIx5m8rKKpycnF6K+d/38shXRxAcEcuyNetkN7kCNx+YxNsVOmaNdeHokUO8+7PIHwTA3Tt38PD05E/H/kHAG2+gVD6mCaWMy3+1gNtXC7l+s9wigJ07dzJlyhT8/f0tPm9paSE1NZUlS5bI/f6kLZgfRU5+MScKrmPo6KK/g6r3ONa3m2TdFjLenQ/ej+ezz1OfChAbG0taWhpRUVHMmDEDby8vlCoVdXV1FBYWcuDAATlxUVGR3OuP28GDacTExLInPZtJQUGWJZmk0fKyc0mInEp83CJ2fbFbPjwet8zMTPbv3y/PitbWVkwmkzyi3d3dmTdvHkuXLn1qZKekpJCYmEjShmTiE5PoVuAWNaG0ePmfeXwYE4Gzo4ZtyTuYGx5useR6vV4+/6WukQ6lJ624uJhVKz/iQnYuG3fsI2rRQpoaDD3SvQfAk3pA42BDQ10DKZ+s5vhf9zPC25OY2BjeeWcOr/n6olarLQKSqlFRXs658+f4Ku0v5OUXEjBlBqt/t5PXxo7q+fLul7/3XiCJEDuNFTdLb3A0bS9Zfz9MfW0Vjg79cXUdiovLUJwGDpQ1gUS+qqpKKquq0dU3YqtxYPLUUKIXfsD4wEC6OpEl2JP2XLJcUjOSen3QauJWeSllJd/wXXkZ1ffu0NLUIMe0te/PK+4euHkMx2f0WEaMfF3W/JKoefwm9EIAul+SRaZKhUoNikfCSbp4dJt09ZL+GwzQoTf20YbPGirP5MAPMoUsBO3hwE95O/4PY9MuHly+U4UAAAAASUVORK5CYII="

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

module.exports=__webpack_require__(79);

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),baseWhile=__webpack_require__(121);function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,baseIteratee(predicate,3),false,true):[];}module.exports=takeRightWhile;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(17),func=convert('groupBy',__webpack_require__(21));func.placeholder=__webpack_require__(8);module.exports=func;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

if (window !== window.top) {
  let blocked = true;

  try {
    blocked = !Number.isInteger(localStorage.length + sessionStorage.length);
  } catch (e) {
    if (blocked) {
      window.parent.postMessage({
        failedToLoad: true
      }, '*');
      window.stop();
    }
  }
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger=__webpack_require__(32);var FUNC_ERROR_TEXT='Expected a function';function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}module.exports=before;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear=__webpack_require__(87),listCacheDelete=__webpack_require__(88),listCacheGet=__webpack_require__(90),listCacheHas=__webpack_require__(91),listCacheSet=__webpack_require__(92);function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var basePullAll=__webpack_require__(149);function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}module.exports=pullAll;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(16),baseIndexOf=__webpack_require__(59),baseIndexOfWith=__webpack_require__(150),baseUnary=__webpack_require__(40),copyArray=__webpack_require__(60);var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}module.exports=basePullAll;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}module.exports=baseIndexOfWith;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var root=__webpack_require__(24);var now=function(){return root.Date.now();};module.exports=now;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;module.exports=freeGlobal;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var createCtor=__webpack_require__(42),root=__webpack_require__(24);var WRAP_BIND_FLAG=1;function createBind(func,bitmask,thisArg){var Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(bitmask&WRAP_BIND_FLAG?thisArg:this,arguments);}return wrapper;}module.exports=createBind;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),createCtor=__webpack_require__(42),createHybrid=__webpack_require__(98),createRecurry=__webpack_require__(99),getHolder=__webpack_require__(103),replaceHolders=__webpack_require__(104),root=__webpack_require__(24);function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}module.exports=createCurry;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

var nativeMax=Math.max;function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength);while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}module.exports=composeArgs;

/***/ }),
/* 157 */
/***/ (function(module, exports) {

var nativeMax=Math.max;function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength);while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}module.exports=composeArgsRight;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}module.exports=countHolders;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray=__webpack_require__(60),isIndex=__webpack_require__(43);var nativeMin=Math.min;function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}module.exports=reorder;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),createCtor=__webpack_require__(42),root=__webpack_require__(24);var WRAP_BIND_FLAG=1;function createPartial(func,bitmask,thisArg,partials){var Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,bitmask&WRAP_BIND_FLAG?thisArg:this,args);}return wrapper;}module.exports=createPartial;

/***/ }),
/* 161 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var baseUnset=__webpack_require__(163),isIndex=__webpack_require__(43);var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}module.exports=basePullAt;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(33),last=__webpack_require__(7),parent=__webpack_require__(165),toKey=__webpack_require__(25);function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}module.exports=baseUnset;

/***/ }),
/* 164 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet=__webpack_require__(62),baseSlice=__webpack_require__(63);function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}module.exports=parent;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor=__webpack_require__(167);var baseFor=createBaseFor();module.exports=baseFor;

/***/ }),
/* 167 */
/***/ (function(module, exports) {

function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}module.exports=createBaseFor;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}module.exports=arrayAggregator;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}module.exports=arrayAggregator;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var getNative=__webpack_require__(171);var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();module.exports=defineProperty;

/***/ }),
/* 171 */
/***/ (function(module, exports) {

function getValue(object,key){return object==null?undefined:object[key];}module.exports=getValue;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(15),isIterateeCall=__webpack_require__(46);function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}module.exports=createAssigner;

/***/ }),
/* 173 */
/***/ (function(module, exports) {

function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy=__webpack_require__(112),hasIn=__webpack_require__(113);function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}module.exports=basePick;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue=__webpack_require__(111),castPath=__webpack_require__(33),isIndex=__webpack_require__(43),isObject=__webpack_require__(10),toKey=__webpack_require__(25);function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=length-1){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}module.exports=baseSet;

/***/ }),
/* 176 */
/***/ (function(module, exports) {

function baseHasIn(object,key){return object!=null&&key in Object(object);}module.exports=baseHasIn;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(33),isArguments=__webpack_require__(71),isArray=__webpack_require__(5),isIndex=__webpack_require__(43),isLength=__webpack_require__(114),toKey=__webpack_require__(25);function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}module.exports=hasPath;

/***/ }),
/* 178 */
/***/ (function(module, exports) {

function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}module.exports=arrayPush;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol=__webpack_require__(180),isArguments=__webpack_require__(71),isArray=__webpack_require__(5);var spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined;function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}module.exports=isFlattenable;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var root=__webpack_require__(24);var Symbol=root.Symbol;module.exports=Symbol;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var mapping=__webpack_require__(182),fallbackHolder=__webpack_require__(8);var push=Array.prototype.push;function baseArity(func,n){return n==2?function(){return func.apply(undefined,arguments);}:function(){return func.apply(undefined,arguments);};}function baseAry(func,n){return n==2?function(a,b){return func(a,b);}:function(a){return func(a);};}function cloneArray(array){var length=array?array.length:0,result=Array(length);while(length--){result[length]=array[length];}return result;}function createCloner(func){return function(object){return func({},object);};}function flatSpread(func,start){return function(){var length=arguments.length,lastIndex=length-1,args=Array(length);while(length--){args[length]=arguments[length];}var array=args[start],otherArgs=args.slice(0,start);if(array){push.apply(otherArgs,array);}if(start!=lastIndex){push.apply(otherArgs,args.slice(start+1));}return func.apply(this,otherArgs);};}function wrapImmutable(func,cloner){return function(){var length=arguments.length;if(!length){return;}var args=Array(length);while(length--){args[length]=arguments[length];}var result=args[0]=cloner.apply(undefined,args);func.apply(undefined,args);return result;};}function baseConvert(util,name,func,options){var isLib=typeof name=='function',isObj=name===Object(name);if(isObj){options=func;func=name;name=undefined;}if(func==null){throw new TypeError();}options||(options={});var config={'cap':'cap'in options?options.cap:true,'curry':'curry'in options?options.curry:true,'fixed':'fixed'in options?options.fixed:true,'immutable':'immutable'in options?options.immutable:true,'rearg':'rearg'in options?options.rearg:true};var defaultHolder=isLib?func:fallbackHolder,forceCurry='curry'in options&&options.curry,forceFixed='fixed'in options&&options.fixed,forceRearg='rearg'in options&&options.rearg,pristine=isLib?func.runInContext():undefined;var helpers=isLib?func:{'ary':util.ary,'assign':util.assign,'clone':util.clone,'curry':util.curry,'forEach':util.forEach,'isArray':util.isArray,'isError':util.isError,'isFunction':util.isFunction,'isWeakMap':util.isWeakMap,'iteratee':util.iteratee,'keys':util.keys,'rearg':util.rearg,'toInteger':util.toInteger,'toPath':util.toPath};var ary=helpers.ary,assign=helpers.assign,clone=helpers.clone,curry=helpers.curry,each=helpers.forEach,isArray=helpers.isArray,isError=helpers.isError,isFunction=helpers.isFunction,isWeakMap=helpers.isWeakMap,keys=helpers.keys,rearg=helpers.rearg,toInteger=helpers.toInteger,toPath=helpers.toPath;var aryMethodKeys=keys(mapping.aryMethod);var wrappers={'castArray':function(castArray){return function(){var value=arguments[0];return isArray(value)?castArray(cloneArray(value)):castArray.apply(undefined,arguments);};},'iteratee':function(iteratee){return function(){var func=arguments[0],arity=arguments[1],result=iteratee(func,arity),length=result.length;if(config.cap&&typeof arity=='number'){arity=arity>2?arity-2:1;return length&&length<=arity?result:baseAry(result,arity);}return result;};},'mixin':function(mixin){return function(source){var func=this;if(!isFunction(func)){return mixin(func,Object(source));}var pairs=[];each(keys(source),function(key){if(isFunction(source[key])){pairs.push([key,func.prototype[key]]);}});mixin(func,Object(source));each(pairs,function(pair){var value=pair[1];if(isFunction(value)){func.prototype[pair[0]]=value;}else{delete func.prototype[pair[0]];}});return func;};},'nthArg':function(nthArg){return function(n){var arity=n<0?1:toInteger(n)+1;return curry(nthArg(n),arity);};},'rearg':function(rearg){return function(func,indexes){var arity=indexes?indexes.length:0;return curry(rearg(func,indexes),arity);};},'runInContext':function(runInContext){return function(context){return baseConvert(util,runInContext(context),options);};}};function castCap(name,func){if(config.cap){var indexes=mapping.iterateeRearg[name];if(indexes){return iterateeRearg(func,indexes);}var n=!isLib&&mapping.iterateeAry[name];if(n){return iterateeAry(func,n);}}return func;}function castCurry(name,func,n){return forceCurry||config.curry&&n>1?curry(func,n):func;}function castFixed(name,func,n){if(config.fixed&&(forceFixed||!mapping.skipFixed[name])){var data=mapping.methodSpread[name],start=data&&data.start;return start===undefined?ary(func,n):flatSpread(func,start);}return func;}function castRearg(name,func,n){return config.rearg&&n>1&&(forceRearg||!mapping.skipRearg[name])?rearg(func,mapping.methodRearg[name]||mapping.aryRearg[n]):func;}function cloneByPath(object,path){path=toPath(path);var index=-1,length=path.length,result=clone(Object(object)),nested=result;while(nested!=null&&++index<length){var key=path[index],value=nested[key];if(value!=null&&!(isFunction(value)||isError(value)||isWeakMap(value))){nested[key]=clone(index==length-1?value:Object(value));}nested=nested[key];}return result;}function convertLib(options){return _.runInContext.convert(options)(undefined);}function createConverter(name,func){var realName=mapping.aliasToReal[name]||name,methodName=mapping.remap[realName]||realName,oldOptions=options;return function(options){var newUtil=isLib?pristine:helpers,newFunc=isLib?pristine[methodName]:func,newOptions=assign(assign({},oldOptions),options);return baseConvert(newUtil,realName,newFunc,newOptions);};}function iterateeAry(func,n){return overArg(func,function(func){return typeof func=='function'?baseAry(func,n):func;});}function iterateeRearg(func,indexes){return overArg(func,function(func){var n=indexes.length;return baseArity(rearg(baseAry(func,n),indexes),n);});}function overArg(func,transform){return function(){var length=arguments.length;if(!length){return func();}var args=Array(length);while(length--){args[length]=arguments[length];}var index=config.rearg?0:length-1;args[index]=transform(args[index]);return func.apply(undefined,args);};}function wrap(name,func,placeholder){var result,realName=mapping.aliasToReal[name]||name,wrapped=func,wrapper=wrappers[realName];if(wrapper){wrapped=wrapper(func);}else if(config.immutable){if(mapping.mutate.array[realName]){wrapped=wrapImmutable(func,cloneArray);}else if(mapping.mutate.object[realName]){wrapped=wrapImmutable(func,createCloner(func));}else if(mapping.mutate.set[realName]){wrapped=wrapImmutable(func,cloneByPath);}}each(aryMethodKeys,function(aryKey){each(mapping.aryMethod[aryKey],function(otherName){if(realName==otherName){var data=mapping.methodSpread[realName],afterRearg=data&&data.afterRearg;result=afterRearg?castFixed(realName,castRearg(realName,wrapped,aryKey),aryKey):castRearg(realName,castFixed(realName,wrapped,aryKey),aryKey);result=castCap(realName,result);result=castCurry(realName,result,aryKey);return false;}});return!result;});result||(result=wrapped);if(result==func){result=forceCurry?curry(result,1):function(){return func.apply(this,arguments);};}result.convert=createConverter(realName,func);result.placeholder=func.placeholder=placeholder;return result;}if(!isObj){return wrap(name,func,defaultHolder);}var _=func;var pairs=[];each(aryMethodKeys,function(aryKey){each(mapping.aryMethod[aryKey],function(key){var func=_[mapping.remap[key]||key];if(func){pairs.push([key,wrap(key,func,_)]);}});});each(keys(_),function(key){var func=_[key];if(typeof func=='function'){var length=pairs.length;while(length--){if(pairs[length][0]==key){return;}}func.convert=createConverter(key,func);pairs.push([key,func]);}});each(pairs,function(pair){_[pair[0]]=pair[1];});_.convert=convertLib;_.placeholder=_;each(keys(_),function(key){each(mapping.realToAlias[key]||[],function(alias){_[alias]=_[key];});});return _;}module.exports=baseConvert;

/***/ }),
/* 182 */
/***/ (function(module, exports) {

exports.aliasToReal={'each':'forEach','eachRight':'forEachRight','entries':'toPairs','entriesIn':'toPairsIn','extend':'assignIn','extendAll':'assignInAll','extendAllWith':'assignInAllWith','extendWith':'assignInWith','first':'head','conforms':'conformsTo','matches':'isMatch','property':'get','__':'placeholder','F':'stubFalse','T':'stubTrue','all':'every','allPass':'overEvery','always':'constant','any':'some','anyPass':'overSome','apply':'spread','assoc':'set','assocPath':'set','complement':'negate','compose':'flowRight','contains':'includes','dissoc':'unset','dissocPath':'unset','dropLast':'dropRight','dropLastWhile':'dropRightWhile','equals':'isEqual','identical':'eq','indexBy':'keyBy','init':'initial','invertObj':'invert','juxt':'over','omitAll':'omit','nAry':'ary','path':'get','pathEq':'matchesProperty','pathOr':'getOr','paths':'at','pickAll':'pick','pipe':'flow','pluck':'map','prop':'get','propEq':'matchesProperty','propOr':'getOr','props':'at','symmetricDifference':'xor','symmetricDifferenceBy':'xorBy','symmetricDifferenceWith':'xorWith','takeLast':'takeRight','takeLastWhile':'takeRightWhile','unapply':'rest','unnest':'flatten','useWith':'overArgs','where':'conformsTo','whereEq':'isMatch','zipObj':'zipObject'};exports.aryMethod={'1':['assignAll','assignInAll','attempt','castArray','ceil','create','curry','curryRight','defaultsAll','defaultsDeepAll','floor','flow','flowRight','fromPairs','invert','iteratee','memoize','method','mergeAll','methodOf','mixin','nthArg','over','overEvery','overSome','rest','reverse','round','runInContext','spread','template','trim','trimEnd','trimStart','uniqueId','words','zipAll'],'2':['add','after','ary','assign','assignAllWith','assignIn','assignInAllWith','at','before','bind','bindAll','bindKey','chunk','cloneDeepWith','cloneWith','concat','conformsTo','countBy','curryN','curryRightN','debounce','defaults','defaultsDeep','defaultTo','delay','difference','divide','drop','dropRight','dropRightWhile','dropWhile','endsWith','eq','every','filter','find','findIndex','findKey','findLast','findLastIndex','findLastKey','flatMap','flatMapDeep','flattenDepth','forEach','forEachRight','forIn','forInRight','forOwn','forOwnRight','get','groupBy','gt','gte','has','hasIn','includes','indexOf','intersection','invertBy','invoke','invokeMap','isEqual','isMatch','join','keyBy','lastIndexOf','lt','lte','map','mapKeys','mapValues','matchesProperty','maxBy','meanBy','merge','mergeAllWith','minBy','multiply','nth','omit','omitBy','overArgs','pad','padEnd','padStart','parseInt','partial','partialRight','partition','pick','pickBy','propertyOf','pull','pullAll','pullAt','random','range','rangeRight','rearg','reject','remove','repeat','restFrom','result','sampleSize','some','sortBy','sortedIndex','sortedIndexOf','sortedLastIndex','sortedLastIndexOf','sortedUniqBy','split','spreadFrom','startsWith','subtract','sumBy','take','takeRight','takeRightWhile','takeWhile','tap','throttle','thru','times','trimChars','trimCharsEnd','trimCharsStart','truncate','union','uniqBy','uniqWith','unset','unzipWith','without','wrap','xor','zip','zipObject','zipObjectDeep'],'3':['assignInWith','assignWith','clamp','differenceBy','differenceWith','findFrom','findIndexFrom','findLastFrom','findLastIndexFrom','getOr','includesFrom','indexOfFrom','inRange','intersectionBy','intersectionWith','invokeArgs','invokeArgsMap','isEqualWith','isMatchWith','flatMapDepth','lastIndexOfFrom','mergeWith','orderBy','padChars','padCharsEnd','padCharsStart','pullAllBy','pullAllWith','rangeStep','rangeStepRight','reduce','reduceRight','replace','set','slice','sortedIndexBy','sortedLastIndexBy','transform','unionBy','unionWith','update','xorBy','xorWith','zipWith'],'4':['fill','setWith','updateWith']};exports.aryRearg={'2':[1,0],'3':[2,0,1],'4':[3,2,0,1]};exports.iterateeAry={'dropRightWhile':1,'dropWhile':1,'every':1,'filter':1,'find':1,'findFrom':1,'findIndex':1,'findIndexFrom':1,'findKey':1,'findLast':1,'findLastFrom':1,'findLastIndex':1,'findLastIndexFrom':1,'findLastKey':1,'flatMap':1,'flatMapDeep':1,'flatMapDepth':1,'forEach':1,'forEachRight':1,'forIn':1,'forInRight':1,'forOwn':1,'forOwnRight':1,'map':1,'mapKeys':1,'mapValues':1,'partition':1,'reduce':2,'reduceRight':2,'reject':1,'remove':1,'some':1,'takeRightWhile':1,'takeWhile':1,'times':1,'transform':2};exports.iterateeRearg={'mapKeys':[1],'reduceRight':[1,0]};exports.methodRearg={'assignInAllWith':[1,0],'assignInWith':[1,2,0],'assignAllWith':[1,0],'assignWith':[1,2,0],'differenceBy':[1,2,0],'differenceWith':[1,2,0],'getOr':[2,1,0],'intersectionBy':[1,2,0],'intersectionWith':[1,2,0],'isEqualWith':[1,2,0],'isMatchWith':[2,1,0],'mergeAllWith':[1,0],'mergeWith':[1,2,0],'padChars':[2,1,0],'padCharsEnd':[2,1,0],'padCharsStart':[2,1,0],'pullAllBy':[2,1,0],'pullAllWith':[2,1,0],'rangeStep':[1,2,0],'rangeStepRight':[1,2,0],'setWith':[3,1,2,0],'sortedIndexBy':[2,1,0],'sortedLastIndexBy':[2,1,0],'unionBy':[1,2,0],'unionWith':[1,2,0],'updateWith':[3,1,2,0],'xorBy':[1,2,0],'xorWith':[1,2,0],'zipWith':[1,2,0]};exports.methodSpread={'assignAll':{'start':0},'assignAllWith':{'start':0},'assignInAll':{'start':0},'assignInAllWith':{'start':0},'defaultsAll':{'start':0},'defaultsDeepAll':{'start':0},'invokeArgs':{'start':2},'invokeArgsMap':{'start':2},'mergeAll':{'start':0},'mergeAllWith':{'start':0},'partial':{'start':1},'partialRight':{'start':1},'without':{'start':1},'zipAll':{'start':0}};exports.mutate={'array':{'fill':true,'pull':true,'pullAll':true,'pullAllBy':true,'pullAllWith':true,'pullAt':true,'remove':true,'reverse':true},'object':{'assign':true,'assignAll':true,'assignAllWith':true,'assignIn':true,'assignInAll':true,'assignInAllWith':true,'assignInWith':true,'assignWith':true,'defaults':true,'defaultsAll':true,'defaultsDeep':true,'defaultsDeepAll':true,'merge':true,'mergeAll':true,'mergeAllWith':true,'mergeWith':true},'set':{'set':true,'setWith':true,'unset':true,'update':true,'updateWith':true}};exports.realToAlias=function(){var hasOwnProperty=Object.prototype.hasOwnProperty,object=exports.aliasToReal,result={};for(var key in object){var value=object[key];if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}}return result;}();exports.remap={'assignAll':'assign','assignAllWith':'assignWith','assignInAll':'assignIn','assignInAllWith':'assignInWith','curryN':'curry','curryRightN':'curryRight','defaultsAll':'defaults','defaultsDeepAll':'defaultsDeep','findFrom':'find','findIndexFrom':'findIndex','findLastFrom':'findLast','findLastIndexFrom':'findLastIndex','getOr':'get','includesFrom':'includes','indexOfFrom':'indexOf','invokeArgs':'invoke','invokeArgsMap':'invokeMap','lastIndexOfFrom':'lastIndexOf','mergeAll':'merge','mergeAllWith':'mergeWith','padChars':'pad','padCharsEnd':'padEnd','padCharsStart':'padStart','propertyOf':'get','rangeStep':'range','rangeStepRight':'rangeRight','restFrom':'rest','spreadFrom':'spread','trimChars':'trim','trimCharsEnd':'trimEnd','trimCharsStart':'trimStart','zipAll':'zip'};exports.skipFixed={'castArray':true,'flow':true,'flowRight':true,'iteratee':true,'mixin':true,'rearg':true,'runInContext':true};exports.skipRearg={'add':true,'assign':true,'assignIn':true,'bind':true,'bindKey':true,'concat':true,'difference':true,'divide':true,'eq':true,'gt':true,'gte':true,'isEqual':true,'lt':true,'lte':true,'matchesProperty':true,'merge':true,'multiply':true,'overArgs':true,'partial':true,'partialRight':true,'propertyOf':true,'random':true,'range':true,'rangeRight':true,'subtract':true,'zip':true,'zipObject':true,'zipObjectDeep':true};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={'ary':__webpack_require__(184),'assign':__webpack_require__(185),'clone':__webpack_require__(186),'curry':__webpack_require__(187),'forEach':__webpack_require__(108),'isArray':__webpack_require__(5),'isError':__webpack_require__(188),'isFunction':__webpack_require__(67),'isWeakMap':__webpack_require__(190),'iteratee':__webpack_require__(191),'keys':__webpack_require__(115),'rearg':__webpack_require__(192),'toInteger':__webpack_require__(32),'toPath':__webpack_require__(193)};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(41);var WRAP_ARY_FLAG=128;function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}module.exports=ary;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject=__webpack_require__(110),keys=__webpack_require__(65);function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}module.exports=baseAssign;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(48);var CLONE_SYMBOLS_FLAG=4;function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}module.exports=clone;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(41);var WRAP_CURRY_FLAG=8;function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}curry.placeholder={};module.exports=curry;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(68),isObjectLike=__webpack_require__(34),isPlainObject=__webpack_require__(189);var domExcTag='[object DOMException]',errorTag='[object Error]';function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}module.exports=isError;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(68),getPrototype=__webpack_require__(109),isObjectLike=__webpack_require__(34);var objectTag='[object Object]';var funcProto=Function.prototype,objectProto=Object.prototype;var funcToString=funcProto.toString;var hasOwnProperty=objectProto.hasOwnProperty;var objectCtorString=funcToString.call(Object);function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}module.exports=isPlainObject;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var getTag=__webpack_require__(73),isObjectLike=__webpack_require__(34);var weakMapTag='[object WeakMap]';function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}module.exports=isWeakMap;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(48),baseIteratee=__webpack_require__(4);var CLONE_DEEP_FLAG=1;function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}module.exports=iteratee;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(41),flatRest=__webpack_require__(72);var WRAP_REARG_FLAG=256;var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});module.exports=rearg;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(16),copyArray=__webpack_require__(60),isArray=__webpack_require__(5),isSymbol=__webpack_require__(44),stringToPath=__webpack_require__(107),toKey=__webpack_require__(25),toString=__webpack_require__(61);function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}module.exports=toPath;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var createFlow=__webpack_require__(195);var flow=createFlow();module.exports=flow;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var LodashWrapper=__webpack_require__(196),flatRest=__webpack_require__(72),getData=__webpack_require__(105),getFuncName=__webpack_require__(197),isArray=__webpack_require__(5),isLaziable=__webpack_require__(100);var FUNC_ERROR_TEXT='Expected a function';var WRAP_CURRY_FLAG=8,WRAP_PARTIAL_FLAG=32,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256;function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}module.exports=createFlow;

/***/ }),
/* 196 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 197 */
/***/ (function(module, exports) {

function stubString(){return'';}module.exports=stubString;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),arrayMap=__webpack_require__(16),unzip=__webpack_require__(116);function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}module.exports=unzipWith;

/***/ }),
/* 199 */
/***/ (function(module, exports) {

function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

/***/ }),
/* 200 */
/***/ (function(module, exports) {

function baseProperty(key){return function(object){return object==null?undefined:object[key];};}module.exports=baseProperty;

/***/ }),
/* 201 */
/***/ (function(module, exports) {

function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}module.exports=baseTimes;

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports=function(module){if(!module.webpackPolyfill){module.deprecate=function(){};module.paths=[];if(!module.children)module.children=[];Object.defineProperty(module,"loaded",{enumerable:true,get:function(){return module.l;}});Object.defineProperty(module,"id",{enumerable:true,get:function(){return module.i;}});module.webpackPolyfill=1;}return module;};

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 204 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports={'cap':false,'curry':false,'fixed':false,'immutable':false,'rearg':false};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var n={name:"de",weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),months:"Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan_Feb_März_Apr_Mai_Juni_Juli_Aug_Sept_Okt_Nov_Dez".split("_"),ordinal:function(e){return e+".";},weekStart:1,formats:{LTS:"HH:mm:ss",LT:"HH:mm",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},relativeTime:{future:"in %s",past:"vor %s",s:"wenigen Sekunden",m:"einer Minute",mm:"%d Minuten",h:"einer Stunde",hh:"%d Stunden",d:"einem Tag",dd:"%d Tagen",M:"einem Monat",MM:"%d Monaten",y:"einem Jahr",yy:"%d Jahren"}};return e.locale(n,null,!0),n;});

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,_){ true?module.exports=_(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var _={name:"el",weekdays:"Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),months:"Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),monthsShort:"Ιαν_Φεβ_Μαρ_Απρ_Μαι_Ιουν_Ιουλ_Αυγ_Σεπτ_Οκτ_Νοε_Δεκ".split("_"),ordinal:function(e){return e;},weekStart:1,relativeTime:{future:"σε %s",past:"πριν %s",s:"μερικά δευτερόλεπτα",m:"ένα λεπτό",mm:"%d λεπτά",h:"μία ώρα",hh:"%d ώρες",d:"μία μέρα",dd:"%d μέρες",M:"ένα μήνα",MM:"%d μήνες",y:"ένα χρόνο",yy:"%d χρόνια"}};return e.locale(_,null,!0),_;});

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,s){ true?module.exports=s(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var s={name:"es",monthsShort:"ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),weekdays:"domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),weekdaysShort:"dom._lun._mar._mié._jue._vie._sáb.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_sá".split("_"),months:"Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"),weekStart:1,formats:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un día",dd:"%d días",M:"un mes",MM:"%d meses",y:"un año",yy:"%d años"},ordinal:function(e){return e+"º";}};return e.locale(s,null,!0),s;});

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

!function(_,e){ true?module.exports=e(__webpack_require__(9)):undefined;}(this,function(_){"use strict";_=_&&_.hasOwnProperty("default")?_.default:_;var e={name:"he",weekdays:"ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),weekdaysMin:"א׳_ב׳_ג׳_ד׳_ה׳_ו_ש׳".split("_"),months:"ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),monthsShort:"ינו_פבר_מרץ_אפר_מאי_יונ_יול_אוג_ספט_אוק_נוב_דצמ".split("_"),relativeTime:{future:"בעוד %s",past:"לפני %s",s:"כמה שניות",m:"דקה",mm:"%d דקות",h:"שעה",hh:"%d שעות",d:"יום",dd:"%d ימים",M:"חודש",MM:"%d חודשים",y:"שנה",yy:"%d שנים"},ordinal:function(_){return _;},format:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [ב]MMMM YYYY",LLL:"D [ב]MMMM YYYY HH:mm",LLLL:"dddd, D [ב]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"}};return _.locale(e,null,!0),e;});

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var o={name:"it",weekdays:"domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),weekStart:1,monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"tra %s",past:"da %s",s:"qualche secondo",m:"un minuto",mm:"%d minuti",h:"un' ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},ordinal:function(e){return e+"º";}};return e.locale(o,null,!0),o;});

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var a={name:"nl",weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),ordinal:function(e){return e+".";},weekStart:1,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",m:"een minuut",mm:"%d minuten",h:"een uur",hh:"%d uur",d:"een dag",dd:"%d dagen",M:"een maand",MM:"%d maanden",y:"een jaar",yy:"%d jaar"}};return e.locale(a,null,!0),a;});

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,i){ true?module.exports=i(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var i={name:"pl",weekdays:"Niedziela_Poniedziałek_Wtorek_Środa_Czwartek_Piątek_Sobota".split("_"),weekdaysShort:"Ndz_Pon_Wt_Śr_Czw_Pt_Sob".split("_"),weekdaysMin:"Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),months:"Styczeń_Luty_Marzec_Kwiecień_Maj_Czerwiec_Lipiec_Sierpień_Wrzesień_Październik_Listopad_Grudzień".split("_"),ordinal:function(e){return e+".";},weekStart:1,relativeTime:{future:"za %s",past:"po %s",s:"kilka sekund",m:"minuta",mm:"%d minut",h:"godzina",hh:"%d godzin",d:"tydzień",dd:"%d tygodni",M:"miesiąc",MM:"%d miesięcy",y:"rok",yy:"%d lat"}};return e.locale(i,null,!0),i;});

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var o={name:"pt-br",weekdays:"Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),months:"Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),ordinal:function(e){return e+"º";},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [às] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [às] HH:mm"},relativeTime:{future:"em %s",past:"há %s",s:"poucos segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"}};return e.locale(o,null,!0),o;});

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var a={name:"pt",weekdays:"Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sab".split("_"),months:"Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),ordinal:function(e){return e+"º";},weekStart:1,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [às] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [às] HH:mm"},relativeTime:{future:"em %s",past:"há %s",s:"alguns segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"}};return e.locale(a,null,!0),a;});

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,r){ true?module.exports=r():undefined;}(this,function(){"use strict";return function(e,r,t){var n=r.prototype;t.en.relativeTime={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};var o=function(e,r,n,o){for(var d,i,a=n.$locale().relativeTime,u=[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],f=u.length,s=0;s<f;s+=1){var l=u[s];l.d&&(d=o?t(e).diff(n,l.d,!0):n.diff(e,l.d,!0));var m=Math.ceil(Math.abs(d));if(m<=l.r||!l.r){i=a[l.l].replace("%d",m);break;}}return r?i:(d>0?a.future:a.past).replace("%s",i);};n.to=function(e,r){return o(e,r,this,!0);},n.from=function(e,r){return o(e,r,this);},n.toNow=function(e){return this.to(t(),e);},n.fromNow=function(e){return this.from(t(),e);};};});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

!function(Y,t){ true?module.exports=t():undefined;}(this,function(){"use strict";return function(Y,t,e){var M=t.prototype,o=M.format,m={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A",l:"M/D/YYYY",ll:"MMM D, YYYY",lll:"MMM D, YYYY h:mm A",llll:"ddd, MMM D, YYYY h:mm A"};e.en.formats=m,M.format=function(Y){var t=this.$locale().formats||{},e=(Y||"YYYY-MM-DDTHH:mm:ssZ").replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(Y,e,M){return e||t[M]||m[M];});return o.call(this,e);};};});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(16),baseIteratee=__webpack_require__(4),baseMap=__webpack_require__(218),baseSortBy=__webpack_require__(219),baseUnary=__webpack_require__(40),compareMultiple=__webpack_require__(220),identity=__webpack_require__(93);function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(baseIteratee));var result=baseMap(collection,function(value){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}module.exports=baseOrderBy;

/***/ }),
/* 218 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 219 */
/***/ (function(module, exports) {

function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}module.exports=baseSortBy;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending=__webpack_require__(221);function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}return object.index-other.index;}module.exports=compareMultiple;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol=__webpack_require__(44);function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}module.exports=compareAscending;

/***/ }),
/* 222 */
/***/ (function(module, exports) {

!function($,window,pluginName,undefined){var containerDefaults={drag:true,drop:true,exclude:"",nested:true,vertical:true},groupDefaults={afterMove:function(){},containerPath:"",containerSelector:"ol, ul",distance:0,delay:0,handle:"",itemPath:"",itemSelector:"li",bodyClass:"dragging",draggedClass:"dragged",isValidTarget:function(){return true;},onCancel:function(){},onDrag:function($item,position){$item.css(position);},onDragStart:function($item,container){$item.css({height:$item.outerHeight(),width:$item.outerWidth()});$item.addClass(container.group.options.draggedClass);$("body").addClass(container.group.options.bodyClass);},onDrop:function($item,container){$item.removeClass(container.group.options.draggedClass).removeAttr("style");$("body").removeClass(container.group.options.bodyClass);},onMousedown:function($item,_super,event){if(!event.target.nodeName.match(/^(input|select|textarea)$/i)){event.preventDefault();return true;}},placeholderClass:"placeholder",placeholder:'<li class="placeholder"></li>',pullPlaceholder:true,serialize:function($parent,$children,parentIsContainer){var result=$.extend({},$parent.data());if(parentIsContainer)return[$children];else if($children[0]){result.children=$children;}delete result.subContainers;delete result.sortable;return result;},tolerance:0},containerGroups={},groupCounter=0,emptyBox={left:0,top:0,bottom:0,right:0},eventNames={start:"touchstart.sortable mousedown.sortable",drop:"touchend.sortable touchcancel.sortable mouseup.sortable",drag:"touchmove.sortable mousemove.sortable",scroll:"scroll.sortable"},subContainerKey="subContainers";function d(a,b){var x=Math.max(0,a[0]-b[0],b[0]-a[1]),y=Math.max(0,a[2]-b[1],b[1]-a[3]);return x+y;}function setDimensions(array,dimensions,tolerance,useOffset){var i=array.length,offsetMethod=useOffset?"offset":"position";tolerance=tolerance||0;while(i--){var el=array[i].el?array[i].el:$(array[i]),pos=el[offsetMethod]();pos.left+=parseInt(el.css('margin-left'),10);pos.top+=parseInt(el.css('margin-top'),10);dimensions[i]=[pos.left-tolerance,pos.left+el.outerWidth()+tolerance,pos.top-tolerance,pos.top+el.outerHeight()+tolerance];}}function getRelativePosition(pointer,element){var offset=element.offset();return{left:pointer.left-offset.left,top:pointer.top-offset.top};}function sortByDistanceDesc(dimensions,pointer,lastPointer){pointer=[pointer.left,pointer.top];lastPointer=lastPointer&&[lastPointer.left,lastPointer.top];var dim,i=dimensions.length,distances=[];while(i--){dim=dimensions[i];distances[i]=[i,d(dim,pointer),lastPointer&&d(dim,lastPointer)];}distances=distances.sort(function(a,b){return b[1]-a[1]||b[2]-a[2]||b[0]-a[0];});return distances;}function ContainerGroup(options){this.options=$.extend({},groupDefaults,options);this.containers=[];if(!this.options.rootGroup){this.scrollProxy=$.proxy(this.scroll,this);this.dragProxy=$.proxy(this.drag,this);this.dropProxy=$.proxy(this.drop,this);this.placeholder=$(this.options.placeholder);if(!options.isValidTarget)this.options.isValidTarget=undefined;}}ContainerGroup.get=function(options){if(!containerGroups[options.group]){if(options.group===undefined)options.group=groupCounter++;containerGroups[options.group]=new ContainerGroup(options);}return containerGroups[options.group];};ContainerGroup.prototype={dragInit:function(e,itemContainer){this.$document=$(itemContainer.el[0].ownerDocument);var closestItem=$(e.target).closest(this.options.itemSelector);if(closestItem.length){this.item=closestItem;this.itemContainer=itemContainer;if(this.item.is(this.options.exclude)||!this.options.onMousedown(this.item,groupDefaults.onMousedown,e)){return;}this.setPointer(e);this.toggleListeners('on');this.setupDelayTimer();this.dragInitDone=true;}},drag:function(e){if(!this.dragging){if(!this.distanceMet(e)||!this.delayMet)return;this.options.onDragStart(this.item,this.itemContainer,groupDefaults.onDragStart,e);this.item.before(this.placeholder);this.dragging=true;}this.setPointer(e);this.options.onDrag(this.item,getRelativePosition(this.pointer,this.item.offsetParent()),groupDefaults.onDrag,e);var p=this.getPointer(e),box=this.sameResultBox,t=this.options.tolerance;if(!box||box.top-t>p.top||box.bottom+t<p.top||box.left-t>p.left||box.right+t<p.left)if(!this.searchValidTarget()){this.placeholder.detach();this.lastAppendedItem=undefined;}},drop:function(e){this.toggleListeners('off');this.dragInitDone=false;if(this.dragging){if(this.placeholder.closest("html")[0]){this.placeholder.before(this.item).detach();}else{this.options.onCancel(this.item,this.itemContainer,groupDefaults.onCancel,e);}this.options.onDrop(this.item,this.getContainer(this.item),groupDefaults.onDrop,e);this.clearDimensions();this.clearOffsetParent();this.lastAppendedItem=this.sameResultBox=undefined;this.dragging=false;}},searchValidTarget:function(pointer,lastPointer){if(!pointer){pointer=this.relativePointer||this.pointer;lastPointer=this.lastRelativePointer||this.lastPointer;}var distances=sortByDistanceDesc(this.getContainerDimensions(),pointer,lastPointer),i=distances.length;while(i--){var index=distances[i][0],distance=distances[i][1];if(!distance||this.options.pullPlaceholder){var container=this.containers[index];if(!container.disabled){if(!this.$getOffsetParent()){var offsetParent=container.getItemOffsetParent();pointer=getRelativePosition(pointer,offsetParent);lastPointer=getRelativePosition(lastPointer,offsetParent);}if(container.searchValidTarget(pointer,lastPointer))return true;}}}if(this.sameResultBox)this.sameResultBox=undefined;},movePlaceholder:function(container,item,method,sameResultBox){var lastAppendedItem=this.lastAppendedItem;if(!sameResultBox&&lastAppendedItem&&lastAppendedItem[0]===item[0])return;item[method](this.placeholder);this.lastAppendedItem=item;this.sameResultBox=sameResultBox;this.options.afterMove(this.placeholder,container,item);},getContainerDimensions:function(){if(!this.containerDimensions)setDimensions(this.containers,this.containerDimensions=[],this.options.tolerance,!this.$getOffsetParent());return this.containerDimensions;},getContainer:function(element){return element.closest(this.options.containerSelector).data(pluginName);},$getOffsetParent:function(){if(this.offsetParent===undefined){var i=this.containers.length-1,offsetParent=this.containers[i].getItemOffsetParent();if(!this.options.rootGroup){while(i--){if(offsetParent[0]!=this.containers[i].getItemOffsetParent()[0]){offsetParent=false;break;}}}this.offsetParent=offsetParent;}return this.offsetParent;},setPointer:function(e){var pointer=this.getPointer(e);if(this.$getOffsetParent()){var relativePointer=getRelativePosition(pointer,this.$getOffsetParent());this.lastRelativePointer=this.relativePointer;this.relativePointer=relativePointer;}this.lastPointer=this.pointer;this.pointer=pointer;},distanceMet:function(e){var currentPointer=this.getPointer(e);return Math.max(Math.abs(this.pointer.left-currentPointer.left),Math.abs(this.pointer.top-currentPointer.top))>=this.options.distance;},getPointer:function(e){var o=e.originalEvent||e.originalEvent.touches&&e.originalEvent.touches[0];return{left:e.pageX||o.pageX,top:e.pageY||o.pageY};},setupDelayTimer:function(){var that=this;this.delayMet=!this.options.delay;if(!this.delayMet){clearTimeout(this._mouseDelayTimer);this._mouseDelayTimer=setTimeout(function(){that.delayMet=true;},this.options.delay);}},scroll:function(){this.clearDimensions();this.clearOffsetParent();},toggleListeners:function(method){var that=this;$.each(['drag','drop','scroll'],function(i,event){that.$document[method](eventNames[event],that[event+'Proxy']);});},clearOffsetParent:function(){this.offsetParent=undefined;},clearDimensions:function(){this.traverse(function(object){object._clearDimensions();});},traverse:function(callback){callback(this);var i=this.containers.length;while(i--){this.containers[i].traverse(callback);}},_clearDimensions:function(){this.containerDimensions=undefined;},_destroy:function(){containerGroups[this.options.group]=undefined;}};function Container(element,options){this.el=element;this.options=$.extend({},containerDefaults,options);this.group=ContainerGroup.get(this.options);this.rootGroup=this.options.rootGroup||this.group;this.handle=this.rootGroup.options.handle||this.rootGroup.options.itemSelector;var itemPath=this.rootGroup.options.itemPath;this.target=itemPath?this.el.find(itemPath):this.el;this.target.on(eventNames.start,this.handle,$.proxy(this.dragInit,this));if(this.options.drop)this.group.containers.push(this);}Container.prototype={dragInit:function(e){var rootGroup=this.rootGroup;if(!this.disabled&&!rootGroup.dragInitDone&&this.options.drag&&this.isValidDrag(e)){rootGroup.dragInit(e,this);}},isValidDrag:function(e){return e.which==1||e.type=="touchstart"&&e.originalEvent.touches.length==1;},searchValidTarget:function(pointer,lastPointer){var distances=sortByDistanceDesc(this.getItemDimensions(),pointer,lastPointer),i=distances.length,rootGroup=this.rootGroup,validTarget=!rootGroup.options.isValidTarget||rootGroup.options.isValidTarget(rootGroup.item,this);if(!i&&validTarget){rootGroup.movePlaceholder(this,this.target,"append");return true;}else while(i--){var index=distances[i][0],distance=distances[i][1];if(!distance&&this.hasChildGroup(index)){var found=this.getContainerGroup(index).searchValidTarget(pointer,lastPointer);if(found)return true;}else if(validTarget){this.movePlaceholder(index,pointer);return true;}}},movePlaceholder:function(index,pointer){var item=$(this.items[index]),dim=this.itemDimensions[index],method="after",width=item.outerWidth(),height=item.outerHeight(),offset=item.offset(),sameResultBox={left:offset.left,right:offset.left+width,top:offset.top,bottom:offset.top+height};if(this.options.vertical){var yCenter=(dim[2]+dim[3])/2,inUpperHalf=pointer.top<=yCenter;if(inUpperHalf){method="before";sameResultBox.bottom-=height/2;}else sameResultBox.top+=height/2;}else{var xCenter=(dim[0]+dim[1])/2,inLeftHalf=pointer.left<=xCenter;if(inLeftHalf){method="before";sameResultBox.right-=width/2;}else sameResultBox.left+=width/2;}if(this.hasChildGroup(index))sameResultBox=emptyBox;this.rootGroup.movePlaceholder(this,item,method,sameResultBox);},getItemDimensions:function(){if(!this.itemDimensions){this.items=this.$getChildren(this.el,"item").filter(":not(."+this.group.options.placeholderClass+", ."+this.group.options.draggedClass+")").get();setDimensions(this.items,this.itemDimensions=[],this.options.tolerance);}return this.itemDimensions;},getItemOffsetParent:function(){var offsetParent,el=this.el;if(el.css("position")==="relative"||el.css("position")==="absolute"||el.css("position")==="fixed")offsetParent=el;else offsetParent=el.offsetParent();return offsetParent;},hasChildGroup:function(index){return this.options.nested&&this.getContainerGroup(index);},getContainerGroup:function(index){var childGroup=$.data(this.items[index],subContainerKey);if(childGroup===undefined){var childContainers=this.$getChildren(this.items[index],"container");childGroup=false;if(childContainers[0]){var options=$.extend({},this.options,{rootGroup:this.rootGroup,group:groupCounter++});childGroup=childContainers[pluginName](options).data(pluginName).group;}$.data(this.items[index],subContainerKey,childGroup);}return childGroup;},$getChildren:function(parent,type){var options=this.rootGroup.options,path=options[type+"Path"],selector=options[type+"Selector"];parent=$(parent);if(path)parent=parent.find(path);return parent.children(selector);},_serialize:function(parent,isContainer){var that=this,childType=isContainer?"item":"container",children=this.$getChildren(parent,childType).not(this.options.exclude).map(function(){return that._serialize($(this),!isContainer);}).get();return this.rootGroup.options.serialize(parent,children,isContainer);},traverse:function(callback){$.each(this.items||[],function(){var group=$.data(this,subContainerKey);if(group)group.traverse(callback);});callback(this);},_clearDimensions:function(){this.itemDimensions=undefined;},_destroy:function(){var that=this;this.target.off(eventNames.start,this.handle);this.el.removeData(pluginName);if(this.options.drop)this.group.containers=$.grep(this.group.containers,function(val){return val!=that;});$.each(this.items||[],function(){$.removeData(this,subContainerKey);});}};var API={enable:function(){this.traverse(function(object){object.disabled=false;});},disable:function(){this.traverse(function(object){object.disabled=true;});},serialize:function(){return this._serialize(this.el,true);},refresh:function(){this.traverse(function(object){object._clearDimensions();});},destroy:function(){this.traverse(function(object){object._destroy();});}};$.extend(Container.prototype,API);$.fn[pluginName]=function(methodOrOptions){var args=Array.prototype.slice.call(arguments,1);return this.map(function(){var $t=$(this),object=$t.data(pluginName);if(object&&API[methodOrOptions])return API[methodOrOptions].apply(object,args)||this;else if(!object&&(methodOrOptions===undefined||typeof methodOrOptions==="object"))$t.data(pluginName,new Container($t,methodOrOptions));return this;});};}(jQuery,window,'sortable');

/***/ }),
/* 223 */
/***/ (function(module, exports) {

!function(a){function b(a){return String(null===a||void 0===a?"":a);}function c(a){return b(a).replace(i,function(a){return h[a];});}var d={method:"GET",queryParam:"q",searchDelay:300,minChars:1,propertyToSearch:"name",jsonContainer:null,contentType:"json",excludeCurrent:!1,excludeCurrentParameter:"x",prePopulate:null,processPrePopulate:!1,hintText:"Type in a search term",noResultsText:"No results",searchingText:"Searching...",deleteText:"&#215;",animateDropdown:!0,placeholder:null,theme:null,zindex:999,resultsLimit:null,enableHTML:!1,resultsFormatter:function(a){var b=a[this.propertyToSearch];return"<li>"+(this.enableHTML?b:c(b))+"</li>";},tokenFormatter:function(a){var b=a[this.propertyToSearch];return"<li><p>"+(this.enableHTML?b:c(b))+"</p></li>";},tokenLimit:null,tokenDelimiter:",",preventDuplicates:!1,tokenValue:"id",allowFreeTagging:!1,allowTabOut:!1,autoSelectFirstResult:!1,onResult:null,onCachedResult:null,onAdd:null,onFreeTaggingAdd:null,onDelete:null,onReady:null,idPrefix:"token-input-",disabled:!1},e={tokenList:"token-input-list",token:"token-input-token",tokenReadOnly:"token-input-token-readonly",tokenDelete:"token-input-delete-token",selectedToken:"token-input-selected-token",highlightedToken:"token-input-highlighted-token",dropdown:"token-input-dropdown",dropdownItem:"token-input-dropdown-item",dropdownItem2:"token-input-dropdown-item2",selectedDropdownItem:"token-input-selected-dropdown-item",inputToken:"token-input-input-token",focused:"token-input-focused",disabled:"token-input-disabled"},f={BEFORE:0,AFTER:1,END:2},g={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,NUMPAD_ENTER:108,COMMA:188},h={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"},i=/[&<>"'\/]/g,j={init:function(b,c){var e=a.extend({},d,c||{});return this.each(function(){a(this).data("settings",e),a(this).data("tokenInputObject",new a.TokenList(this,b,e));});},clear:function(){return this.data("tokenInputObject").clear(),this;},add:function(a){return this.data("tokenInputObject").add(a),this;},remove:function(a){return this.data("tokenInputObject").remove(a),this;},get:function(){return this.data("tokenInputObject").getTokens();},toggleDisabled:function(a){return this.data("tokenInputObject").toggleDisabled(a),this;},setOptions:function(b){return a(this).data("settings",a.extend({},a(this).data("settings"),b||{})),this;},destroy:function(){if(this.data("tokenInputObject")){this.data("tokenInputObject").clear();var a=this,b=this.parent();return b.empty(),a.show(),b.append(a),a;}}};a.fn.tokenInput=function(a){return j[a]?j[a].apply(this,Array.prototype.slice.call(arguments,1)):j.init.apply(this,arguments);},a.TokenList=function(b,d,h){function i(d){return a(b).data("settings").enableHTML?d:c(d);}function j(c){a(b).data("settings").disabled="boolean"==typeof c?c:!a(b).data("settings").disabled,P.attr("disabled",a(b).data("settings").disabled),U.toggleClass(a(b).data("settings").classes.disabled,a(b).data("settings").disabled),R&&q(a(R),f.END),Q.attr("disabled",a(b).data("settings").disabled);}function k(){return null!==a(b).data("settings").tokenLimit&&N>=a(b).data("settings").tokenLimit?(P.hide(),void u()):void 0;}function l(){if(L!==(L=P.val())){var a=U.width()-P.offset().left-U.offset().left;X.html(c(L)||c(h.placeholder)),P.width(Math.min(U.width(),Math.max(a,X.width()+30)));}}function m(){var c=a.trim(P.val()),d=c.split(a(b).data("settings").tokenDelimiter);a.each(d,function(c,d){if(d){a.isFunction(a(b).data("settings").onFreeTaggingAdd)&&(d=a(b).data("settings").onFreeTaggingAdd.call(Q,d));var e={};e[a(b).data("settings").tokenValue]=e[a(b).data("settings").propertyToSearch]=d,o(e);}});}function n(c){var d=a(a(b).data("settings").tokenFormatter(c)),e=c.readonly===!0?!0:!1;e&&d.addClass(a(b).data("settings").classes.tokenReadOnly),d.addClass(a(b).data("settings").classes.token).insertBefore(V),e||a("<span>"+a(b).data("settings").deleteText+"</span>").addClass(a(b).data("settings").classes.tokenDelete).appendTo(d).click(function(){return a(b).data("settings").disabled?void 0:(s(a(this).parent()),Q.change(),!1);});return a.data(d.get(0),"tokeninput",c),M=M.slice(0,S).concat([c]).concat(M.slice(S)),S++,t(M,Q),N+=1,null!==a(b).data("settings").tokenLimit&&N>=a(b).data("settings").tokenLimit&&(P.hide(),u()),d;}function o(c){var d=a(b).data("settings").onAdd;if(N>0&&a(b).data("settings").preventDuplicates){var e=null;if(U.children().each(function(){var b=a(this),d=a.data(b.get(0),"tokeninput");return d&&d[h.tokenValue]===c[h.tokenValue]?(e=b,!1):void 0;}),e)return p(e),V.insertAfter(e),void I(P);}P.width(1),(null==a(b).data("settings").tokenLimit||N<a(b).data("settings").tokenLimit)&&(n(c),P.attr("placeholder",null),k()),P.val(""),u(),a.isFunction(d)&&d.call(Q,c);}function p(c){a(b).data("settings").disabled||(c.addClass(a(b).data("settings").classes.selectedToken),R=c.get(0),P.val(""),u());}function q(c,d){c.removeClass(a(b).data("settings").classes.selectedToken),R=null,d===f.BEFORE?(V.insertBefore(c),S--):d===f.AFTER?(V.insertAfter(c),S++):(V.appendTo(U),S=N),I(P);}function r(b){var c=R;R&&q(a(R),f.END),c===b.get(0)?q(b,f.END):p(b);}function s(c){var d=a.data(c.get(0),"tokeninput"),e=a(b).data("settings").onDelete,f=c.prevAll().length;f>S&&f--,c.remove(),R=null,I(P),M=M.slice(0,f).concat(M.slice(f+1)),0==M.length&&P.attr("placeholder",h.placeholder),S>f&&S--,t(M,Q),N-=1,null!==a(b).data("settings").tokenLimit&&(P.show().val(""),I(P)),a.isFunction(e)&&e.call(Q,d);}function t(c,d){var e=a.map(c,function(c){return"function"==typeof a(b).data("settings").tokenValue?a(b).data("settings").tokenValue.call(this,c):c[a(b).data("settings").tokenValue];});d.val(e.join(a(b).data("settings").tokenDelimiter));}function u(){W.hide().empty(),T=null;}function v(){W.css({position:"absolute",top:U.offset().top+U.outerHeight(!0),left:U.offset().left,width:U.width(),"z-index":a(b).data("settings").zindex}).show();}function w(){a(b).data("settings").searchingText&&(W.html("<p>"+i(a(b).data("settings").searchingText)+"</p>"),v());}function x(){a(b).data("settings").hintText&&(W.html("<p>"+i(a(b).data("settings").hintText)+"</p>"),v());}function y(a){return a.replace(Z,"\\$&");}function z(a,b){return a.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+y(b)+")(?![^<>]*>)(?![^&;]+;)","gi"),function(a,b){return"<b>"+i(b)+"</b>";});}function A(a,b,c){return a.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+y(b)+")(?![^<>]*>)(?![^&;]+;)","g"),z(b,c));}function B(c){if(a(b).data("settings").excludeCurrent){var d=a(b).data("tokenInputObject").getTokens(),e=[];d.length&&(a.each(c,function(c,f){var g=!0;a.each(d,function(c,d){return f[a(b).data("settings").propertyToSearch]==d[a(b).data("settings").propertyToSearch]?(g=!1,!1):void 0;}),g&&e.push(f);}),c=e);}return c;}function C(c,d){if(d=B(d),d&&d.length){W.empty();var e=a("<ul/>").appendTo(W).mouseover(function(b){D(a(b.target).closest("li"));}).mousedown(function(b){return o(a(b.target).closest("li").data("tokeninput")),Q.change(),!1;}).hide();a(b).data("settings").resultsLimit&&d.length>a(b).data("settings").resultsLimit&&(d=d.slice(0,a(b).data("settings").resultsLimit)),a.each(d,function(d,f){var g=a(b).data("settings").resultsFormatter(f);g=A(g,f[a(b).data("settings").propertyToSearch],c),g=a(g).appendTo(e),g.addClass(d%2?a(b).data("settings").classes.dropdownItem:a(b).data("settings").classes.dropdownItem2),0===d&&a(b).data("settings").autoSelectFirstResult&&D(g),a.data(g.get(0),"tokeninput",f);}),v(),a(b).data("settings").animateDropdown?e.slideDown("fast"):e.show();}else a(b).data("settings").noResultsText&&(W.html("<p>"+i(a(b).data("settings").noResultsText)+"</p>"),v());}function D(c){c&&(T&&E(a(T)),c.addClass(a(b).data("settings").classes.selectedDropdownItem),T=c.get(0));}function E(c){c.removeClass(a(b).data("settings").classes.selectedDropdownItem),T=null;}function F(){var c=P.val();c&&c.length&&(R&&q(a(R),f.AFTER),c.length>=a(b).data("settings").minChars?(w(),clearTimeout(K),K=setTimeout(function(){G(c);},a(b).data("settings").searchDelay)):u());}function G(c){var d=c+H(),e=O.get(d);if(e)a.isFunction(a(b).data("settings").onCachedResult)&&(e=a(b).data("settings").onCachedResult.call(Q,e)),C(c,e);else if(a(b).data("settings").url){var f=H(),g={};if(g.data={},f.indexOf("?")>-1){var i=f.split("?");g.url=i[0];var j=i[1].split("&");a.each(j,function(a,b){var c=b.split("=");g.data[c[0]]=c[1];});}else g.url=f;if(g.data[a(b).data("settings").queryParam]=c,g.type=a(b).data("settings").method,g.dataType=a(b).data("settings").contentType,a(b).data("settings").crossDomain&&(g.dataType="jsonp"),a(b).data("settings").excludeCurrent){var k=a(b).data("tokenInputObject").getTokens(),l=a.map(k,function(c){return"function"==typeof a(b).data("settings").tokenValue?a(b).data("settings").tokenValue.call(this,c):c[a(b).data("settings").tokenValue];});g.data[a(b).data("settings").excludeCurrentParameter]=l.join(a(b).data("settings").tokenDelimiter);}g.success=function(e){O.add(d,a(b).data("settings").jsonContainer?e[a(b).data("settings").jsonContainer]:e),a.isFunction(a(b).data("settings").onResult)&&(e=a(b).data("settings").onResult.call(Q,e)),P.val()===c&&C(c,a(b).data("settings").jsonContainer?e[a(b).data("settings").jsonContainer]:e);},h.onSend&&h.onSend(g),a.ajax(g);}else if(a(b).data("settings").local_data){var m=a.grep(a(b).data("settings").local_data,function(d){return d[a(b).data("settings").propertyToSearch].toLowerCase().indexOf(c.toLowerCase())>-1;});O.add(d,m),a.isFunction(a(b).data("settings").onResult)&&(m=a(b).data("settings").onResult.call(Q,m)),C(c,m);}}function H(){var c=a(b).data("settings").url;return"function"==typeof a(b).data("settings").url&&(c=a(b).data("settings").url.call(a(b).data("settings"))),c;}function I(a){setTimeout(function(){a.focus();},50);}if("string"==typeof d||"function"==typeof d){a(b).data("settings").url=d;var J=H();void 0===a(b).data("settings").crossDomain&&"string"==typeof J&&(a(b).data("settings").crossDomain=-1===J.indexOf("://")?!1:location.href.split(/\/+/g)[1]!==J.split(/\/+/g)[1]);}else"object"==typeof d&&(a(b).data("settings").local_data=d);a(b).data("settings").classes?a(b).data("settings").classes=a.extend({},e,a(b).data("settings").classes):a(b).data("settings").theme?(a(b).data("settings").classes={},a.each(e,function(c,d){a(b).data("settings").classes[c]=d+"-"+a(b).data("settings").theme;})):a(b).data("settings").classes=e;var K,L,M=[],N=0,O=new a.TokenList.Cache(),P=a('<input type="text" autocomplete="off" autocapitalize="off"/>').css({outline:"none"}).attr("id",a(b).data("settings").idPrefix+b.id).focus(function(){return a(b).data("settings").disabled?!1:((null===a(b).data("settings").tokenLimit||a(b).data("settings").tokenLimit!==N)&&x(),void U.addClass(a(b).data("settings").classes.focused));}).blur(function(){u(),a(b).data("settings").allowFreeTagging&&m(),a(this).val(""),U.removeClass(a(b).data("settings").classes.focused);}).bind("keyup keydown blur update",l).keydown(function(c){var d,e;switch(c.keyCode){case g.LEFT:case g.RIGHT:case g.UP:case g.DOWN:if(0===this.value.length)d=V.prev(),e=V.next(),d.length&&d.get(0)===R||e.length&&e.get(0)===R?c.keyCode===g.LEFT||c.keyCode===g.UP?q(a(R),f.BEFORE):q(a(R),f.AFTER):c.keyCode!==g.LEFT&&c.keyCode!==g.UP||!d.length?c.keyCode!==g.RIGHT&&c.keyCode!==g.DOWN||!e.length||p(a(e.get(0))):p(a(d.get(0)));else{var h=null;c.keyCode===g.DOWN||c.keyCode===g.RIGHT?(h=a(W).find("li").first(),T&&(h=a(T).next())):(h=a(W).find("li").last(),T&&(h=a(T).prev())),D(h);}break;case g.BACKSPACE:if(d=V.prev(),0===this.value.length)return R?(s(a(R)),Q.change()):d.length&&p(a(d.get(0))),!1;1===a(this).val().length?u():setTimeout(function(){F();},5);break;case g.TAB:case g.ENTER:case g.NUMPAD_ENTER:case g.COMMA:if(T)o(a(T).data("tokeninput")),Q.change();else{if(a(b).data("settings").allowFreeTagging){if(a(b).data("settings").allowTabOut&&""===a(this).val())return!0;m();}else if(a(this).val(""),a(b).data("settings").allowTabOut)return!0;c.stopPropagation(),c.preventDefault();}return!1;case g.ESCAPE:return u(),!0;default:String.fromCharCode(c.which)&&setTimeout(function(){F();},5);}});h.placeholder&&P.attr("placeholder",h.placeholder);var Q=a(b).hide().val("").focus(function(){I(P);}).blur(function(){return P.blur(),Q;}),R=null,S=0,T=null,U=a("<ul />").addClass(a(b).data("settings").classes.tokenList).click(function(b){var c=a(b.target).closest("li");c&&c.get(0)&&a.data(c.get(0),"tokeninput")?r(c):(R&&q(a(R),f.END),I(P));}).mouseover(function(c){var d=a(c.target).closest("li");d&&R!==this&&d.addClass(a(b).data("settings").classes.highlightedToken);}).mouseout(function(c){var d=a(c.target).closest("li");d&&R!==this&&d.removeClass(a(b).data("settings").classes.highlightedToken);}).insertBefore(Q),V=a("<li />").addClass(a(b).data("settings").classes.inputToken).appendTo(U).append(P),W=a("<div/>").addClass(a(b).data("settings").classes.dropdown).appendTo("body").hide(),X=a("<tester/>").insertAfter(P).css({position:"absolute",top:-9999,left:-9999,width:"auto",fontSize:P.css("fontSize"),fontFamily:P.css("fontFamily"),fontWeight:P.css("fontWeight"),letterSpacing:P.css("letterSpacing"),whiteSpace:"nowrap"});Q.val("");var Y=a(b).data("settings").prePopulate||Q.data("pre");a(b).data("settings").processPrePopulate&&a.isFunction(a(b).data("settings").onResult)&&(Y=a(b).data("settings").onResult.call(Q,Y)),Y&&Y.length&&a.each(Y,function(a,b){n(b),k(),P.attr("placeholder",null);}),a(b).data("settings").disabled&&j(!0),"function"==typeof a(b).data("settings").onReady&&a(b).data("settings").onReady.call(),this.clear=function(){U.children("li").each(function(){0===a(this).children("input").length&&s(a(this));});},this.add=function(a){o(a);},this.remove=function(b){U.children("li").each(function(){if(0===a(this).children("input").length){var c=a(this).data("tokeninput"),d=!0;for(var e in b)if(b[e]!==c[e]){d=!1;break;}d&&s(a(this));}});},this.getTokens=function(){return M;},this.toggleDisabled=function(a){j(a);},l();var Z=new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]","g");},a.TokenList.Cache=function(b){var c,d,e={},f=0;c=a.extend({max_size:500},b),d=function(){e={},f=0;},this.add=function(a,b){f>c.max_size&&d(),e[a]||(f+=1),e[a]=b;},this.get=function(a){return e[a];};};}(jQuery);

/***/ }),
/* 224 */
/***/ (function(module, exports) {

var guiders = function ($) {
  var guiders = $.guiders = {};
  guiders.version = "2.0.0";
  guiders._defaultSettings = {
    attachTo: null,
    autoFocus: false,
    buttons: [{
      name: "Close"
    }],
    buttonCustomHTML: "",
    classString: null,
    closeOnEscape: false,
    description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    highlight: null,
    isHashable: true,
    maxWidth: null,
    offset: {
      top: null,
      left: null
    },
    onClose: null,
    onHide: null,
    onShow: null,
    overlay: false,
    position: 0,
    shouldSkip: function () {},
    title: "Sample title goes here",
    width: 400,
    xButton: false
  };
  guiders._htmlSkeleton = ["<div class='guider'>", "  <div class='guiders_content'>", "    <h1 class='guiders_title'></h1>", "    <div class='guiders_close'></div>", "    <p class='guiders_description'></p>", "    <div class='guiders_buttons_container'>", "    </div>", "  </div>", "  <div class='guiders_arrow'>", "  </div>", "</div>"].join("");
  guiders._arrowSize = 42;
  guiders._backButtonTitle = "Back";
  guiders._buttonAttributes = {
    "href": "javascript:void(0);"
  };
  guiders._buttonClassName = "guiders_button";
  guiders._buttonClickEvent = "click touch";
  guiders._buttonElement = "<a></a>";
  guiders._closeButtonTitle = "Close";
  guiders._currentGuiderID = null;
  guiders._fixedOrAbsolute = "fixed";
  guiders._guiders = {};
  guiders._lastCreatedGuiderID = null;
  guiders._nextButtonTitle = "Next";
  guiders._offsetNameMapping = {
    "topLeft": 11,
    "top": 12,
    "topRight": 1,
    "rightTop": 2,
    "right": 3,
    "rightBottom": 4,
    "bottomRight": 5,
    "bottom": 6,
    "bottomLeft": 7,
    "leftBottom": 8,
    "left": 9,
    "leftTop": 10
  };
  guiders._windowHeight = 0;
  var ieBrowserMatch = navigator.userAgent.match(/MSIE\s([\d.]+)/);
  guiders._isIE = ieBrowserMatch && ieBrowserMatch.length > 1;
  guiders._ieVersion = ieBrowserMatch && ieBrowserMatch.length > 1 ? Number(ieBrowserMatch[1]) : -1;

  guiders._addButtons = function (myGuider) {
    var guiderButtonsContainer = myGuider.elem.find(".guiders_buttons_container");

    if (myGuider.buttons === null || myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
      return;
    }

    for (var i = myGuider.buttons.length - 1; i >= 0; i--) {
      var thisButton = myGuider.buttons[i];
      var thisButtonElem = $(guiders._buttonElement, $.extend({
        "class": guiders._buttonClassName,
        "html": thisButton.name
      }, guiders._buttonAttributes, thisButton.html || {}));

      if (typeof thisButton.classString !== "undefined" && thisButton.classString !== null) {
        thisButtonElem.addClass(thisButton.classString);
      }

      guiderButtonsContainer.append(thisButtonElem);
      var thisButtonName = thisButton.name.toLowerCase();

      if (thisButton.onclick) {
        thisButtonElem.bind(guiders._buttonClickEvent, thisButton.onclick);
      } else {
        switch (thisButtonName) {
          case guiders._closeButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              guiders.hideAll();

              if (myGuider.onClose) {
                myGuider.onClose(myGuider, false);
              }

              $("body").trigger("guidersClose");
            });
            break;

          case guiders._nextButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.next();
            });
            break;

          case guiders._backButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.prev();
            });
            break;
        }
      }
    }

    if (myGuider.buttonCustomHTML !== "") {
      var myCustomHTML = $(myGuider.buttonCustomHTML);
      myGuider.elem.find(".guiders_buttons_container").append(myCustomHTML);
    }

    if (myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
    }
  };

  guiders._addXButton = function (myGuider) {
    var xButtonContainer = myGuider.elem.find(".guiders_close");
    var xButton = $("<div></div>", {
      "class": "guiders_x_button",
      "role": "button"
    });
    xButtonContainer.append(xButton);
    xButton.click(function () {
      guiders.hideAll();

      if (myGuider.onClose) {
        myGuider.onClose(myGuider, true);
      }

      $("body").trigger("guidersClose");
    });
  };

  guiders._attach = function (myGuider) {
    if (typeof myGuider !== 'object') {
      return;
    }

    var attachTo = $(myGuider.attachTo);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();

    if (myGuider.position === 0 || attachTo.length === 0) {
      var fixedOrAbsolute = "fixed";

      if (guiders._isIE && guiders._ieVersion < 9) {
        fixedOrAbsolute = "absolute";
      }

      myGuider.elem.css("position", fixedOrAbsolute);
      myGuider.elem.css("top", ($(window).height() - myHeight) / 3 + "px");
      myGuider.elem.css("left", ($(window).width() - myWidth) / 2 + "px");
      return;
    }

    var base = attachTo.offset();
    var top = base.top;
    var left = base.left;
    var topMarginOfBody = $("body").outerHeight(true) - $("body").outerHeight(false);
    top -= topMarginOfBody;

    if (guiders._offsetNameMapping[myGuider.position]) {
      myGuider.position = guiders._offsetNameMapping[myGuider.position];
    }

    var attachToHeight = attachTo.innerHeight();
    var attachToWidth = attachTo.innerWidth();
    var bufferOffset = 0.9 * guiders._arrowSize;
    var offset = {
      1: [-bufferOffset - myHeight, attachToWidth - myWidth],
      2: [0, bufferOffset + attachToWidth],
      3: [attachToHeight / 2 - myHeight / 2, bufferOffset + attachToWidth],
      4: [attachToHeight - myHeight, bufferOffset + attachToWidth],
      5: [bufferOffset + attachToHeight, attachToWidth - myWidth],
      6: [bufferOffset + attachToHeight, attachToWidth / 2 - myWidth / 2],
      7: [bufferOffset + attachToHeight, 0],
      8: [attachToHeight - myHeight, -myWidth - bufferOffset],
      9: [attachToHeight / 2 - myHeight / 2, -myWidth - bufferOffset],
      10: [0, -myWidth - bufferOffset],
      11: [-bufferOffset - myHeight, 0],
      12: [-bufferOffset - myHeight, attachToWidth / 2 - myWidth / 2]
    }[myGuider.position];
    top += offset[0];
    left += offset[1];
    var positionType = "absolute";

    if (attachTo.css("position") === "fixed" && guiders._fixedOrAbsolute === "fixed") {
      positionType = "fixed";
      top -= $(window).scrollTop();
      left -= $(window).scrollLeft();
    }

    if (myGuider.offset.top !== null) {
      top += myGuider.offset.top;
    }

    if (myGuider.offset.left !== null) {
      left += myGuider.offset.left;
    }

    guiders._styleArrow(myGuider);

    myGuider.elem.css({
      "position": positionType,
      "top": top,
      "left": left
    });
    return myGuider;
  };

  guiders._dehighlightElement = function (selector) {
    $(selector).removeClass('guiders_highlight');
  };

  guiders._hideOverlay = function () {
    $("#guiders_overlay").fadeOut("fast");
  };

  guiders._highlightElement = function (selector) {
    $(selector).addClass('guiders_highlight');
  };

  guiders._initializeOverlay = function () {
    if ($("#guiders_overlay").length === 0) {
      $("<div id='guiders_overlay'></div>").hide().appendTo("body");
    }
  };

  guiders._showOverlay = function () {
    $("#guiders_overlay").fadeIn("fast", function () {
      if (this.style.removeAttribute) {
        this.style.removeAttribute("filter");
      }
    });

    if (guiders._isIE) {
      $("#guiders_overlay").css("position", "absolute");
    }
  };

  guiders._styleArrow = function (myGuider) {
    var position = myGuider.position || 0;

    if (!position) {
      return;
    }

    var myGuiderArrow = $(myGuider.elem.find(".guiders_arrow"));
    myGuiderArrow.addClass({
      1: "guiders_arrow_down",
      2: "guiders_arrow_left",
      3: "guiders_arrow_left",
      4: "guiders_arrow_left",
      5: "guiders_arrow_up",
      6: "guiders_arrow_up",
      7: "guiders_arrow_up",
      8: "guiders_arrow_right",
      9: "guiders_arrow_right",
      10: "guiders_arrow_right",
      11: "guiders_arrow_down",
      12: "guiders_arrow_down"
    }[position]);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();
    var arrowOffset = guiders._arrowSize / 2;
    var position = {
      1: ["right", arrowOffset],
      2: ["top", arrowOffset],
      3: ["top", myHeight / 2 - arrowOffset],
      4: ["bottom", arrowOffset],
      5: ["right", arrowOffset],
      6: ["left", myWidth / 2 - arrowOffset],
      7: ["left", arrowOffset],
      8: ["bottom", arrowOffset],
      9: ["top", myHeight / 2 - arrowOffset],
      10: ["top", arrowOffset],
      11: ["left", arrowOffset],
      12: ["left", myWidth / 2 - arrowOffset]
    }[myGuider.position];
    myGuiderArrow.css(position[0], position[1] + "px");
  };

  guiders._showIfHashed = function (myGuider) {
    var GUIDER_HASH_TAG = "guider=";
    var hashIndex = window.location.hash.indexOf(GUIDER_HASH_TAG);

    if (hashIndex !== -1) {
      var hashGuiderId = window.location.hash.substr(hashIndex + GUIDER_HASH_TAG.length);

      if (myGuider.id.toLowerCase() === hashGuiderId.toLowerCase()) {
        guiders.show(myGuider.id);
      }
    }
  };

  guiders._updatePositionOnResize = function () {
    var _resizing = undefined;
    $(window).resize(function () {
      if (typeof _resizing !== "undefined") {
        clearTimeout(_resizing);
      }

      _resizing = setTimeout(function () {
        _resizing = undefined;

        if (typeof guiders !== "undefined") {
          guiders.reposition();
        }
      }, 20);
    });
  };

  guiders._updatePositionOnResize();

  guiders._unwireEscape = function () {
    $(document).unbind("keydown");
  };

  guiders._wireEscape = function (myGuider) {
    $(document).keydown(function (event) {
      if (event.keyCode == 27 || event.which == 27) {
        guiders.hideAll();

        if (myGuider.onClose) {
          myGuider.onClose(myGuider, true);
        }

        $("body").trigger("guidersClose");
        return false;
      }
    });
  };

  guiders.createGuider = function (passedSettings) {
    if (passedSettings === null || passedSettings === undefined) {
      passedSettings = {};
    }

    var myGuider = $.extend({}, guiders._defaultSettings, passedSettings);
    myGuider.id = myGuider.id || "guider_random_" + String(Math.floor(Math.random() * 1000));
    var guiderElement = $("#" + myGuider.id);

    if (!guiderElement.length) {
      guiderElement = $(guiders._htmlSkeleton);
    }

    myGuider.elem = guiderElement;

    if (typeof myGuider.classString !== "undefined" && myGuider.classString !== null) {
      myGuider.elem.addClass(myGuider.classString);
    }

    if (Number(myGuider.width) === myGuider.width) {
      myGuider.width = String(myGuider.width) + "px";
    }

    if (Number(myGuider.maxWidth) === myGuider.maxWidth) {
      myGuider.maxWidth = String(myGuider.maxWidth) + "px";
    }

    myGuider.elem.css("width", myGuider.width);
    myGuider.elem.css("maxWidth", myGuider.maxWidth);
    var guiderTitleContainer = guiderElement.find(".guiders_title");
    guiderTitleContainer.html(myGuider.title);
    guiderElement.find(".guiders_description").html(myGuider.description);

    guiders._addButtons(myGuider);

    if (myGuider.xButton) {
      guiders._addXButton(myGuider);
    }

    guiderElement.hide();
    guiderElement.appendTo("body");
    guiderElement.attr("id", myGuider.id);

    if (typeof myGuider.attachTo !== "undefined" && myGuider !== null) {
      guiders._attach(myGuider);
    }

    guiders._initializeOverlay();

    guiders._guiders[myGuider.id] = myGuider;

    if (guiders._lastCreatedGuiderID != null) {
      myGuider.prev = guiders._lastCreatedGuiderID;
    }

    guiders._lastCreatedGuiderID = myGuider.id;

    if (myGuider.isHashable) {
      guiders._showIfHashed(myGuider);
    }

    return guiders;
  };

  guiders.get = function (id) {
    if (typeof guiders._guiders[id] === "undefined") {
      return null;
    }

    return guiders._guiders[id] || null;
  };

  guiders.getCurrentGuider = function () {
    return guiders._guiders[guiders._currentGuiderID] || null;
  };

  guiders.hideAll = function (omitHidingOverlay, next) {
    next = next || false;
    $(".guider:visible").each(function (index, elem) {
      var myGuider = guiders.get($(elem).attr('id'));

      if (myGuider.onHide) {
        myGuider.onHide(myGuider, next);
      }
    });
    $(".guider").fadeOut("fast");
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (currentGuider && currentGuider.highlight) {
      guiders._dehighlightElement(currentGuider.highlight);
    }

    if (!(typeof omitHidingOverlay !== "undefined" && omitHidingOverlay === true)) {
      guiders._hideOverlay();
    }

    return guiders;
  };

  guiders.next = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    currentGuider.elem.data("locked", true);
    var nextGuiderId = currentGuider.next || null;

    if (nextGuiderId !== null && nextGuiderId !== "") {
      var nextGuider = guiders.get(nextGuiderId);
      var omitHidingOverlay = nextGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (currentGuider && currentGuider.highlight) {
        guiders._dehighlightElement(currentGuider.highlight);
      }

      if (nextGuider.shouldSkip && nextGuider.shouldSkip()) {
        guiders._currentGuiderID = nextGuider.id;
        guiders.next();
        return guiders.getCurrentGuider();
      } else {
        guiders.show(nextGuiderId);
        return guiders.getCurrentGuider();
      }
    }
  };

  guiders.prev = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    if (currentGuider.prev === null) {
      return null;
    }

    var prevGuider = guiders._guiders[currentGuider.prev];
    prevGuider.elem.data("locked", true);
    var prevGuiderId = prevGuider.id || null;

    if (prevGuiderId !== null && prevGuiderId !== "") {
      var myGuider = guiders.get(prevGuiderId);
      var omitHidingOverlay = myGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (prevGuider && prevGuider.highlight) {
        guiders._dehighlightElement(prevGuider.highlight);
      }

      guiders.show(prevGuiderId);
      return myGuider;
    }
  };

  guiders.reposition = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    guiders._attach(currentGuider);
  };

  guiders.scrollToCurrent = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return;
    }

    var windowHeight = guiders._windowHeight;
    $(window).scrollTop();
    var guiderOffset = currentGuider.elem.offset();
    var guiderElemHeight = currentGuider.elem.height();
    var scrollToHeight = Math.round(Math.max(guiderOffset.top + guiderElemHeight / 2 - windowHeight / 2, 0));
    window.scrollTo(0, scrollToHeight);
  };

  guiders.show = function (id) {
    if (!id && guiders._lastCreatedGuiderID) {
      id = guiders._lastCreatedGuiderID;
    }

    var myGuider = guiders.get(id);

    if (myGuider.overlay) {
      guiders._showOverlay(myGuider);

      if (myGuider.highlight && myGuider.attachTo) {
        guiders._highlightElement(myGuider.attachTo);
      }
    }

    if (myGuider.closeOnEscape) {
      guiders._wireEscape(myGuider);
    } else {
      guiders._unwireEscape(myGuider);
    }

    if (myGuider.onShow) {
      myGuider.onShow(myGuider);
    }

    guiders._attach(myGuider);

    myGuider.elem.fadeIn("fast").data("locked", false);
    guiders._currentGuiderID = id;
    var windowHeight = guiders._windowHeight = $(window).height();
    var scrollHeight = $(window).scrollTop();
    var guiderOffset = myGuider.elem.offset();
    var guiderElemHeight = myGuider.elem.height();
    var isGuiderBelow = scrollHeight + windowHeight < guiderOffset.top + guiderElemHeight;
    var isGuiderAbove = guiderOffset.top < scrollHeight;

    if (myGuider.autoFocus && (isGuiderBelow || isGuiderAbove)) {
      setTimeout(guiders.scrollToCurrent, 10);
    }

    $(myGuider.elem).trigger("guiders.show");
    return guiders;
  };

  $.fn.guider = function (passedOptions) {
    passedOptions = passedOptions || {};
    var options = $.extend({}, passedOptions);
    options.id = $(this).attr("id");
    var buttons = [];
    $(this).find(".guiders_buttons_container").children().each(function () {
      var buttonOptions = {
        name: $(this).html(),
        classString: $(this).attr("class")
      };

      if ($(this).attr("data-onclick")) {
        var functionName = $(this).attr("data-onclick");

        buttonOptions.onclick = function () {
          window[functionName]();
        };
      }

      $(this).remove();
      buttons.push(buttonOptions);
    });
    options.buttons = buttons;
    title = $(this).find(".guiders_title").html();

    if (title) {
      options.title = title;
    }

    description = $(this).find(".guiders_description").html();

    if (description) {
      options.description = description;
    }

    for (var optionName in guiders._defaultSettings) {
      if (!guiders._defaultSettings.hasOwnProperty(optionName)) {
        continue;
      }

      var optionValue = $(this).attr("data-" + optionName);

      if (optionValue === undefined || optionValue === null) {
        continue;
      }

      if (optionValue == "true") {
        optionValue = true;
      } else if (optionValue == "false") {
        optionValue = false;
      }

      options[optionName] = optionValue;
    }

    guiders.createGuider(options);
    return this;
  };

  return guiders;
}.call(this, jQuery);

/***/ }),
/* 225 */
/***/ (function(module, exports) {

var FUNC_ERROR_TEXT='Expected a function';function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}module.exports=negate;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var Stack=__webpack_require__(228),equalArrays=__webpack_require__(229),equalByTag=__webpack_require__(231),equalObjects=__webpack_require__(232),getTag=__webpack_require__(73),isArray=__webpack_require__(5),isBuffer=__webpack_require__(66),isTypedArray=__webpack_require__(69);var COMPARE_PARTIAL_FLAG=1;var argsTag='[object Arguments]',arrayTag='[object Array]',objectTag='[object Object]';var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}module.exports=baseIsEqualDeep;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear=__webpack_require__(87),listCacheDelete=__webpack_require__(88),listCacheGet=__webpack_require__(90),listCacheHas=__webpack_require__(91),listCacheSet=__webpack_require__(92);function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(49),arraySome=__webpack_require__(230),cacheHas=__webpack_require__(50);var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}module.exports=equalArrays;

/***/ }),
/* 230 */
/***/ (function(module, exports) {

function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}module.exports=arraySome;

/***/ }),
/* 231 */
/***/ (function(module, exports) {

function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys=__webpack_require__(233);var COMPARE_PARTIAL_FLAG=1;var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}module.exports=equalObjects;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(45);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 234 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 235 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 236 */
/***/ (function(module, exports) {

var nativeFloor=Math.floor,nativeRandom=Math.random;function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}module.exports=baseRandom;

/***/ }),
/* 237 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 238 */
/***/ (function(module, exports) {

function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}module.exports=baseClamp;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol=__webpack_require__(44);function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}module.exports=baseExtremum;

/***/ }),
/* 240 */
/***/ (function(module, exports) {

function baseGt(value,other){return value>other;}module.exports=baseGt;

/***/ }),
/* 241 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 242 */
/***/ (function(module, exports) {

function stubArray(){return[];}module.exports=stubArray;

/***/ }),
/* 243 */
/***/ (function(module, exports) {

function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(49),arrayIncludes=__webpack_require__(75),arrayIncludesWith=__webpack_require__(76),arrayMap=__webpack_require__(16),baseUnary=__webpack_require__(40),cacheHas=__webpack_require__(50);var nativeMin=Math.min;function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}module.exports=baseIntersection;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLikeObject=__webpack_require__(35);function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}module.exports=castArrayLikeObject;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var forEach=__webpack_require__(119).forEach;var elementUtilsMaker=__webpack_require__(247);var listenerHandlerMaker=__webpack_require__(248);var idGeneratorMaker=__webpack_require__(249);var idHandlerMaker=__webpack_require__(250);var reporterMaker=__webpack_require__(251);var browserDetector=__webpack_require__(120);var batchProcessorMaker=__webpack_require__(252);var stateHandler=__webpack_require__(254);var objectStrategyMaker=__webpack_require__(255);var scrollStrategyMaker=__webpack_require__(256);function isCollection(obj){return Array.isArray(obj)||obj.length!==undefined;}function toArray(collection){if(!Array.isArray(collection)){var array=[];forEach(collection,function(obj){array.push(obj);});return array;}else{return collection;}}function isElement(obj){return obj&&obj.nodeType===1;}module.exports=function(options){options=options||{};var idHandler;if(options.idHandler){idHandler={get:function(element){return options.idHandler.get(element,true);},set:options.idHandler.set};}else{var idGenerator=idGeneratorMaker();var defaultIdHandler=idHandlerMaker({idGenerator:idGenerator,stateHandler:stateHandler});idHandler=defaultIdHandler;}var reporter=options.reporter;if(!reporter){var quiet=reporter===false;reporter=reporterMaker(quiet);}var batchProcessor=getOption(options,"batchProcessor",batchProcessorMaker({reporter:reporter}));var globalOptions={};globalOptions.callOnAdd=!!getOption(options,"callOnAdd",true);globalOptions.debug=!!getOption(options,"debug",false);var eventListenerHandler=listenerHandlerMaker(idHandler);var elementUtils=elementUtilsMaker({stateHandler:stateHandler});var detectionStrategy;var desiredStrategy=getOption(options,"strategy","object");var strategyOptions={reporter:reporter,batchProcessor:batchProcessor,stateHandler:stateHandler,idHandler:idHandler};if(desiredStrategy==="scroll"){if(browserDetector.isLegacyOpera()){reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");desiredStrategy="object";}else if(browserDetector.isIE(9)){reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");desiredStrategy="object";}}if(desiredStrategy==="scroll"){detectionStrategy=scrollStrategyMaker(strategyOptions);}else if(desiredStrategy==="object"){detectionStrategy=objectStrategyMaker(strategyOptions);}else{throw new Error("Invalid strategy name: "+desiredStrategy);}var onReadyCallbacks={};function listenTo(options,elements,listener){function onResizeCallback(element){var listeners=eventListenerHandler.get(element);forEach(listeners,function(listener){listener(element);});}function addListener(callOnAdd,element,listener){eventListenerHandler.add(element,listener);if(callOnAdd){listener(element);}}if(!listener){listener=elements;elements=options;options={};}if(!elements){throw new Error("At least one element required.");}if(!listener){throw new Error("Listener required.");}if(isElement(elements)){elements=[elements];}else if(isCollection(elements)){elements=toArray(elements);}else{return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");}var elementsReady=0;var callOnAdd=getOption(options,"callOnAdd",globalOptions.callOnAdd);var onReadyCallback=getOption(options,"onReady",function(){});var debug=getOption(options,"debug",globalOptions.debug);forEach(elements,function(element){if(!stateHandler.getState(element)){stateHandler.initState(element);idHandler.set(element);}var id=idHandler.get(element);debug&&reporter.log("Attaching listener to element",id,element);if(!elementUtils.isDetectable(element)){debug&&reporter.log(id,"Not detectable.");if(elementUtils.isBusy(element)){debug&&reporter.log(id,"System busy making it detectable");addListener(callOnAdd,element,listener);onReadyCallbacks[id]=onReadyCallbacks[id]||[];onReadyCallbacks[id].push(function(){elementsReady++;if(elementsReady===elements.length){onReadyCallback();}});return;}debug&&reporter.log(id,"Making detectable...");elementUtils.markBusy(element,true);return detectionStrategy.makeDetectable({debug:debug},element,function(element){debug&&reporter.log(id,"onElementDetectable");if(stateHandler.getState(element)){elementUtils.markAsDetectable(element);elementUtils.markBusy(element,false);detectionStrategy.addListener(element,onResizeCallback);addListener(callOnAdd,element,listener);var state=stateHandler.getState(element);if(state&&state.startSize){var width=element.offsetWidth;var height=element.offsetHeight;if(state.startSize.width!==width||state.startSize.height!==height){onResizeCallback(element);}}if(onReadyCallbacks[id]){forEach(onReadyCallbacks[id],function(callback){callback();});}}else{debug&&reporter.log(id,"Element uninstalled before being detectable.");}delete onReadyCallbacks[id];elementsReady++;if(elementsReady===elements.length){onReadyCallback();}});}debug&&reporter.log(id,"Already detecable, adding listener.");addListener(callOnAdd,element,listener);elementsReady++;});if(elementsReady===elements.length){onReadyCallback();}}function uninstall(elements){if(!elements){return reporter.error("At least one element is required.");}if(isElement(elements)){elements=[elements];}else if(isCollection(elements)){elements=toArray(elements);}else{return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");}forEach(elements,function(element){eventListenerHandler.removeAllListeners(element);detectionStrategy.uninstall(element);stateHandler.cleanState(element);});}return{listenTo:listenTo,removeListener:eventListenerHandler.removeListener,removeAllListeners:eventListenerHandler.removeAllListeners,uninstall:uninstall};};function getOption(options,name,defaultValue){var value=options[name];if((value===undefined||value===null)&&defaultValue!==undefined){return defaultValue;}return value;}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
module.exports=function(options){var getState=options.stateHandler.getState;return{isDetectable:function(element){var state=getState(element);return state&&!!state.isDetectable;},markAsDetectable:function(element){getState(element).isDetectable=true;},isBusy:function(element){return!!getState(element).busy;},markBusy:function(element,busy){getState(element).busy=!!busy;}};};

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
module.exports=function(idHandler){var eventListeners={};function getListeners(element){var id=idHandler.get(element);if(id===undefined){return[];}return eventListeners[id]||[];}return{get:getListeners,add:function(element,listener){var id=idHandler.get(element);if(!eventListeners[id]){eventListeners[id]=[];}eventListeners[id].push(listener);},removeListener:function(element,listener){var listeners=getListeners(element);for(var i=0,len=listeners.length;i<len;++i){if(listeners[i]===listener){listeners.splice(i,1);break;}}},removeAllListeners:function(element){var listeners=getListeners(element);if(!listeners){return;}listeners.length=0;}};};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
module.exports=function(){var idCount=1;function generate(){return idCount++;}return{generate:generate};};

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
module.exports=function(options){var idGenerator=options.idGenerator;var getState=options.stateHandler.getState;return{get:function(element){var state=getState(element);if(state&&state.id!==undefined){return state.id;}return null;},set:function(element){var state=getState(element);if(!state){throw new Error("setId required the element to have a resize detection state.");}var id=idGenerator.generate();state.id=id;return id;}};};

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
module.exports=function(quiet){function noop(){}var reporter={log:noop,warn:noop,error:noop};if(!quiet&&window.console){var attachFunction=function(reporter,name){reporter[name]=function(){var f=console[name];if(f.apply){f.apply(console,arguments);}else{for(var i=0;i<arguments.length;i++){f(arguments[i]);}}};};attachFunction(reporter,"log");attachFunction(reporter,"warn");attachFunction(reporter,"error");}return reporter;};

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var utils=__webpack_require__(253);module.exports=function(options){options=options||{};var reporter=options.reporter;var asyncProcess=utils.getOption(options,"async",true);var autoProcess=utils.getOption(options,"auto",true);if(autoProcess&&!asyncProcess){reporter&&reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");asyncProcess=true;}var batch=Batch();var asyncFrameHandler;var isProcessing=false;function addFunction(level,fn){if(!isProcessing&&autoProcess&&asyncProcess&&batch.size()===0){processBatchAsync();}batch.add(level,fn);}function processBatch(){isProcessing=true;while(batch.size()){var processingBatch=batch;batch=Batch();processingBatch.process();}isProcessing=false;}function forceProcessBatch(localAsyncProcess){if(isProcessing){return;}if(localAsyncProcess===undefined){localAsyncProcess=asyncProcess;}if(asyncFrameHandler){cancelFrame(asyncFrameHandler);asyncFrameHandler=null;}if(localAsyncProcess){processBatchAsync();}else{processBatch();}}function processBatchAsync(){asyncFrameHandler=requestFrame(processBatch);}function cancelFrame(listener){var cancel=clearTimeout;return cancel(listener);}function requestFrame(callback){return function(fn){return setTimeout(fn,0);}(callback);}return{add:addFunction,force:forceProcessBatch};};function Batch(){var batch={};var size=0;var topLevel=0;var bottomLevel=0;function add(level,fn){if(!fn){fn=level;level=0;}if(level>topLevel){topLevel=level;}else if(level<bottomLevel){bottomLevel=level;}if(!batch[level]){batch[level]=[];}batch[level].push(fn);size++;}function process(){for(var level=bottomLevel;level<=topLevel;level++){var fns=batch[level];for(var i=0;i<fns.length;i++){var fn=fns[i];fn();}}}function getSize(){return size;}return{add:add,process:process,size:getSize};}

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var utils=module.exports={};utils.getOption=getOption;function getOption(options,name,defaultValue){var value=options[name];if((value===undefined||value===null)&&defaultValue!==undefined){return defaultValue;}return value;}

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var prop="_erd";function initState(element){element[prop]={};return getState(element);}function getState(element){return element[prop];}function cleanState(element){delete element[prop];}module.exports={initState:initState,getState:getState,cleanState:cleanState};

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var browserDetector=__webpack_require__(120);module.exports=function(options){options=options||{};var reporter=options.reporter;var batchProcessor=options.batchProcessor;var getState=options.stateHandler.getState;if(!reporter){throw new Error("Missing required dependency: reporter.");}function makeDetectable(options,element,callback){if(!callback){callback=element;element=options;options=null;}options=options||{};options.debug;function injectObject(element,callback){var positionCheckPerformed=false;var style=window.getComputedStyle(element);var width=element.offsetWidth;var height=element.offsetHeight;getState(element).startSize={width:width,height:height};function mutateDom(){function alterPositionStyles(){if(style.position==="static"){element.style.position="relative";var removeRelativeStyles=function(reporter,element,style,property){var value=style[property];if(value!=="auto"&&function(value){return value.replace(/[^-\d\.]/g,"");}(value)!=="0"){reporter.warn("An element that is positioned static has style."+property+"="+value+" which is ignored due to the static positioning. The element will need to be positioned relative, so the style."+property+" will be set to 0. Element: ",element);element.style[property]=0;}};removeRelativeStyles(reporter,element,style,"top");removeRelativeStyles(reporter,element,style,"right");removeRelativeStyles(reporter,element,style,"bottom");removeRelativeStyles(reporter,element,style,"left");}}function onObjectLoad(){if(!positionCheckPerformed){alterPositionStyles();}function getDocument(element,callback){if(!element.contentDocument){setTimeout(function(){getDocument(element,callback);},100);return;}callback(element.contentDocument);}var objectElement=this;getDocument(objectElement,function(){callback(element);});}if(style.position!==""){alterPositionStyles(style);positionCheckPerformed=true;}var object=document.createElement("object");object.style.cssText="display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;";object.tabIndex=-1;object.type="text/html";object.onload=onObjectLoad;if(!browserDetector.isIE()){object.data="about:blank";}element.appendChild(object);getState(element).object=object;if(browserDetector.isIE()){object.data="about:blank";}}if(batchProcessor){batchProcessor.add(mutateDom);}else{mutateDom();}}if(browserDetector.isIE(8)){callback(element);}else{injectObject(element,callback);}}function getObject(element){return getState(element).object;}return{makeDetectable:makeDetectable,addListener:function(element,listener){if(!getObject(element)){throw new Error("Element is not detectable by this strategy.");}function listenerProxy(){listener(element);}if(browserDetector.isIE(8)){getState(element).object={proxy:listenerProxy};element.attachEvent("onresize",listenerProxy);}else{var object=getObject(element);object.contentDocument.defaultView.addEventListener("resize",listenerProxy);}},uninstall:function(element){if(browserDetector.isIE(8)){element.detachEvent("onresize",getState(element).object.proxy);}else{element.removeChild(getObject(element));}delete getState(element).object;}};};

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var forEach=__webpack_require__(119).forEach;module.exports=function(options){options=options||{};var reporter=options.reporter;var batchProcessor=options.batchProcessor;var getState=options.stateHandler.getState;options.stateHandler.hasState;var idHandler=options.idHandler;if(!batchProcessor){throw new Error("Missing required dependency: batchProcessor");}if(!reporter){throw new Error("Missing required dependency: reporter.");}var scrollbarSizes=function(){var width=500;var height=500;var child=document.createElement("div");child.style.cssText="position: absolute; width: "+width*2+"px; height: "+height*2+"px; visibility: hidden; margin: 0; padding: 0;";var container=document.createElement("div");container.style.cssText="position: absolute; width: "+width+"px; height: "+height+"px; overflow: scroll; visibility: none; top: "+-width*3+"px; left: "+-height*3+"px; visibility: hidden; margin: 0; padding: 0;";container.appendChild(child);document.body.insertBefore(container,document.body.firstChild);var widthSize=width-container.clientWidth;var heightSize=height-container.clientHeight;document.body.removeChild(container);return{width:widthSize,height:heightSize};}();var detectionContainerClass="erd_scroll_detection_container";(function(styleId,containerClass){function injectStyle(style,method){method=method||function(element){document.head.appendChild(element);};var styleElement=document.createElement("style");styleElement.innerHTML=style;styleElement.id=styleId;method(styleElement);return styleElement;}if(!document.getElementById(styleId)){var containerAnimationClass=containerClass+"_animation";var style="/* Created by the element-resize-detector library. */\n";style+="."+containerClass+" > div::-webkit-scrollbar { display: none; }\n\n";style+="."+(containerClass+"_animation_active")+" { -webkit-animation-duration: 0.1s; animation-duration: 0.1s; -webkit-animation-name: "+containerAnimationClass+"; animation-name: "+containerAnimationClass+"; }\n";style+="@-webkit-keyframes "+containerAnimationClass+" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";style+="@keyframes "+containerAnimationClass+" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";injectStyle(style);}})("erd_scroll_detection_scrollbar_style",detectionContainerClass);function addAnimationClass(element){element.className+=" "+detectionContainerClass+"_animation_active";}function addEvent(el,name,cb){if(el.addEventListener){el.addEventListener(name,cb);}else if(el.attachEvent){el.attachEvent("on"+name,cb);}else{return reporter.error("[scroll] Don't know how to add event listeners.");}}function removeEvent(el,name,cb){if(el.removeEventListener){el.removeEventListener(name,cb);}else if(el.detachEvent){el.detachEvent("on"+name,cb);}else{return reporter.error("[scroll] Don't know how to remove event listeners.");}}function getExpandElement(element){return getState(element).container.childNodes[0].childNodes[0].childNodes[0];}function getShrinkElement(element){return getState(element).container.childNodes[0].childNodes[0].childNodes[1];}function makeDetectable(options,element,callback){if(!callback){callback=element;element=options;options=null;}options=options||{};function debug(){if(options.debug){var args=Array.prototype.slice.call(arguments);args.unshift(idHandler.get(element),"Scroll: ");if(reporter.log.apply){reporter.log.apply(null,args);}else{for(var i=0;i<args.length;i++){reporter.log(args[i]);}}}}function isDetached(element){if(!function(element){return element===element.ownerDocument.body||element.ownerDocument.body.contains(element);}(element)){return true;}if(getComputedStyle(element)===null){return true;}return false;}function isUnrendered(element){var container=getState(element).container.childNodes[0];var style=getComputedStyle(container);return!style.width||style.width.indexOf("px")===-1;}function getStyle(){var elementStyle=getComputedStyle(element);var style={};style.position=elementStyle.position;style.width=element.offsetWidth;style.height=element.offsetHeight;style.top=elementStyle.top;style.right=elementStyle.right;style.bottom=elementStyle.bottom;style.left=elementStyle.left;style.widthCSS=elementStyle.width;style.heightCSS=elementStyle.height;return style;}function storeStartSize(){var style=getStyle();getState(element).startSize={width:style.width,height:style.height};debug("Element start size",getState(element).startSize);}function initListeners(){getState(element).listeners=[];}function storeStyle(){debug("storeStyle invoked.");if(!getState(element)){debug("Aborting because element has been uninstalled");return;}var style=getStyle();getState(element).style=style;}function storeCurrentSize(element,width,height){getState(element).lastWidth=width;getState(element).lastHeight=height;}function getExpandChildElement(element){return getExpandElement(element).childNodes[0];}function getWidthOffset(){return 2*scrollbarSizes.width+1;}function getHeightOffset(){return 2*scrollbarSizes.height+1;}function getExpandWidth(width){return width+10+getWidthOffset();}function getExpandHeight(height){return height+10+getHeightOffset();}function getShrinkWidth(width){return width*2+getWidthOffset();}function getShrinkHeight(height){return height*2+getHeightOffset();}function positionScrollbars(element,width,height){var expand=getExpandElement(element);var shrink=getShrinkElement(element);var expandWidth=getExpandWidth(width);var expandHeight=getExpandHeight(height);var shrinkWidth=getShrinkWidth(width);var shrinkHeight=getShrinkHeight(height);expand.scrollLeft=expandWidth;expand.scrollTop=expandHeight;shrink.scrollLeft=shrinkWidth;shrink.scrollTop=shrinkHeight;}function injectContainerElement(){var container=getState(element).container;if(!container){container=document.createElement("div");container.className=detectionContainerClass;container.style.cssText="visibility: hidden; display: inline; width: 0px; height: 0px; z-index: -1; overflow: hidden; margin: 0; padding: 0;";getState(element).container=container;addAnimationClass(container);element.appendChild(container);var onAnimationStart=function(){getState(element).onRendered&&getState(element).onRendered();};addEvent(container,"animationstart",onAnimationStart);getState(element).onAnimationStart=onAnimationStart;}return container;}function injectScrollElements(){function alterPositionStyles(){var style=getState(element).style;if(style.position==="static"){element.style.position="relative";var removeRelativeStyles=function(reporter,element,style,property){var value=style[property];if(value!=="auto"&&function(value){return value.replace(/[^-\d\.]/g,"");}(value)!=="0"){reporter.warn("An element that is positioned static has style."+property+"="+value+" which is ignored due to the static positioning. The element will need to be positioned relative, so the style."+property+" will be set to 0. Element: ",element);element.style[property]=0;}};removeRelativeStyles(reporter,element,style,"top");removeRelativeStyles(reporter,element,style,"right");removeRelativeStyles(reporter,element,style,"bottom");removeRelativeStyles(reporter,element,style,"left");}}debug("Injecting elements");if(!getState(element)){debug("Aborting because element has been uninstalled");return;}alterPositionStyles();var rootContainer=getState(element).container;if(!rootContainer){rootContainer=injectContainerElement();}var scrollbarWidth=scrollbarSizes.width;var scrollbarHeight=scrollbarSizes.height;var containerStyle="position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; "+function(left,top,bottom,right){left=!left?"0":left+"px";top=!top?"0":top+"px";bottom=!bottom?"0":bottom+"px";right=!right?"0":right+"px";return"left: "+left+"; top: "+top+"; right: "+right+"; bottom: "+bottom+";";}(-(1+scrollbarWidth),-(1+scrollbarHeight),-scrollbarHeight,-scrollbarWidth);var containerContainer=document.createElement("div");var container=document.createElement("div");var expand=document.createElement("div");var expandChild=document.createElement("div");var shrink=document.createElement("div");var shrinkChild=document.createElement("div");containerContainer.dir="ltr";containerContainer.style.cssText="position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; width: 100%; height: 100%; left: 0px; top: 0px;";containerContainer.className=detectionContainerClass;container.className=detectionContainerClass;container.style.cssText=containerStyle;expand.style.cssText="position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";expandChild.style.cssText="position: absolute; left: 0; top: 0;";shrink.style.cssText="position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";shrinkChild.style.cssText="position: absolute; width: 200%; height: 200%;";expand.appendChild(expandChild);shrink.appendChild(shrinkChild);container.appendChild(expand);container.appendChild(shrink);containerContainer.appendChild(container);rootContainer.appendChild(containerContainer);function onExpandScroll(){getState(element).onExpand&&getState(element).onExpand();}function onShrinkScroll(){getState(element).onShrink&&getState(element).onShrink();}addEvent(expand,"scroll",onExpandScroll);addEvent(shrink,"scroll",onShrinkScroll);getState(element).onExpandScroll=onExpandScroll;getState(element).onShrinkScroll=onShrinkScroll;}function registerListenersAndPositionElements(){function updateChildSizes(element,width,height){var expandChild=getExpandChildElement(element);var expandWidth=getExpandWidth(width);var expandHeight=getExpandHeight(height);expandChild.style.width=expandWidth+"px";expandChild.style.height=expandHeight+"px";}function updateDetectorElements(done){var width=element.offsetWidth;var height=element.offsetHeight;debug("Storing current size",width,height);storeCurrentSize(element,width,height);batchProcessor.add(0,function(){if(!getState(element)){debug("Aborting because element has been uninstalled");return;}if(!areElementsInjected()){debug("Aborting because element container has not been initialized");return;}if(options.debug){var w=element.offsetWidth;var h=element.offsetHeight;if(w!==width||h!==height){reporter.warn(idHandler.get(element),"Scroll: Size changed before updating detector elements.");}}updateChildSizes(element,width,height);});batchProcessor.add(1,function(){if(!getState(element)){debug("Aborting because element has been uninstalled");return;}if(!areElementsInjected()){debug("Aborting because element container has not been initialized");return;}positionScrollbars(element,width,height);});if(done){batchProcessor.add(2,function(){if(!getState(element)){debug("Aborting because element has been uninstalled");return;}if(!areElementsInjected()){debug("Aborting because element container has not been initialized");return;}done();});}}function areElementsInjected(){return!!getState(element).container;}function notifyListenersIfNeeded(){function isFirstNotify(){return getState(element).lastNotifiedWidth===undefined;}debug("notifyListenersIfNeeded invoked");var state=getState(element);if(isFirstNotify()&&state.lastWidth===state.startSize.width&&state.lastHeight===state.startSize.height){return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");}if(state.lastWidth===state.lastNotifiedWidth&&state.lastHeight===state.lastNotifiedHeight){return debug("Not notifying: Size already notified");}debug("Current size not notified, notifying...");state.lastNotifiedWidth=state.lastWidth;state.lastNotifiedHeight=state.lastHeight;forEach(getState(element).listeners,function(listener){listener(element);});}function handleRender(){debug("startanimation triggered.");if(isUnrendered(element)){debug("Ignoring since element is still unrendered...");return;}debug("Element rendered.");var expand=getExpandElement(element);var shrink=getShrinkElement(element);if(expand.scrollLeft===0||expand.scrollTop===0||shrink.scrollLeft===0||shrink.scrollTop===0){debug("Scrollbars out of sync. Updating detector elements...");updateDetectorElements(notifyListenersIfNeeded);}}function handleScroll(){debug("Scroll detected.");if(isUnrendered(element)){debug("Scroll event fired while unrendered. Ignoring...");return;}var width=element.offsetWidth;var height=element.offsetHeight;if(width!==getState(element).lastWidth||height!==getState(element).lastHeight){debug("Element size changed.");updateDetectorElements(notifyListenersIfNeeded);}else{debug("Element size has not changed ("+width+"x"+height+").");}}debug("registerListenersAndPositionElements invoked.");if(!getState(element)){debug("Aborting because element has been uninstalled");return;}getState(element).onRendered=handleRender;getState(element).onExpand=handleScroll;getState(element).onShrink=handleScroll;var style=getState(element).style;updateChildSizes(element,style.width,style.height);}function finalizeDomMutation(){debug("finalizeDomMutation invoked.");if(!getState(element)){debug("Aborting because element has been uninstalled");return;}var style=getState(element).style;storeCurrentSize(element,style.width,style.height);positionScrollbars(element,style.width,style.height);}function ready(){callback(element);}function install(){debug("Installing...");initListeners();storeStartSize();batchProcessor.add(0,storeStyle);batchProcessor.add(1,injectScrollElements);batchProcessor.add(2,registerListenersAndPositionElements);batchProcessor.add(3,finalizeDomMutation);batchProcessor.add(4,ready);}debug("Making detectable...");if(isDetached(element)){debug("Element is detached");injectContainerElement();debug("Waiting until element is attached...");getState(element).onRendered=function(){debug("Element is now attached");install();};}else{install();}}return{makeDetectable:makeDetectable,addListener:function(element,listener){var listeners=getState(element).listeners;if(!listeners.push){throw new Error("Cannot add listener to an element that is not detectable.");}getState(element).listeners.push(listener);},uninstall:function(element){var state=getState(element);if(!state){return;}state.onExpandScroll&&removeEvent(getExpandElement(element),"scroll",state.onExpandScroll);state.onShrinkScroll&&removeEvent(getShrinkElement(element),"scroll",state.onShrinkScroll);state.onAnimationStart&&removeEvent(state.container,"animationstart",state.onAnimationStart);state.container&&element.removeChild(state.container);}};};

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice=__webpack_require__(63),isIterateeCall=__webpack_require__(46),toInteger=__webpack_require__(32);function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}module.exports=slice;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual=__webpack_require__(118),get=__webpack_require__(259),hasIn=__webpack_require__(113),isKey=__webpack_require__(106),isStrictComparable=__webpack_require__(260),matchesStrictComparable=__webpack_require__(261),toKey=__webpack_require__(25);var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}module.exports=baseMatchesProperty;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet=__webpack_require__(62);function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}module.exports=get;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var isObject=__webpack_require__(10);function isStrictComparable(value){return value===value&&!isObject(value);}module.exports=isStrictComparable;

/***/ }),
/* 261 */
/***/ (function(module, exports) {

function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}module.exports=matchesStrictComparable;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(4),isArrayLike=__webpack_require__(74),keys=__webpack_require__(65);function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=baseIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}module.exports=createFind;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex=__webpack_require__(264),baseIteratee=__webpack_require__(4),toInteger=__webpack_require__(32);var nativeMax=Math.max;function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,baseIteratee(predicate,3),index);}module.exports=findIndex;

/***/ }),
/* 264 */
/***/ (function(module, exports) {

function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}module.exports=baseFindIndex;

/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var foreground_messaging_namespaceObject = {};
__webpack_require__.r(foreground_messaging_namespaceObject);
__webpack_require__.d(foreground_messaging_namespaceObject, "sendMessage", function() { return sendMessage; });
__webpack_require__.d(foreground_messaging_namespaceObject, "addListener", function() { return addListener; });
var privateBrowsing_namespaceObject = {};
__webpack_require__.r(privateBrowsing_namespaceObject);
__webpack_require__.d(privateBrowsing_namespaceObject, "isPrivateBrowsing", function() { return isPrivateBrowsing; });
var history_namespaceObject = {};
__webpack_require__.r(history_namespaceObject);
__webpack_require__.d(history_namespaceObject, "addURLToHistory", function() { return addURLToHistory; });
__webpack_require__.d(history_namespaceObject, "isURLVisited", function() { return isURLVisited; });
var xhrCache_namespaceObject = {};
__webpack_require__.r(xhrCache_namespaceObject);
__webpack_require__.d(xhrCache_namespaceObject, "set", function() { return set; });
__webpack_require__.d(xhrCache_namespaceObject, "check", function() { return xhrCache_check; });
__webpack_require__.d(xhrCache_namespaceObject, "delete", function() { return delete_; });
__webpack_require__.d(xhrCache_namespaceObject, "clear", function() { return clear; });
var ajax_namespaceObject = {};
__webpack_require__.r(ajax_namespaceObject);
__webpack_require__.d(ajax_namespaceObject, "ajax", function() { return ajax; });
var download_namespaceObject = {};
__webpack_require__.r(download_namespaceObject);
__webpack_require__.d(download_namespaceObject, "download", function() { return download; });
var id_namespaceObject = {};
__webpack_require__.r(id_namespaceObject);
__webpack_require__.d(id_namespaceObject, "getExtensionId", function() { return getExtensionId; });
__webpack_require__.d(id_namespaceObject, "getURL", function() { return getURL; });
__webpack_require__.d(id_namespaceObject, "getOptionsURL", function() { return getOptionsURL; });
__webpack_require__.d(id_namespaceObject, "isOptionsPage", function() { return isOptionsPage; });
var i18n_namespaceObject = {};
__webpack_require__.r(i18n_namespaceObject);
__webpack_require__.d(i18n_namespaceObject, "locale", function() { return i18n_locale; });
__webpack_require__.d(i18n_namespaceObject, "_loadI18n", function() { return _loadI18n; });
__webpack_require__.d(i18n_namespaceObject, "i18n", function() { return i18n; });
var permissions_namespaceObject = {};
__webpack_require__.r(permissions_namespaceObject);
__webpack_require__.d(permissions_namespaceObject, "has", function() { return permissions_has; });
__webpack_require__.d(permissions_namespaceObject, "request", function() { return request; });
var auth_namespaceObject = {};
__webpack_require__.r(auth_namespaceObject);
__webpack_require__.d(auth_namespaceObject, "launchAuthFlow", function() { return launchAuthFlow; });
var multicast_namespaceObject = {};
__webpack_require__.r(multicast_namespaceObject);
__webpack_require__.d(multicast_namespaceObject, "multicast", function() { return multicast; });
var tabs_namespaceObject = {};
__webpack_require__.r(tabs_namespaceObject);
__webpack_require__.d(tabs_namespaceObject, "openNewTab", function() { return openNewTab; });
__webpack_require__.d(tabs_namespaceObject, "openNewTabs", function() { return openNewTabs; });
var pageAction_namespaceObject = {};
__webpack_require__.r(pageAction_namespaceObject);
__webpack_require__.d(pageAction_namespaceObject, "onClick", function() { return pageAction_onClick; });
__webpack_require__.d(pageAction_namespaceObject, "show", function() { return show; });
__webpack_require__.d(pageAction_namespaceObject, "hide", function() { return pageAction_hide; });
var session_namespaceObject = {};
__webpack_require__.r(session_namespaceObject);
__webpack_require__.d(session_namespaceObject, "get", function() { return get; });
__webpack_require__.d(session_namespaceObject, "set", function() { return session_set; });
__webpack_require__.d(session_namespaceObject, "delete_", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "delete", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "has", function() { return session_has; });
__webpack_require__.d(session_namespaceObject, "clear", function() { return session_clear; });
var storage_namespaceObject = {};
__webpack_require__.r(storage_namespaceObject);
__webpack_require__.d(storage_namespaceObject, "get", function() { return storage_get; });
__webpack_require__.d(storage_namespaceObject, "getAll", function() { return getAll; });
__webpack_require__.d(storage_namespaceObject, "getMultiple", function() { return getMultiple; });
__webpack_require__.d(storage_namespaceObject, "set", function() { return storage_set; });
__webpack_require__.d(storage_namespaceObject, "setMultiple", function() { return setMultiple; });
__webpack_require__.d(storage_namespaceObject, "delete", function() { return storage_delete_; });
__webpack_require__.d(storage_namespaceObject, "deleteMultiple", function() { return deleteMultiple; });
__webpack_require__.d(storage_namespaceObject, "has", function() { return storage_has; });
__webpack_require__.d(storage_namespaceObject, "keys", function() { return storage_keys; });
__webpack_require__.d(storage_namespaceObject, "clear", function() { return storage_clear; });
__webpack_require__.d(storage_namespaceObject, "wrap", function() { return wrap; });
__webpack_require__.d(storage_namespaceObject, "wrapPrefix", function() { return wrapPrefix; });
__webpack_require__.d(storage_namespaceObject, "wrapBlob", function() { return wrapBlob; });
var string_namespaceObject = {};
__webpack_require__.r(string_namespaceObject);
__webpack_require__.d(string_namespaceObject, "encode", function() { return encode; });
__webpack_require__.d(string_namespaceObject, "escape", function() { return string_escape; });
__webpack_require__.d(string_namespaceObject, "safe", function() { return safe; });
__webpack_require__.d(string_namespaceObject, "areSimilar", function() { return areSimilar; });
__webpack_require__.d(string_namespaceObject, "regexRegex", function() { return regexRegex; });
__webpack_require__.d(string_namespaceObject, "html", function() { return string_html; });
__webpack_require__.d(string_namespaceObject, "_html", function() { return _html; });
var context_namespaceObject = {};
__webpack_require__.r(context_namespaceObject);
__webpack_require__.d(context_namespaceObject, "data", function() { return context_data; });
__webpack_require__.d(context_namespaceObject, "establish", function() { return establish; });
var bodyClasses_namespaceObject = {};
__webpack_require__.r(bodyClasses_namespaceObject);
__webpack_require__.d(bodyClasses_namespaceObject, "addMissing", function() { return addMissing; });
__webpack_require__.d(bodyClasses_namespaceObject, "add", function() { return bodyClasses_add; });
__webpack_require__.d(bodyClasses_namespaceObject, "remove", function() { return bodyClasses_remove; });
__webpack_require__.d(bodyClasses_namespaceObject, "toggle", function() { return bodyClasses_toggle; });
var browserDetect_namespaceObject = {};
__webpack_require__.r(browserDetect_namespaceObject);
__webpack_require__.d(browserDetect_namespaceObject, "browser", function() { return browser; });
__webpack_require__.d(browserDetect_namespaceObject, "version", function() { return browserDetect_version; });
__webpack_require__.d(browserDetect_namespaceObject, "OS", function() { return OS; });
var createElement_namespaceObject = {};
__webpack_require__.r(createElement_namespaceObject);
__webpack_require__.d(createElement_namespaceObject, "toggleButton", function() { return toggleButton; });
__webpack_require__.d(createElement_namespaceObject, "icon", function() { return icon; });
__webpack_require__.d(createElement_namespaceObject, "table", function() { return createElement_table; });
__webpack_require__.d(createElement_namespaceObject, "tabMenuItem", function() { return createElement_tabMenuItem; });
__webpack_require__.d(createElement_namespaceObject, "fancyToggleButton", function() { return fancyToggleButton; });
var alert_namespaceObject = {};
__webpack_require__.r(alert_namespaceObject);
__webpack_require__.d(alert_namespaceObject, "open", function() { return alert_open; });
__webpack_require__.d(alert_namespaceObject, "makeButton", function() { return makeButton; });
var caseBuilder_namespaceObject = {};
__webpack_require__.r(caseBuilder_namespaceObject);
__webpack_require__.d(caseBuilder_namespaceObject, "drawOptionBuilder", function() { return drawOptionBuilder; });
__webpack_require__.d(caseBuilder_namespaceObject, "drawBuilderBlock", function() { return drawBuilderBlock; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderItem", function() { return readBuilderItem; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderBlock", function() { return readBuilderBlock; });
__webpack_require__.d(caseBuilder_namespaceObject, "makeBuilderBlockSortable", function() { return makeBuilderBlockSortable; });
var stage_namespaceObject = {};
__webpack_require__.r(stage_namespaceObject);
__webpack_require__.d(stage_namespaceObject, "add", function() { return stageOption; });
__webpack_require__.d(stage_namespaceObject, "commit", function() { return commitStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "reset", function() { return clearStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "isDirty", function() { return hasStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "get", function() { return getStagedOptions; });
var table_namespaceObject = {};
__webpack_require__.r(table_namespaceObject);
__webpack_require__.d(table_namespaceObject, "getMatchingValueOrAdd", function() { return getMatchingValueOrAdd; });
var settingsNavigation_namespaceObject = {};
__webpack_require__.r(settingsNavigation_namespaceObject);
__webpack_require__.d(settingsNavigation_namespaceObject, "module", function() { return settingsNavigation_module; });
__webpack_require__.d(settingsNavigation_namespaceObject, "makeUrlHashLink", function() { return makeUrlHashLink; });
__webpack_require__.d(settingsNavigation_namespaceObject, "parseHash", function() { return parseHash; });
__webpack_require__.d(settingsNavigation_namespaceObject, "makeUrlHash", function() { return makeUrlHash; });
__webpack_require__.d(settingsNavigation_namespaceObject, "isSettingsUrl", function() { return isSettingsUrl; });
__webpack_require__.d(settingsNavigation_namespaceObject, "setHash", function() { return setHash; });
__webpack_require__.d(settingsNavigation_namespaceObject, "update", function() { return settingsNavigation_update; });
__webpack_require__.d(settingsNavigation_namespaceObject, "open", function() { return settingsNavigation_open; });
__webpack_require__.d(settingsNavigation_namespaceObject, "close", function() { return settingsNavigation_close; });
var commandLine_namespaceObject = {};
__webpack_require__.r(commandLine_namespaceObject);
__webpack_require__.d(commandLine_namespaceObject, "module", function() { return commandLine_module; });
__webpack_require__.d(commandLine_namespaceObject, "open", function() { return commandLine_open; });
__webpack_require__.d(commandLine_namespaceObject, "toggle", function() { return commandLine_toggle; });
__webpack_require__.d(commandLine_namespaceObject, "registerCommand", function() { return registerCommand; });
var dashboard_namespaceObject = {};
__webpack_require__.r(dashboard_namespaceObject);
__webpack_require__.d(dashboard_namespaceObject, "module", function() { return dashboard_module; });
__webpack_require__.d(dashboard_namespaceObject, "addTab", function() { return addTab; });
__webpack_require__.d(dashboard_namespaceObject, "widgets", function() { return widgets; });
__webpack_require__.d(dashboard_namespaceObject, "createSubredditToggleButton", function() { return createSubredditToggleButton; });
var newCommentCount_namespaceObject = {};
__webpack_require__.r(newCommentCount_namespaceObject);
__webpack_require__.d(newCommentCount_namespaceObject, "module", function() { return newCommentCount_module; });
__webpack_require__.d(newCommentCount_namespaceObject, "hasEntry", function() { return hasEntry; });
__webpack_require__.d(newCommentCount_namespaceObject, "getNewCount", function() { return getNewCount; });
var showImages_namespaceObject = {};
__webpack_require__.r(showImages_namespaceObject);
__webpack_require__.d(showImages_namespaceObject, "genericHosts", function() { return genericHosts; });
__webpack_require__.d(showImages_namespaceObject, "module", function() { return showImages_module; });
__webpack_require__.d(showImages_namespaceObject, "toggleViewImages", function() { return toggleViewImages; });
__webpack_require__.d(showImages_namespaceObject, "toggleThingExpandos", function() { return toggleThingExpandos; });
__webpack_require__.d(showImages_namespaceObject, "types", function() { return showImages_types; });
__webpack_require__.d(showImages_namespaceObject, "matchesTypes", function() { return matchesTypes; });
__webpack_require__.d(showImages_namespaceObject, "getLinkExpando", function() { return getLinkExpando; });
__webpack_require__.d(showImages_namespaceObject, "Media", function() { return Media; });
__webpack_require__.d(showImages_namespaceObject, "moveMedia", function() { return moveMedia; });
__webpack_require__.d(showImages_namespaceObject, "resizeMedia", function() { return resizeMedia; });
var filteReddit_namespaceObject = {};
__webpack_require__.r(filteReddit_namespaceObject);
__webpack_require__.d(filteReddit_namespaceObject, "module", function() { return filteReddit_module; });
__webpack_require__.d(filteReddit_namespaceObject, "defaultFilters", function() { return defaultFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "listFilters", function() { return listFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "addExternalFilter", function() { return addExternalFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "addOndemandCase", function() { return addOndemandCase; });
__webpack_require__.d(filteReddit_namespaceObject, "addCustomFilter", function() { return addCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "updateCustomFilter", function() { return updateCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "saveFilterlineStateAsDefault", function() { return saveFilterlineStateAsDefault; });
var userTagger_namespaceObject = {};
__webpack_require__.r(userTagger_namespaceObject);
__webpack_require__.d(userTagger_namespaceObject, "module", function() { return userTagger_module; });
__webpack_require__.d(userTagger_namespaceObject, "applyToUser", function() { return applyToUser; });
__webpack_require__.d(userTagger_namespaceObject, "tags", function() { return userTagger_tags; });
__webpack_require__.d(userTagger_namespaceObject, "Tag", function() { return userTagger_Tag; });
var postCases_namespaceObject = {};
__webpack_require__.r(postCases_namespaceObject);
__webpack_require__.d(postCases_namespaceObject, "commentCount", function() { return CommentCount_CommentCount; });
__webpack_require__.d(postCases_namespaceObject, "newCommentCount", function() { return NewCommentCount_NewCommentCount; });
__webpack_require__.d(postCases_namespaceObject, "commentsOpened", function() { return CommentsOpened_CommentsOpened; });
__webpack_require__.d(postCases_namespaceObject, "domain", function() { return Domain_Domain; });
__webpack_require__.d(postCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(postCases_namespaceObject, "isLocked", function() { return IsLocked_IsLocked; });
__webpack_require__.d(postCases_namespaceObject, "isNSFW", function() { return IsNSFW_IsNSFW; });
__webpack_require__.d(postCases_namespaceObject, "isSpoiler", function() { return IsSpoiler_IsSpoiler; });
__webpack_require__.d(postCases_namespaceObject, "isVisited", function() { return IsVisited_IsVisited; });
__webpack_require__.d(postCases_namespaceObject, "linkFlair", function() { return LinkFlair_LinkFlair; });
__webpack_require__.d(postCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(postCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(postCases_namespaceObject, "postTitle", function() { return PostTitle_PostTitle; });
__webpack_require__.d(postCases_namespaceObject, "postType", function() { return PostType_PostType; });
__webpack_require__.d(postCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(postCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(postCases_namespaceObject, "subreddit", function() { return Subreddit_Subreddit; });
__webpack_require__.d(postCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(postCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(postCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(postCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(postCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });
var readComments_namespaceObject = {};
__webpack_require__.r(readComments_namespaceObject);
__webpack_require__.d(readComments_namespaceObject, "module", function() { return readComments_module; });
__webpack_require__.d(readComments_namespaceObject, "isRead", function() { return isRead; });
var commentCases_namespaceObject = {};
__webpack_require__.r(commentCases_namespaceObject);
__webpack_require__.d(commentCases_namespaceObject, "commentContent", function() { return CommentContent_CommentContent; });
__webpack_require__.d(commentCases_namespaceObject, "commentLength", function() { return CommentLength_CommentLength; });
__webpack_require__.d(commentCases_namespaceObject, "depth", function() { return Depth_Depth; });
__webpack_require__.d(commentCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(commentCases_namespaceObject, "isDeleted", function() { return IsDeleted_IsDeleted; });
__webpack_require__.d(commentCases_namespaceObject, "isRead", function() { return IsRead_IsRead; });
__webpack_require__.d(commentCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(commentCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(commentCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(commentCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(commentCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(commentCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(commentCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(commentCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(commentCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });
var browseCases_namespaceObject = {};
__webpack_require__.r(browseCases_namespaceObject);
__webpack_require__.d(browseCases_namespaceObject, "browsingFrontPage", function() { return BrowsingFrontPage_BrowsingFrontPage; });
__webpack_require__.d(browseCases_namespaceObject, "currentLocation", function() { return CurrentLocation_CurrentLocation; });
__webpack_require__.d(browseCases_namespaceObject, "currentMulti", function() { return CurrentMulti_CurrentMulti; });
__webpack_require__.d(browseCases_namespaceObject, "currentUserProfile", function() { return CurrentUserProfile_CurrentUserProfile; });
__webpack_require__.d(browseCases_namespaceObject, "currentSub", function() { return CurrentSub_CurrentSub; });
__webpack_require__.d(browseCases_namespaceObject, "date", function() { return Date_Date; });
__webpack_require__.d(browseCases_namespaceObject, "dow", function() { return Dow_Dow; });
__webpack_require__.d(browseCases_namespaceObject, "loggedInAs", function() { return LoggedInAs_LoggedInAs; });
__webpack_require__.d(browseCases_namespaceObject, "toggle", function() { return Toggle_Toggle; });
var usernameHider_namespaceObject = {};
__webpack_require__.r(usernameHider_namespaceObject);
__webpack_require__.d(usernameHider_namespaceObject, "module", function() { return usernameHider_module; });
__webpack_require__.d(usernameHider_namespaceObject, "getDisplayText", function() { return getDisplayText; });
var quickMessage_namespaceObject = {};
__webpack_require__.r(quickMessage_namespaceObject);
__webpack_require__.d(quickMessage_namespaceObject, "module", function() { return quickMessage_module; });
__webpack_require__.d(quickMessage_namespaceObject, "onClickMessageLink", function() { return onClickMessageLink; });
__webpack_require__.d(quickMessage_namespaceObject, "openQuickMessageDialog", function() { return openQuickMessageDialog; });
var commentNavigator_namespaceObject = {};
__webpack_require__.r(commentNavigator_namespaceObject);
__webpack_require__.d(commentNavigator_namespaceObject, "module", function() { return commentNavigator_module; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateCustomConditions", function() { return updateCustomConditions; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateFromSelected", function() { return updateFromSelected; });
__webpack_require__.d(commentNavigator_namespaceObject, "setCategory", function() { return setCategory; });
__webpack_require__.d(commentNavigator_namespaceObject, "toggle", function() { return commentNavigator_toggle; });
__webpack_require__.d(commentNavigator_namespaceObject, "move", function() { return commentNavigator_move; });
var hideChildComments_namespaceObject = {};
__webpack_require__.r(hideChildComments_namespaceObject);
__webpack_require__.d(hideChildComments_namespaceObject, "module", function() { return hideChildComments_module; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggleAll", function() { return toggleAll; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggle", function() { return hideChildComments_toggle; });
var neverEndingReddit_namespaceObject = {};
__webpack_require__.r(neverEndingReddit_namespaceObject);
__webpack_require__.d(neverEndingReddit_namespaceObject, "module", function() { return neverEndingReddit_module; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "loadNextPage", function() { return loadNextPage; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "getNextPrevLinks", function() { return getNextPrevLinks; });
var noParticipation_namespaceObject = {};
__webpack_require__.r(noParticipation_namespaceObject);
__webpack_require__.d(noParticipation_namespaceObject, "module", function() { return noParticipation_module; });
__webpack_require__.d(noParticipation_namespaceObject, "isVotingBlocked", function() { return isVotingBlocked; });
__webpack_require__.d(noParticipation_namespaceObject, "nonNpLocation", function() { return nonNpLocation; });
__webpack_require__.d(noParticipation_namespaceObject, "notifyNoVote", function() { return notifyNoVote; });
var saveComments_namespaceObject = {};
__webpack_require__.r(saveComments_namespaceObject);
__webpack_require__.d(saveComments_namespaceObject, "module", function() { return saveComments_module; });
__webpack_require__.d(saveComments_namespaceObject, "showEducationalNotification", function() { return showEducationalNotification; });
var showParent_namespaceObject = {};
__webpack_require__.r(showParent_namespaceObject);
__webpack_require__.d(showParent_namespaceObject, "module", function() { return showParent_module; });
__webpack_require__.d(showParent_namespaceObject, "startHover", function() { return startHover; });
var singleClick_namespaceObject = {};
__webpack_require__.r(singleClick_namespaceObject);
__webpack_require__.d(singleClick_namespaceObject, "module", function() { return singleClick_module; });
__webpack_require__.d(singleClick_namespaceObject, "openTabs", function() { return openTabs; });
var keyboardNav_namespaceObject = {};
__webpack_require__.r(keyboardNav_namespaceObject);
__webpack_require__.d(keyboardNav_namespaceObject, "module", function() { return keyboardNav_module; });
var providers_namespaceObject = {};
__webpack_require__.r(providers_namespaceObject);
__webpack_require__.d(providers_namespaceObject, "File", function() { return File_File; });
__webpack_require__.d(providers_namespaceObject, "GoogleDrive", function() { return GoogleDrive_GoogleDrive; });
__webpack_require__.d(providers_namespaceObject, "OneDrive", function() { return OneDrive_OneDrive; });
__webpack_require__.d(providers_namespaceObject, "Dropbox", function() { return Dropbox_Dropbox; });
var subredditManager_namespaceObject = {};
__webpack_require__.r(subredditManager_namespaceObject);
__webpack_require__.d(subredditManager_namespaceObject, "module", function() { return subredditManager_module; });
__webpack_require__.d(subredditManager_namespaceObject, "createShortcutToggleButton", function() { return createShortcutToggleButton; });
__webpack_require__.d(subredditManager_namespaceObject, "getMultiCounts", function() { return getMultiCounts; });
__webpack_require__.d(subredditManager_namespaceObject, "subscribeToSubreddit", function() { return subscribeToSubreddit; });

// EXTERNAL MODULE: ./lib/options/handleBlocking.js
var handleBlocking = __webpack_require__(145);

// EXTERNAL MODULE: ./node_modules/lodash/once.js
var once = __webpack_require__(0);
var once_default = /*#__PURE__*/__webpack_require__.n(once);

// CONCATENATED MODULE: ./lib/environment/utils/messaging.js
class MessageHandlerError extends Error {
  constructor(message, stack) {
    super();
    this.message = message;
    this.stack = stack;
  }

}

function createMessageHandler(_sendMessage, errorOnUnrecognizedTypes = false) {
  const listeners = new Map();
  return {
    _handleMessage: function ({
      type,
      data
    }, sendResponse, context) {
      const listener = listeners.get(type);

      if (!listener) {
        if (errorOnUnrecognizedTypes) {
          sendResponse({
            error: {
              message: `Unrecognised message type: ${type}`,
              stack: ''
            }
          });
        }

        return false;
      }

      let response;

      try {
        response = listener(data, context);
      } catch (e) {
        console.error(e);
        sendResponse({
          error: {
            message: e.message,
            stack: e.stack
          }
        });
        return false;
      }

      if (response instanceof Promise) {
        response.then(data => sendResponse({
          data
        }), e => {
          console.error(e);
          sendResponse({
            error: {
              message: e.message,
              stack: e.stack
            }
          });
        });
        return true;
      } else {
        sendResponse({
          data: response
        });
        return false;
      }
    },
    sendMessage: async function (type, data, context) {
      const {
        data: newData,
        error
      } = await _sendMessage({
        type,
        data
      }, context);

      if (error) {
        throw new MessageHandlerError(error.message, `${error.stack}\n    at target's "${type}" handler`);
      } else {
        return newData;
      }
    },
    addListener: function (type, callback) {
      if (listeners.has(type)) {
        throw new Error(`Listener for "${type}" already exists.`);
      }

      listeners.set(type, callback);
    }
  };
}
// CONCATENATED MODULE: ./lib/environment/utils/api.js
function apiToPromise(func) {
  return (...args) => new Promise((resolve, reject) => func(...args, (...results) => {
    if (chrome.runtime.lastError) {
      reject(new Error(chrome.runtime.lastError.message));
    } else {
      resolve(results.length > 1 ? results : results[0]);
    }
  }));
}
// CONCATENATED MODULE: ./lib/environment/foreground/messaging.js



const _sendMessage = apiToPromise(chrome.runtime.sendMessage);

const {
  _handleMessage,
  sendMessage,
  addListener
} = createMessageHandler(obj => _sendMessage(obj));
chrome.runtime.onMessage.addListener((obj, sender, sendResponse) => _handleMessage(obj, sendResponse));

// CONCATENATED MODULE: ./lib/environment/foreground/privateBrowsing.js
function isPrivateBrowsing() {
  return chrome.extension.inIncognitoContext;
}
// CONCATENATED MODULE: ./lib/environment/foreground/history.js


async function addURLToHistory(url) {
  if (isPrivateBrowsing()) return;
  await sendMessage('addURLToHistory', url);
}
function isURLVisited(url) {
  return sendMessage('isURLVisited', url);
}
// EXTERNAL MODULE: ./node_modules/lodash/fromPairs.js
var fromPairs = __webpack_require__(122);
var fromPairs_default = /*#__PURE__*/__webpack_require__.n(fromPairs);

// CONCATENATED MODULE: ./lib/environment/foreground/xhrCache.js

function set(key, value) {
  return sendMessage('XHRCache', ['set', key, value]);
}
function xhrCache_check(key, maxAge) {
  return sendMessage('XHRCache', ['check', key, maxAge]);
}

function delete_(key) {
  return sendMessage('XHRCache', ['delete', key]);
}


function clear() {
  return sendMessage('XHRCache', ['clear']);
}
// CONCATENATED MODULE: ./lib/environment/foreground/ajax.js





class FetchError extends Error {
  constructor(url, status) {
    super(`${url} failed with status ${status}`);
    this.status = void 0;
    this.status = status;
  }

}

async function ajax(options) {
  const {
    method,
    url,
    headers,
    data,
    type,
    cacheFor,
    sameOrigin,
    credentials
  } = buildRequestParams(options);

  if (cacheFor) {
    const cached = await xhrCache_check(url, cacheFor);

    if (cached) {
      return processResponse(cached, type);
    }
  }

  const response = await (sameOrigin ? fetch(url, {
    method,
    headers,
    credentials,
    body: data
  }).then(async r => ({
    ok: r.ok,
    status: r.status,
    headers: fromPairs_default()(Array.from(r.headers.entries())),
    text: await r.text()
  })) : sendMessage('ajax', {
    method,
    url,
    headers,
    data,
    credentials
  }));

  if (!response.ok) {
    throw new FetchError(url, response.status);
  }

  if (cacheFor) {
    set(url, response);
  }

  return processResponse(response, type);
}

ajax.invalidate = options => delete_(buildRequestParams(options).url);

function buildRequestParams({
  method = 'GET',
  url,
  query = {},
  headers = {},
  data,
  type = 'text',
  credentials,
  cacheFor = 0
}) {
  const siteOrigin = new URL(context_data.origin);
  const requestURL = new URL(url, siteOrigin);

  for (const [key, val] of Object.entries(query)) {
    requestURL.searchParams.set(key, String(val));
  }

  const sameSite = requestURL.hostname.split('.').slice(-2).join('.') === siteOrigin.hostname.split('.').slice(-2).join('.');

  if (sameSite) {
    requestURL.searchParams.set('app', 'res');
    if (!credentials) credentials = 'include';

    if (method !== 'GET' && method !== 'HEAD') {
      if (context_data.userHash) headers['X-Modhash'] = context_data.userHash;
    }

    requestURL.hostname = requestURL.hostname.replace(/new\./, 'www.');
  }

  const sameOrigin = siteOrigin.origin === requestURL.origin;

  if (typeof data === 'object') {
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    data = new URLSearchParams(data).toString();
  }

  return {
    method,
    url: requestURL.href,
    headers,
    data,
    type,
    cacheFor,
    credentials: credentials || 'omit',
    sameOrigin
  };
}

function processResponse(response, type) {
  switch (type) {
    case 'text':
      return response.text;

    case 'json':
      return JSON.parse(response.text);

    case 'raw':
      return response;

    default:
      throw new Error(`Invalid type: ${type}`);
  }
}
// CONCATENATED MODULE: ./lib/environment/foreground/download.js

function download(url, filename) {
  sendMessage('download', {
    url: new URL(url, location.href).href,
    filename
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/id.js
function getExtensionId() {
  return chrome.runtime.id;
}
const getURL = chrome.runtime.getURL;
const getOptionsURL = (hash = '') => new URL(hash, getURL('options.html'));
const isOptionsPage = () => location.origin === getOptionsURL().origin;
// CONCATENATED MODULE: ./node_modules/exec-loader!./build/buildToken.js
/* harmony default export */ var buildToken = ("9854476423840821");
// CONCATENATED MODULE: ./lib/constants/localStorage.js
const CACHED_LANG_KEY = 'RES.i18nCachedLang';
const CACHED_MESSAGES_KEY = 'RES.i18nCachedMessages';
const CACHED_MESSAGES_TOKEN_KEY = 'RES.i18nCachedMessagesToken';
// CONCATENATED MODULE: ./lib/environment/foreground/i18n.js



const REDDIT_LANGUAGES = new Set(['en', 'af', 'ar', 'be', 'bg', 'bn-IN', 'bn-bd', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en-us', 'eo', 'es', 'es-ar', 'es-mx', 'et', 'eu', 'fa', 'fi', 'fil', 'fr', 'fr-ca', 'fy-NL', 'ga-ie', 'gd', 'gl', 'he', 'hi', 'hr', 'hu', 'hy', 'id', 'is', 'it', 'ja', 'kn_IN', 'ko', 'la', 'leet', 'lol', 'lt', 'lv', 'ms', 'mt-MT', 'nl', 'nn', 'no', 'pir', 'pl', 'pt', 'pt-pt', 'pt_BR', 'ro', 'ru', 'sk', 'sl', 'sr', 'sr-la', 'sv', 'ta', 'th', 'tr', 'uk', 'vi', 'zh', 'zh-cn']);
const SPECIAL_LANGUAGES = new Set(['leet', 'lol', 'pir']);
let i18n_locale = navigator.language || 'en';

function isValidLocale(localeString) {
  try {
    return typeof 0 .toLocaleString(localeString) === 'string';
  } catch (e) {
    return false;
  }
}

function getRedditLocale() {
  const redditLocale = typeof document !== 'undefined' && document.documentElement.getAttribute('lang');

  if (redditLocale && REDDIT_LANGUAGES.has(redditLocale)) {
    const locale = redditLocale.toLowerCase().replace('_', '-');

    if (isValidLocale(locale)) {
      requestIdleCallback(() => {
        sendMessage('setLastRedditLocale', locale);
      });
      return locale;
    }
  }

  return sendMessage('getLastRedditLocale');
}

let messages;
async function _loadI18n() {
  const redditLocale = await getRedditLocale();
  if (redditLocale && !SPECIAL_LANGUAGES.has(redditLocale)) i18n_locale = redditLocale;

  if (localStorage.getItem(CACHED_LANG_KEY) === redditLocale && localStorage.getItem(CACHED_MESSAGES_TOKEN_KEY) === buildToken) {
    try {
      messages = JSON.parse(localStorage.getItem(CACHED_MESSAGES_KEY) || '');
      return;
    } catch (e) {
      console.error('Failed to parse cached i18n', e);
    }
  }

  messages = await sendMessage('i18n', redditLocale);

  try {
    localStorage.setItem(CACHED_MESSAGES_KEY, JSON.stringify(messages));
    localStorage.setItem(CACHED_LANG_KEY, redditLocale);
    localStorage.setItem(CACHED_MESSAGES_TOKEN_KEY, buildToken);
  } catch (e) {
    console.error('Could not cache i18n - RES will load VERY slowly', e);
    localStorage.removeItem('ads.adserverDownvotePixel');
    localStorage.removeItem('ads.adserverUpvotePixel');
  }
}
function i18n(messageName, ...substitutions) {
  if (!messageName) return '';

  if (!messages) {
    console.error('i18n called too early! key:', messageName);
    return messageName;
  }

  const message = messages[messageName];
  if (!message) return messageName;
  if (substitutions.length === 0) return message;
  return message.replace(/\$(\d)\b(?!\$)/g, (match, number) => substitutions[number - 1]);
}
// EXTERNAL MODULE: ./node_modules/lodash/memoize.js
var memoize = __webpack_require__(1);
var memoize_default = /*#__PURE__*/__webpack_require__.n(memoize);

// EXTERNAL MODULE: ./node_modules/lodash/pull.js
var pull = __webpack_require__(6);
var pull_default = /*#__PURE__*/__webpack_require__.n(pull);

// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(3);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./node_modules/lodash/curryRight.js
var curryRight = __webpack_require__(51);
var curryRight_default = /*#__PURE__*/__webpack_require__.n(curryRight);

// EXTERNAL MODULE: ./node_modules/lodash/remove.js
var lodash_remove = __webpack_require__(52);
var remove_default = /*#__PURE__*/__webpack_require__.n(lodash_remove);

// CONCATENATED MODULE: ./lib/utils/generator.js
function* range(start, end) {
  for (let i = start; i < end; ++i) {
    yield i;
  }
}
function* zip(...iterables) {
  const generators = iterables.map(it => it[Symbol.iterator]());
  let results;

  while ((results = generators.map(gen => gen.next())).some(r => !r.done)) {
    yield results.map(r => r.value);
  }
}
// CONCATENATED MODULE: ./lib/utils/async.js






function waitFor(callback, interval = 1) {
  return new Promise(resolve => {
    (function repeat() {
      const val = callback();

      if (!val) {
        setTimeout(repeat, interval);
        return;
      }

      resolve(val);
    })();
  });
}
const forEachChunked = (() => {
  const queues = [];
  const run = frameThrottle(() => {
    const start = performance.now();

    do {
      remove_default()(queues, ({
        generator,
        callback,
        resolve,
        reject
      }) => {
        const {
          value,
          done
        } = generator.next();

        if (done) {
          resolve();
          return true;
        }

        try {
          callback(value);
        } catch (e) {
          if (generator.return) generator.return();
          reject(e);
          return true;
        }
      });

      if (!queues.length) {
        return;
      }
    } while (performance.now() - start < 1000 / 30);

    run();
  });
  return curryRight_default()((collection, callback) => new Promise((resolve, reject) => {
    const iterable = Symbol.iterator in collection ? collection : Array.from(collection);
    queues.push({
      generator: iterable[Symbol.iterator](),
      callback,
      resolve,
      reject
    });
    run();
  }));
})();
function batch(callback, {
  size = 100,
  delay = 50
} = {}) {
  function* batchAccumulator() {
    const entries = [];
    const promises = [];

    function addPromise() {
      if (entries.length) {
        return new Promise((resolve, reject) => {
          promises.push({
            resolve,
            reject
          });
        });
      } else {
        return undefined;
      }
    }

    const invoke = once_default()(async () => {
      startNewBatch();

      try {
        const results = (await callback(entries)) || [];

        for (const [{
          resolve,
          reject
        }, result] of zip(promises, results)) {
          if (result instanceof Error) reject(result);else resolve(result);
        }
      } catch (e) {
        for (const {
          reject
        } of promises) {
          reject(e);
        }
      }
    });

    const timeout = delay ? debounce_default()(invoke, delay) : async_throttle(invoke);

    while (entries.length < size) {
      const entry = yield addPromise();
      if (entry === undefined) throw new Error('undefined passed into batch generator');
      entries.push(entry);
      timeout();
    }

    const lastPromise = addPromise();
    invoke();
    yield lastPromise;
  }

  let currentBatch;

  function startNewBatch() {
    currentBatch = batchAccumulator();
    currentBatch.next();
  }

  startNewBatch();
  return entry => {
    const {
      value
    } = currentBatch.next(entry);
    if (value === undefined) throw new Error('Batch generator was not replaced after completion');
    return value;
  };
}

function always(promise, callback) {
  return promise.then(callback, callback);
}

function fastAsync(callback) {
  return function (...args) {
    return function next(generator, arg, throwing) {
      const {
        value,
        done
      } = !throwing ? generator.next(arg) : generator.throw(arg);

      if (done) {
        return value;
      } else if (!(value instanceof Promise)) {
        return next(generator, value, false);
      } else {
        return value.then(val => next(generator, val, false), err => next(generator, err, true));
      }
    }(Reflect.apply(callback, this, args), undefined, false);
  };
}
function asyncFlow(firstFn, ...fns) {
  return fastAsync(function* (...args) {
    let accum = firstFn(...args);

    for (const fn of fns) {
      accum = fn((yield accum));
    }

    return accum;
  });
}
function reifyPromise(promise) {
  let val = promise;
  promise.then(x => {
    val = x;
  });
  return {
    get: () => val
  };
}
function keyedMutex(callback, keyResolver = x => x) {
  const queues = new Map();
  return function (...args) {
    const key = keyResolver(...args);
    const tail = queues.has(key) ? always(queues.get(key), () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queues.set(key, tail);
      always(tail, () => {
        if (queues.get(key) === tail) queues.delete(key);
      });
    }

    return tail;
  };
}
function mutex(callback) {
  let queue;
  return function (...args) {
    const tail = queue ? always(queue, () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queue = tail;
      always(tail, () => {
        if (queue === tail) queue = undefined;
      });
    }

    return tail;
  };
}
function async_throttle(callback) {
  let promise;
  return () => {
    promise = promise || Promise.resolve().then(() => {
      promise = null;
      callback();
    });
    return promise;
  };
}
function frameDebounce(callback, debounce = 1) {
  let remaining;
  const update = frameThrottle(() => {
    if (remaining) requestAnimationFrame(() => {
      update();
    });else callback();
    remaining -= 1;
  });
  return () => {
    remaining = debounce;
    requestAnimationFrame(() => {
      update();
    });
  };
}
function frameThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestAnimationFrame(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}
const throttleQueuePositionReset = (() => {
  let queues = [];
  const run = async_throttle(() => {
    for (const fn of queues) {
      try {
        fn();
      } catch (e) {}
    }

    queues = [];
  });
  return function (callback) {
    let queued = false;
    return (...a) => {
      if (queued) {
        pull_default()(queues, callback);
      } else {
        queued = true;
      }

      queues.push(callback);
      run();
    };
  };
})();
function idleThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestIdleCallback(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}
// CONCATENATED MODULE: ./lib/environment/foreground/permissions.js




function filterPerms(perms) {
  const permissions = perms.filter(p => !p.includes('://') && p !== '<all_urls>');
  const origins = perms.filter(p => p.includes('://') || p === '<all_urls>');
  return {
    permissions,
    origins
  };
}

const permissions_has = memoize_default()(perms => sendMessage('permissions', {
  operation: 'contains',
  ...filterPerms(perms)
}), perms => perms.join(','));
const request = mutex(async perms => {
  if (await permissions_has(perms)) return;
  const {
    permissions,
    origins
  } = filterPerms(perms);
  const granted = await sendMessage('permissions', {
    operation: 'request',
    permissions,
    origins
  });

  if (granted) {
    permissions_has.cache.set(perms.join(','), true);
  } else {
    throw new Error(`Permission not granted for: ${perms.join(', ')}`);
  }
});
// CONCATENATED MODULE: ./lib/environment/foreground/auth.js


async function launchAuthFlow({
  domain,
  clientId,
  scope = '',
  permissions
}, warnUserInteraction) {
  if (permissions.length && !(await permissions_has(permissions))) {
    const resAuth = 'https://redditenhancementsuite.com/oauth';

    if ( true && !(await permissions_has([resAuth]))) {
      permissions.push(resAuth);
    }

    await warnUserInteraction(permissions.includes(resAuth) ? 'You may be redirected to redditenhancementsuite.com to complete the login process.' : '');
    await request(permissions);
  }

  let responseUrl;

  try {
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: false
    });
  } catch (e) {
    console.error('Noninteractive auth failed:', e);
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: true
    });
  }

  const hash = new URL(responseUrl).hash.slice(1);
  const token = new URLSearchParams(hash).get('access_token');
  if (!token) throw new Error('No token found in response.');
  return token;
}
// CONCATENATED MODULE: ./lib/environment/foreground/multicast.js

const callbacks = new Map();
addListener('multicast', ({
  name,
  args
}) => {
  const callback = callbacks.get(name);
  if (callback) return callback(...args);
});
function multicast(callback, {
  name,
  local = true,
  crossContext = true
}) {
  if (callbacks.has(name)) {
    throw new Error(`Multicast handler with name "${name}" exists.`);
  }

  callbacks.set(name, callback);

  function localOnly(...args) {
    callback(...args);
  }

  const invoke = (...args) => {
    sendMessage('multicast', {
      name,
      args,
      crossContext
    });

    if (local) {
      localOnly(...args);
    }
  };

  invoke.local = localOnly;
  return invoke;
}
// CONCATENATED MODULE: ./lib/environment/foreground/tabs.js

function openNewTab(url, focus = true) {
  return openNewTabs(focus, url);
}
function openNewTabs(focus, ...urls) {
  let focusIndex;
  if (typeof focus !== 'string') focus = !!focus;

  switch (focus) {
    case 'first':
      focusIndex = 0;
      break;

    case true:
    case 'last':
      focusIndex = urls.length - 1;
      break;

    case false:
    case 'none':
      focusIndex = -1;
      break;

    default:
      throw new Error(`Invalid focus specified: ${focus}`);
  }

  urls = urls.map(url => new URL(url, location.href).href);
  return sendMessage('openNewTabs', {
    urls,
    focusIndex
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/pageAction.js


const clickListeners = [];
function pageAction_onClick(callback) {
  clickListeners.push(callback);
}
addListener('pageActionClick', () => {
  for (const fn of clickListeners) fn();
});
const pageAction_update = frameThrottle(value => sendMessage('pageAction', value));
function show(state = false) {
  return pageAction_update({
    operation: 'show',
    state
  });
}
function pageAction_hide() {
  return pageAction_update({
    operation: 'hide'
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/session.js

function get(key) {
  return sendMessage('session', ['get', key]);
}
function session_set(key, value) {
  return sendMessage('session', ['set', key, value]);
}
function session_delete_(key) {
  return sendMessage('session', ['delete', key]);
}

function session_has(key) {
  return sendMessage('session', ['has', key]);
}
function session_clear() {
  return sendMessage('session', ['clear']);
}
// EXTERNAL MODULE: ./node_modules/lodash/transform.js
var transform = __webpack_require__(31);
var transform_default = /*#__PURE__*/__webpack_require__.n(transform);

// CONCATENATED MODULE: ./lib/utils/object.js
function extendDeep(target, source) {
  for (const key of Object.keys(source)) {
    if (target[key] && source[key] && typeof target[key] === 'object' && typeof source[key] === 'object' && !Array.isArray(source[key]) && !Array.isArray(target[key])) {
      extendDeep(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }

  return target;
}
function mapScalarToObject(option, value) {
  const object = {};
  option.fields.forEach((field, index) => {
    Object.defineProperty(object, field.key, {
      get: () => value[index],
      set: v => {
        value[index] = v;
      }
    });
  });
  return object;
}
// CONCATENATED MODULE: ./lib/environment/foreground/storage.js







const __set = apiToPromise((items, callback) => chrome.storage.local.set(items, callback));

const _set = (key, value) => __set({
  [key]: value
});

const __get = apiToPromise((keys, callback) => chrome.storage.local.get(keys, callback));

const _get = async (key, defaultValue = null) => (await __get({
  [key]: defaultValue
}))[key];

const _delete = apiToPromise((keys, callback) => chrome.storage.local.remove(keys, callback));

const _clear = apiToPromise(callback => chrome.storage.local.clear(callback));

const withLockOn = keyedMutex((key, fn) => fn());
function storage_get(key) {
  return withLockOn(key, () => _get(key, null));
}
function getAll() {
  return __get(null);
}
function getMultiple(keys) {
  const defaults = {};

  for (const k of keys) {
    defaults[k] = null;
  }

  return __get(defaults);
}
function storage_set(key, value) {
  return withLockOn(key, () => _set(key, value));
}
function setMultiple(valueMap) {
  return __set(valueMap);
}

function compareAndSet(key, defaultValue, oldValue, newValue) {
  return sendMessage('storage-cas', [key, defaultValue, oldValue, newValue]);
}

function patch(key, value) {
  return withLockOn(key, async () => {
    const extended = extendDeep((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function patchShallow(key, value) {
  return withLockOn(key, async () => {
    const extended = Object.assign((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function deletePaths(key, paths) {
  return withLockOn(key, async () => {
    const stored = await _get(key);
    if (!stored) return;

    for (const path of paths) {
      path.reduce((obj, key, i, {
        length
      }) => {
        if (!obj) return;
        if (i < length - 1) return obj[key];
        delete obj[key];
      }, stored);
    }

    return _set(key, stored);
  });
}

function storage_delete_(key) {
  return withLockOn(key, () => _delete(key));
}


function deleteMultiple(keys) {
  return _delete(keys);
}
function storage_has(key) {
  return withLockOn(key, async () => {
    const sentinel = Math.random();
    return (await _get(key, sentinel)) !== sentinel;
  });
}
async function storage_keys() {
  return Object.keys((await __get(null)));
}
function storage_clear() {
  return _clear();
}

class Wrapper {
  constructor(key, def) {
    this._key = void 0;
    this._default = void 0;
    this._key = key;
    this._default = def;
  }

  get() {
    return storage_get(this._key()).then(val => val === null ? this._default : val);
  }

  set(value) {
    return storage_set(this._key(), value);
  }

  patch(value) {
    return patch(this._key(), value);
  }

  compareAndSet(oldValue, newValue) {
    return compareAndSet(this._key(), this._default, oldValue, newValue);
  }

  deletePath(...path) {
    return deletePaths(this._key(), [path]);
  }

  delete() {
    return storage_delete_(this._key());
  }

  has() {
    return storage_has(this._key());
  }

}

function wrap(key, defaultValue) {
  const keyGenerator = typeof key === 'string' ? () => key : once_default()(key);
  return new Wrapper(keyGenerator, defaultValue);
}

class storage_PrefixWrapper {
  constructor(prefix, def, keyMapper, batching) {
    this._prefix = void 0;
    this._keyMapper = void 0;
    this._default = void 0;
    this._get = void 0;
    this._prefix = prefix;
    this._default = def;
    this._keyMapper = keyMapper;

    if (batching) {
      this._get = batch(async keys => {
        const v = await this.getMultipleNullable(keys);
        return keys.map(key => v[this._keyMapper(key)]);
      }, {
        size: Infinity,
        delay: 0
      });
    } else {
      this._get = key => storage_get(this._keyGen(key));
    }
  }

  _keyGen(key) {
    return this._prefix + this._keyMapper(key);
  }

  get(key) {
    return this._get(key).then(val => val === null ? this._default() : val);
  }

  getNullable(key) {
    return this._get(key);
  }

  async getAll() {
    const everything = await getAll();
    return transform_default()(everything, (acc, v, k) => {
      if (k.startsWith(this._prefix)) {
        acc[k.slice(this._prefix.length)] = v;
      }
    }, {});
  }

  async getMultiple(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return transform_default()(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v === null ? this._default() : v;
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return transform_default()(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v;
    }, {});
  }

  set(key, value) {
    return storage_set(this._keyGen(key), value);
  }

  patch(key, value) {
    return patch(this._keyGen(key), value);
  }

  deletePath(key, ...path) {
    return deletePaths(this._keyGen(key), [path]);
  }

  delete(key) {
    return storage_delete_(this._keyGen(key));
  }

  deleteMultiple(keys) {
    return deleteMultiple(keys.map(k => this._keyGen(k)));
  }

  has(key) {
    return storage_has(this._keyGen(key));
  }

}

function wrapPrefix(prefix, defaultValue, destructiveKeyMapper = x => x, batching = false) {
  return new storage_PrefixWrapper(prefix, defaultValue, destructiveKeyMapper, batching);
}

class storage_BlobWrapper {
  constructor(rootKey, def) {
    this._rootKey = void 0;
    this._default = void 0;
    this._rootKey = rootKey;
    this._default = def;
  }

  get(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? this._default() : val[key]);
  }

  getNullable(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? null : val[key]);
  }

  getAll() {
    return storage_get(this._rootKey).then(val => val === null ? {} : val);
  }

  async getMultiple(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return transform_default()(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? this._default() : rawValues[key];
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return transform_default()(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? null : rawValues[key];
    }, {});
  }

  set(key, value) {
    return patchShallow(this._rootKey, {
      [key]: value
    });
  }

  patch(key, value) {
    return patch(this._rootKey, {
      [key]: value
    });
  }

  deletePath(key, ...path) {
    return deletePaths(this._rootKey, [[key, ...path]]);
  }

  delete(key) {
    return deletePaths(this._rootKey, [[key]]);
  }

  deleteMultiple(keys) {
    return deletePaths(this._rootKey, keys.map(k => [k]));
  }

  has(key) {
    return storage_get(this._rootKey).then(val => val !== null && val[key] !== undefined);
  }

  clear() {
    return storage_delete_(this._rootKey);
  }

}

function wrapBlob(rootKey, defaultValue) {
  return new storage_BlobWrapper(rootKey, defaultValue);
}
// CONCATENATED MODULE: ./lib/environment/index.js




















// CONCATENATED MODULE: ./lib/utils/time.js
const MINUTE = 1000 * 60;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
function fromSecondsToTime(timeInSeconds) {
  const minutes = Math.floor(timeInSeconds / 60) % 60;
  const hours = Math.floor(timeInSeconds / 3600);
  const time = [minutes, timeInSeconds % 60];

  if (hours > 0) {
    time.unshift(hours);
  }

  return time.map(part => String(part).padStart(2, '0')).join(':');
}
// EXTERNAL MODULE: ./node_modules/lodash/partition.js
var partition = __webpack_require__(80);
var partition_default = /*#__PURE__*/__webpack_require__.n(partition);

// EXTERNAL MODULE: ./node_modules/lodash/assignIn.js
var assignIn = __webpack_require__(123);
var assignIn_default = /*#__PURE__*/__webpack_require__.n(assignIn);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(124);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./lib/utils/flow.js
function downcast(val, ty) {
  return val;
}
// CONCATENATED MODULE: ./lib/utils/dom.js






function waitForEvent(ele, ...events) {
  return Promise.race(events.map(event => new Promise(resolve => ele.addEventListener(event, function fire() {
    ele.removeEventListener(event, fire);
    resolve();
  }))));
}
function waitForChild(ele, selector) {
  return new Promise(resolve => {
    const child = Array.from(ele.children).find(child => child.matches(selector));

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
            observer.disconnect();
            resolve(downcast(node, HTMLElement));
            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true
    });
  });
}
function watchForChildren(ele, selector, callback) {
  for (const child of Array.from(ele.children).filter(child => child.matches(selector))) {
    callback(child);
  }

  watchForFutureChildren(ele, selector, callback);
}
function watchForFutureChildren(ele, selector, callback) {
  new MutationObserver(mutations => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
          callback(downcast(node, HTMLElement));
        }
      }
    }
  }).observe(ele, {
    childList: true
  });
}
function waitForDescendant(ele, selector) {
  return new Promise(resolve => {
    const child = ele.querySelector(selector);

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const child = ele.querySelector(selector);

            if (child) {
              observer.disconnect();
              resolve(child);
            }

            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForFutureDescendant(ele, selector, {
  added = false,
  removed = false
} = {
  added: true,
  removed: false
}) {
  return new Promise(resolve => {
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of [...(added ? mutation.addedNodes : []), ...(removed ? mutation.removedNodes : [])]) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const child = ele.querySelector(selector);

            if (child) {
              observer.disconnect();
              resolve(child);
            }

            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForRemoval(el, cancel) {
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.removedNodes) {
          if (node.contains(el)) {
            observer.disconnect();
            resolve();
          }
        }
      }
    });
    observer.observe(document.body, {
      subtree: true,
      childList: true
    });
    if (cancel) cancel.then(() => {
      observer.disconnect();
      reject(new Error('Canceled'));
    });
  });
}
function watchForDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  for (const child of ele.querySelectorAll(selector)) {
    callback(child);
  }

  watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches);
}
function watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  new MutationObserver(mutations => {
    const children = new Set();

    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.matches(selector)) {
            children.add(node);
            if (ignoreChildrenIfAddedNodeMatches) continue;
          }

          for (const child of node.querySelectorAll(selector)) {
            children.add(child);
          }
        }
      }
    }

    for (const child of children) {
      callback(downcast(child, HTMLElement));
    }
  }).observe(ele, {
    childList: true,
    subtree: true
  });
}
function empty(parent) {
  while (parent.lastChild) parent.removeChild(parent.lastChild);

  return parent;
}
function click(obj, button = 0) {
  obj.dispatchEvent(new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    detail: 0,
    screenX: 1,
    screenY: 1,
    clientX: 1,
    clientY: 1,
    button
  }));
}

click.isProgrammaticEvent = e => e.clientX === 1 && e.clientY === 1;

const getViewportSize = memoize_default()(() => {
  waitForEvent(window, 'resize').then(() => {
    getViewportSize.cache.clear();
  });
  let visualViewport;

  if (window.visualViewport) {
    visualViewport = window.visualViewport;
  } else {
    const viewportSizedElement = document.createElement('div');
    viewportSizedElement.style.width = viewportSizedElement.style.height = '100%';
    viewportSizedElement.style.position = 'fixed';
    document.body.appendChild(viewportSizedElement);
    visualViewport = viewportSizedElement.getBoundingClientRect();
    viewportSizedElement.remove();
  }

  return pick_default()(visualViewport, ['height', 'width']);
});
function elementInViewport(ele) {
  if (!ele || !ele.offsetParent) return false;
  const {
    top,
    left,
    bottom,
    right
  } = ele.getBoundingClientRect();
  return top >= 0 && left >= 0 && bottom <= getViewportSize().height && right <= getViewportSize().width;
}

function getViewportDimensions() {
  const headerOffset = getHeaderOffset();
  const left = window.pageXOffset;
  const top = window.pageYOffset + headerOffset;
  const width = getViewportSize().width;
  const height = getViewportSize().height - headerOffset;
  return {
    yOffset: headerOffset,
    left,
    top,
    bottom: top + height,
    right: left + width,
    width,
    height
  };
}

function getPercentageVisibleYAxis(obj) {
  const rect = obj.getBoundingClientRect();
  const top = Math.max(0, rect.bottom - rect.height);
  const bottom = Math.min(getViewportSize().height, rect.bottom);

  if (rect.height === 0) {
    return 0;
  }

  return Math.max(0, (bottom - top) / rect.height);
}

const padBottom = once_default()(() => {
  const element = document.createElement('div');
  element.style.clear = 'both';
  return (scrollTop, viewportHeight) => {
    const currentPadding = element.clientHeight;
    const paddingRequired = 50 + -(document.documentElement.scrollHeight - scrollTop - viewportHeight - currentPadding);
    if (paddingRequired > 0) document.body.append(element);else element.remove();
    element.style.height = `${paddingRequired}px`;
  };
});

let recentScroll = false;
let scrollInvokationToken;
function scrollToElement(to, from, {
  scrollStyle,
  restrictDirectionTo,
  direction: selectedDirection,
  anchor,
  waitTillVisible
}) {
  const _scrollInvokationToken = scrollInvokationToken = {};

  if (waitTillVisible && !to.offsetParent) {
    return new Promise(res => {
      requestAnimationFrame(() => {
        if (scrollInvokationToken !== _scrollInvokationToken) return;
        (scrollToElement(...arguments) || Promise.resolve()).then(res);
      });
    });
  }

  if (scrollStyle === 'none' && !anchor) {
    return;
  }

  if (!to.offsetParent) {
    console.error('Element is not visible.');
    return;
  }

  if (scrollStyle === 'none' && anchor) {
    const diff = to.getBoundingClientRect().top - anchor.to;
    if (diff) window.scrollBy(0, diff);
  }

  const viewport = getViewportDimensions();

  const target = assignIn_default()({}, to.getBoundingClientRect());

  target.top -= viewport.yOffset;
  target.bottom -= viewport.yOffset;
  const top = viewport.top + target.top - 5;

  if (scrollStyle === 'middle' && target.height >= viewport.height) {
    scrollStyle = 'top';
  }

  let compensateHeader = true;
  let scrollY;

  if (scrollStyle === 'top') {
    padBottom()(top, viewport.height);
    scrollY = top;
  } else if (from && scrollStyle === 'adopt') {
    const fromTop = anchor && typeof anchor.from === 'number' ? anchor.from : from.getBoundingClientRect().top;
    let diff = to.getBoundingClientRect().top - fromTop;

    if (fromTop < 0) {
      diff += fromTop;
    } else if (fromTop > viewport.height - 60) {
      diff += fromTop - viewport.height + 60;
    }

    scrollY = window.scrollY + diff;
    compensateHeader = false;
  } else if (scrollStyle === 'middle') {
    const buffer = (viewport.height - target.height) / 2;
    const newScrollY = top - buffer;

    if (elementInViewport(to)) {
      const viewportDirection = newScrollY >= window.scrollY ? 'down' : 'up';
      if (viewportDirection !== selectedDirection) return;
    }

    scrollY = newScrollY;
  } else if (target.top >= 0 && target.bottom <= viewport.height) {} else if (scrollStyle === 'legacy') {
    scrollY = top;
  } else if (target.top < viewport.yOffset) {
    scrollY = top;
  } else if (viewport.height < target.bottom && target.height < viewport.height) {
    if (scrollStyle === 'page') {
      scrollY = top;
    } else {
      scrollY = viewport.top + target.bottom - viewport.height;
    }
  } else {
    scrollY = top;
  }

  if (scrollY !== undefined) {
    if (compensateHeader) scrollY -= getHeaderOffset();
    const scollDirection = scrollY > viewport.top ? 'down' : 'up';
    if (viewport.top === scrollY || restrictDirectionTo && restrictDirectionTo !== scollDirection) return;
    window.scrollTo(0, scrollY);
    recentScroll = true;
    waitForEvent(window, 'scroll').then(() => {
      recentScroll = false;
    });
  }
}

scrollToElement.isProgrammaticEvent = () => recentScroll;

class dom_EdgeScroll {
  constructor(element) {
    this.distanceStartScrolling = 40;
    this.element = void 0;
    this.update = frameThrottle(e => {
      let scrollElement = this.element;

      while (scrollElement = this.findBlocker(scrollElement)) {
        const distances = {
          top: Math.ceil(e.clientY - Math.max(0, scrollElement.getBoundingClientRect().top)),
          bottom: Math.ceil(Math.min(getViewportSize().height, scrollElement === document.documentElement ? getViewportSize().height : scrollElement.getBoundingClientRect().bottom) - e.clientY)
        };

        if (distances.top < this.distanceStartScrolling) {
          scrollElement.scrollTop -= this.distanceStartScrolling - distances.top;
        } else if (distances.bottom < this.distanceStartScrolling) {
          scrollElement.scrollTop += this.distanceStartScrolling - distances.bottom;
        } else {
          continue;
        }

        this.update(e);
      }
    });
    this.element = element;
  }

  findBlocker(b) {
    const _e = b.getBoundingClientRect();

    let p = b;

    while (p = p.parentElement) {
      const _p = p.getBoundingClientRect();

      if (p.scrollHeight - 1 > _p.height && (_p.top > _e.top || _e.bottom > _p.bottom)) return p;
    }
  }

  start() {
    window.addEventListener('mousemove', this.update);
  }

  stop() {
    window.removeEventListener('mousemove', this.update);
  }

}
const dom_headerIds = {
  fullWidth: [],
  partialWidth: []
};
function _addHeaderId(elementId, partialWidth = false) {
  dom_headerIds[partialWidth ? 'partialWidth' : 'fullWidth'].push(elementId);
}
const getHeaderOffset = memoize_default()((includePartialWidthHeaders = false) => {
  const headers = [...dom_headerIds.fullWidth, ...(includePartialWidthHeaders ? dom_headerIds.partialWidth : [])];
  return headers.map(id => document.getElementById(id)).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
});
const getD2xBodyOffset = memoize_default()(() => {
  try {
    return document.getElementById('2x-container').offsetTop;
  } catch (e) {
    return 65;
  }
});
function addCSS(css) {
  let style = addStyle(css);
  return {
    remove() {
      if (!style) return;
      style.remove();
      style.textContent = '';
      style = undefined;
    }

  };
}

function addStyle(css) {
  const style = document.createElement('style');
  style.textContent = css;
  (document.head || document.documentElement).appendChild(style);
  return style;
}

const preventCloning = (() => {
  if (typeof window === 'undefined') return e => e;
  const attribute = `res-prevent-cloning-${Date.now()}`;
  const elements = new WeakSet();
  waitForEvent(window, 'DOMContentLoaded', 'load').then(() => {
    watchForFutureDescendants(document.body, `[${attribute}]`, e => {
      if (!elements.has(e)) e.remove();
    });
  });
  return element => {
    element.setAttribute(attribute, '');
    elements.add(element);
    return element;
  };
})();
// CONCATENATED MODULE: ./lib/utils/location.js




function matchesPageLocation(includes, excludes = []) {
  const [includeStrings, includeRegExps] = partition_default()(includes, x => typeof x === 'string');

  const [excludeStrings, excludeRegExps] = partition_default()(excludes, x => typeof x === 'string');

  return (!excludes.length || !(isPageType(...excludeStrings) || isAppType(...excludeStrings) || matchesPageRegex(...excludeRegExps))) && (!includes.length || isPageType(...includeStrings) || isAppType(...includeStrings) || matchesPageRegex(...includeRegExps));
}
const regexes = {
  frontpage: /^\/(?:hot|new|rising|controversial|top)?(?:\/|$)/i,
  comments: /^\/(?:r\/([\w\.]+)\/|(u(?:ser)?\/[\w-]+)\/)?comments\/([a-z0-9]+)(?:\/|$)/i,
  commentsLinklist: /^\/(?:r\/[\w\.\+]+\/|u(?:ser)?\/[\w-]+\/)?comments\/?$/i,
  inbox: /^\/(?:r\/([\w\.]+)\/)?message(?:\/|$)/i,
  profile: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profile2x: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profileCommentsPage: /^\/user\/([\w\-]+)\/comments\/([a-z0-9]+)(?:\/|$)/i,
  submit: /^\/(?:r\/([\w\.\+]+)\/)?submit(?:\/|$)/i,
  prefs: /^\/prefs(?:\/|$)/i,
  account: /^\/account-activity(?:\/|$)/i,
  wiki: /^\/(?:r\/([\w\.]+)\/)?wiki(?:\/|$)/i,
  stylesheet: /^\/(?:r\/([\w\.]+)\/)about\/stylesheet(?:\/|$)/i,
  search: /^\/(?:r\/[\w\.\+]+\/|(?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+\/|domain\/[^\/]+\/)?search(?:\/|$)/i,
  commentPermalink: /^\/(?:r\/([\w\.]+)\/)?comments\/([a-z0-9]+)\/[^\/]*\/([a-z0-9]+)(?:\/|$)/i,
  duplicates: /^\/r\/[\w\.\+]+\/duplicates\/([a-z0-9]+)/i,
  subreddit: /^\/r\/([\w\.\+]+)(?:\/|$)/i,
  subredditAbout: /^\/r\/([\w\.]+)\/about(?:\/(?!modqueue|reports|spam|unmoderated|edited)|$)/i,
  modqueue: /^\/(?:r|me\/f)\/([\w\.\+]+)\/about\/(?:modqueue|reports|spam|unmoderated|edited)(?:\/|$)/i,
  multireddit: /^\/((?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+)(?:\/|$)/i,
  domain: /^\/domain\/([\w\.]+)(?:\/|$)/i,
  composeMessage: /^\/(?:r\/([\w\.\+]+)\/)?message\/compose(?:\/|$)/i,
  liveThread: /^\/live\/(?!create(?:\/|$))([a-z0-9]+)(?:\/|$)/i
};
const execRegexes = {
  comments: path => {
    const match = regexes.comments.exec(path);
    if (!match) return match;
    match.splice(1, 2, match[1] || match[2] && match[2].replace(/^u.*\//, 'u_'));
    return match;
  }
};
const appType = once_default()(() => {
  if (document.documentElement.hasAttribute('res-options')) {
    return 'options';
  }

  if (document.documentElement.getAttribute('xmlns')) {
    return 'r2';
  }

  return 'd2x';
});
function isAppType(...types) {
  const thisApp = appType();
  return types.some(type => type === thisApp);
}
const appPageTypes = {
  r2: {
    default: 'linklist',
    pageTypes: ['wiki', 'search', 'stylesheet', 'modqueue', 'subredditAbout', 'comments', 'commentsLinklist', 'profile', 'liveThread', 'inbox', 'submit', 'account', 'prefs']
  },
  d2x: {
    pageTypes: ['profile2x', 'profileCommentsPage', 'submit']
  },
  options: {
    pageTypes: []
  }
};
const pageType = memoize_default()(() => {
  waitForEvent(document, 'reddit.urlChanged').then(() => {
    pageType.cache.clear();
  });
  const spec = appPageTypes[appType()];
  return spec.pageTypes.find(pageType => regexes[pageType].test(location.pathname)) || spec.default;
});
function isPageType(...types) {
  const thisPage = pageType();
  return types.some(type => type === thisPage);
}
function matchesPageRegex(...regexps) {
  return regexps.some(regex => regex.test(location.pathname));
}
const currentSubreddit = once_default()(() => {
  const match = location.pathname.match(regexes.subreddit);
  if (match) return match[1];
});
function isCurrentSubreddit(...subreddits) {
  const sub = (currentSubreddit() || '').toLowerCase();
  if (!sub) return false;
  return subreddits.some(v => v.toLowerCase() === sub);
}
const currentMultireddit = once_default()(() => {
  const match = location.pathname.match(regexes.multireddit);
  if (match) return match[1];
});
function isCurrentMultireddit(...multireddits) {
  const multi = (currentMultireddit() || '').toLowerCase();
  if (!multi) return false;
  return multireddits.some(v => v.toLowerCase() === multi);
}
const currentDomain = once_default()(() => {
  const match = location.pathname.match(regexes.domain);
  if (match) return match[1];
});
const currentUserProfile = once_default()(() => {
  const match = location.pathname.match(regexes.profile);
  if (match) return match[1];
});
const fullLocation = once_default()(() => {
  const regex = Object.keys(regexes).find(key => location.pathname.match(regexes[key]));
  if (!regex) return location.pathname.toLowerCase();
  return [regex, ...(location.pathname.match(regexes[regex]) || []).slice(1)].filter(v => v).join('-').toLowerCase();
});
const COMMENT_CODE_REGEX = /^[\/#].+$/;
function isCommentCode(link) {
  const href = link.getAttribute('href');
  const emptyText = link.textContent.length === 0;
  const isCommentCode = COMMENT_CODE_REGEX.test(href);
  return emptyText && isCommentCode;
}
function isEmptyLink(link) {
  const href = link.getAttribute('href');
  return typeof href !== 'string' || href.startsWith('javascript:') || href === '#';
}
const inQuarantinedSubreddit = once_default()(() => document.body.classList.contains('quarantine'));
// EXTERNAL MODULE: ./node_modules/lodash/fp/flow.js
var flow = __webpack_require__(2);
var flow_default = /*#__PURE__*/__webpack_require__.n(flow);

// EXTERNAL MODULE: ./node_modules/lodash/zipWith.js
var zipWith = __webpack_require__(27);
var zipWith_default = /*#__PURE__*/__webpack_require__.n(zipWith);

// EXTERNAL MODULE: ./node_modules/fast-levenshtein/levenshtein.js
var levenshtein = __webpack_require__(125);
var levenshtein_default = /*#__PURE__*/__webpack_require__.n(levenshtein);

// CONCATENATED MODULE: ./lib/utils/html.js
const escapeLookups = {
  '&': '&amp;',
  '"': '&quot;',
  "'": '&apos;',
  '<': '&lt;',
  '>': '&gt;',
  '/': '&#47;'
};
function escapeHTML(str) {
  return str ? str.toString().replace(/[&"'<>\/]/g, m => escapeLookups[m]) : '';
}
// CONCATENATED MODULE: ./lib/utils/string.js






function stringTagFunction(valueTransform) {
  return (strings, ...values) => zipWith_default()(strings, values.map(valueTransform), (s, v) => `${s}${v === undefined ? '' : v}`).join('');
}

const encode = stringTagFunction(encodeURIComponent);
const string_escape = stringTagFunction(escapeHTML);
function safe(str) {
  return {
    __safe__: str
  };
}
const MAX_DISTANCE_RATIO = 0.05;
function areSimilar(a, b) {
  return levenshtein_default.a.get(a, b) <= MAX_DISTANCE_RATIO * Math.max(a.length, b.length);
}
const regexRegex = /^\/(.*)\/([gimu]+)?$/;
const htmlTagFunction = stringTagFunction(x => {
  if (typeof x === 'number') return String(x);
  if (!x) return '';
  if (typeof x === 'string') return escapeHTML(x);
  if (Array.isArray(x)) return x.map(s => s.__safe__).join('');
  if (x.hasOwnProperty('__safe__')) return x.__safe__;
  throw new TypeError(`Invalid html template interpolation: ${String(x)}`);
});
const string_html = flow_default()(htmlTagFunction, markup => {
  const template = document.createElement('div');
  template.innerHTML = markup;

  if (template.childElementCount !== 1) {
    throw new Error(`Html template should have exactly one root node, but had ${template.childElementCount}`);
  }

  const child = downcast(template.firstElementChild, HTMLElement);
  child.remove();
  return child;
});
const _html = flow_default()(htmlTagFunction, safe);
// CONCATENATED MODULE: ./lib/utils/user.js





const isLoggedIn = once_default()(() => {
  if (loggedInUser()) {
    return true;
  } else if (document.querySelector('header a[href^="/message/inbox"]')) {
    return true;
  }
});
const loggedInUser = once_default()(() => documentLoggedInUser(document));
const documentLoggedInUser = document => {
  if (isAppType('d2x')) {
    const findFirstTextNode = e => [...e.childNodes].filter(v => v.nodeType === 3).concat(...[...e.children].map(findFirstTextNode));

    const button = document.querySelector('#USER_DROPDOWN_ID > *');
    const username = button && findFirstTextNode(button)[0];
    return username && username.textContent;
  }

  const link = document.querySelector('#header-bottom-right > span.user > a');
  if (!link || link.classList.contains('login-required')) return;
  const profile = regexes.profile.exec(link.pathname);

  if (profile) {
    return profile[1];
  }
};
const isModeratorAnywhere = once_default()(() => !!document.getElementById('modmail'));
const loggedInUserHash = once_default()(async () => {
  const hashEle = document.querySelector('[name=uh]');

  if (hashEle instanceof HTMLInputElement) {
    return hashEle.value;
  }

  const userInfo = await loggedInUserInfo();
  return userInfo && userInfo.data && userInfo.data.modhash;
});
const loggedInUserInfo = once_default()(() => !isLoggedIn() ? Promise.resolve() : ajax({
  url: '/api/me.json',
  type: 'json'
}).then(data => data.data && data.data.modhash ? data : undefined));
const usernameRE = /(?:u|user)\/([\w\-]{3,20}(?![\w\-]))/;
const usernameSelector = ['.contents .author', 'p.tagline a.author', '#friend-table span.user a', '.sidecontentbox .author', 'div.md a[href^="/u/"]:not([href*="/m/"])', 'div.md a[href*="reddit.com/u/"]:not([href*="/m/"])', '.usertable a.author', '.parent > a.author', '.usertable span.user a', 'div.wiki-page-content .author', '.Post__authorLink'].join(', ');
function getUsernameFromLink(element) {
  if (!(element instanceof HTMLAnchorElement)) return;
  const {
    href,
    origin
  } = element;
  if (!location.origin.endsWith(origin.split('.').slice(-2).join('.'))) return;
  const [, username] = href.match(usernameRE) || [];
  if (username) return username;
}
function getUserInfo(username = loggedInUser()) {
  if (!username) {
    return Promise.reject(new Error('getUserInfo: null/undefined username'));
  }

  return ajax({
    url: encode`/user/${username}/about.json`,
    type: 'json',
    cacheFor: 10 * MINUTE
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/context.js

const context_data = {
  userHash: null,
  username: null,
  origin: 'https://www.reddit.com'
};
function establish(contentStart) {
  context_data.origin = location.origin;
  contentStart.then(() => {
    context_data.username = loggedInUser();
    loggedInUserHash().then(hash => {
      context_data.userHash = hash;
    });
  });
}
// EXTERNAL MODULE: ./node_modules/lodash/fp/once.js
var fp_once = __webpack_require__(126);
var fp_once_default = /*#__PURE__*/__webpack_require__.n(fp_once);

// CONCATENATED MODULE: ./lib/constants/urlHashes.js
const RES_DISABLED_HASH = '#res:disabled';
const RES_SETTINGS_HASH = '#res:settings';
const RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH = '#res:settings-redirect-standalone-options-page';
const RES_NER_PAGE_HASH = '#res:ner-page';
// CONCATENATED MODULE: ./lib/utils/Cache.js
class LRUCache {
  constructor(capacity) {
    this.map = void 0;
    this.capacity = void 0;
    this.map = new Map();
    this.capacity = capacity;
  }

  get(key, maxAge = Infinity) {
    const now = Date.now();
    const entry = this.map.get(key);

    if (entry && now - entry.createTime < maxAge) {
      entry.hitTime = now;
      return entry.value;
    }
  }

  set(key, value) {
    const now = Date.now();
    this.map.set(key, {
      value,
      createTime: now,
      hitTime: now
    });

    if (this.map.size > this.capacity) {
      Array.from(this.map.entries()).sort(([, a], [, b]) => b.hitTime - a.hitTime).slice(this.capacity / 2 | 0).forEach(([key]) => this.map.delete(key));
    }

    return this;
  }

  delete(key) {
    return this.map.delete(key);
  }

  clear() {
    this.map.clear();
  }

}
// CONCATENATED MODULE: ./lib/utils/array.js


async function forEachSeq(iterable, callback) {
  for (const val of iterable) {
    await callback(val);
  }
}
async function asyncFilter(array, predicate) {
  const shouldKeep = await Promise.all(array.map(predicate));
  return array.filter((e, i) => shouldKeep[i]);
}
async function asyncReduce(iterable, callback, initialValue) {
  let accumulator = initialValue;

  for (const val of iterable) {
    accumulator = await callback(accumulator, val);
  }

  return accumulator;
}
const asyncFind = fastAsync(function* (iterable, predicate) {
  for (const val of iterable) {
    if (yield predicate(val)) return val;
  }
});

function concurrentFold(array, reduce, initialValue, baseCase) {
  if (!array.length) return Promise.resolve(initialValue);
  return new Promise((resolve, reject) => {
    let remaining = array.length;
    let accum = initialValue;

    function onResolve(x) {
      if (remaining === 0) return;
      accum = reduce(accum, x);

      if (accum === baseCase || --remaining === 0) {
        remaining = 0;
        resolve(accum);
      }
    }

    function onReject(err) {
      if (remaining === 0) return;
      remaining = 0;
      reject(err);
    }

    array.forEach(promise => promise.then(onResolve, onReject));
  });
}

function asyncSome(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a || !!b, false, true);
}
function asyncEvery(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a && !!b, true, false);
}
const filterMap = curryRight_default()((iterable, callback) => {
  const mapped = [];

  for (const x of iterable) {
    const result = callback(x);
    if (result) mapped.push(result[0]);
  }

  return mapped;
});
// CONCATENATED MODULE: ./lib/utils/Thing.js






const elementMap = new WeakMap();
const Thing_things = new Set();
const SECRET_TOKEN = new class {}();

const thingElementsCached = memoize_default()(doc => {
  waitForFutureDescendant(doc, Thing_Thing.thingSelector, {
    added: true,
    removed: true
  }).then(() => thingElementsCached.cache.delete(doc));
  return Array.from(doc.querySelectorAll(Thing_Thing.thingSelector));
});

class Thing_Thing {
  static thingElements(doc = document.body, topLevelOnly = false) {
    const loading = document.readyState === 'loading';
    const eles = thingElementsCached(doc);
    if (!loading && !topLevelOnly) return eles;
    const topLevels = eles.filter(e => !e.parentElement.closest(Thing_Thing.thingSelector));

    if (loading) {
      let last = topLevels.slice(-1)[0];

      if (last) {
        do {
          if (last.nextElementSibling) break;
        } while (last = last.parentElement);

        if (!last) {
          const incomplete = topLevels.pop();

          if (incomplete) {
            eles.splice(eles.indexOf(incomplete), Infinity);
          }
        }
      }
    }

    return topLevelOnly ? topLevels : eles;
  }

  static things(doc) {
    return Thing_Thing.thingElements(doc).map(e => Thing_Thing.checkedFrom(e));
  }

  static visibleThingElements(doc) {
    return Thing_Thing.thingElements(doc).filter(v => v.offsetParent);
  }

  static visibleThings(doc) {
    return filterMap(Thing_Thing.visibleThingElements(doc), ele => {
      const thing = Thing_Thing.from(ele);
      if (thing) return [thing];
    });
  }

  static runTasksRange(a, b, marginTop, marginBottom) {
    let top, bottom;

    if (a && b) {
      [top, bottom] = a.getDirectionOf(b) === 'down' ? [a, b] : [b, a];
    } else if (a || b) {
      top = bottom = downcast(a || b, Thing_Thing);
    } else {
      return;
    }

    const thingElements = Thing_Thing.thingElements();
    let tidx = thingElements.indexOf(top.element);
    let bidx = thingElements.indexOf(bottom.element);
    let thing;

    for (const e of thingElements.slice(tidx, bidx + 1)) {
      thing = Thing_Thing.checkedFrom(e);
      if (thing.tasks.completed) continue;
      if (thing.isVisible()) thing.runTasks();
    }

    while ((thing = Thing_Thing.from(thingElements[--tidx])) && (marginTop > 0 || thing.parent)) {
      if (thing.tasks.completed || thing.isVisible()) {
        marginTop--;
        thing.runTasks();
      }
    }

    while ((thing = Thing_Thing.from(thingElements[++bidx])) && (marginBottom > 0 || thing.parent)) {
      if (thing.tasks.completed || thing.isVisible()) {
        marginBottom--;
        thing.runTasks();
      }
    }
  }

  static checkedFrom(element) {
    const thing = Thing_Thing.from(element);

    if (!thing) {
      throw new Error(`Could not construct Thing from ${String(element)}`);
    }

    return thing;
  }

  static from(element) {
    if (!element) return null;
    if (element instanceof Thing_Thing) return element;
    const thingElement = element.closest(Thing_Thing.thingSelector);
    if (!thingElement) return null;
    if (elementMap.has(thingElement)) return elementMap.get(thingElement);
    const entry = thingElement.querySelector(Thing_Thing.entrySelector) || thingElement;
    const thing = new Thing_Thing(SECRET_TOKEN, downcast(thingElement, HTMLElement), entry);
    elementMap.set(thingElement, thing);
    Thing_things.add(thing);
    return thing;
  }

  constructor(token, thing, entry) {
    this.element = void 0;
    this.entry = void 0;
    this.parent = void 0;
    this.children = new Set();
    this.tasks = {
      completed: false,
      visible: [],
      immediate: [],
      byId: new Map()
    };
    this.refreshPartialVisibility = throttleQueuePositionReset(() => {
      this.element.classList.toggle('res-thing-partial', this.isHiddenByFilter(true) && (this.element.matches('.morerecursion, .morechildren') || Array.from(this.children).some(v => !v.isHiddenByFilter())));
    });

    if (token !== SECRET_TOKEN) {
      throw new Error('Use Thing.from() or Thing.checkedFrom() instead of new Thing()');
    }

    this.element = thing;
    this.entry = entry;
    const _p = this.element.parentElement;
    this.parent = _p && Thing_Thing.from(_p.closest('.thing'));
    if (this.parent) this.parent.children.add(this);
  }

  runTasks() {
    if (this.tasks.completed) return;
    this.tasks.immediate.map(fn => fn());
    this.tasks.visible.map(fn => fn());
  }

  select() {
    Thing_Thing.selected = this;
  }

  anchor() {
    const anchor = getPercentageVisibleYAxis(this.entry) && {
      to: this.entry.getBoundingClientRect().top
    };
    if (!anchor) return;
    requestAnimationFrame(() => {
      if (!this.entry.offsetParent) return;
      scrollToElement(this.entry, undefined, {
        scrollStyle: 'none',
        anchor
      });
    });
  }

  setHideFilter(match) {
    this.element.classList.toggle('res-thing-filter-hide', !!match);

    if (this.isComment()) {
      this.refreshPartialVisibility();

      for (const p of this.getParents()) p.refreshPartialVisibility();
    }
  }

  setFilterReasons(elements) {
    for (const old of this.element.querySelectorAll('.res-thing-filter-remove-matching-entry')) old.remove();

    this.element.prepend(...elements);
  }

  getDirectionOf(other) {
    if (!this.isVisible() || !other.isVisible()) return;
    return other.entry.compareDocumentPosition(this.entry) & Node.DOCUMENT_POSITION_FOLLOWING ? 'up' : 'down';
  }

  getThreadTop() {
    let thing = this;
    let current = this.element;

    while (current = current.parentElement) {
      if (current.matches(Thing_Thing.thingSelector)) thing = downcast(current, HTMLElement);
    }

    return Thing_Thing.checkedFrom(thing);
  }

  getParents() {
    const parents = [];
    let level = this;

    while (level = level.parent) parents.push(level);

    return parents;
  }

  getNext({
    direction = 'down',
    excludeMoreChildren = false
  } = {}, things = Thing_Thing.thingElements()) {
    let index = things.indexOf(this.element);
    let target;

    do {
      index += direction === 'down' ? 1 : -1;
      const _target = things[index];
      target = _target;
      if (!target) return null;
      if (excludeMoreChildren && target.matches('.morechildren')) continue;
    } while (!target.offsetParent);

    return Thing_Thing.from(target);
  }

  getNextSibling(options) {
    if (!this.element.parentElement) return null;
    const things = Array.from(this.element.parentElement.children).filter(e => e.matches(Thing_Thing.thingSelector));
    return this.getNext(options, things);
  }

  getClosest(func, ...args) {
    const target = Reflect.apply(func, this, args);

    if (target) {
      return target;
    } else {
      if (this.parent) return this.parent.getClosest(func, ...args);
    }
  }

  getClosestVisible(options = {
    excludeMoreChildren: true
  }) {
    if (this.element.offsetParent) return this;
    return this.getNext({
      direction: 'down',
      ...options
    }) || this.getNext({
      direction: 'up',
      ...options
    });
  }

  isMessage() {
    return this.element.classList.contains('message');
  }

  isSubreddit() {
    return this.element.classList.contains('subreddit');
  }

  isPost() {
    return this.element.classList.contains('link') || this.element.classList.contains('search-result-link');
  }

  isLinkPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return !this.element.querySelector('a').classList.contains('self');
    } else {
      return !this.element.classList.contains('self');
    }
  }

  isSelfPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return this.element.querySelector('a').classList.contains('self');
    } else {
      return this.element.classList.contains('self');
    }
  }

  isComment() {
    return this.element.classList.contains('comment') || this.element.classList.contains('was-comment');
  }

  isTopLevelComment() {
    return this.isComment() && !!this.element.parentElement && this.element.parentElement.classList.contains('nestedlisting');
  }

  getTitle() {
    const element = this.getTitleElement();
    return element && element.textContent || '';
  }

  getTitleElement() {
    return this.entry.querySelector('a.title, a.search-title') || this.entry.querySelector('.title');
  }

  getTitleUrl() {
    const element = this.getTitleElement();

    if (element) {
      return element.href;
    }

    return '';
  }

  getPostLink() {
    return downcast(this.entry.querySelector('a.title, a.search-link'), HTMLAnchorElement);
  }

  getPostUrl() {
    return this.element.dataset.url || this.getPostLink().href;
  }

  getTextBody() {
    return this.entry.querySelector('.md');
  }

  getCommentsLink() {
    return downcast(this.entry.querySelector('a.comments, a.search-comments'), HTMLAnchorElement);
  }

  getCommentPermalink() {
    return this.entry.querySelector('a.bylink');
  }

  getHideElement() {
    return this.entry.querySelector('.hide-button a, .unhide-button a');
  }

  getNumberOfChildren() {
    const numChildrenElem = this.element.querySelector('.numchildren');
    const match = numChildrenElem && /(\d+)/.exec(numChildrenElem.textContent);
    return match && parseInt(match[1], 10) || 0;
  }

  static _parseScore(scoreEle) {
    return parseInt(scoreEle.title || scoreEle.textContent, 10) || 0;
  }

  getScore() {
    const element = this._getActiveScoreElement();

    return element && Thing_Thing._parseScore(element);
  }

  _getActiveScoreElement() {
    if (this.isPost()) {
      return this.element.querySelector(['.midcol.unvoted > .score.unvoted', '.midcol.likes > .score.likes', '.midcol.dislikes > .score.dislikes', '.search-score'].join(', '));
    } else {
      return this.entry.querySelector('.tagline > .score');
    }
  }

  getAllScoreElements() {
    const toScoreTuple = ele => [ele, Thing_Thing._parseScore(ele)];

    if (this.isPost()) {
      return Array.from(this.element.querySelectorAll('.midcol > .score, .search-score')).map(toScoreTuple);
    } else {
      return Array.from(this.entry.querySelectorAll('.tagline > .score')).map(toScoreTuple);
    }
  }

  getAuthor() {
    const data = this.element.getAttribute('data-author');

    if (data) {
      return data;
    }

    const element = this.getAuthorElement();

    if (element) {
      const match = regexes.profile.exec(element.pathname);

      if (match) {
        return match[1];
      }
    }
  }

  getAuthorUrl() {
    const author = this.getAuthor();

    if (author) {
      return `/user/${author}/`;
    }

    return '';
  }

  getAuthorElement() {
    return this.entry.querySelector('.tagline a.author, .search-author .author');
  }

  getSubreddit() {
    const data = this.element.getAttribute('data-subreddit');

    if (data) {
      return data;
    }

    const element = this.getSubredditLink();

    if (element) {
      const match = regexes.subreddit.exec(element.pathname);

      if (match) {
        return match[1];
      }
    } else {
      return currentSubreddit();
    }
  }

  getSubredditLink() {
    if (this.isPost()) {
      return this.entry.querySelector('.tagline a.subreddit, a.search-subreddit-link');
    } else if (this.isComment()) {
      return this.entry.querySelector('.parent a.subreddit, .tagline .subreddit a');
    }
  }

  getPostDomain() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.getPostDomainLink();

    if (element) {
      return element.textContent;
    }

    const text = this.getPostDomainText();

    if (text) {
      return text;
    }

    const subreddit = this.getSubreddit();

    if (subreddit) {
      return `self.${subreddit}`;
    }

    return 'reddit.com';
  }

  getPostDomainUrl() {
    const link = this.getPostDomainLink();

    if (link) {
      return link.href;
    }

    return `/domain/${this.getPostDomain()}/`;
  }

  getPostDomainLink() {
    return this.element.querySelector('.domain a');
  }

  getPostDomainText() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.element.querySelector('.domain');
    if (!element) return '';
    const text = element.textContent || '';
    return text.replace(/[\(\)\s]/g, '');
  }

  getCommentCount() {
    const element = this.getCommentCountElement();
    if (!element) return;
    return parseInt(/\d+/.exec(element.textContent || element.getAttribute('data-text')), 10) || 0;
  }

  getCommentCountElement() {
    if (this.isPost()) {
      return this.element.querySelector('.buttons .comments');
    } else if (this.isComment()) {
      return this.element.querySelector('.buttons a.full-comments');
    }
  }

  getPostThumbnailUrl() {
    const thumbnail = this.getPostThumbnailElement();
    if (!thumbnail) return '';
    return thumbnail.src || '';
  }

  getPostThumbnailElement() {
    return this.element.querySelector('.thumbnail img');
  }

  getPostFlairText() {
    const element = this.getPostFlairElement();
    return element && element.textContent || '';
  }

  getPostFlairElement() {
    return this.entry.querySelector('.title > .linkflairlabel');
  }

  getUserFlairText() {
    const element = this.getUserFlairElement();
    return element && element.textContent || '';
  }

  getUserFlairElement() {
    return this.entry.querySelector('.tagline > .flair');
  }

  getCrosspostBadgeElement() {
    return this.entry.querySelector('.crosspost-badge');
  }

  getUpvoteButton() {
    return this._getVoteButton('div.up, div.upmod');
  }

  getDownvoteButton() {
    return this._getVoteButton('div.down, div.downmod');
  }

  _getVoteButton(selector) {
    const previousSibling = this.entry.previousSibling;

    if (previousSibling.tagName === 'A') {
      return previousSibling.previousSibling.querySelector(selector);
    } else {
      return previousSibling.querySelector(selector);
    }
  }

  getTimestamp() {
    const element = this.getTimestampElement();
    return element && new Date(element.getAttribute('datetime'));
  }

  getTimestampElement() {
    return this.entry.querySelector('time');
  }

  getPostEditTimestamp() {
    const element = this.getPostEditTimestampElement();
    return element && Date.parse(element.getAttribute('datetime')) / 1000 || 0;
  }

  getPostEditTimestampElement() {
    return this.entry.querySelector('time.edited-timestamp');
  }

  getFullname() {
    return this.element.getAttribute('data-fullname') || '';
  }

  getUserattrsElement() {
    return this.entry.querySelector('.userattrs');
  }

  getRank() {
    const rank = parseInt(this.element.getAttribute('data-rank'), 10);
    if (!isNaN(rank)) return rank;
  }

  getRankElement() {
    if (!this.isPost()) return;
    return this.element.querySelector('.rank');
  }

  getTaglineElement() {
    return this.entry.querySelector('.tagline');
  }

  getCommentCollapseToggleElement() {
    return this.entry.querySelector('.expand');
  }

  setCommentCollapse(state, reason, openOnlyWhenSameReason = false) {
    const toggle = this.getCommentCollapseToggleElement();
    if (!toggle) return;
    if (state) toggle.setAttribute('collapse-reason', reason);
    if (this.isCollapsed() === state) return;
    if (!state && openOnlyWhenSameReason && toggle.getAttribute('collapse-reason') !== reason) return;
    if (!state) toggle.removeAttribute('collapse-reason');
    toggle.click();
  }

  getPostTime() {
    const element = this.getPostTimeElement();

    if (element) {
      return element.textContent;
    }

    return '';
  }

  getPostTimeElement() {
    return this.entry.querySelector('.tagline time');
  }

  isNSFW() {
    return this.element.classList.contains('over18') || !!this.entry.querySelector('.nsfw-stamp');
  }

  isSpoiler() {
    if (this.element.classList.contains('search-result')) {
      return !!this.entry.querySelector('.spoiler-stamp');
    }

    return this.element.classList.contains('spoiler');
  }

  isCrosspost() {
    return !!this.getCrosspostBadgeElement();
  }

  isLocked() {
    if (this.element.classList.contains('search-result')) {
      return this.element.classList.contains('linkflair-locked');
    }

    return this.element.classList.contains('locked');
  }

  isDeleted() {
    return this.element.classList.contains('deleted');
  }

  isHiddenByFilter(partialAsFiltered = false) {
    if (this.element.matches('body.hideOver18 .over18:not(.allowOver18)')) return true;
    if (!this.element.classList.contains('res-thing-filter-hide')) return false;
    if (this.element.classList.contains('res-filterline-highlight-match')) return false;

    if (partialAsFiltered) {
      if (this.element.classList.contains('res-thing-partial') && this.element.classList.contains('res-selected')) return false;
      return true;
    } else {
      if (this.element.classList.contains('res-thing-hide-children')) return true;
      return !this.element.classList.contains('res-thing-partial');
    }
  }

  isCollapsed() {
    return this.element.classList.contains('collapsed');
  }

  isVisible() {
    if (this.element.classList.contains('promoted')) return false;
    if (!document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter()) return false;
    const {
      parent
    } = this;

    if (parent) {
      if (parent.isCollapsed()) return false;
      if (parent.element.classList.contains('res-children-hidden')) return false;
      if (!parent.isVisible()) return false;
    }

    return true;
  }

  isContentVisible() {
    return !(this.element.classList.contains('res-thing-has-placeholder') || !document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter(true) || this.isCollapsed() || !this.isVisible());
  }

  isSelected() {
    return this.element.classList.contains('res-selected');
  }

  isUpvoted() {
    return this.entry.classList.contains('likes');
  }

  isDownvoted() {
    return this.entry.classList.contains('dislikes');
  }

  isUnvoted() {
    return this.entry.classList.contains('unvoted');
  }

}
Thing_Thing.thingSelector = '.listing .thing, .linklisting .thing, .nestedlisting .thing, .search-result-link';
Thing_Thing.entrySelector = '.entry';

Thing_Thing.registeredThings = (doc = document.body) => Array.from(Thing_things).filter(thing => doc.contains(thing.element));

Thing_Thing.selected = void 0;
// CONCATENATED MODULE: ./lib/utils/thingMetadata.js


const getPostMetadata = batch(async requests => {
  const byId = requests.map(r => r.id).map(id => `t3_${id}`).join(',');
  const {
    data: {
      children
    }
  } = await ajax({
    url: `/by_id/${byId}.json`,
    query: {
      limit: 100,
      raw_json: 1
    },
    type: 'json'
  });
  return children.map(c => c.data);
}, {
  size: 100
});
// EXTERNAL MODULE: ./node_modules/tinycolor2/tinycolor.js
var tinycolor = __webpack_require__(81);
var tinycolor_default = /*#__PURE__*/__webpack_require__.n(tinycolor);

// CONCATENATED MODULE: ./lib/utils/color.js

function colorToArray(colorString) {
  const {
    r,
    g,
    b
  } = tinycolor_default()(colorString).toRgb();
  return [r, g, b];
}
function colorFromArray([r, g, b]) {
  return tinycolor_default()({
    r,
    g,
    b
  }).toHexString();
}
// CONCATENATED MODULE: ./lib/utils/hash.js

const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
function randomHash(len = 5) {
  const arr = new Array(len);

  for (const i of range(0, len)) {
    arr[i] = chars.charAt(Math.random() * chars.length | 0);
  }

  return arr.join('');
}
function hashCode(str) {
  let hash = 0;

  for (const char of str) {
    hash = (hash << 5) - hash + char.charCodeAt(0) | 0;
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/thingHide.js


const hideEndpoint = '/api/hide';
const unhideEndpoint = '/api/unhide';
const [HIDE, UNHIDE] = [false, true];

const send = (state, things) => {
  function setState(newState) {
    for (const thing of things) {
      const hideElement = thing.getHideElement();

      if (hideElement) {
        hideElement.textContent = newState === HIDE ? 'unhide' : 'hide';
        hideElement.setAttribute('action', newState === HIDE ? 'unhide' : 'hide');
      }
    }
  }

  for (const thing of things) {
    const hideElement = thing.getHideElement();
    if (hideElement) hideElement.textContent = state === HIDE ? 'hiding…' : 'unhiding…';
  }

  const fullnames = things.map(thing => thing.getFullname());
  return ajax({
    method: 'POST',
    url: state === HIDE ? hideEndpoint : unhideEndpoint,
    data: {
      id: fullnames.join(',')
    }
  }).then(() => {
    setState(HIDE);
  }, () => {
    setState(UNHIDE);
  });
};

const thingHide_hide = batch(things => send(HIDE, things), {
  size: 50
});
const unhide = batch(things => send(UNHIDE, things), {
  size: 50
});
// CONCATENATED MODULE: ./lib/utils/keycode.js


const NAMED_KEYS = {
  Backspace: 'Backspace',
  Tab: 'Tab',
  Enter: 'Enter',
  Escape: 'Escape',
  Space: ' ',
  PageUp: 'PageUp',
  PageDown: 'PageDown',
  End: 'End',
  Home: 'Home',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Shift: 'Shift',
  Control: 'Control',
  Alt: 'Alt'
};
const keyCodes = {
  '-1': 'none',
  '8': 'backspace',
  '9': 'tab',
  '13': 'enter',
  '16': 'shift',
  '17': 'ctrl',
  '18': 'alt',
  '19': 'pause/break',
  '20': 'caps lock',
  '27': 'escape',
  '33': 'page up',
  '34': 'page down',
  '35': 'end',
  '36': 'home',
  '37': 'left arrow',
  '38': 'up arrow',
  '39': 'right arrow',
  '40': 'down arrow',
  '45': 'insert',
  '46': 'delete',
  '91': 'left window',
  '92': 'right window',
  '93': 'select key',
  '96': 'numpad 0',
  '97': 'numpad 1',
  '98': 'numpad 2',
  '99': 'numpad 3',
  '100': 'numpad 4',
  '101': 'numpad 5',
  '102': 'numpad 6',
  '103': 'numpad 7',
  '104': 'numpad 8',
  '105': 'numpad 9',
  '106': 'multiply',
  '107': 'add',
  '109': 'subtract',
  '110': 'decimal point',
  '111': 'divide',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'num lock',
  '145': 'scroll lock',
  '186': ';',
  '187': '=',
  '188': ',',
  '189': '-',
  '190': '.',
  '191': '/',
  '192': '`',
  '219': '[',
  '220': '\\',
  '221': ']',
  '222': '\''
};
function keycode_niceKeyCode(keyArray) {
  if (!keyArray && isNaN(keyArray)) {
    return '';
  }

  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (typeof keyArray === 'string') {
    const split = keyArray.split(',');
    const code = parseInt(split[0], 10);
    const modifiers = [...split.slice(1).map(s => s === 'true'), false, false, false, false];
    const [alt, ctrl, shift, meta] = modifiers;
    keyArray = [code, alt, ctrl, shift, meta];
  }

  const [keyCode, ...modifiers] = keyArray;

  const keyCombo = zipWith_default()(modifiers, ['alt-', 'ctrl-', 'shift-', 'command-'], (predicate, name) => predicate && name).filter(x => x).join('');

  const keyName = keyCodes[keyCode] || String.fromCharCode(keyCode);
  return `${keyCombo}${keyName}`;
}
function checkKeysForEvent(event, keyArray) {
  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (keyArray.length === 4) {
    keyArray.push(false);
  }

  const eventHash = hashKeyEvent(event);
  const arrayHash = hashKeyArray(keyArray);
  return eventHash === arrayHash;
}
function hashKeyEvent(event) {
  const keyArray = [event.keyCode, event.altKey, event.ctrlKey, event.shiftKey, event.metaKey];
  return hashKeyArray(keyArray);
}
function hashKeyArray(keyArray) {
  const length = 5;
  let hash = keyArray[0] * Math.pow(2, length);

  for (const i of range(1, length)) {
    if (keyArray[i]) {
      hash += 2 ** i;
    }
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/localization.js



const Dayjs = once_default()(() => {
  const dayjs = __webpack_require__(9);

  const localeCode = i18n_locale.toLowerCase();
  if (localeCode.startsWith('de')) dayjs.locale(__webpack_require__(206));
  if (localeCode.startsWith('el')) dayjs.locale(__webpack_require__(207));
  if (localeCode.startsWith('es')) dayjs.locale(__webpack_require__(208));
  if (localeCode.startsWith('he')) dayjs.locale(__webpack_require__(209));
  if (localeCode.startsWith('it')) dayjs.locale(__webpack_require__(210));
  if (localeCode.startsWith('nl')) dayjs.locale(__webpack_require__(211));
  if (localeCode.startsWith('pl')) dayjs.locale(__webpack_require__(212));
  if (localeCode.startsWith('pt-br')) dayjs.locale(__webpack_require__(213));
  if (localeCode.startsWith('pt')) dayjs.locale(__webpack_require__(214));
  dayjs.extend(__webpack_require__(215));
  dayjs.extend(__webpack_require__(216));
  return dayjs;
});

const localization_dayjs = (...args) => new Dayjs()(...args);
function formatNumber(number) {
  return number.toLocaleString(i18n_locale);
}
function formatDate(date) {
  return localization_dayjs(date).format('L');
}
function formatDateTime(date) {
  return localization_dayjs(date).format('L LTS');
}
function formatDateDiff(from, to) {
  return localization_dayjs(to).from(from, true);
}
function formatRelativeTime(from) {
  return localization_dayjs(from).fromNow();
}
// CONCATENATED MODULE: ./lib/utils/math.js
function numericalCompare(op, a, b) {
  switch (op) {
    case '==':
      return a == b;

    case '!=':
      return a != b;

    case '>':
      return a > b;

    case '<':
      return a < b;

    case '>=':
      return a >= b;

    case '<=':
      return a <= b;

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function inverseOperator(op) {
  switch (op) {
    case '==':
      return '!=';

    case '!=':
      return '==';

    case '>':
      return '<=';

    case '<':
      return '>=';

    case '>=':
      return '<';

    case '<=':
      return '>';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function prettyOperator(op) {
  switch (op) {
    case '==':
      return '=';

    case '!=':
      return '≠';

    case '>':
      return '>';

    case '<':
      return '<';

    case '>=':
      return '≥';

    case '<=':
      return '≤';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function interpolate(low, high, frac) {
  return (1 - frac) * low + frac * high;
}
function deinterpolate(low, high, value) {
  if (low === -Infinity && high === Infinity) {
    return 0.5;
  } else if (low === -Infinity) {
    return 1;
  } else if (high === Infinity) {
    return 0;
  }

  return (value - low) / (high - low);
}
function projectInto(fromLow, fromHigh, toLow, toHigh, value) {
  return interpolate(toLow, toHigh, deinterpolate(fromLow, fromHigh, value));
}
function positiveModulo(a, n) {
  return (a % n + n) % n;
}
// EXTERNAL MODULE: ./node_modules/lodash/groupBy.js
var groupBy = __webpack_require__(21);
var groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);

// CONCATENATED MODULE: ./lib/utils/options.js

function indexOptionTable(option, keyIndex, keyTransformer = v => v) {
  const source = option.fields[keyIndex].type === 'list' ? Array.from(function* (nestedArray) {
    for (const arr of nestedArray) {
      for (const subKey of arr[keyIndex].split(',')) {
        yield [...arr.slice(0, keyIndex), subKey, ...arr.slice(keyIndex + 1)];
      }
    }
  }(option.value)) : option.value;
  return groupBy_default()(source, arr => keyTransformer(arr[keyIndex]));
}
// CONCATENATED MODULE: ./lib/utils/profiling.js
let profiling_counter = 0;
function markStart() {
  const tag = (++profiling_counter).toString();
  performance.mark(tag);
  return tag;
}
function markEnd(tag, name) {
  performance.measure(name, tag);
}
// CONCATENATED MODULE: ./lib/utils/storage.js


async function maybePruneOldEntries(id, entryStorage, keepTrackDays = 30) {
  if (!(await shouldPrune(id))) return;
  const now = Date.now();

  for (const [id, {
    updateTime
  } = {}] of Object.entries((await entryStorage.getAll()))) {
    if (!updateTime || now - updateTime > DAY * keepTrackDays) {
      entryStorage.delete(id);
    }
  }
}
async function shouldPrune(id, interval = WEEK) {
  await new Promise(res => setTimeout(() => requestIdleCallback(res), 10000));
  const lastStorage = storage_namespaceObject.wrap(`last_prune.${id}`, 0);
  const now = Date.now();
  if (now - (await lastStorage.get()) < interval) return false;
  lastStorage.set(now);
  return true;
}
// CONCATENATED MODULE: ./lib/utils/value.js
function firstValid(...vals) {
  return vals.find(val => val !== undefined && val !== null && (typeof val !== 'number' || !isNaN(val)));
}
// EXTERNAL MODULE: ./node_modules/lodash/sortBy.js
var lodash_sortBy = __webpack_require__(11);
var sortBy_default = /*#__PURE__*/__webpack_require__.n(lodash_sortBy);

// CONCATENATED MODULE: ./lib/utils/watchers.js







const elementWatchers = {
  page: [],
  selfText: []
};
const thingWatchers = {
  comment: [],
  message: [],
  post: [],
  subreddit: []
};

const runCallback = fn => {
  try {
    return fn();
  } catch (e) {
    console.error(e);
  }
};

const addCallback = (callback, actingOnElement, {
  immediate,
  id
} = {}) => {
  const thing = Thing_Thing.from(actingOnElement);

  if (thing) {
    const task = once_default()(() => runCallback(callback));

    if (id) thing.tasks.byId.set(id, task);
    (immediate ? thing.tasks.immediate : thing.tasks.visible).push(task);
    if (immediate || thing.tasks.completed) task();
  } else {
    runCallback(callback);
  }
};

function registerElement(type, element) {
  for (const {
    selector,
    callback,
    options,
    registered
  } of elementWatchers[type]) {
    const elements = selector && !element.matches(selector) ? Array.from(element.querySelectorAll(selector)) : [element];

    for (const e of elements) {
      if (registered.has(e)) continue;
      registered.add(e);
      addCallback(() => callback(e), e, options);
    }
  }
}

function registerThing(element) {
  const thing = Thing_Thing.checkedFrom(element);
  const thingWatcherCallbacks = thing.isPost() && thingWatchers.post || thing.isComment() && thingWatchers.comment || thing.isMessage() && thingWatchers.message || thing.isSubreddit() && thingWatchers.subreddit || [];

  for (const {
    callback,
    options,
    registered
  } of thingWatcherCallbacks) {
    if (registered.has(thing)) continue;
    registered.add(thing);
    addCallback(() => callback(thing), thing.element, options);
  }

  return thing;
}

function watchForThings(types, callback, options) {
  if (!types) types = Object.keys(thingWatchers);
  const entry = {
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) thingWatchers[type].push(entry);
}
function watchForElements(types, selector, callback, options) {
  const entry = {
    selector,
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) elementWatchers[type].push(entry);
}

const _runLikelyVisibleTasks = () => {
  let max = Math.ceil(screen.availHeight / 55);
  const queue = [];
  let i = 0;
  return async thing => {
    const n = i++;
    const filterTask = thing.tasks.byId.get('filter');
    await (filterTask && filterTask());

    const check = queue[n] = () => {
      delete queue[n];

      if (thing.tasks.completed || thing.isVisible()) {
        thing.runTasks();
      } else if (n < max) {
        max++;
        const nextCheck = queue.find(Boolean);
        if (nextCheck) nextCheck();
      }
    };

    if (n < max) check();
  };
};

function registerPage(page, runLikelyVisibleVisibleTasks = _runLikelyVisibleTasks()) {
  const things = filterMap([page.matches(Thing_Thing.thingSelector) && page, ...page.querySelectorAll(Thing_Thing.thingSelector)], e => e instanceof HTMLElement ? [registerThing(e)] : undefined);
  registerElement('page', page);
  things.forEach(runLikelyVisibleVisibleTasks);
}
const HIDE_FOLLOWING_CLASS = 'res-thing-hide-following';
function r2WatcherSitetableStart() {
  watchForThings(['post'], thing => {
    const container = thing.entry.querySelector('div.expando');
    if (!container) return;
    watchForChildren(container, 'form', () => {
      const body = thing.getTextBody();
      if (body) registerElement('selfText', body);
    });
  });
  const thingElements = Thing_Thing.thingElements(document.body, true);

  const runLikelyVisibleVisibleTasks = _runLikelyVisibleTasks();

  for (const e of thingElements) registerPage(e, runLikelyVisibleVisibleTasks);

  const lastThing = thingElements.slice(-1)[0];
  if (lastThing) lastThing.classList.add(HIDE_FOLLOWING_CLASS);
}
function r2WatcherContentLoaded() {
  const io = new IntersectionObserver(entries => {
    const intersecting = filterMap(entries, ({
      target,
      isIntersecting
    }) => isIntersecting && [Thing_Thing.from(target)]);
    if (!intersecting.length) return;
    const thingElements = Thing_Thing.thingElements();

    const things = sortBy_default()(intersecting, thing => thingElements.indexOf(thing.element));

    for (const thing of things) thing.runTasks();

    Thing_Thing.runTasksRange(things.slice(-1)[0], things[0], 10, 10);
  }, {
    rootMargin: '50%'
  });
  watchForThings(null, thing => {
    io.observe(thing.element);
    addCallback(() => {
      io.unobserve(thing.element);
      thing.tasks.completed = true;
    }, thing.element);
  }, {
    immediate: true
  });

  if (isPageType('comments')) {
    const commentarea = document.body.querySelector('.commentarea');
    if (commentarea) watchForFutureDescendants(commentarea, '.thing', registerPage, true);
  } else {
    const watchList = memoize_default()(ele => {
      if (ele) watchForFutureChildren(ele, '.thing', registerPage);
    });

    watchForThings(null, thing => {
      watchList(thing.element.parentElement);
    });
  }

  (document.body.querySelector(`.${HIDE_FOLLOWING_CLASS}`) || document.body).classList.remove(HIDE_FOLLOWING_CLASS);
  registerPage(document.body);
}
// CONCATENATED MODULE: ./lib/constants/jsapi.js
const JSAPI_CONSUMER_NAME = 'reddit-enhancement-suite';
// CONCATENATED MODULE: ./lib/utils/watchers_d2x.js

const watchers_d2x_callbacks = {
  subreddit: [],
  postAuthor: [],
  post: []
};
function watchForRedditEvents(type, callback) {
  if (!watchers_d2x_callbacks[type]) {
    watchers_d2x_callbacks[type] = [];
  }

  watchers_d2x_callbacks[type].push(callback);
}

function handleRedditEvent(event) {
  const {
    target,
    detail: {
      type,
      data
    }
  } = event;
  const fns = watchers_d2x_callbacks[type];

  if (!fns) {
    return;
  }

  let expandoId = `${type}|`;

  switch (type) {
    case 'postAuthor':
      expandoId += data.post.id;
      break;

    case 'commentAuthor':
      expandoId += data.comment.id;
      break;

    case 'userHovercard':
      expandoId += `${data.contextId}|${data.user.id}`;
      break;

    case 'subreddit':
    case 'post':
    case 'postModTools':
    default:
      expandoId += data.id;
      break;
  }

  const update = target.expando && target.expando._.id === expandoId ? (target.expando._.update || 0) + 1 : 0;
  const expando = { ...data,
    _: {
      id: expandoId,
      type,
      update
    }
  };
  target.expando = expando;
  const ownedTarget = target.querySelector(`[data-name="${JSAPI_CONSUMER_NAME}"]`);

  for (const fn of fns) {
    try {
      fn(ownedTarget, expando);
    } catch (e) {
      console.log(e);
    }
  }
}

function initD2xWatcher() {
  document.addEventListener('reddit', handleRedditEvent, true);
  const meta = document.createElement('meta');
  meta.name = 'jsapi.consumer';
  meta.content = JSAPI_CONSUMER_NAME;
  document.head.appendChild(meta);
  meta.dispatchEvent(new CustomEvent('reddit.ready'));
}
// EXTERNAL MODULE: ./node_modules/lodash/difference.js
var difference = __webpack_require__(12);
var difference_default = /*#__PURE__*/__webpack_require__.n(difference);

// CONCATENATED MODULE: ./lib/utils/bodyClasses.js

const classes = new Set();
const addMissing = () => {
  document.body.classList.add(...difference_default()(Array.from(classes), Array.from(document.body.classList)));
};
function bodyClasses_add(...change) {
  for (const cls of change) classes.add(cls);

  if (document.documentElement) document.documentElement.classList.add(...change);
  if (document.body) document.body.classList.add(...change);
}
function bodyClasses_remove(...change) {
  for (const cls of change) classes.delete(cls);

  if (document.documentElement) document.documentElement.classList.remove(...change);
  if (document.body) document.body.classList.remove(...change);
}
function bodyClasses_toggle(state, ...change) {
  if (state) bodyClasses_add(...change);else bodyClasses_remove(...change);
}
// CONCATENATED MODULE: ./lib/utils/browserDetect.js
let versionSearchString;

const searchString = datas => {
  const data = datas.find(data => {
    versionSearchString = data.versionSearch || data.identity;
    return data.string ? data.string.includes(data.subString) : data.prop;
  });
  return data ? data.identity : undefined;
};

const searchVersion = dataString => {
  const index = dataString.indexOf(versionSearchString);

  if (index === -1) {
    return;
  }

  return parseFloat(dataString.substring(index + versionSearchString.length + 1));
};

const hasNavigator = typeof navigator !== 'undefined';
const browser = hasNavigator ? searchString(dataBrowser()) || 'An unknown browser' : 'An unknown browser without `navigator`';
const browserDetect_version = hasNavigator ? searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || 'an unknown version' : 'an unknown version without `navigator`';
const OS = hasNavigator ? searchString(dataOS()) || 'an unknown OS' : 'an unknown OS without `navigator`';

function dataBrowser() {
  return [{
    string: navigator.userAgent,
    subString: 'OPR/',
    identity: 'Opera'
  }, {
    string: navigator.userAgent,
    subString: 'Edge',
    identity: 'Edge Spartan'
  }, {
    string: navigator.userAgent,
    subString: 'Edg',
    identity: 'Edge'
  }, {
    string: navigator.userAgent,
    subString: 'Chrome',
    identity: 'Chrome'
  }, {
    string: navigator.userAgent,
    subString: 'OmniWeb',
    versionSearch: 'OmniWeb/',
    identity: 'OmniWeb'
  }, {
    string: navigator.vendor,
    subString: 'Apple',
    identity: 'Safari',
    versionSearch: 'Version'
  }, {
    prop: window.opera,
    identity: 'Opera',
    versionSearch: 'Version'
  }, {
    string: navigator.vendor,
    subString: 'iCab',
    identity: 'iCab'
  }, {
    string: navigator.vendor,
    subString: 'KDE',
    identity: 'Konqueror'
  }, {
    string: navigator.userAgent,
    subString: 'Firefox',
    identity: 'Firefox'
  }, {
    string: navigator.vendor,
    subString: 'Camino',
    identity: 'Camino'
  }, {
    string: navigator.userAgent,
    subString: 'Netscape',
    identity: 'Netscape'
  }, {
    string: navigator.userAgent,
    subString: 'MSIE',
    identity: 'Explorer',
    versionSearch: 'MSIE'
  }, {
    string: navigator.userAgent,
    subString: 'Gecko',
    identity: 'Mozilla',
    versionSearch: 'rv'
  }, {
    string: navigator.userAgent,
    subString: 'Mozilla',
    identity: 'Netscape',
    versionSearch: 'Mozilla'
  }];
}

function dataOS() {
  return [{
    string: navigator.platform,
    subString: 'Win',
    identity: 'Windows'
  }, {
    string: navigator.platform,
    subString: 'Mac',
    identity: 'Mac'
  }, {
    string: navigator.userAgent,
    subString: 'iPhone',
    identity: 'iPhone/iPod'
  }, {
    string: navigator.platform,
    subString: 'Linux',
    identity: 'Linux'
  }];
}
// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var dist_jquery = __webpack_require__(127);
var jquery_default = /*#__PURE__*/__webpack_require__.n(dist_jquery);

// CONCATENATED MODULE: ./lib/vendor/jquery.js

const $ = jquery_default.a;
window.$ = window.jQuery = $;
// EXTERNAL MODULE: ./node_modules/jquery-sortable/source/js/jquery-sortable.js
var jquery_sortable = __webpack_require__(222);

// EXTERNAL MODULE: ./node_modules/jquery.tokeninput/build/jquery.tokeninput.min.js
var jquery_tokeninput_min = __webpack_require__(223);

// EXTERNAL MODULE: ./lib/vendor/guiders.js
var guiders = __webpack_require__(224);

// EXTERNAL MODULE: ./node_modules/dompurify/dist/purify.js
var purify = __webpack_require__(128);
var purify_default = /*#__PURE__*/__webpack_require__.n(purify);

// EXTERNAL MODULE: ./lib/vendor/HTMLPasteurizer.js
var HTMLPasteurizer = __webpack_require__(23);

// CONCATENATED MODULE: ./lib/vendor/safeHtml.js


const DOMPurify = purify_default()(window);
const config = {
  ALLOWED_TAGS: HTMLPasteurizer["Pasteurizer"].DEFAULT_CONFIG.elemWhitelist,
  ALLOW_DATA_ATTR: false,
  ADD_ATTR: [].concat(HTMLPasteurizer["Pasteurizer"].DEFAULT_CONFIG.attrWhitelist).concat(Object.values(HTMLPasteurizer["Pasteurizer"].DEFAULT_CONFIG.tagAttrWhitelist)).reduce((a, n) => a.concat(n), []),
  ALLOW_UNKNOWN_PROTOCOLS: true,
  KEEP_CONTENT: HTMLPasteurizer["Pasteurizer"].DEFAULT_CONFIG.hoistOrphanedContents,
  RETURN_DOM: true,
  SAFE_FOR_JQUERY: true
};

const safeHtml = dirty => {
  if (!dirty) {
    return [];
  }

  const body = DOMPurify.sanitize(dirty, config);
  [].slice.call(body.childNodes).forEach(node => HTMLPasteurizer["Pasteurizer"].scrubNode(node, HTMLPasteurizer["Pasteurizer"].DEFAULT_CONFIG));
  return body.childNodes;
};

/* harmony default export */ var vendor_safeHtml = (safeHtml);
// CONCATENATED MODULE: ./lib/vendor/jqueryPlugins.js




const jqueryPlugins_guiders = $.guiders;


$.fn.safeHtml = function (string) {
  return $(this).empty().append(vendor_safeHtml(string));
};
// CONCATENATED MODULE: ./lib/vendor/index.js


// CONCATENATED MODULE: ./lib/utils/createElement.js





function toggleButton(onClick = () => {}, fieldID, enabled = false, onText = i18n('toggleOn'), offText = i18n('toggleOff'), isTable = false, usesBatch = false) {
  const toggle = string_html`
		<div ${fieldID && _html`id="${fieldID}Container"`} class="toggleButton ${enabled && 'enabled'}">
			<span class="toggleThumb"></span>
			<div class="toggleLabel ${usesBatch && 'res-icon'}"
				${onText && _html`data-enabled-text="${onText}"`}
				${offText && _html`data-disabled-text="${offText}"`}
			></div>
			<input id="${fieldID}" name="${fieldID}" type="checkbox" ${enabled && 'checked'}
				${isTable && _html`tableOption="true"`}
			/>
		</div>
	`;
  toggle.addEventListener('click', () => {
    const checkbox = downcast(toggle.querySelector('input[type=checkbox]'), HTMLInputElement);
    const enabling = !checkbox.checked;
    checkbox.checked = enabling;
    toggle.classList.toggle('enabled', enabling);
    onClick(enabling);
  });
  return toggle;
}
function icon(charCode, tagName = 'span', className = '', title = '') {
  const icon = document.createElement(tagName);
  icon.className = className;
  icon.classList.add('res-icon');
  icon.textContent = String.fromCharCode(charCode);
  icon.setAttribute('title', title);
  return icon;
}
function createElement_table(items, callback) {
  items = [].concat(items);
  const description = [];
  description.push('<table>');

  for (const item of items.map(callback)) {
    if (typeof item === 'string') {
      description.push(item);
    } else if (item) {
      description.push(...item);
    }
  }

  description.push('</table>');
  return description.join('\n');
}
function createElement_tabMenuItem({
  text,
  aftercontent,
  className,
  title,
  checked,
  prepend
}) {
  let menu = document.querySelector('#header-bottom-left ul.tabmenu');

  if (!menu && isPageType('search', 'modqueue')) {
    menu = $('<ul>', {
      class: 'tabmenu'
    }).appendTo('#header-bottom-left').get(0);
  } else if (!menu) {
    if (isAppType('r2')) {
      console.warn('Could not find tab menu');
    }

    return document.createElement('a');
  }

  const element = string_html`
		<li class="res-tabmenu-button ${checked && 'selected'} ${className}">
			<a
				${title && _html`title="${title}"`}
				${aftercontent && _html`aftercontent="${aftercontent}"`}
			>${text}</a>
		</li>
	`;
  if (prepend) menu.prepend(element);else menu.appendChild(element);
  const a = element.querySelector('a');
  a.addEventListener('click', () => {
    checked = !checked;
    element.classList.toggle('selected', checked);
    a.dispatchEvent(new CustomEvent('change', {
      detail: checked
    }));
  });
  return a;
}
function fancyToggleButton(text, title, state, callback) {
  const element = document.createElement('span');
  element.className = 'res-fancy-toggle-button';
  element.title = title;

  const refresh = () => {
    if (state) {
      element.textContent = `-${text}`;
      element.classList.add('remove');
    } else {
      element.textContent = `+${text}`;
      element.classList.remove('remove');
    }
  };

  element.addEventListener('click', () => {
    state = !state;
    callback(state);
    refresh();
  });
  refresh();
  return element;
}
// CONCATENATED MODULE: ./lib/utils/alert.js





const alert_$container = once_default()(() => $('<div>', {
  id: 'alert_message'
}).appendTo(document.body));

const $overlay = once_default()(() => $('<div>', {
  id: 'alert_message_background'
}).appendTo(document.body));

const alert_open = mutex((text, {
  cancelable = false
} = {}) => new Promise((resolve, reject) => {
  function confirm() {
    resolve();
    close();
  }

  function cancel() {
    reject(new Error('User cancelled alert.'));
    close();
  }

  function close() {
    $(document.body).off('keyup', listenForEscape);
    alert_$container().hide();
    $overlay().hide();
  }

  function listenForEscape(e) {
    if (e.key === NAMED_KEYS.Escape) {
      if (cancelable) cancel();else confirm();
    }
  }

  $(document.body).on('keyup', listenForEscape);
  $overlay().show();
  alert_$container().empty().append($('<div>', {
    html: text
  })).show();

  if (cancelable) {
    $(makeButton('confirm', 'button-right')).click(confirm).appendTo(alert_$container());
    $(makeButton('cancel', 'button-right')).click(cancel).appendTo(alert_$container()).focus();
  } else {
    $(makeButton('ok')).click(confirm).appendTo(alert_$container()).focus();
  }
}));
function makeButton(text, cls) {
  const btn = document.createElement('input');
  btn.setAttribute('type', 'button');
  btn.setAttribute('value', text);

  if (cls) {
    btn.classList.add(cls);
  }

  return btn;
}
// EXTERNAL MODULE: ./node_modules/lodash/flatten.js
var flatten = __webpack_require__(18);
var flatten_default = /*#__PURE__*/__webpack_require__.n(flatten);

// CONCATENATED MODULE: ./lib/utils/caseBuilder.js




function drawOptionBuilder(options, mod, optionName) {
  const option = options[optionName];
  const $addRowButton = $('<button class="addRowButton">');
  const $itemContainer = $('<div class="optionBuilder">');
  $itemContainer.attr({
    'data-module-id': mod.moduleID,
    'data-option-name': optionName
  });
  $addRowButton.text(i18n(option.addItemText) || '+add item').on('click', function () {
    const $newBody = drawBuilderItem(option.defaultTemplate(), option.customOptionsFields, option.cases);
    $(this).siblings('.optionBuilder:first').trigger('change').append($newBody);
    const firstText = $newBody.find('input[type=text], textarea')[0];

    if (firstText) {
      setTimeout(() => firstText.focus(), 200);
    }
  });
  option.value.forEach(item => drawBuilderItem(item, option.customOptionsFields, option.cases).appendTo($itemContainer));
  makeBuilderItemsSortable($itemContainer);
  return $('<div>').append($itemContainer, $addRowButton)[0];
}

function drawBuilderItem(data, customOptionsFields = [], cases) {
  const $editButton = $('<div>').addClass('res-icon-button res-icon builderControls builderTrailingControls').html('&#xF061;').attr('title', 'copy and share, or update your settings with a new version').on('click', function () {
    const $item = $(this).closest('.builderItem');
    const data = readBuilderItem($item, customOptionsFields, cases);
    const json = prompt('Copy this and share it, or paste a new version and update your settings', JSON.stringify(data));

    if (json !== null) {
      const newData = JSON.parse(json);
      $item.trigger('change').replaceWith(drawBuilderItem(newData, customOptionsFields, cases));
    }
  });
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want remove this filter?')) {
      $(this).trigger('change');
      $(this).closest('.builderItem').trigger('change').remove();
    }
  });
  const customOptions = string_namespaceObject.html`<ul class="builderCustomOptions"></ul>`;

  for (const fields of customOptionsFields) {
    const li = document.createElement('li');
    $(li).append(drawFields(fields, data.opts || {}));
    customOptions.append(li);
  }

  const $header = $('<div class="builderItemControls">').append(drawHandle(), $('<textarea name="builderNote" rows="2" cols="40" placeholder="Write a description/note for this">').val(data.note), $('<input type="hidden" name="version">').val(data.ver), $('<input type="hidden" name="id">').val(data.id), customOptions, $editButton, $deleteButton);
  const $body = drawBuilderBlock(data.body, cases, false);
  makeBuilderBlockSortable($body);
  return $('<div class="builderItem">').append($header, $body);
}

function drawHandle() {
  return $('<div>').addClass('res-icon-button res-icon handle builderControls').html('&#xF0AA;').attr('title', 'drag and drop to move this condition');
}

function drawDeleteButton() {
  return $('<div>').addClass('res-icon-button res-icon builderControls').html('&#xF056;').attr('title', 'remove this condition');
}

function drawBuilderBlock(data, cases, addBaseControls = true) {
  if (!cases.hasOwnProperty(data.type)) {
    console.error(`Case type ${data.type} is not available. Ignoring block.`, data);
    return $();
  }

  const $block = $('<div class="builderBlock">').attr('data-type', data.type).append(drawFields(cases[data.type].fields, data, cases));
  if (!addBaseControls) return $block;
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want to delete this condition?')) {
      $(this).trigger('change');
      $(this).closest('.builderWrap').parent('li').remove();
    }
  });
  return $('<div class="builderWrap">').append(drawHandle(), $block, $deleteButton);
}
function readBuilderItem(item, customOptionsFields = [], cases) {
  const $firstBlock = $(item).find('> .builderBlock');
  const $header = $(item).find('.builderItemControls');
  return {
    note: $header.find('textarea[name=builderNote]').val(),
    ver: parseInt($header.find('input[name=version]').val(), 10),
    id: $header.find('input[name=id]').val(),
    body: readBuilderBlock($firstBlock, cases),
    opts: readFields($header.find('.builderCustomOptions li'), flatten_default()(customOptionsFields), cases)
  };
}
function readBuilderBlock($element, cases) {
  const type = $element.attr('data-type');
  const BlockClass = cases[type];
  const data = {
    type,
    ...readFields($element, BlockClass.fields, cases)
  };
  const multiType = BlockClass.fields.find(({
    type
  }) => type === 'multi');

  if (!multiType) {
    try {
      BlockClass.validate(data);
      $element.removeClass('builderBlock-error');
    } catch (e) {
      $element.attr('error', e.message).addClass('builderBlock-error');
      throw e;
    }
  }

  return data;
}

function readFields($element, fields, cases) {
  return fields.reduce((acc, field) => {
    if (typeof field === 'string') return acc;
    const $fieldElem = $element.find(`> [name=${field.id}]`);
    const fieldModule = builderFields[field.type];

    if (fieldModule && typeof fieldModule.read === 'function') {
      acc[field.id] = fieldModule.read($fieldElem, field, cases);
    } else {
      acc[field.id] = $fieldElem.val();
    }

    return acc;
  }, {});
}

function drawFields(fields, data, cases) {
  return fields.map(field => {
    if (typeof field === 'string') return field;
    const fieldModule = builderFields[field.type];

    if (fieldModule) {
      return fieldModule.draw(data, field, cases);
    } else {
      return $(`<input type="${field.type}">`).attr('name', field.id).val(data[field.id]);
    }
  });
}

function makeBuilderItemsSortable($builder) {
  const edgeScroll = new dom_EdgeScroll($builder.get(0));
  $builder.sortable({
    nested: false,
    handle: '.builderItem > .builderItemControls .handle',
    placeholderClass: 'RESSortPlaceholder',
    placeholder: '<div class="RESSortPlaceholder"></div>',
    containerSelector: '.optionBuilder',
    itemSelector: '.builderItem',

    onDrop($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.stop();
      $item.trigger('change');
    },

    onDragStart($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.start();
    }

  });
}

function makeBuilderBlockSortable($builderBlock) {
  const edgeScroll = new dom_EdgeScroll($builderBlock.get(0));
  $builderBlock.sortable({
    nested: true,
    handle: '.handle',
    placeholderClass: 'RESSortPlaceholder',
    placeholder: '<li class="RESSortPlaceholder"></li>',
    containerSelector: '.builderWrap',
    itemPath: '> .builderBlock > .builderMulti',
    itemSelector: 'li',

    onDrop($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.stop();
      $item.trigger('change');
    },

    onDragStart($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.start();
    }

  });
}
const builderFields = {
  multi: {
    draw(data, field, cases = {}) {
      const $rowWrapper = $('<ul class="builderMulti">').attr('name', field.id);

      const addItem = itemData => drawBuilderBlock(itemData, cases).appendTo($rowWrapper).wrap('<li>');

      const items = data[field.id];
      items.forEach(addItem);
      const addCaseSelect = downcast(string_namespaceObject.html`
				<select class="addBuilderBlock">
					<option>+ add a condition</option>
					${Object.entries(cases).map(([key, {
        text
      }]) => string_namespaceObject._html`
						<option value="${key}">${text}</option>
					`)}
				</select>
			`, HTMLSelectElement);
      addCaseSelect.addEventListener('change', () => {
        const type = addCaseSelect.value;

        if (type !== '' && cases.hasOwnProperty(type)) {
          addItem({
            type,
            ...cases[type].defaultConditions
          }).find('input[type=text], input[type=number], textarea').focus();
        }

        addCaseSelect.selectedIndex = 0;
      });
      return $rowWrapper.add(addCaseSelect);
    },

    read($elem, fields, cases) {
      return $elem.find('> li > .builderWrap > .builderBlock').map(function () {
        return readBuilderBlock($(this), cases);
      }).get();
    }

  },
  hidden: {
    draw(data, field) {
      const id = field.id;
      return $('<input type="hidden">').attr('name', id).val(data[id]);
    }

  },
  number: {
    draw(data, field) {
      const id = field.id;
      return $('<input type="number">').attr('name', id).val(data[id]);
    },

    read($elem) {
      return parseInt($elem.val(), 10);
    }

  },
  check: {
    draw(data, field) {
      const id = field.id;
      const $input = $('<input type="checkbox">').prop('checked', data[id]);
      return $('<label>').attr('name', id).text(field.label).prepend($input);
    },

    read($elem) {
      return $elem.find('input').get(0).checked;
    }

  },
  checkset: {
    uid: 0,

    draw(data, field) {
      const id = field.id;
      const prefixId = this.uid++;
      const $wrap = $('<span class="checkset">').attr('name', field.id);
      field.items.forEach((e, idx) => {
        const itemId = `checkset-${prefixId}-${idx}X`;
        const $box = $('<input type="checkbox" />').attr('id', itemId).attr('name', e);

        if (data.hasOwnProperty(id) && data[id].includes(e)) {
          $box.prop('checked', true);
        }

        const $label = $('<label>').attr('for', itemId).text(e);
        $wrap.append($box, $label);
      });
      return $wrap;
    },

    read($elem, fields) {
      return fields.items.filter(e => $elem.children(`[name="${e}"]`).prop('checked'));
    }

  },
  duration: {
    draw(data, field) {
      let durr = data[field.id];
      durr /= 60 * 1000;
      const minutes = durr % 60;
      durr = (durr - minutes) / 60;
      const hours = durr % 24;
      durr = (durr - hours) / 24;
      const days = durr;
      return $('<span class="durationField">').attr('name', field.id).append([$('<input type="number" name="days" />').val(days), ' days ', $('<input type="number" name="hours" />').val(hours), ' hours ', $('<input type="number" name="minutes" />').val(minutes), ' minutes ']);
    },

    read($elem) {
      const days = parseFloat($elem.children('[name=days]').val()) || 0;
      const hours = parseFloat($elem.children('[name=hours]').val()) || 0;
      const minutes = parseFloat($elem.children('[name=minutes]').val()) || 0;
      let duration = 0;
      duration += days * 24 * 60 * 60;
      duration += hours * 60 * 60;
      duration += minutes * 60;
      duration *= 1000;
      return duration;
    }

  },
  select: {
    draw(data, field) {
      const value = data[field.id];
      let entries = field.options;

      if (typeof entries === 'string') {
        entries = this.getPredefinedChoices(entries);
      }

      const $dropdown = $('<select>').attr('name', field.id);
      entries.forEach(row => {
        let label, value;

        if (typeof row === 'string') {
          label = value = row;
        } else {
          label = row[0];
          value = row[1];
        }

        $('<option>').text(label).val(value).appendTo($dropdown);
      });
      $dropdown.val(value);
      return $dropdown;
    },

    getPredefinedChoices(name) {
      if (name === 'COMPARISON') {
        return [['exactly', '=='], ['not', '!='], ['more than', '>'], ['less than', '<'], ['at least', '>='], ['at most', '<=']];
      } else {
        throw new Error(`Option set "${name}" is not defined`);
      }
    }

  }
};
// CONCATENATED MODULE: ./lib/utils/index.js





































// EXTERNAL MODULE: ./node_modules/lodash/omitBy.js
var omitBy = __webpack_require__(129);
var omitBy_default = /*#__PURE__*/__webpack_require__.n(omitBy);

// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js
var isEqual = __webpack_require__(13);
var isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);

// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js
var isEmpty = __webpack_require__(14);
var isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);

// EXTERNAL MODULE: ./node_modules/lodash/fp/map.js
var map = __webpack_require__(19);
var map_default = /*#__PURE__*/__webpack_require__.n(map);

// EXTERNAL MODULE: ./node_modules/lodash/fp/keyBy.js
var keyBy = __webpack_require__(28);
var keyBy_default = /*#__PURE__*/__webpack_require__.n(keyBy);

// CONCATENATED MODULE: ./lib/core/module.js
class Module {
  constructor(moduleID) {
    this.moduleID = void 0;
    this.moduleName = void 0;
    this.category = '';
    this.description = '';
    this.descriptionRaw = false;
    this.keywords = [];
    this.bodyClass = false;
    this.options = {};
    this.include = [];
    this.exclude = [];

    this.shouldRun = () => true;

    this.onToggle = () => {};

    this.onSaveSettings = () => {};

    this.hidden = false;
    this.disabledByDefault = false;
    this.alwaysEnabled = false;
    this.sort = 0;
    this.onInit = undefined;
    this.beforeLoad = undefined;
    this.contentStart = undefined;
    this.go = undefined;
    this.afterLoad = undefined;
    this.always = undefined;
    this.permissions = {
      requiredPermissions: []
    };
    this.moduleID = moduleID;
    this.moduleName = moduleID;
  }

}
// EXTERNAL MODULE: ./node_modules/lodash/random.js
var random = __webpack_require__(130);
var random_default = /*#__PURE__*/__webpack_require__.n(random);

// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__(29);
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);

// CONCATENATED MODULE: ./lib/core/options/listTypes.js
/* harmony default export */ var listTypes = ({
  subreddits: {
    source: '/api/search_reddit_names.json?app=res',
    hintText: 'type a subreddit name',

    onResult(response) {
      return response.names.map(name => ({
        id: name,
        name
      }));
    },

    onCachedResult(response) {
      return response.names.map(name => ({
        id: name,
        name
      }));
    }

  }
});
// CONCATENATED MODULE: ./lib/core/options/stage.js




let stagedOptions;
clearStagedOptions();


function stageOption(moduleID, optionName, optionValue) {
  const mod = modules_get(moduleID);
  stagedOptions[moduleID] = stagedOptions[moduleID] || {};

  if (!isEqual_default()(mod.options[optionName].value, optionValue)) {
    stagedOptions[moduleID][optionName] = {
      value: optionValue
    };
  } else {
    delete stagedOptions[moduleID][optionName];
  }

  if (isEmpty_default()(stagedOptions[moduleID])) {
    delete stagedOptions[moduleID];
  }
}



function commitStagedOptions() {
  for (const [modId, options] of Object.entries(stagedOptions)) {
    for (const [optionName, option] of Object.entries(options)) {
      options_set(modId, optionName, option.value);
    }

    modules_get(modId).onSaveSettings(options);
  }

  clearStagedOptions();
}



function clearStagedOptions() {
  stagedOptions = {};
}



function hasStagedOptions() {
  return !isEmpty_default()(stagedOptions);
}



function getStagedOptions(moduleID) {
  return stagedOptions[moduleID];
}
// CONCATENATED MODULE: ./lib/core/options/table.js




function getMatchingValue(module, optionKey, valueIdentifiers) {
  const option = module.options[optionKey];
  const values = option.value;
  if (option.type !== 'table' || !values || !values.length) return;
  return values.find(value => {
    let containValid = false;
    const match = option.fields.every((field, fi) => {
      const fieldValue = value[fi];
      const matchValue = firstValid(valueIdentifiers[fi], valueIdentifiers[field.key]);

      if (matchValue === undefined) {
        return true;
      }

      if (matchValue === fieldValue) {
        containValid = true;
        return true;
      }

      return false;
    });
    return match && containValid;
  });
}

function addValue(module, optionKey, value) {
  const option = module.options[optionKey];

  if (option.type !== 'table') {
    throw new Error(`Tried to save table value to non-table option: modules.${module.moduleID}.options.${optionKey}`);
  }

  if (!option.value) {
    option.value = [];
  }

  const values = option.value;
  const optionValue = option.fields.map((field, i) => firstValid(value[i], value[field.key], field.value));
  values.push(optionValue);
  options_set(module, optionKey, values);
  return optionValue;
}

function getMatchingValueOrAdd(opaqueId, optionKey, valueIdentifier, hydrateValue = x => x) {
  const module = modules_get(opaqueId);
  let matchingValue = getMatchingValue(module, optionKey, valueIdentifier);

  if (!matchingValue) {
    const value = hydrateValue(valueIdentifier);
    matchingValue = addValue(module, optionKey, value);
  }

  return matchingValue;
}
// CONCATENATED MODULE: ./lib/core/options/index.js






// CONCATENATED MODULE: ./lib/modules/floater.js


var _temp;






const floater_module = new Module('floater');
floater_module.category = 'productivityCategory';
floater_module.moduleName = 'floaterName';
floater_module.description = 'floaterDesc';
floater_module.alwaysEnabled = true;
floater_module.hidden = true;

class floater_Container {
  static isAvailable() {
    return true;
  }

  constructor() {
    this.element = document.createElement('div');
    this.list = string_namespaceObject.html`<ul class="res-floater-list"></ul>`;
    this.element.append(this.list);
    go.then(() => this.go());
  }

  go() {}

  add(element, {
    separate,
    order
  }) {
    if (separate) {
      $(this.element).append(element);
    } else {
      const li = string_namespaceObject.html`<li style="order: ${order}"></li>`;
      $(li).append(element);
      this.list.append(li);
    }
  }

}

const containers = {
  inNavbar: (_temp = class inNavbar extends floater_Container {
    constructor(...args) {
      super(...args);
      this.updateHeaderWidth = frameThrottle(() => {
        const {
          width
        } = this.element.getBoundingClientRect();
        const headerButton = document.querySelector('.header-user-dropdown');
        headerButton.style.marginRight = `${width}px`;
      });
    }

    static isAvailable() {
      return isAppType('d2x') && !!document.querySelector('.header-user-dropdown');
    }

    go() {
      this.element.classList.add('res-floater-inNavbar');
      document.body.append(this.element);
      this.updateHeaderWidth();
    }

    add(element, opts) {
      super.add(element, opts);
      this.updateHeaderWidth();
    }

  }, _temp),
  belowFixedNavbar: class extends floater_Container {
    static isAvailable() {
      return isAppType('d2x');
    }

    go() {
      this.element.classList.add('res-floater-belowNavbar');
      this.element.style.top = `${5 + getD2xBodyOffset()}px`;
      document.body.append(this.element);
    }

  },
  visibleAfterScroll: class extends floater_Container {
    static isAvailable() {
      return !isAppType('d2x');
    }

    go() {
      this.element.classList.add('res-floater-visibleAfterScroll');
      document.body.append(this.element);
      this.element.style.top = `${8 + getHeaderOffset(true)}px`;

      if (!document.querySelector('#RESPinnedHeaderSpacer')) {
        this.element.hidden = true;
        new IntersectionObserver(entries => {
          this.element.hidden = entries[0].isIntersecting;
        }).observe(document.querySelector('#header'));
      }
    }

  },
  inert: floater_Container
};

const getContainer = memoize_default()(name => new (containers[name].isAvailable() ? containers[name] : containers.inert)());

function addElement(element, {
  container: containerName = ['inNavbar', 'belowFixedNavbar', 'visibleAfterScroll'].find(name => containers[name].isAvailable()) || 'inert',
  separate = false,
  order = 0
} = {}) {
  if (!isRunning(floater_module)) return;
  getContainer(containerName).add(element, {
    separate,
    order
  });
}
// CONCATENATED MODULE: ./lib/modules/hover.js




const hover_module = new Module('hover');
hover_module.moduleName = 'hoverName';
hover_module.category = 'coreCategory';
hover_module.description = 'hoverDesc';
hover_module.alwaysEnabled = true;
hover_module.options = {
  instances: {
    description: 'hoverInstancesDesc',
    title: 'hoverInstancesTitle',
    type: 'table',
    value: [],
    fields: [{
      key: 'name',
      name: 'hoverInstancesName',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'hoverInstancesEnabled',
      type: 'boolean',
      value: true
    }]
  },
  openDelay: {
    type: 'text',
    value: '500',
    description: 'hoverOpenDelayDesc',
    title: 'hoverOpenDelayTitle'
  },
  fadeDelay: {
    type: 'text',
    value: '500',
    description: 'hoverFadeDelayDesc',
    title: 'hoverFadeDelayTitle'
  },
  fadeSpeed: {
    noconfig: true,
    type: 'text',
    value: '0.7',
    description: 'hoverFadeSpeedDesc',
    title: 'hoverFadeSpeedTitle'
  },
  width: {
    type: 'text',
    value: '512',
    description: 'hoverWidthDesc',
    title: 'hoverWidthTitle'
  },
  closeOnMouseOut: {
    type: 'boolean',
    value: true,
    description: 'hoverCloseOnMouseOutDesc',
    title: 'hoverCloseOnMouseOutTitle'
  }
};

hover_module.beforeLoad = () => {
  hover_Hover._defaultOptions = {
    openDelay: parseFloat(hover_module.options.openDelay.value),
    fadeDelay: parseFloat(hover_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(hover_module.options.fadeSpeed.value),
    width: parseFloat(hover_module.options.width.value),
    closeOnMouseOut: hover_module.options.closeOnMouseOut.value
  };
};

const instances = {};

function getInstance(type = 'infocard', id = '_default', hidden) {
  if (!instances[type]) {
    instances[type] = {};
  }

  if (!instances[type][id]) {
    instances[type][id] = type === 'dropdownList' ? new hover_HoverDropdownList(id) : type === 'infocard' ? new hover_HoverInfoCard(id) : new hover_Hover(id);
    instances[type][id].enabled(hidden === HIDDEN_FROM_SETTINGS || hover_isEnabled(type, id));
  }

  return instances[type][id];
}

const HIDDEN_FROM_SETTINGS = true;
const infocard = (id, hidden) => getInstance('infocard', id, hidden);
const dropdownList = (id, hidden) => getInstance('dropdownList', id, hidden);

function hover_isEnabled(type, id) {
  const row = findOrMakeRow(type, id);
  return row[1];
}

function findOrMakeRow(type, id) {
  const name = `${type}.${id}`;
  let row = hover_module.options.instances.value.find(value => value[0] === name);

  if (!row) {
    row = [name, true];
    hover_module.options.instances.value.push(row);
    options_set(hover_module, 'instances', hover_module.options.instances.value);
  }

  return row;
}

function getFixedParent(e) {
  const p = e.parentElement;
  return p && (window.getComputedStyle(p).position === 'fixed' && e || getFixedParent(p));
}

const pin = {
  bottom: 'bottom',
  right: 'right'
};

class hover_Hover {
  constructor(id) {
    this.template = `
		<div class="RESHover">
			<div data-hover-element="0" />
			<div data-hover-element="1" />
			<div data-hover-element="2" />
			<div data-hover-element="3" />
		</div>
	`;
    this._options = hover_Hover._defaultOptions;
    this._enabled = true;
    this.instanceID = void 0;
    this.visible = false;
    this._hideTimer = null;
    this._showTimer = null;
    this._closeFadeTimer = null;
    this._target = void 0;
    this._callback = void 0;
    this._container = void 0;
    this._fixedPosition = false;
    this._closePromise = void 0;
    this._closePromiseResolve = void 0;

    this._startShowTimer = () => {
      if (this._showTimer) return;

      this._cancelHideTimer();

      waitForEvent(this.getCheckedTarget(), 'mouseleave').then(this._cancelShowTimer);
      this._showTimer = setTimeout(() => this.open(), this._options.openDelay);
    };

    this._cancelShowTimer = () => {
      if (!this._showTimer) return;
      clearTimeout(this._showTimer);
      this._showTimer = null;
    };

    this._startHideTimer = () => {
      if (this._hideTimer || this._closeFadeTimer) return;

      this._cancelShowTimer();

      this._hideTimer = setTimeout(() => this.close(true), this._options.fadeDelay);
    };

    this._cancelHideTimer = () => {
      if (!this._hideTimer) return;
      clearTimeout(this._hideTimer);
      this._hideTimer = null;
    };

    this.instanceID = id;
  }

  enabled(enabled) {
    this._enabled = enabled;
    return this;
  }

  options(options) {
    this._options = { ...this._options,
      ...options
    };
    return this;
  }

  target(element) {
    if (this._target && this._target !== element) {
      this.close();
    }

    this._target = element;
    return this;
  }

  getCheckedTarget() {
    if (!this._target || !this._target.offsetParent) {
      this.close();
      throw new Error('Cannot show hover without target; closing hover.');
    }

    return this._target;
  }

  populateWith(callback) {
    this._callback = callback;
    return this;
  }

  getContainer() {
    const container = this._container = this._container || this._render();

    if (!document.body.contains(container)) {
      document.body.append(container);
    }

    return container;
  }

  _render() {
    const ele = $(this.template).get(0);

    this._addContainerHandlers(ele);

    if (this._options.className) ele.classList.add(this._options.className);
    return ele;
  }

  _addContainerHandlers(ele) {
    const checkMouseLeave = ({
      target
    }) => {
      if (this.visible && this._options.closeOnMouseOut && !(ele.contains(target) || this.getCheckedTarget().contains(target))) this._startHideTimer();
    };

    $(ele).on('mouseenter', () => {
      this._cancelHideTimer();

      this._clearCloseFade();
    }).on('mouseleave', checkMouseLeave).on('click', '.RESCloseButton', () => this.close(true)).on('keyup', e => {
      if (e.key === NAMED_KEYS.Escape) this.close(true);
      e.stopImmediatePropagation();
    });

    if (this._options.closeOnMouseOut) {
      document.body.addEventListener('mousemove', checkMouseLeave);
      document.body.addEventListener('mouseover', checkMouseLeave);
    }
  }

  begin() {
    if (!this._enabled) return false;

    if (this._options.openDelay) {
      this._startShowTimer();
    } else {
      this.open();
    }
  }

  open() {
    if (!this._enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    this._clearCloseFade();

    const callback = this._callback;
    if (!callback) throw new Error();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this._closePromise = new Promise(res => {
      this._closePromiseResolve = res;
    });

    this._displayLoadIndicator();

    (async () => {
      try {
        this.populate((await callback(this)));
      } catch (e) {
        this.close();
        throw e;
      }
    })();

    waitForRemoval(this.getCheckedTarget(), this._closePromise).then(() => {
      this.close();
    }).catch(() => {});
    this.visible = true;
  }

  _displayLoadIndicator() {}

  async refresh() {
    const callback = this._callback;
    if (callback) this.populate((await callback(this)));
  }

  populate(items) {
    if (!this._enabled) return false;
    const container = this.getContainer();
    items.forEach((item, i) => {
      if (!item) return;
      const $element = $(container).find(`[data-hover-element="${i}"]`);
      $element.children().detach();
      $element.empty().append(item);
    });
    const fixedParent = getFixedParent(this.getCheckedTarget());

    if (fixedParent) {
      this._fixedPosition = true;

      const onScroll = () => {
        this.close(false);
        fixedParent.removeEventListener('scroll', onScroll, true);
      };

      fixedParent.addEventListener('scroll', onScroll, true);
    }

    this._updatePosition();
  }

  _positionContainer({
    top = 'auto',
    right = 'auto',
    bottom = 'auto',
    left = 'auto'
  }) {
    $(this.getContainer()).css({
      position: this._fixedPosition ? 'fixed' : 'absolute',
      top: top !== 'auto' ? top + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      right: right !== 'auto' ? right + (this._fixedPosition ? 0 : window.scrollX) : 'auto',
      bottom: bottom !== 'auto' ? bottom + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      left: left !== 'auto' ? left + (this._fixedPosition ? 0 : window.scrollX) : 'auto'
    });
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left
    } = target.getBoundingClientRect();

    this._positionContainer({
      top,
      left
    });
  }

  resetShowTimer() {
    if (this._showTimer) {
      this._cancelShowTimer();

      this._startShowTimer();
    }
  }

  _startCloseFade() {
    if (this._closeFadeTimer) return;
    this._closeFadeTimer = setTimeout(() => {
      this.remove();
    }, this._options.fadeSpeed * 1000);
    this.getContainer().style.transitionDuration = `${this._options.fadeSpeed}s`;
    this.getContainer().classList.add('transitionToTransparent');
  }

  _clearCloseFade() {
    if (!this._closeFadeTimer) return;
    clearTimeout(this._closeFadeTimer);
    this.getContainer().style.transitionDuration = '';
    this.getContainer().classList.remove('transitionToTransparent');
    this._closeFadeTimer = null;
  }

  close(fade = false) {
    if (!this._enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    if (fade) this._startCloseFade();else this.remove();
  }

  remove() {
    this._clearCloseFade();

    this.getContainer().remove();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this.visible = false;
  }

}

hover_Hover._defaultOptions = {};

class hover_HoverInfoCard extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverInfoCard RESDialogSmall">
			<h3 class="RESHoverTitle" data-hover-element="0"></h3>
			<div class="RESCloseButton">x</div>
			<div class="RESHoverBody RESDialogContents" data-hover-element="1"></div>
		</div>
	`;
    this._loadIndicator = '<div class="RESCenteredLoadIndicator"><span class="RESLoadingSpinner"></span></div>';
  }

  _displayLoadIndicator() {
    this.populate([null, this._loadIndicator]);
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      bottom,
      right
    } = target.getBoundingClientRect();
    const $container = $(this.getContainer()).removeClass('right below');
    const tooltipWidth = this._options.width;
    let tooltipLeft, tooltipTop;

    if (!this._options.pin && right + tooltipWidth + 25 < getViewportSize().width) {
      tooltipTop = top - 14;
      tooltipLeft = right + 25;
    } else if (this._options.pin === pin.bottom || left - tooltipWidth - 30 < 0) {
      $container.addClass('below');
      tooltipTop = bottom + 10;
      tooltipLeft = Math.min(Math.max(getViewportSize().width - tooltipWidth, 0), left);
    } else {
      $container.addClass('right');
      tooltipTop = top - 14;
      tooltipLeft = left - tooltipWidth - 30;
    }

    $container.get(0).style.width = `${tooltipWidth}px`;

    this._positionContainer({
      left: tooltipLeft,
      top: tooltipTop
    });
  }

}

class hover_HoverDropdownList extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverDropdownList RESDropdownList">
			<ul class="RESDropdownOptions" data-hover-element="0"></ul>
		</div>
	`;
    this._options = { ...hover_Hover._defaultOptions,
      pin: pin.bottom,
      offsetWidth: 0,
      offsetHeight: 2,
      bottomPadding: 10
    };
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      height,
      width
    } = target.getBoundingClientRect();
    const $container = $(this.getContainer());

    switch (this._options.pin) {
      case pin.right:
        const bottomAlign = top + $container.height() + this._options.bottomPadding > getViewportSize().height;

        if (bottomAlign) {
          this._positionContainer({
            left: left + width,
            bottom: this._options.bottomPadding
          });
        } else {
          this._positionContainer({
            left: left + width,
            top: top + this._options.offsetHeight
          });
        }

        break;

      case pin.bottom:
      default:
        const leftAlign = left + $container.outerWidth() < getViewportSize().width;

        if (leftAlign) {
          this._positionContainer({
            left,
            top: top + height + this._options.offsetHeight
          });
        } else {
          this._positionContainer({
            right: getViewportSize().width - left - width + this._options.offsetWidth,
            top: top + height + this._options.offsetHeight
          });
        }

        break;
    }
  }

}
// CONCATENATED MODULE: ./lib/modules/settingsNavigation.js







const settingsNavigation_module = new Module('settingsNavigation');
settingsNavigation_module.moduleName = 'settingsNavName';
settingsNavigation_module.category = 'coreCategory';
settingsNavigation_module.description = 'settingsNavDesc';
settingsNavigation_module.hidden = true;
settingsNavigation_module.alwaysEnabled = true;
settingsNavigation_module.options = {
  showAllOptions: {
    title: 'settingsNavigationShowAllOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'settingsNavigationShowAllOptionsDesc',
    noconfig: true
  },
  showAllOptionsAlert: {
    title: 'settingsNavigationShowAllOptionsAlertTitle',
    type: 'boolean',
    value: true,
    description: 'settingsNavigationShowAllOptionsAlertDesc',
    noconfig: true
  }
};

settingsNavigation_module.beforeLoad = () => {
  addMenuItem(() => string_namespaceObject.html`<div id="SettingsConsole">
			${i18n('RESSettingsConsole')}
			<span module="search" class="RESMenuItemButton res-icon" title="search settings">\uF094</span>
		</div>`, e => settingsNavigation_open(e.target.getAttribute('module')), -10);
  registerCommand(/^set(?:t?ings?)?$/, 'settings [words to search for]- search RES settings console', (command, val) => `Search RES settings ${val && val.length ? ` for: ${val}` : ''}`, (command, val) => settingsNavigation_open('search', val));
};

settingsNavigation_module.contentStart = () => {
  function findModules(val) {
    return modules_all().filter(v => !v.hidden).map(v => v.moduleID).filter(id => id.toLowerCase().match(val.toLowerCase())).sort();
  }

  registerCommand(/^mod(?:ule?)?$/, 'module [name of module] - open module settings', (command, val) => {
    const matches = findModules(val);
    return matches.length ? `Open module ${matches[0]}` : 'Could not find any matching module.';
  }, (command, val) => settingsNavigation_open(findModules(val)[0]));
  window.addEventListener('popstate', () => {
    settingsNavigation_update();
  });
  settingsNavigation_update();
  document.body.addEventListener('click', e => {
    if (e.ctrlKey) return;
    const url = e.target instanceof HTMLAnchorElement && new URL(e.target.href, location.origin);

    if (url && isSettingsUrl(url.href)) {
      settingsNavigation_update(url);
      e.stopImmediatePropagation();
      e.preventDefault();
    }
  }, true);
};

function makeUrlHashLink(moduleID, optionKey, displayText, cssClass) {
  const mod = getUnchecked(moduleID);

  if (!displayText) {
    if (mod && optionKey) {
      displayText = i18n(mod.options[optionKey].title);
    } else if (mod) {
      displayText = i18n(mod.moduleName);
    } else {
      displayText = 'Settings';
    }
  }

  let title = ['RES Settings'];

  if (mod) {
    title.push(i18n(mod.moduleName));
  }

  if (optionKey) {
    title.push(optionKey);
  }

  title = title.join(' &gt; ');
  const hash = makeUrlHash(moduleID, optionKey);
  return `<a class="${cssClass || ''}" href="${hash}" title="${title}">${displayText}</a>`;
}
function parseHash(hash) {
  const params = hash.match(/\/(?:\w|\s|%20)+/g);
  return {
    moduleID: params && params[0] && params[0].substring(1).replace('%20', ' ') || undefined,
    optionKey: params && params[1] && params[1].substring(1).replace('%20', ' ') || undefined
  };
}
function makeUrlHash(moduleID, optionKey) {
  const hashComponents = [RES_SETTINGS_HASH];

  if (moduleID) {
    hashComponents.push(moduleID);
  }

  if (moduleID && optionKey) {
    hashComponents.push(optionKey);
  }

  return hashComponents.join('/');
}
function isSettingsUrl(href) {
  const {
    origin,
    hash
  } = new URL(href, location.origin);
  const sameSite = origin === getOptionsURL().origin || origin.split('.').slice(-2).join('.') === context_data.origin.split('.').slice(-2).join('.');
  if (!sameSite) return false;
  return hash.startsWith(RES_SETTINGS_HASH) || hash.startsWith('#!settings');
}
function setHash(hash) {
  if (window.top === window) {
    if (parseHash(location.hash).moduleID === parseHash(hash).moduleID) {
      history.replaceState(null, '', hash);
    } else {
      history.pushState(null, '', hash);
    }
  } else {
    window.parent.postMessage({
      hash
    }, '*');
  }
}
let iframe;
function settingsNavigation_update(url = location) {
  if (isSettingsUrl(url.href)) {
    const {
      moduleID,
      optionKey
    } = parseHash(url.hash);
    settingsNavigation_open(moduleID, optionKey);
  } else if (iframe) {
    iframe.contentWindow.postMessage({
      close: true
    }, '*');
  }
}

function listener({
  origin,
  data
}) {
  if (origin !== getOptionsURL().origin) return;
  const {
    failedToLoad,
    hash,
    closing
  } = data;
  if (failedToLoad) handleEmbedFailure();
  if (hash) setHash(hash);
  if (closing) settingsNavigation_close();
}

function handleEmbedFailure() {
  console.warn('Embed failed. Opening RES settings console in new tab');
  if (iframe) openNewTab(iframe.src, true);
  settingsNavigation_close();
}

function settingsNavigation_open(moduleID, optionKey) {
  if (iframe || isOptionsPage()) {
    (iframe && iframe.contentWindow || window).postMessage({
      load: {
        moduleID,
        optionKey
      }
    }, '*');
  } else {
    iframe = document.createElement('iframe');
    iframe.id = 'console-container';
    iframe.src = getOptionsURL(makeUrlHash(moduleID, optionKey)).href;
    window.addEventListener('message', listener);
    iframe.addEventListener('load', () => {
      if (iframe) iframe.contentWindow.postMessage({
        context: context_data
      }, '*');
      let success;
      window.addEventListener('message', ({
        origin,
        data
      }) => {
        if (origin === getOptionsURL().origin && data.loadSuccess) success = true;
      });
      setTimeout(() => {
        if (!success) handleEmbedFailure();
      }, 3000);
    });
    document.body.append(iframe);
    document.body.classList.add('res-console-open');
  }
}
function settingsNavigation_close() {
  if (isOptionsPage()) {
    window.parent.postMessage({
      closing: true
    }, '*');
    window.close();
  } else {
    window.removeEventListener('message', listener);
    if (!iframe) return;
    iframe.remove();
    iframe = null;
    document.body.classList.remove('res-console-open');
    if (isSettingsUrl(location.href)) history.pushState(null, '', location.pathname + location.search);
  }
}
// CONCATENATED MODULE: ./lib/modules/menu.js








const menu_module = new Module('RESMenu');
menu_module.moduleName = 'menuName';
menu_module.category = 'coreCategory';
menu_module.description = 'The <span class="gearIcon"></span> dropdown menu to manage RES settings and quick options';
menu_module.descriptionRaw = true;
menu_module.alwaysEnabled = true;
menu_module.options = {
  gearIconClickAction: {
    title: 'menuGearIconClickActionTitle',
    type: 'enum',
    values: [{
      name: 'menuGearIconClickActionOpenSettings',
      value: 'openSettings'
    }, {
      name: 'menuGearIconClickActionOpenCommandLine',
      value: 'openCommandLine'
    }, {
      name: 'menuGearIconClickActionToggleMenu',
      value: 'toggleMenu'
    }, {
      name: 'menuGearIconClickActionToggleMenuNoHover',
      value: 'toggleMenuNoHover'
    }],
    value: 'toggleMenuNoHover',
    description: 'menuGearIconClickActionDesc',
    bodyClass: true,
    advanced: true
  }
};
const menu_items = [];
let menu_gear;

menu_module.contentStart = () => {
  menu_gear = string_namespaceObject.html`<span id="RESSettingsButton" style="cursor: pointer" title="${i18n('RESSettings')}" class="gearIcon"></span>`;

  if (menu_module.options.gearIconClickAction.value !== 'toggleMenuNoHover') {
    menu_gear.addEventListener('mouseenter', () => {
      showDropdown(200);
    });
  }

  menu_gear.addEventListener('click', () => {
    if (menu_module.options.gearIconClickAction.value === 'openCommandLine' && isRunning(commandLine_namespaceObject)) {
      commandLine_toggle();
      hideDropdown();
    } else if (menu_module.options.gearIconClickAction.value === 'openSettings') {
      settingsNavigation_open();
      hideDropdown();
    } else {
      showDropdown(0);
    }
  });
  const r2MenuPosition = document.body.querySelector('#header-bottom-right ul');

  if (r2MenuPosition) {
    r2MenuPosition.after(string_namespaceObject.html`<span class="separator">|</span>`, menu_gear);
  } else {
    addElement(menu_gear, {
      order: 5
    });
  }
};

menu_module.afterLoad = () => {
  requestAnimationFrame(addLegacyStyling);
};

function showDropdown(openDelay) {
  dropdownList(menu_module.moduleID, HIDDEN_FROM_SETTINGS).options({
    openDelay,
    fadeDelay: 200,
    fadeSpeed: 0.2
  }).populateWith(() => {
    const f = document.createDocumentFragment();
    f.append(...menu_items.sort(({
      order: a
    }, {
      order: b
    }) => a - b).map(buildItem));
    return [f];
  }).target(menu_gear).begin();
}

function hideDropdown() {
  dropdownList(menu_module.moduleID).close(true);
}

function addMenuItem(getElement, onClick = () => {}, order = 0) {
  menu_items.push({
    getElement,
    onClick,
    order
  });
}

function buildItem({
  getElement,
  onClick
}) {
  const li = document.createElement('li');
  li.addEventListener('click', onClick, true);
  li.addEventListener('click', hideDropdown);
  li.append(getElement());
  return li;
}

function addLegacyStyling() {
  const {
    backgroundImage
  } = window.getComputedStyle(menu_gear);

  if (backgroundImage && backgroundImage !== 'none') {
    menu_gear.classList.add('res-gearIcon-legacy');
  }
}
// CONCATENATED MODULE: ./lib/modules/commandLine.js






const commandLine_module = new Module('commandLine');
commandLine_module.moduleName = 'commandLineName';
commandLine_module.description = 'commandLineDesc';
commandLine_module.category = 'coreCategory';
commandLine_module.options = {
  launch: {
    title: 'commandLineLaunchTitle',
    type: 'button',
    text: 'Launch',
    description: 'commandLineLaunchDesc',

    callback() {
      commandLine_open();
    }

  },
  menuItem: {
    title: 'commandLineMenuItemTitle',
    type: 'boolean',
    description: 'commandLineMenuItemDesc',
    value: false
  }
};

commandLine_module.contentStart = () => {
  if (commandLine_module.options.menuItem.value) {
    commandLine_addMenuItem();
  }
};

function commandLine_addMenuItem() {
  addMenuItem(() => string_namespaceObject.html`<div>command line <span class="RESMenuItemButton res-icon">\uF060</span></div>`, () => commandLine_open());
}

const commandLine = once_default()(() => {
  const widget = string_namespaceObject.html`
		<div id="keyCommandLineWidget" hidden>
			<div id="keyCommandForm">
				<input id="keyCommandInput" type="text" autocomplete="off">
				type a command, ? for help, esc to close
				<div id="keyCommandInputTip"></div>
				<div id="keyCommandInputError"></div>
			</div>
		</div>
	`;
  document.body.append(widget);
  const input = downcast(widget.querySelector('#keyCommandInput'), HTMLInputElement);
  const $tip = $(widget).find('#keyCommandInputTip');
  const $error = $(widget).find('#keyCommandInputError');

  const setTip = str => $tip.safeHtml(str);

  const clearTip = () => $tip.empty();

  const setError = str => $error.safeHtml(str);

  const clearError = () => $error.empty();

  input.addEventListener('blur', () => {
    if (!input.value.length) {
      commandLine_close();
    } else {
      setError('click into the text input and press escape to close the command line');
    }
  });
  document.addEventListener('keyup', e => {
    if (!widget.hidden && e.key === NAMED_KEYS.Escape) {
      commandLine_close();
      e.stopImmediatePropagation();
    }
  });
  input.addEventListener('input', async () => {
    clearTip();
    clearError();
    const tip = await commandLine_getTip(commandLine_parse(input.value));
    if (tip) setTip(tip);
  });
  const commandLineForm = widget.querySelector('#keyCommandForm');
  commandLineForm.addEventListener('keydown', async e => {
    if (e.key === NAMED_KEYS.Enter) {
      const error = await commandLine_executeCommand(commandLine_parse(input.value), e);

      if (error) {
        setError(error);
      } else if (error !== false) {
        commandLine_close();
      }
    }
  });
  return {
    widget,
    input
  };
});

function commandLine_open(initialCmd = '') {
  commandLine().widget.hidden = false;
  commandLine().input.focus();
  commandLine().input.value = initialCmd;
  commandLine().input.dispatchEvent(new Event('input'));
}

function commandLine_close() {
  commandLine().input.blur();
  commandLine().widget.hidden = true;
}

function commandLine_toggle() {
  if (commandLine().widget.hidden) commandLine_open();else commandLine_close();
}

function navigateTo(url, e) {
  if (e.shiftKey) {
    openNewTab(url, !e.altKey);
  } else {
    location.href = url;
  }
}

const commands = [];
function registerCommand(commandPredicate, description, getTip, executeCommand) {
  commands.push({
    commandPredicate,
    description,
    getTip,
    executeCommand
  });
}

function getCommandSpec(command, val) {
  let result;
  commands.some(commandSpec => {
    let predicateResult;

    if (typeof commandSpec.commandPredicate.exec === 'function') {
      predicateResult = commandSpec.commandPredicate.exec(command);
    } else if (typeof commandSpec.commandPredicate === 'string') {
      predicateResult = commandSpec.commandPredicate === command;
    } else if (typeof commandSpec.commandPredicate === 'function') {
      predicateResult = commandSpec.commandPredicate(command, val);
    }

    if (predicateResult) {
      result = { ...commandSpec,
        predicateResult
      };
      return true;
    }
  });
  return result;
}

function commandLine_parse(input) {
  const splitWords = input.split(' ');
  const command = splitWords[0];
  const value = splitWords.slice(1).join(' ');
  return {
    command,
    value
  };
}

function commandLine_getTip({
  command,
  value
}) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.getTip(command, value, matchingCommandSpec.predicateResult) || matchingCommandSpec.description;
  }
}

function commandLine_executeCommand({
  command,
  value
}, event) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.executeCommand(command, value, matchingCommandSpec.predicateResult, event);
  } else {
    return 'unknown command - type ? for help';
  }
}

registerCommand(/^\/?r\/(.*)/, 'r/[subreddit] - navigates to subreddit', (command, val, match) => `navigate to subreddit: ${match[1]}`, (command, val, match, e) => {
  navigateTo(`/r/${match[1]}`, e);
});
registerCommand(/^\/?m\/(.*)/, 'm/[multi] - view your multi-reddit [multi]', (command, val, match) => `navigate to multi-reddit: /me/m/${match[1]}`, (command, val, match, e) => {
  navigateTo(`/me/m/${match[1]}`, e);
});
registerCommand('m', 'm - go to inbox', () => 'View messages', (command, value, match, e) => {
  navigateTo('/message/inbox/', e);
});
registerCommand('mm', 'mm - go to moderator mail', () => 'View moderator mail', (command, value, match, e) => {
  navigateTo('/message/moderator/', e);
});
registerCommand('front', 'front - go to frontpage', () => 'Go to frontpage', (command, value, match, e) => {
  navigateTo('/', e);
});
registerCommand(/^XHR/, 'XHRCache clear - manipulate the XHR cache', () => 'clear - clear the cache (use if inline images aren\'t loading properly)', (command, value) => {
  if (/^\s*$/.test(value)) {
    return 'Operation required [clear]';
  }

  switch (value) {
    case 'clear':
      xhrCache_namespaceObject.clear();
      break;

    default:
      return 'The only accepted operation is <tt>clear</tt>';
  }
});
registerCommand(/^user$|^u$|^\/?u(?:ser)?\/(\w*((?!\/m\/).)*)$/, 'user [username] or u/[username] - view profile for [username]', (command, val, match) => {
  val = val || match[1];

  if (!val && loggedInUser()) {
    return 'go to profile';
  } else if (!val) {
    return false;
  } else {
    return `go to profile for: ${val}`;
  }
}, (command, val, match, e) => {
  val = val || match[1] || loggedInUser();

  if (!val) {
    return 'not logged in';
  }

  navigateTo(`/u/${val}`, e);
});
registerCommand(/^\/?u(?:ser)?\/(\w+)\/m(?:\/(.+))?/, 'u/[username]/m/[multi] - view the multireddit [multi] curated by [username]', (command, val, match) => `navigate to multi-reddit: /u/${match[1]}/m/${match[2] || ''}`, (command, val, match, e) => {
  if (!match[1]) {
    return 'no multi-reddit specified';
  }

  navigateTo(`/u/${match[1]}/m/${match[2]}`, e);
});
registerCommand(/^\/?me(?:\/?(.*))$/, ['me - view profile for current user', 'me/saved or me/s - view current user\'s saved links', 'me/saved#comments or me/sc - view current user\'s saved comments', 'me/submitted or me/sub - view current user\'s submitted content', 'me/comments or me/c - view current user\'s comments', 'me/gilded or me/g - view current user\'s gilded content', 'me/liked or me/l - view current user\'s liked content ', 'me/disliked or me/d - view current user\'s disliked content', 'me/hidden or me/h - view current user\'s hidden content'], (command, val, match) => {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    return 'not logged in';
  }

  let str;

  switch (match[1]) {
    case '':
      str = `navigate to user profile: ${loggedIn}`;
      break;

    case 'saved':
    case 's':
      str = 'navigate to current user\'s saved content';
      break;

    case 'saved#comments':
    case 'sc':
      str = 'navigate to current RES\'s saved comments';
      break;

    case 'submitted':
    case 'sub':
      str = 'navigate to current user\'s submitted content';
      break;

    case 'comments':
    case 'c':
      str = 'navigate to current user\'s comments';
      break;

    case 'gilded':
    case 'g':
      str = 'navigate to current user\'s gilded content';
      break;

    case 'liked':
    case 'l':
      str = 'navigate to current user\'s liked content';
      break;

    case 'disliked':
    case 'd':
      str = 'navigate to current user\'s disliked content';
      break;

    case 'hidden':
    case 'h':
      str = 'navigate to current user\'s hidden content';
      break;

    default:
      str = 'navigate to [s]aved, [s]aved[c]omments, [sub]mitted, [c]omments, [g]ilded, [l]iked, [d]isliked, [h]idden';
      break;
  }

  return str;
}, (command, val, match, e) => {
  const currentUser = loggedInUser();

  if (!currentUser) {
    return 'not logged in';
  }

  switch (match[1]) {
    case '':
      navigateTo(`/user/${currentUser}`, e);
      break;

    case 'saved':
    case 's':
      navigateTo(`/user/${currentUser}/saved`, e);
      break;

    case 'saved#comments':
    case 'sc':
      navigateTo(`/user/${currentUser}/saved#comments`, e);
      break;

    case 'submitted':
    case 'sub':
      navigateTo(`/user/${currentUser}/submitted`, e);
      break;

    case 'comments':
    case 'c':
      navigateTo(`/user/${currentUser}/comments`, e);
      break;

    case 'gilded':
    case 'g':
      navigateTo(`/user/${currentUser}/gilded`, e);
      break;

    case 'liked':
    case 'l':
      navigateTo(`/user/${currentUser}/liked`, e);
      break;

    case 'disliked':
    case 'd':
      navigateTo(`/user/${currentUser}/disliked`, e);
      break;

    case 'hidden':
    case 'h':
      navigateTo(`/user/${currentUser}/hidden`, e);
      break;

    default:
      return 'unknown command - type ? for help';
  }
});
registerCommand('userinfo', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`
    }).then(alert_namespaceObject.open);
  }
});
registerCommand('userbadge', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`,
      type: 'json'
    }).then(({
      data
    }) => alert_namespaceObject.open(`, .id-t2_${data.id}::before`));
  }
});
{
  const optionsRegex = /(?:RES)?opt(?:ion)?s?[\.\s]+(.*)/i;
  const moduleDataRegex = /(?:RES)?mod(?:ule)?s?[\.\s]+(.*)/i;

  function sanitizeStorageKey(key) {
    let match;

    if (match = optionsRegex.exec(key)) {
      key = `RESoptions.${match[1]}`;
    } else if (match = moduleDataRegex.exec(key)) {
      key = `RESmodules.${match[1]}`;
    }

    return key;
  }

  function executeCommand(command, key, value) {
    if (command === 'get') {
      storage_namespaceObject.get(key).then(value => alert_namespaceObject.open(string_namespaceObject.escape`Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value)}</textarea>`));
    } else if (command === 'update') {
      const id = `RESStorageUpdate-${Date.now()}`;
      storage_namespaceObject.get(key).then(value => alert_namespaceObject.open(string_namespaceObject.escape`Value of RESStorage[${key}]: <br><br><textarea id="${id}" rows="5" cols="50">${JSON.stringify(value)}</textarea>`, {
        cancelable: true
      }).then(() => {
        const textArea = document.getElementById(id);

        if (textArea) {
          storage_namespaceObject.set(key, JSON.parse(downcast(textArea, HTMLTextAreaElement).value));
        }
      }));
    } else if (command === 'remove') {
      storage_namespaceObject.delete(key);
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] deleted`);
    } else if (command === 'set') {
      storage_namespaceObject.set(key, JSON.parse(value));
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] set to:<br><br><textarea rows="5" cols="50">${value}</textarea>`);
    } else {
      return 'You must specify either "get [key]" or "set [key] [value]"';
    }
  }

  registerCommand(/(?:RES)?stor(?:e|age)?/i, 'RESStorage [get|set|update|remove] [key] [value] - For debug use only, you shouldn\'t mess with this unless you know what you\'re doing.', () => {}, (command, val) => {
    const splitWords = val.split(' ');

    if (splitWords.length < 2) {
      return 'You must specify "get [key]", "update [key]" or "set [key] [value]"';
    } else {
      const key = sanitizeStorageKey(splitWords[1]);
      const value = splitWords.slice(2).join(' ');
      return executeCommand(splitWords[0], key, value);
    }
  });
}
const sortTypes = {
  n: 'new',
  t: 'top',
  h: 'hot',
  r: 'rising',
  c: 'controversial',
  g: 'gilded',
  p: 'ads'
};

const sortTypeRecognizesPeriod = sortType => sortTypes.t === sortType || sortTypes.c === sortType;

const periods = ['hour', 'day', 'week', 'month', 'year', 'all'];

const getPeriod = val => val && periods.find(period => period.startsWith(val));

registerCommand(/^\/([nthrcgp])?/, '/n, /t, /h, /r, /c, /g, or /p - goes to new, top, hot, rising, controversial, gilded, or promoted sort of current subreddit, multireddit or user page', (command, val, match) => {
  const sortType = sortTypes[match[1]];

  if (sortType) {
    return sortTypeRecognizesPeriod(sortType) ? `sort by ${sortType} [(${periods.map(period => getPeriod(val) === period ? `<b>${period}</b>` : period).join('|')})]` : `sort by ${sortType}`;
  } else {
    return 'sort by ([n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted)';
  }
}, (command, val, match, e) => {
  const sortType = sortTypes[match[1]];

  if (!sortType) {
    return 'invalid sort command - must be one of [n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted';
  }

  function _navigateTo(v) {
    const url = new URL(v, location.href);
    const period = getPeriod(val);

    if (sortTypeRecognizesPeriod(sortType) && period) {
      url.searchParams.append('t', period);
    }

    navigateTo(url.href, e);
  }

  const currentUser = currentUserProfile();

  if (currentUser) {
    if (sortType === 'gilded') {
      _navigateTo(`/user/${currentUser}/${sortType}`);
    } else if (sortType === 'ads' || sortType === 'rising') {
      return `invalid sort command - "${sortType}" is not supported on profile pages`;
    } else {
      _navigateTo(`/user/${currentUser}?sort=${sortType}`);
    }

    return;
  }

  const subreddit = currentSubreddit();

  if (subreddit) {
    _navigateTo(`/r/${subreddit}/${sortType}`);

    return;
  }

  const multi = currentMultireddit();

  if (multi) {
    _navigateTo(`/${multi}/${sortType}`);
  } else {
    _navigateTo(`/${sortType}`);
  }
});
registerCommand(cmd => ['s', 'search'].includes(cmd), 's[earch] [query] - searches the current subreddit (if any) or all of Reddit', (command, val) => {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    return `Search all of Reddit: ${val}`;
  }

  return `Search /r/${subreddit}: ${val}`;
}, (command, val, match, e) => {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
    return;
  }

  navigateTo(string_namespaceObject.encode`/r/${subreddit}/search?q=${val}&restrict_sr=on`, e);
});
registerCommand('sr', 'sr [query] - searches all of Reddit', (command, val) => `Search all of Reddit: ${val}`, (command, val, match, e) => {
  navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
});
registerCommand('?', false, () => {
  const descriptions = commands.map(command => command.description).reduce((a, b) => b ? a.concat(b) : a, []);

  if (descriptions.length) {
    return `<ul><li>${descriptions.join('</li><li>')}</li></ul>`;
  }
}, () => false);
// CONCATENATED MODULE: ./lib/modules/notifications.js









const notifications_module = new Module('notifications');
notifications_module.moduleName = 'notificationsName';
notifications_module.category = 'coreCategory';
notifications_module.description = 'notificationsDesc';
notifications_module.options = {
  sticky: {
    description: 'notificationStickyDesc',
    title: 'notificationStickyTitle',
    type: 'enum',
    value: 'notificationType',
    values: [{
      name: 'notificationsPerNotificationType',
      value: 'notificationType'
    }, {
      name: 'notificationsAlwaysSticky',
      value: 'all'
    }, {
      name: 'notificationsNeverSticky',
      value: 'none'
    }]
  },
  closeDelay: {
    type: 'text',
    value: '3000',
    description: 'notificationCloseDelayDesc',
    title: 'notificationCloseDelayTitle'
  },
  fadeOutLength: {
    type: 'text',
    value: '3000',
    description: 'notificationFadeOutLengthDesc',
    title: 'notificationFadeOutLengthTitle',
    advanced: true
  },
  notificationTypes: {
    description: 'notificationNotificationTypesDesc',
    title: 'notificationNotificationTypesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'notificationsAddNotificationType',
    fields: [{
      key: 'moduleID',
      name: 'moduleID',
      type: 'text'
    }, {
      key: 'notificationID',
      name: 'notificationsNotificationID',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'notificationsEnabled',
      type: 'boolean',
      value: true
    }, {
      key: 'sticky',
      name: 'notificationsSticky',
      type: 'boolean',
      value: false
    }, {
      key: 'cooldown',
      name: 'notificationsCooldown',
      type: 'text',
      value: '0'
    }],
    value: []
  }
};
const recentNotificationStorage = storage_namespaceObject.wrap('RESmodules.notifications.recent', []);

notifications_module.beforeLoad = () => {
  registerCommand('notification', false, () => {}, (command, val) => {
    notifications_showNotification(val, 4000);
  });
};

notifications_module.go = () => {
  setupNotificationContainer();
};

const notificationTimers = [];
let notificationCount = 0;
const notificationsContainer = string_namespaceObject.html`<div id="RESNotifications"></div>`;

function getOrAddNotificationType(notification) {
  const valueIdentifier = {
    moduleID: firstValid(notification.moduleID, '--'),
    notificationID: firstValid(notification.notificationID, notification.optionKey, notification.header, hashCode(notification.message instanceof HTMLElement ? notification.message.outerHTML : notification.message))
  };
  const value = table_namespaceObject.getMatchingValueOrAdd(notifications_module, 'notificationTypes', valueIdentifier, function () {
    return { ...notification,
      ...valueIdentifier
    };
  });

  if (typeof value[4] !== 'number') {
    value[4] = parseInt(value[4], 10) || 0;
  }

  return mapScalarToObject(notifications_module.options.notificationTypes, value);
}

function enableNotificationType(notificationType, enabled) {
  const value = table_namespaceObject.getMatchingValueOrAdd(notifications_module, 'notificationTypes', notificationType);
  value[2] = !!enabled;
  options_set(notifications_module, 'notificationTypes', notifications_module.options.notificationTypes.value);
}

async function notifications_showNotification(contentObj, delay) {
  if (!isRunning(notifications_module)) {
    return {
      element: document.createElement('div'),

      close() {}

    };
  }

  if (typeof contentObj === 'string') {
    contentObj = {
      message: contentObj
    };
  }

  const notificationType = getOrAddNotificationType(contentObj);
  if (!notificationType.enabled) return notificationError('enabled');
  if (!(await hasNotificationCooledDown(notificationType))) return notificationError('cooldown');
  logNotification(notificationType);
  const thisNotification = createNotificationElement(contentObj, notificationType);

  if (contentObj.closeDelay !== undefined) {
    delay = contentObj.closeDelay;
  }

  if (contentObj.noDisable) {
    thisNotification.querySelector('.RESNotificationFooter').style.display = 'none';
  } else {
    thisNotification.querySelector('.RESNotificationToggle input').addEventListener('change', e => {
      const target = e.target;
      enableNotificationType(notificationType, target.checked);
    });
  }

  const thisNotificationCloseButton = thisNotification.querySelector('.RESNotificationClose');
  thisNotificationCloseButton.addEventListener('click', e => {
    const thisNotification = e.target.parentNode.parentNode;
    closeNotification(thisNotification);
  });
  const isSticky = notifications_module.options.sticky.value === 'all' || notifications_module.options.sticky.value === 'notificationType' && notificationType.sticky;

  if (!isSticky && delay !== Infinity) {
    setCloseNotificationTimer({
      currentTarget: thisNotification
    }, delay);
  }

  notificationsContainer.appendChild(thisNotification);
  notificationCount++;
  $(thisNotification).fadeIn(200).addClass('transition');
  return {
    element: thisNotification,
    close: once_default()(() => closeNotification(thisNotification))
  };
}

function notificationError(error) {
  return {
    element: document.createElement('div'),

    close() {},

    error
  };
}

function renderHeaderHtml(contentObj) {
  let header;
  const mod = contentObj.moduleID && getUnchecked(contentObj.moduleID);

  if (contentObj.header) {
    header = contentObj.header;
  } else {
    header = [];

    if (mod) {
      header.push(i18n(mod.moduleName));
    }

    if (contentObj.type === 'error') {
      header.push('Error');
    }

    header = header.join(' ');
  }

  if (mod && !mod.hidden) {
    header += makeUrlHashLink(mod.moduleID, contentObj.optionKey, ' ', 'gearIcon');
  }

  return header;
}

function setupNotificationContainer() {
  notificationsContainer.style.top = `${getHeaderOffset(true)}px`;
  document.body.append(notificationsContainer);
}

function createNotificationElement(contentObj, notificationType) {
  const $thisNotification = $('<div>', {
    id: `RESNotification-${notificationCount || 0}`,
    class: ['RESNotification', `${notificationType.moduleID}-${notificationType.notificationID}`].join(' '),
    html: `
			<div class="RESNotificationHeader">
				<h3></h3>
				<div class="RESNotificationClose RESCloseButton">&times;</div>
			</div>
			<div class="RESNotificationContent"></div>
			<div class="RESNotificationFooter">
				<label class="RESNotificationToggle">
				<input type="checkbox" checked> Always show this type of notification</label>
			</div>
		`
  });
  $thisNotification.find('h3').append(renderHeaderHtml(contentObj));
  $thisNotification.find('.RESNotificationContent').append(contentObj.message);
  $thisNotification.find('.RESNotificationToggle').attr('title', `Show notifications from ${notificationType.moduleID} - ${notificationType.notificationID}`);
  return $thisNotification.get(0);
}

function setCloseNotificationTimer({
  currentTarget: thisNotification
}, delay, duration) {
  delay = +firstValid(delay, parseInt(notifications_module.options.closeDelay.value, 10), notifications_module.options.closeDelay.default);
  duration = +firstValid(duration, parseInt(notifications_module.options.fadeOutLength.value, 10), notifications_module.options.fadeOutLength.default);
  const thisNotificationID = +thisNotification.getAttribute('id').split('-')[1];
  thisNotification.classList.add('timerOn');
  thisNotification.setAttribute('style', `-webkit-animation-delay: ${delay / 1000}s; -webkit-animation-duration: ${duration / 1000}s; animation-delay: ${delay / 1000}s; animation-duration: ${duration / 1000}s`);
  delay += duration;
  clearAsyncTasks(thisNotification);
  const thisTimer = setTimeout(() => closeNotification(thisNotification), delay);
  notificationTimers[thisNotificationID] = thisTimer;
  thisNotification.addEventListener('mouseenter', cancelCloseNotificationTimer);
}

function cancelCloseNotificationTimer({
  currentTarget: thisNotification
}) {
  thisNotification.classList.remove('timerOn');
  thisNotification.removeAttribute('style');
  clearAsyncTasks(thisNotification);
  thisNotification.addEventListener('mouseleave', setCloseNotificationTimer);
}

function clearAsyncTasks(thisNotification) {
  thisNotification.removeEventListener('mouseleave', setCloseNotificationTimer);
  thisNotification.removeEventListener('mouseenter', cancelCloseNotificationTimer);
  const thisNotificationID = +thisNotification.getAttribute('id').split('-')[1];
  clearTimeout(notificationTimers[thisNotificationID]);
}

function closeNotification(thisNotification) {
  clearAsyncTasks(thisNotification);
  $(thisNotification).fadeOut(thisNotification.classList.contains('timerOn') ? 0 : 200).promise().then(notificationClosed);
}

function notificationClosed() {
  for (const notification of notificationsContainer.querySelectorAll('.RESNotification')) {
    if (!notification.offsetParent) {
      notification.remove();
    }
  }
}

async function hasNotificationCooledDown(notificationType) {
  const recentNotifications = await recentNotificationStorage.get();
  const latestNotificationOfSameType = recentNotifications.find(({
    moduleID,
    notificationID
  }) => moduleID === notificationType.moduleID && notificationID === notificationType.notificationID);

  if (!latestNotificationOfSameType || !latestNotificationOfSameType.timestamp) {
    return true;
  }

  if (latestNotificationOfSameType.timestamp + notificationType.cooldown <= Date.now()) {
    return true;
  }

  return false;
}

async function logNotification(notificationType) {
  const collection = await recentNotificationStorage.get();
  const newItem = {
    moduleID: notificationType.moduleID,
    notificationID: notificationType.notificationID,
    timestamp: Date.now()
  };
  collection.unshift(newItem);
  const pruned = pruneLog(collection);
  recentNotificationStorage.set(pruned);
}

const maxItemsPerNotificationType = 1;

function pruneLog(collection) {
  const pruned = [];
  const index = {};

  for (const item of collection) {
    index[item.moduleID] = index[item.moduleID] || {};
    index[item.moduleID][item.notificationID] = 1 + (index[item.moduleID][item.notificationID] || 0);

    if (+index[item.moduleID][item.notificationID] === maxItemsPerNotificationType) {
      pruned.push(item);
    }
  }

  return pruned;
}
// CONCATENATED MODULE: ./lib/modules/penaltyBox.js









const penaltyBox_module = new Module('penaltyBox');
const MIN_PENALTY = 1;
const MAX_PENALTY = 100;
penaltyBox_module.moduleName = 'penaltyBoxName';
penaltyBox_module.category = 'coreCategory';
penaltyBox_module.description = 'penaltyBoxDesc';
penaltyBox_module.options = {
  delayFeatures: {
    type: 'boolean',
    value: true,
    description: 'penaltyBoxDelayFeaturesDesc',
    title: 'penaltyBoxDelayFeaturesTitle'
  },
  suspendFeatures: {
    type: 'boolean',
    value: false,
    description: 'penaltyBoxSuspendFeaturesDesc',
    title: 'penaltyBoxSuspendFeaturesTitle'
  },
  features: {
    description: 'penaltyBoxFeaturesDesc',
    title: 'penaltyBoxFeaturesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'penaltyBoxFeaturesAddRowText',
    fields: [{
      key: 'moduleID',
      name: 'moduleID',
      type: 'text'
    }, {
      key: 'optionKey',
      name: 'optionKey',
      type: 'text'
    }, {
      key: 'monitoring',
      name: 'penaltyBoxFeaturesMonitoring',
      type: 'boolean',
      value: true
    }, {
      key: 'penalty',
      name: 'penaltyBoxFeaturesPenalty',
      type: 'text',
      value: '0'
    }],
    value: []
  }
};
function alterFeaturePenalty(moduleID, optionKey, valueDelta) {
  if (isNaN(parseInt(valueDelta, 10))) {
    console.warn('Could not alter penalty for', moduleID, optionKey, ' - bad value:', valueDelta);
    return MIN_PENALTY;
  }

  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);
  if (!value.monitoring) return MIN_PENALTY;
  value.penalty = clamp_default()(value.penalty + valueDelta, MIN_PENALTY, MAX_PENALTY);
  options_set(penaltyBox_module, 'features', penaltyBox_module.options.features.value);

  if (value.penalty >= MAX_PENALTY) {
    suspendFeature(moduleID, optionKey);
  }

  return value.penalty;
}

function stopMonitoringFeature(moduleID, optionKey) {
  const value = getOrAddFeatures(moduleID, optionKey);
  value.monitoring = false;
  value.penalty = MIN_PENALTY;
  options_set(penaltyBox_module, 'features', penaltyBox_module.options.features.value);
}

function getFeaturePenalty(moduleID, optionKey) {
  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  if (!penaltyBox_module.options.delayFeatures.value) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);

  if (!value.monitoring) {
    return MIN_PENALTY;
  }

  if (!value.penalty || MIN_PENALTY >= value.penalty) {
    return MIN_PENALTY;
  }

  return value.penalty;
}
function penalizedDelay(moduleID, optionKey, delayOption) {
  const penalty = getFeaturePenalty(moduleID, optionKey);

  if (!penalty || penalty === MIN_PENALTY) {
    return parseInt(delayOption.value, 10);
  }

  const max = parseInt(delayOption.penalizedValue || delayOption.value, 10) * 6;
  const initial = parseInt(delayOption.default, 10);
  return Math.min(max, (max - initial) * (penalty / 100) + initial);
}

function getOrAddFeatures(moduleID, optionKey) {
  const value = table_namespaceObject.getMatchingValueOrAdd(penaltyBox_module, 'features', {
    moduleID,
    optionKey
  });
  const obj = mapScalarToObject(penaltyBox_module.options.features, value);
  obj.penalty = parseInt(obj.penalty, 10) || 0;
  return obj;
}

async function suspendFeature(moduleID, optionKey) {
  if (!penaltyBox_module.options.suspendFeatures.value) {
    return;
  }

  const featureModule = modules_get(moduleID);
  const option = featureModule.options[optionKey];

  if (!option) {
    console.warn('Could not find option', moduleID, optionKey);
    return;
  }

  if (option.type !== 'boolean') {
    console.warn(`${penaltyBox_module.moduleID} could not disable option`, moduleID, optionKey);
    return;
  }

  const oldValue = option.value;
  const newValue = !option.value;
  options_set(moduleID, optionKey, newValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  const notification = await notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesNotificationHeader'),
    message: `
			${i18n('penaltyBoxSuspendFeaturesNotificationMessage', featureOptionLink)}
			<p><a class="RESNotificationButtonBlue" id="penaltyBoxEnableFeature" href="#">
				${i18n('penaltyBoxSuspendFeaturesUndoButton')}
			</a></p>
		`.trim()
  });
  $(notification.element).on('click', '#penaltyBoxEnableFeature', e => {
    e.preventDefault();
    notification.close();
    pardonSuspendedFeature(moduleID, optionKey, oldValue);
  });
}

function pardonSuspendedFeature(moduleID, optionKey, oldValue) {
  options_set(moduleID, optionKey, oldValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesRevertNotificationHeader'),
    message: i18n('penaltyBoxSuspendFeaturesRevertNotificationMessage', featureOptionLink)
  });
}
// EXTERNAL MODULE: ./node_modules/lodash/last.js
var last = __webpack_require__(7);
var last_default = /*#__PURE__*/__webpack_require__.n(last);

// EXTERNAL MODULE: ./node_modules/lodash/maxBy.js
var maxBy = __webpack_require__(53);
var maxBy_default = /*#__PURE__*/__webpack_require__.n(maxBy);

// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__(82);
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);

// EXTERNAL MODULE: ./node_modules/lodash/pickBy.js
var pickBy = __webpack_require__(22);
var pickBy_default = /*#__PURE__*/__webpack_require__.n(pickBy);

// EXTERNAL MODULE: ./node_modules/lodash/escapeRegExp.js
var escapeRegExp = __webpack_require__(83);
var escapeRegExp_default = /*#__PURE__*/__webpack_require__.n(escapeRegExp);

// CONCATENATED MODULE: ./lib/modules/filteReddit/Case.js



class Case_Case {
  static async getSelectedEntryValue() {
    const selected = Thing_Thing.selected;
    if (!selected) throw new Error('No entry is currently selected.');
    let conditions;

    if (this.defaultConditions) {
      if (!this.thingToCriterion) throw Error('Case does not have method `thingToCriterion`');
      if (!this.criterionToConditions) throw Error('Case does not have method `criterionToConditions`');
      conditions = this.criterionToConditions((await this.thingToCriterion(selected)));
    }

    const cased = this.fromConditions(conditions);
    const state = await cased.evaluate(selected);
    if (typeof state !== 'boolean') throw new Error('Could not evaluate case against selected thing');
    return {
      conditions,
      state
    };
  }

  static criterionToConditions(criterion) {
    const parse = this.parseCriterion && this.parseCriterion.bind(this);

    if (!parse) {
      throw new Error('Does not accept criterion');
    }

    if (!criterion && this.pattern && !this.pattern.startsWith('[')) {
      throw new Error('Requires criterion');
    }

    const parts = criterion.split(' & ');

    if (this.criterionOperators && criterion && parts.length > 1) {
      return getGroup('all', parts.map(v => cases_getConditions(this.type, parse(v))));
    } else {
      return parse(criterion);
    }
  }

  static fromConditions(from, propagateError = false) {
    let cased;
    const conditions = cases_getConditions(from && from.type || this.type, from);
    const type = conditions.type;

    try {
      const CaseClass = cases_get(type);
      if (CaseClass.disabled) throw new Error(`${CaseClass.type} is disabled`);
      cased = new CaseClass(conditions);
    } catch (e) {
      if (propagateError) throw e;
      console.error(`Could not build case: ${e.message}. Ignoring.`, e);
      cased = new cases_Inert(conditions);
    }

    return cased;
  }

  static buildRegex(val, {
    fullMatch = true
  } = {}) {
    if (!val) throw new Error('Pattern cannot be empty');

    if (string_namespaceObject.regexRegex.test(val)) {
      const [, str, flags] = string_namespaceObject.regexRegex.exec(val);
      return new RegExp(str, flags);
    } else {
      const patt = escapeRegExp_default()(val);

      return new RegExp(fullMatch ? `^${patt}$` : patt, 'i');
    }
  }

  static get disabled() {
    return false;
  }

  static validate(conditions) {
    const cased = Case_Case.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');
    return true;
  }

  static getCustomFilter() {
    if (this._customFilter) return this._customFilter;
    throw new Error('Source not found');
  }

  constructor(conditions) {
    this.trueText = void 0;
    this.falseText = void 0;
    this.conditions = void 0;
    this.value = void 0;
    this.observers = new Set();
    this.conditions = this.value = conditions;
  }

  isValid() {
    return true;
  }

  isEvaluatable() {
    return !(this instanceof cases_Inert || this.constructor.disabled);
  }

  hasType(type) {
    return this.constructor.type === type;
  }

  evaluate(thing, values) {
    throw new Error('evaluate() must be implemented for all Case subclasses');
  }

  onObserve() {}

  observe(observer) {
    if (!this.observers.has(observer) && this.onObserve()) {
      this.observers.add(observer);
      return true;
    }
  }

  refresh(thing) {
    for (const o of this.observers) o.refresh(thing);
  }

}
Case_Case.type = void 0;
Case_Case.text = void 0;
Case_Case.thingToCriterion = void 0;
Case_Case.parseCriterion = void 0;
Case_Case.defaultConditions = void 0;
Case_Case.fields = void 0;
Case_Case.slow = 0;
Case_Case.reconcile = void 0;
Case_Case.contexts = void 0;
Case_Case.unique = false;
Case_Case.variant = 'basic';
Case_Case.pattern = '';
Case_Case.criterionOperators = false;
Case_Case._customFilter = void 0;
class Case_PatternCase extends Case_Case {
  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static reconcile(values) {
    const a = values[0];
    if (!a) throw new Error('No values');
    return { ...a,
      patt: values.map(v => v.patt)
    };
  }

  build(fullMatchDefault, pattIfEmpty) {
    const {
      patt,
      fullMatch = fullMatchDefault
    } = this.conditions;
    const raw = Array.isArray(patt) ? patt : [patt];
    const plain = new Set();
    const variants = {};

    for (let _patt of raw) {
      if (!_patt) {
        if (typeof pattIfEmpty === 'string') _patt = pattIfEmpty;else if (raw.length === 1) throw new Error('Pattern cannot be empty');else continue;
      }

      if (string_namespaceObject.regexRegex.test(_patt)) {
        const [, str, flags = ''] = string_namespaceObject.regexRegex.exec(_patt);
        if (!variants[flags]) variants[flags] = [];
        variants[flags].push(str);
      } else {
        plain.add(escapeRegExp_default()(_patt));
      }
    }

    if (plain.size) {
      const str = Array.from(plain).join('|');
      if (!variants.i) variants.i = [];
      variants.i.push(fullMatch ? `^(${str})$` : str);
    }

    return Object.entries(variants).map(([flags, sources]) => new RegExp(sources.join('|'), flags));
  }

}
Case_PatternCase.defaultConditions = {
  patt: ''
};
Case_PatternCase.pattern = 'RegEx';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentCount.js


class CommentCount_CommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `comment count ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `comment count ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getCommentCount() || 0);
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const commentCount = thing.getCommentCount();
    if (isNaN(commentCount)) return null;
    return numericalCompare(this.value.op, commentCount, this.value.val);
  }

}
CommentCount_CommentCount.text = 'Comment count';
CommentCount_CommentCount.defaultConditions = {
  op: '>',
  val: 0
};
CommentCount_CommentCount.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' comments'];
CommentCount_CommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/dashboard.js










const dashboard_module = new Module('dashboard');
dashboard_module.moduleName = 'dashboardName';
dashboard_module.category = 'productivityCategory';
dashboard_module.description = 'dashboardDesc';
dashboard_module.bodyClass = true;
dashboard_module.options = {
  menuItem: {
    type: 'boolean',
    value: true,
    description: 'dashboardMenuItemDesc',
    title: 'dashboardMenuItemTitle'
  },
  defaultPosts: {
    type: 'text',
    value: '3',
    description: 'dashboardDefaultPostsDesc',
    title: 'dashboardDefaultPostsTitle',
    advanced: true
  },
  defaultSort: {
    type: 'enum',
    values: [{
      name: 'hot',
      value: 'hot'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'rising',
      value: 'rising'
    }, {
      name: 'controversial',
      value: 'controversial'
    }, {
      name: 'top',
      value: 'top'
    }],
    value: 'hot',
    description: 'dashboardDefaultSortDesc',
    title: 'dashboardDefaultSortTitle'
  },
  defaultSortSearch: {
    type: 'enum',
    values: [{
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    value: 'relevance',
    description: 'dashboardDefaultSortSearchDesc',
    title: 'dashboardDefaultSortSearchTitle'
  },
  dashboardShortcut: {
    type: 'boolean',
    value: true,
    description: 'dashboardDashboardShortcutDesc',
    title: 'dashboardDashboardShortcutTitle'
  },
  tagsPerPage: {
    type: 'text',
    value: '25',
    description: 'dashboardTagsPerPageDesc',
    title: 'dashboardTagsPerPageTitle',
    advanced: true
  }
};

dashboard_module.shouldRun = () => isCurrentSubreddit('dashboard');

const initialWidgetLoad = once_default()(getLatestWidgets);

dashboard_module.always = () => {
  if (modules_isEnabled(dashboard_module)) {
    if (dashboard_module.options.menuItem.value) {
      const dashboardUrl = isAppType('d2x') ? 'https://old.reddit.com/r/Dashboard' : '/r/Dashboard';
      addMenuItem(() => string_namespaceObject.html`<a href="${dashboardUrl}">${i18n('myDashboard')}</a>`, undefined, -7);
    }

    const subreddit = currentSubreddit();

    if (dashboard_module.options.dashboardShortcut.value && subreddit) {
      sitetableStarted.then(async () => {
        await initialWidgetLoad();
        addDashboardShortcuts(subreddit);
      });
    }
  }
};

dashboard_module.go = async () => {
  await initialWidgetLoad();
  drawDashboard();
  document.querySelector('#header-bottom-left .tabmenu').classList.add('res-dashboard-tabmenu-ready');
};

const initialTabID = location.hash.replace('#', '') || 'dashboardContents';
let selectedTabMenuItem;
function addTab(tabID, tabName, tabModuleId) {
  const $tabPage = $('<div class="dashboardPane">').appendTo('#siteTable.linklisting').hide();
  const tabMenuItem = createElement_namespaceObject.tabMenuItem({
    text: tabName,
    className: 'res-dashboard-tab',
    prepend: true
  });

  if (tabModuleId) {
    const gear = string_namespaceObject.html`${string_namespaceObject.safe(makeUrlHashLink(tabModuleId, undefined, ' ', 'gearIcon'))}`;
    tabMenuItem.after(gear);
  }

  tabMenuItem.addEventListener('change', ({
    detail: active
  }) => {
    if (active) {
      $tabPage.show();
      if (selectedTabMenuItem) selectedTabMenuItem.click();
      selectedTabMenuItem = tabMenuItem;
      location.hash = tabID;
    } else {
      $tabPage.hide();
    }
  });
  if (tabID === initialTabID) tabMenuItem.click();
  return $tabPage;
}
const MAX_ROWS = 100;
const dashboardStorage = storage_namespaceObject.wrap(() => `RESmodules.dashboard.${loggedInUser() || 'null'}`, []);
let widgets = [];

async function getLatestWidgets() {
  widgets = (await dashboardStorage.get()).filter(Boolean);
}

function drawDashboard() {
  const $tabPage = addTab('dashboardContents', 'My dashboard', dashboard_module.moduleID);
  attachAddComponent($tabPage);
  attachEditComponent();
  initUpdateQueue();
}

function initUpdateQueue() {
  for (const widget of widgets) {
    if (widget) addWidget(widget);
  }

  const $dashboard = $('#RESDashboard');
  const edgeScroll = new dom_EdgeScroll($dashboard.get(0));
  setTimeout(() => {
    $dashboard.sortable({
      delay: 200,
      nested: false,
      handle: 'div.RESDashboardComponentHeader',
      itemSelector: '.RESDashboardComponent',
      placeholderClass: 'RESSortPlaceholder',
      placeholder: '<li class="RESSortPlaceholder"></li>',

      onDrop($item, container, _super, event) {
        _super($item, container, _super, event);

        edgeScroll.stop();
        saveOrder();
      },

      onDragStart() {
        edgeScroll.start();
      }

    });
  }, 300);
}

const updateQueue = [];
let updateQueueTimer;

function addToUpdateQueue(updateFunction) {
  updateQueue.push(updateFunction);

  if (!updateQueueTimer) {
    updateQueueTimer = setInterval(processUpdateQueue, 2000);
    setTimeout(processUpdateQueue, 100);
  }
}

function processUpdateQueue() {
  const thisUpdate = updateQueue.pop();
  thisUpdate();

  if (updateQueue.length < 1) {
    clearInterval(updateQueueTimer);
    updateQueueTimer = undefined;
  }
}

function saveOrder() {
  const data = $('#siteTable li.RESDashboardComponent').toArray().map(e => $(e).attr('id'));
  data.reverse();
  const newOrder = [];

  for (const widget of widgets) {
    const newIndex = data.indexOf(widget.basePath.replace(/(\/|\+)/g, '_'));
    newOrder[newIndex] = widget;
  }

  widgets = newOrder;
  dashboardStorage.set(widgets);
}

let widgetBeingEdited;

function attachEditComponent() {
  const $dashboardEditComponent = $('<div id="RESDashboardEditComponent" class="RESDashboardComponent" />');
  $dashboardEditComponent.html(`
		<div class="editWidget">Edit widget</div>
		<div id="editRedditFormContainer" class="editRedditForm">
			<form id="editRedditForm">
				<input type="text" id="editReddit">
				<input type="text" id="editRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
			<form id="editSearchForm">
				<input type="text" id="editSearch" placeholder="search terms">
				<input type="text" id="editSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
		</div>
	`);
  $dashboardEditComponent.find('#editRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = $('#editReddit').val();

    if (thisBasePath !== '') {
      if (thisBasePath.includes(',')) {
        thisBasePath = thisBasePath.replace(/,/g, '+');
      }

      widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
      widgetBeingEdited.basePath = `/r/${thisBasePath}`;
      widgetBeingEdited.displayName = $('#editRedditDisplayName').val();
      widgetBeingEdited.update();
      $('#editReddit').tokenInput('clear');
      $('#RESDashboardEditComponent').fadeOut(() => $('#editReddit').blur());
      widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', `/r/${thisBasePath}`);
      dashboard_updateWidget();
    }
  });
  $dashboardEditComponent.find('#editSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = $('#editSearch').val();
    widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
    widgetBeingEdited.basePath = string_namespaceObject.encode`/search?q=${thisBasePath}`;
    widgetBeingEdited.displayName = $('#editSearchDisplayName').val();
    widgetBeingEdited.update();
    $('#RESDashboardEditComponent').fadeOut(() => {
      $('#editSearch').val('').blur();
      $('#editSearchDisplayName').val('').blur();
    });
    widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', thisBasePath);
    dashboard_updateWidget();
  });
  $dashboardEditComponent.find('.cancelButton').click(() => {
    if (widgetBeingEdited.basePath.startsWith('/search?q=')) {
      $('#RESDashboardEditComponent').fadeOut(() => $('#editSearchDisplayName').val('').blur());
    } else {
      $('#editReddit').tokenInput('clear');
      $('#RESDashboardEditComponent').fadeOut(() => $('#editReddit').blur());
    }
  });
  $(document.body).append($dashboardEditComponent);
}

let firstEdit;

function showEditForm() {
  let basePath = widgetBeingEdited.basePath;
  const widgetEle = widgetBeingEdited.widgetEle;
  const eleTop = $(widgetEle).position().top;
  const eleWidth = $(widgetEle).width();
  $('#RESDashboardEditComponent').css('top', `${eleTop}px`).css('left', '5px').css('width', `${eleWidth + 2}px`);

  if (basePath.startsWith('/search?q=')) {
    $('#editSearchDisplayName').val(widgetBeingEdited.displayName);
    $('#editSearch').val(decodeURIComponent(basePath.substr(10)));
    $('#editSearchForm').show();
    $('#editRedditForm').hide();
    $('#RESDashboardEditComponent').fadeIn('fast');
  } else {
    $('#editRedditDisplayName').val(widgetBeingEdited.displayName);
    $('#editRedditForm').show();
    $('#editSearchForm').hide();
    $('#RESDashboardEditComponent').fadeIn('fast');
    basePath = basePath.replace(/^\/r\//, '');
    const reddits = basePath.split('+');
    const prepop = reddits.map(reddit => ({
      id: reddit,
      name: reddit
    }));

    if (!firstEdit) {
      $('#editReddit').tokenInput('/api/search_reddit_names.json?app=res', {
        method: 'POST',
        queryParam: 'query',
        theme: 'facebook',
        allowFreeTagging: true,
        zindex: 999999999,

        onResult(response) {
          if (response.names.length === 0) {
            const failedQueryValue = $('#token-input-editReddit').val();
            return [{
              id: failedQueryValue,
              name: failedQueryValue,
              failedResult: true
            }];
          }

          return response.names.map(name => ({
            id: name,
            name,
            failedResult: false
          }));
        },

        onCachedResult(response) {
          return this.onResult(response);
        },

        prePopulate: prepop,
        searchingText: 'Searching for matching reddits - may take a few seconds...',
        hintText: 'Type one or more subreddits for which to create a widget.',

        resultsFormatter(item) {
          let thisDesc = item.name;

          if (item.failedResult) {
            thisDesc += ' - [this subreddit may not exist, ensure proper spelling]';
          }

          return `<li>${thisDesc}</li>`;
        }

      });
      firstEdit = true;
    } else {
      $('#editReddit').tokenInput('clear');

      for (const value of prepop) {
        $('#editReddit').tokenInput('add', value);
      }
    }
  }
}

let $dashboardUL;

function attachAddComponent($tabPage) {
  const $dashboardAddComponent = $('<div id="RESDashboardAddComponent" class="RESDashboardComponent" />');
  $dashboardAddComponent.html(`
		<div class="addNewWidget">Add a new widget</div>
		<div id="addWidgetButtons">
			<div class="addButton" id="addSearchWidget">+search widget</div>
			<div class="addButton" id="addMailWidget">+mail widget</div>
			<div class="addButton" id="addUserWidget">+user widget</div>
			<div class="addButton" id="addRedditWidget">+subreddit widget</div>
		</div>
		<div id="addSearchFormContainer" class="addSearchForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addSearchForm">
				<input type="text" id="addSearch" placeholder="search terms">
				<input type="text" id="addSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addMailWidgetContainer">
			<div class="backToWidgetTypes">&laquo; back</div>
			<div class="addButton widgetShortcut" widgetPath="/message/inbox/">+inbox</div>
			<div class="addButton widgetShortcut" widgetPath="/message/unread/">+unread</div>
			<div class="addButton widgetShortcut" widgetPath="/message/messages/">+messages</div>
			<div class="addButton widgetShortcut" widgetPath="/message/comments/">+comment replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/selfreply/">+post replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/moderator/">+modmail</div>
		</div>
		<div id="addUserFormContainer" class="addUserForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addUserForm">
				<input type="text" id="addUser">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addRedditFormContainer" class="addRedditForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addRedditForm">
				<input type="text" id="addReddit">
				<input type="text" id="addRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
	`);
  $dashboardAddComponent.find('.backToWidgetTypes').click(function () {
    $(this).parent().fadeOut(() => $('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('.widgetShortcut').click(function () {
    const thisBasePath = $(this).attr('widgetPath');
    addWidget({
      basePath: thisBasePath
    }, true);
    $('#addMailWidgetContainer').fadeOut(() => $('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addRedditWidget').click(() => {
    $('#addWidgetButtons').fadeOut(() => {
      $('#addRedditFormContainer').fadeIn(() => {
        $('#token-input-addReddit').focus();
      });
    });
  });
  $dashboardAddComponent.find('#addMailWidget').click(() => {
    $('#addWidgetButtons').fadeOut(() => $('#addMailWidgetContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addUserWidget').click(() => {
    $('#addWidgetButtons').fadeOut(() => $('#addUserFormContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchWidget').click(() => {
    $('#addWidgetButtons').fadeOut(() => $('#addSearchFormContainer').fadeIn());
  });
  const thisEle = $dashboardAddComponent.find('#addReddit');
  $(thisEle).tokenInput('/api/search_reddit_names.json?app=res', {
    method: 'POST',
    queryParam: 'query',
    theme: 'facebook',
    allowFreeTagging: true,
    zindex: 999999999,

    onResult(response) {
      if (response.names.length === 0) {
        const failedQueryValue = $('#token-input-editReddit').val();
        return [{
          id: failedQueryValue,
          name: failedQueryValue,
          failedResult: true
        }];
      }

      return response.names.map(name => ({
        id: name,
        name,
        failedResult: false
      }));
    },

    onCachedResult(response) {
      return this.onResult(response);
    },

    searchingText: 'Searching for matching reddits - may take a few seconds...',
    hintText: 'Type one or more subreddits for which to create a widget.',

    resultsFormatter(item) {
      let thisDesc = item.name;

      if (item.failedResult) {
        thisDesc += ' - [this subreddit may not exist, ensure proper spelling]';
      }

      return `<li>${thisDesc}</li>`;
    }

  });
  $dashboardAddComponent.find('#addRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = $('#addReddit').val();

    if (thisBasePath !== '') {
      if (thisBasePath.includes(',')) {
        thisBasePath = thisBasePath.replace(/,/g, '+');
      }

      const thisDisplayName = $('#addRedditDisplayName').val() ? $('#addRedditDisplayName').val() : thisBasePath;
      addWidget({
        basePath: thisBasePath,
        displayName: thisDisplayName
      }, true);
      $('#addReddit').tokenInput('clear');
      $('#addRedditFormContainer').fadeOut(() => {
        $('#addReddit').blur();
        $('#addWidgetButtons').fadeIn();
      });
    }
  });
  $dashboardAddComponent.find('#addUserForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = `/user/${$('#addUser').val()}`;
    addWidget({
      basePath: thisBasePath
    }, true);
    $('#addUser').val('').blur();
    $('#addUserFormContainer').fadeOut(() => $('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = string_namespaceObject.encode`/search?q=${$('#addSearch').val()}`;
    const thisDisplayName = $('#addSearchDisplayName').val() ? $('#addSearchDisplayName').val() : thisBasePath;
    addWidget({
      basePath: thisBasePath,
      displayName: thisDisplayName
    }, true);
    $('#addSearch').val('').blur();
    $('#addSearchFormContainer').fadeOut(() => $('#addWidgetButtons').fadeIn());
  });
  $dashboardUL = $('<ul id="RESDashboard"></ul>');
  $tabPage.append($dashboardAddComponent, $dashboardUL);
}

function addWidget(optionsObject, isNew) {
  if (!optionsObject.basePath.startsWith('/')) {
    optionsObject.basePath = `/r/${optionsObject.basePath}`;
  }

  const exists = widgets.some(widget => widget.basePath === optionsObject.basePath);
  setTimeout(() => {
    $(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).hide();
  }, 1000);

  if (exists && isNew) {
    alert_namespaceObject.open(`A widget for ${optionsObject.basePath} already exists!`);
  } else {
    const thisWidget = new WidgetObject(optionsObject);
    thisWidget.init();
    saveWidget(thisWidget.optionsObject());
  }
}

async function removeWidget(optionsObject) {
  await getLatestWidgets();
  let exists;
  widgets = widgets.filter(widget => {
    if (widget.basePath === optionsObject.basePath) {
      exists = true;
      $(document.getElementById(widget.basePath.replace(/\/|\+/g, '_'))).fadeOut('slow', function () {
        $(this).detach();
      });
      setTimeout(() => {
        $(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).show();
      }, 1000);
      return false;
    }

    return true;
  });

  if (!exists) {
    notifications_showNotification({
      moduleID: 'dashboard',
      type: 'error',
      message: 'The widget you just tried to remove does not seem to exist.'
    });
  }

  dashboardStorage.set(widgets);
}

async function saveWidget(optionsObject) {
  await getLatestWidgets();
  let index = widgets.findIndex(widget => widget.basePath === optionsObject.basePath);

  if (index === -1) {
    index = widgets.length;
  }

  widgets[index] = optionsObject;
  dashboardStorage.set(widgets);
}

async function dashboard_updateWidget() {
  await getLatestWidgets();
  widgets = widgets.map(widget => {
    if (widget.basePath === widgetBeingEdited.formerBasePath) {
      delete widgetBeingEdited.formerBasePath;
      widget = widgetBeingEdited.optionsObject();
    }

    return widget;
  });
  dashboardStorage.set(widgets);
}

function WidgetObject(widgetOptions) {
  this.basePath = widgetOptions.basePath;

  if (widgetOptions.displayName === undefined || widgetOptions.displayName === null) {
    widgetOptions.displayName = this.basePath;
  }

  this.displayName = widgetOptions.displayName;
  this.numPosts = widgetOptions.numPosts || parseInt(dashboard_module.options.defaultPosts.value, 10);
  this.sortBy = widgetOptions.sortBy || dashboard_module.options.defaultSort.value;
  this.sortSearchBy = widgetOptions.sortSearchBy || dashboard_module.options.defaultSortSearch.value;
  this.minimized = widgetOptions.minimized || false;
  this.widgetEle = $(`
		<li class="RESDashboardComponent" id="${this.basePath.replace(/\/|\+/g, '_')}">
			<div class="RESDashboardComponentScrim">
				<div class="RESDashboardComponentLoader">
					<span class="dashboardLoader"/><span>querying the server. one moment please.</span>
				</div>
			</div>
		</li>
	`);
  this.header = $(`<div class="RESDashboardComponentHeader"><a class="widgetPath" title="${this.basePath}" href="${this.basePath}"></a></div>`);
  this.header.find('.widgetPath').text(this.displayName);
  this.sortControls = $('<ul class="widgetSortButtons"><li sort="hot">hot</li><li sort="new">new</li><li sort="rising">rising</li><li sort="controversial">controversial</li><li sort="top">top</li></ul>');
  this.sortSearchControls = $('<ul class="widgetSortButtons"><li sort="relevance">relevance</li><li sort="top">top</li><li sort="new">new</li><li sort="comments">comments</li></ul>');

  this.optionsObject = () => ({
    basePath: this.basePath,
    displayName: this.displayName,
    numPosts: this.numPosts,
    sortBy: this.sortBy,
    sortSearchBy: this.sortSearchBy,
    minimized: this.minimized
  });

  $(this.sortControls).find(`li[sort=${this.sortBy}]`).addClass('active');
  $(this.sortControls).find('li').click(e => {
    this.sortChange($(e.target).attr('sort'));
  });
  $(this.sortSearchControls).find(`li[sort=${this.sortSearchBy}]`).addClass('active');
  $(this.sortSearchControls).find('li').click(e => {
    this.sortChange($(e.target).attr('sort'));
  });
  $(this.header).append(this.sortControls);

  if (!this.basePath.startsWith('/r/') && !this.basePath.startsWith('/user/')) {
    setTimeout(() => $(this.sortControls).hide(), 100);
  }

  $(this.header).append(this.sortSearchControls);

  if (!this.basePath.startsWith('/search?q=')) {
    setTimeout(() => $(this.sortSearchControls).hide(), 100);
  }

  this.stateControls = $('<ul class="widgetStateButtons"><li class="updateTime"></li><li action="refresh" class="refresh"><span class="res-icon">&#xF0B0;</span></li><li action="refreshAll" class="refreshAll">Refresh All</li><li action="addRow">+row</li><li action="subRow">-row</li><li action="edit" class="editButton"><span class="res-icon">&#xF139;</span></li><li action="minimize" class="minimize">-</li><li action="delete" class="RESClose">&times;</li></ul>');
  $(this.stateControls).find('li').click(e => {
    switch ($(e.target).attr('action')) {
      case 'refresh':
        this.update();
        break;

      case 'refreshAll':
        $('li[action="refresh"]').click();
        break;

      case 'addRow':
        if (this.numPosts === MAX_ROWS) break;
        this.numPosts++;
        if (this.numPosts === MAX_ROWS) $(this.stateControls).find('li[action=addRow]').addClass('disabled');
        $(this.stateControls).find('li[action=subRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'subRow':
        if (this.numPosts === 0) break;
        this.numPosts--;
        if (this.numPosts === 1) $(this.stateControls).find('li[action=subRow]').addClass('disabled');
        $(this.stateControls).find('li[action=addRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'minimize':
        $(this.widgetEle).toggleClass('minimized');

        if ($(this.widgetEle).hasClass('minimized')) {
          $(e.target).text('+');
          this.minimized = true;
        } else {
          $(e.target).text('-');
          this.minimized = false;
          this.update();
        }

        $(this.contents).parent().slideToggle();
        saveWidget(this.optionsObject());
        break;

      case 'delete':
        removeWidget(this.optionsObject());
        break;

      default:
        break;
    }
  });
  $(this.header).append(this.stateControls);

  this.sortChange = sortBy => {
    this.sortBy = sortBy;
    this.sortSearchBy = sortBy;
    $(this.header).find('ul.widgetSortButtons li').removeClass('active');
    $(this.header).find(`ul.widgetSortButtons li[sort=${sortBy}]`).addClass('active');
    this.update();
    saveWidget(this.optionsObject());
  };

  this.edit = () => {
    widgetBeingEdited = this;
    showEditForm();
  };

  $(this.header).find('.editButton').click(this.edit);

  this.update = () => {
    if (this.basePath.includes('/user/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `?sort=${this.sortBy}`;
    } else if (this.basePath.includes('/r/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `/${this.sortBy}/`;
    } else if (this.basePath.includes('/search?q=')) {
      this.sortPath = `&sort=${this.sortSearchBy}`;
    } else {
      this.sortPath = '';
    }

    this.url = `${location.protocol}//${location.hostname}/${this.basePath}${this.sortPath}`;
    $(this.contents).fadeTo('fast', 0.25);
    $(this.scrim).fadeIn();
    ajax({
      method: 'GET',
      url: this.url,
      query: {
        limit: this.numPosts
      }
    }).then(this.populate).catch(this.error);
  };

  this.container = $('<div class="RESDashboardComponentContainer"><div class="RESDashboardComponentContents"></div></div>');

  if (this.minimized) {
    $(this.container).addClass('minimized');
    $(this.stateControls).find('li.minimize').addClass('minimized').text('+');
  }

  this.scrim = $(this.widgetEle).find('.RESDashboardComponentScrim');
  this.contents = $(this.container).find('.RESDashboardComponentContents');

  this.init = () => {
    if (isCurrentSubreddit('dashboard')) {
      this.draw();
      if (!this.minimized) addToUpdateQueue(this.update);
    }
  };

  this.draw = () => {
    $(this.widgetEle).append(this.header);
    $(this.widgetEle).append(this.container);
    if (this.minimized) $(this.widgetEle).addClass('minimized');
    $dashboardUL.prepend(this.widgetEle);
  };

  this.populate = response => {
    let $widgetContent = $(response).find('#siteTable, .search-result-group>.contents:last');
    const $thisWidgetContents = $(this.contents);
    $widgetContent.attr('id', `siteTable_${this.basePath.replace(/\/|\+/g, '_')}`);
    if ($widgetContent.length === 2) $widgetContent = $($widgetContent[1]);
    $widgetContent.attr('url', `${this.url}?limit=${this.numPosts}`);

    if ($widgetContent.length > 0 && $widgetContent.html() !== '') {
      $widgetContent.html($widgetContent.html().replace(/<script(.|\s)*?\/script>/g, ''));
      const $noResults = $widgetContent.find('#noresults.error');

      if ($noResults.length) {
        $widgetContent.html('<span class="error">No results found for this widget. Some sort methods, such as rising, may not always have results. Please try a different method.</span>');
      }

      try {
        $thisWidgetContents.empty().append($widgetContent);
      } catch (e) {}

      $thisWidgetContents.fadeTo('fast', 1);
      $(this.scrim).fadeOut(function () {
        $(this).hide();
      });
    } else {
      if (this.url.includes('/message/')) {
        $thisWidgetContents.html('<div class="widgetNoMail">No messages were found.</div>');
      } else {
        $thisWidgetContents.html('<div class="error">There were no results returned for this widget. If you made a typo, simply close the widget to delete it. If reddit is just under heavy load, try clicking refresh in a few moments.</div>');
      }

      $thisWidgetContents.fadeTo('fast', 1);
      $(this.scrim).fadeOut();
    }

    $(this.stateControls).find('.updateTime').text(`updated: ${formatDateTime()}`);

    if ($widgetContent[0]) {
      registerPage($widgetContent[0]);
    }
  };

  this.error = e => {
    if (e.status === 404) {
      $(this.contents).html('<div class="error">This widget received a 404 not found error. You may have made a typo when adding it.</div>');
    } else {
      $(this.contents).html('<div class="error">There was an error loading data for this widget. Reddit may be under heavy load, or you may have provided an invalid path.</div>');
    }

    $(this.scrim).fadeOut();
    $(this.contents).fadeTo('fast', 1);
  };
}

function addDashboardShortcuts(subreddit) {
  const subButtons = document.querySelectorAll('.side .fancy-toggle-button');

  for (const subButton of subButtons) {
    let isMulti, thisSubredditFragment;

    if (!subreddit.includes('+') && !isCurrentSubreddit('mod')) {
      isMulti = false;
      thisSubredditFragment = subreddit;
    } else if ($(subButton).parent().hasClass('subButtons')) {
      isMulti = true;
      thisSubredditFragment = $(subButton).parent().parent().find('a.title').text();
    } else {
      isMulti = true;
      thisSubredditFragment = $(subButton).next().text();
    }

    if ($(`#subButtons-${thisSubredditFragment}`).length === 0) {
      const $subButtonsWrapper = $(`<div id="subButtons-${thisSubredditFragment}" class="subButtons" style="margin: 0 !important;"></div>`);
      $(subButton).wrap($subButtonsWrapper);

      if (isMulti) {
        const theWrap = $(subButton).parent();
        $(theWrap).appendTo($(theWrap).parent());
      }
    }

    const $subButtons = $(`#subButtons-${thisSubredditFragment}`);
    const button = createSubredditToggleButton(subreddit);
    button.classList.add('RESDashboardToggle');
    $subButtons.append(button);
    const next = $subButtons.next();

    if ($(next).hasClass('title') && !$subButtons.hasClass('swapped')) {
      $subButtons.before($(next));
      $subButtons.addClass('swapped');
    }
  }
}

function createSubredditToggleButton(subreddit) {
  const basePath = `/r/${subreddit.toLowerCase()}`;
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveDashboard'), i18n('subredditInfoAddThisSubredditToDashboard'), widgets.some(widget => widget && widget.basePath.toLowerCase() === basePath), state => {
    if (state) {
      addWidget({
        basePath
      });
      notifications_showNotification({
        header: 'Dashboard Notification',
        moduleID: 'dashboard',
        message: `
						Dashboard widget added for ${basePath}
						<p><a class="RESNotificationButtonBlue" href="/r/Dashboard">view the dashboard</a></p>
						<div class="clear"></div>
					`
      });
    } else {
      removeWidget({
        basePath
      });
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/newCommentCount.js







const newCommentCount_module = new Module('newCommentCount');
newCommentCount_module.moduleName = 'newCommentCountName';
newCommentCount_module.category = 'submissionsCategory';
newCommentCount_module.description = 'newCommentCountDesc';
newCommentCount_module.options = {
  hideWhenUnchanged: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountHideWhenUnchangedDesc',
    title: 'newCommentCountHideWhenUnchangedTitle'
  },
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'newCommentCountCleanCommentsDesc',
    title: 'newCommentCountCleanCommentsTitle',
    advanced: true
  },
  subscriptionLength: {
    type: 'text',
    value: '2',
    description: 'newCommentCountSubscriptionLengthDesc',
    title: 'newCommentCountSubscriptionLengthTitle'
  },
  showSubscribeButton: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountShowSubscribeButtonDesc',
    title: 'newCommentCountShowSubscribeButtonTitle'
  },
  notifyEditedPosts: {
    dependsOn: options => options.showSubscribeButton.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountNotifyEditedPostsDesc',
    title: 'newCommentCountNotifyEditedPostsTitle',
    advanced: true
  },
  monitorPostsVisited: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountMonitorPostsVisitedDesc',
    title: 'newCommentCountMonitorPostsVisitedTitle',
    advanced: true
  },
  monitorPostsVisitedIncognito: {
    dependsOn: options => options.monitorPostsVisited.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountMonitorPostsVisitedIncognitoDesc',
    title: 'newCommentCountMonitorPostsVisitedIncognitoTitle',
    advanced: true
  }
};
const newCommentCount_entryStorage = storage_namespaceObject.wrapPrefix('newCommentCount.', () => {
  throw new Error('Default value should never be retrieved');
}, undefined, true);
const subscriptionStorage = storage_namespaceObject.wrapBlob('RESmodules.newCommentCount.subscriptions', () => {
  throw new Error('Subscription not found');
});
let subscriptionButton;

newCommentCount_module.beforeLoad = () => {
  if (isPageType('comments') && newCommentCount_module.options.showSubscribeButton.value) {
    subscriptionButton = string_namespaceObject.html`<span id="REScommentSubToggle" class="RESSubscriptionButton"></span>`;
    refreshSubscriptionButton();
  }

  watchForThings(['post'], getNewCount, {
    immediate: true
  });
  watchForThings(['post'], displayNewCommentCount);
};

newCommentCount_module.contentStart = () => {
  if (subscriptionButton) {
    $('.commentarea .panestack-title').append(subscriptionButton);
  }

  if (isCurrentSubreddit('dashboard')) {
    addDashboardFunctionality();
  }

  maybePruneOldEntries('newCommentCount', newCommentCount_entryStorage, parseInt(newCommentCount_module.options.cleanComments.value, 10));
};

let listingThing;
let currentCommentCount;

newCommentCount_module.afterLoad = () => {
  if (!document.hidden) {
    checkSubscriptions();
  }

  if (isPageType('comments')) {
    listingThing = Thing_Thing.from(document.querySelector('#siteTable a.comments'));

    if (listingThing) {
      currentCommentCount = listingThing.getCommentCount();

      if (typeof currentCommentCount === 'number') {
        setEntry(getId(listingThing), currentCommentCount);
        watchForThings(['comment'], updateCurrentCommentCountFromMyComment);
      }
    }
  }
};

const getId = thing => thing.getFullname().split('_').slice(-1)[0];

const hasEntry = thing => newCommentCount_entryStorage.has(getId(thing));

function setEntry(id, newCommentCount) {
  if (!newCommentCount_module.options.monitorPostsVisited.value) return false;
  if (!newCommentCount_module.options.monitorPostsVisitedIncognito.value && isPrivateBrowsing()) return false;
  newCommentCount_entryStorage.set(id, {
    count: newCommentCount,
    updateTime: Date.now()
  });
}

const getNewCount = memoize_default()(async thing => {
  const currentCount = thing.getCommentCount();
  if (typeof currentCount !== 'number') return;
  const {
    count: lastOpenedCount
  } = (await newCommentCount_entryStorage.getNullable(getId(thing))) || {};
  if (typeof lastOpenedCount !== 'number') return;
  return Math.max(currentCount - lastOpenedCount, 0);
});

async function displayNewCommentCount(thing) {
  const newCount = await getNewCount(thing);
  if (typeof newCount !== 'number') return;
  if (!newCount && newCommentCount_module.options.hideWhenUnchanged.value) return;
  if (newCount) thing.element.classList.add('res-hasNewComments');
  $(thing.getCommentCountElement()).append(`<span class="newComments">&nbsp;(${newCount} new)</span>`);
}

function updateCurrentCommentCountFromMyComment(thing) {
  const timestamp = thing.getTimestamp();
  const isRecent = timestamp && Date.now() - timestamp.getTime() < 10000;
  const isMine = loggedInUser() === thing.getAuthor();

  if (isRecent && isMine && listingThing && typeof currentCommentCount === 'number') {
    setEntry(getId(listingThing), ++currentCommentCount);
  }
}

const refreshSubscriptionButton = mutex(async () => {
  const id = (execRegexes.comments(location.pathname) || [])[2];
  const button = subscriptionButton;
  if (!id || !button) return;
  const subscriptions = await subscriptionStorage.getAll();

  if (subscriptions.hasOwnProperty(id)) {
    $(button).html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');
    waitForEvent(button, 'click').then(async () => {
      await unsubscribe(id);
      notifications_showNotification({
        notificationID: 'newCommentCountUnsubscribe',
        moduleID: 'newCommentCount',
        message: 'You are now unsubscribed from this thread.'
      }, 3000);
    }).then(refreshSubscriptionButton);
  } else {
    $(button).html('<span class="res-icon">&#xF03B;</span> subscribe').attr('title', 'notify me of new comments').removeClass('unsubscribe');
    waitForEvent(button, 'click').then(async () => {
      await newCommentCount_subscribe(id, currentCommentCount || 0, listingThing && listingThing.getPostEditTimestamp() || 0);
      notifications_showNotification({
        notificationID: 'newCommentCountSubscribe',
        moduleID: 'newCommentCount',
        optionKey: 'subscriptionLength',
        message: `
					<p>
						You are now subscribed to this thread for ${newCommentCount_module.options.subscriptionLength.value} days.
						When new comments are posted you'll receive a notification.
					</p>
					<p><a href="/r/Dashboard#newCommentsContents">Manage subscriptions</a></p>
				`
      }, 5000);
    }).then(refreshSubscriptionButton);
  }
});

function newCommentCount_subscribe(id, newCommentCount, newEditedTime) {
  const now = Date.now();
  return subscriptionStorage.set(id, {
    count: newCommentCount,
    subscriptionDate: now,
    updateTime: now,
    editedTime: newEditedTime,
    url: location.href.replace(location.hash, ''),
    title: document.title
  });
}

function unsubscribe(id) {
  return subscriptionStorage.delete(id);
}

async function checkSubscriptions() {
  const now = Date.now();

  for (const [id, subscription] of Object.entries((await subscriptionStorage.getAll()))) {
    const {
      subscriptionDate,
      updateTime
    } = subscription;

    if (now - subscriptionDate > DAY * parseInt(newCommentCount_module.options.subscriptionLength.value, 10)) {
      unsubscribe(id);
    } else if (now - updateTime > 5 * MINUTE) {
      subscriptionStorage.patch(id, {
        updateTime: now
      });
      checkThread(id, subscription);
    }
  }
}

async function checkThread(id, subscription) {
  const {
    num_comments: newCount,
    edited: newEditedTime
  } = await getPostMetadata({
    id
  });
  const {
    count,
    editedTime,
    url,
    title
  } = subscription;

  if (newCount > count) {
    subscriptionStorage.patch(id, {
      count: newCount
    });
    const notification = await notifications_showNotification({
      header: 'New comments',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, 10000);
    const {
      button,
      promise
    } = createButton(id, 'unsubscribe');
    promise.then(notification.close);
    $(notification.element).find('.RESNotificationContent').append(button);
  }

  if (newCommentCount_module.options.notifyEditedPosts.value && newEditedTime > editedTime) {
    subscriptionStorage.patch(id, {
      editedTime: newEditedTime
    });
    const notification = await notifications_showNotification({
      header: 'Post edited',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      optionKey: 'notifyEditedPosts',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, 10000);
    const {
      button,
      promise
    } = createButton(id, 'unsubscribe');
    promise.then(notification.close);
    $(notification.element).find('.RESNotificationContent').append(button);
  }
}

function createButton(id, type) {
  const $button = $('<span class="RESSubscriptionButton">');
  let action;

  switch (type) {
    case 'unsubscribe':
      $button.html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');

      action = () => unsubscribe(id);

      break;

    case 'renew':
      $button.html('<span class="res-icon">&#xF03B;</span> renew').attr('title', `renew for ${newCommentCount_module.options.subscriptionLength.value} days`);

      action = async () => {
        await subscriptionStorage.patch(id, {
          subscriptionDate: Date.now()
        });
        notifications_showNotification({
          notificationID: 'newCommentCountRenew',
          moduleID: 'newCommentCount',
          optionKey: 'subscriptionLength',
          message: `Subscription renewed for ${newCommentCount_module.options.subscriptionLength.value} days.`
        });
      };

      break;

    case 'delete':
      $button.html('<span class="res-icon">&#xF155;</span>').attr('title', 'delete from list').addClass('deleteIcon');

      action = async () => {
        const {
          title
        } = await subscriptionStorage.get(id);
        return alert_namespaceObject.open(`Are you sure you want to unsubscribe from post: "${title}"?`, {
          cancelable: true
        }).then(() => unsubscribe(id));
      };

      break;

    default:
      break;
  }

  return {
    button: $button.get(0),
    promise: waitForEvent($button.get(0), 'click').then(action)
  };
}

function addDashboardFunctionality() {
  const $tabPage = addTab('newCommentsContents', 'My Subscriptions', newCommentCount_module.moduleID);
  const $openOnReddit = $('<a href="#" id="openOnReddit">as reddit link listing</a>');
  $openOnReddit.click(event => {
    event.preventDefault();
    let url = 't3_';
    const $threads = $('#newCommentsTable tbody > tr');
    const ids = $threads.get().map(ele => ele.getAttribute('data-id'));
    const concatIds = ids.join(',t3_');
    url += concatIds;
    location.href = `/by_id/${url}`;
  });
  $tabPage.append($openOnReddit);
  const $thisTable = $('<table id="newCommentsTable" />');
  $thisTable.append('<thead><tr><th sort="" class="active">Submission</th><th sort="subreddit">Subreddit</th><th sort="updateTime">Last viewed</th><th sort="subscriptionDate">Expires in</th><th class="actions">Actions</th></tr></thead><tbody></tbody>');
  $tabPage.append($thisTable);
  $('#newCommentsTable thead th').click(function (e) {
    e.preventDefault();

    if ($(this).hasClass('actions')) {
      return false;
    }

    if ($(this).hasClass('active')) {
      $(this).toggleClass('descending');
    }

    $(this).addClass('active');
    $(this).siblings().removeClass('active').find('SPAN').remove();
    $(this).find('.sortAsc, .sortDesc').remove();

    if ($(e.target).hasClass('descending')) {
      $(this).append('<span class="sortDesc" />');
    } else {
      $(this).append('<span class="sortAsc" />');
    }

    drawSubscriptionsTable($(e.target).attr('sort'), $(e.target).hasClass('descending'));
  });
  drawSubscriptionsTable();
}

let currentSortMethod, isDescending;

async function drawSubscriptionsTable(sortMethod, descending) {
  currentSortMethod = sortMethod || currentSortMethod;
  isDescending = descending === undefined ? isDescending : !!descending;
  $('#newCommentsTable tbody').html('');
  const thisCounts = filterMap(Object.entries((await subscriptionStorage.getAll())), ([id, commentCount]) => {
    const match = new URL(commentCount.url).pathname.match(regexes.subreddit);

    if (match) {
      return [{
        id,
        subreddit: match[1].toLowerCase(),
        ...commentCount
      }];
    }
  });

  switch (currentSortMethod) {
    case 'subscriptionDate':
      thisCounts.sort((a, b) => a.subscriptionDate > b.subscriptionDate ? 1 : b.subscriptionDate > a.subscriptionDate ? -1 : 0);
      if (isDescending) thisCounts.reverse();
      break;

    case 'updateTime':
      thisCounts.sort((a, b) => a.updateTime > b.updateTime ? 1 : b.updateTime > a.updateTime ? -1 : 0);
      if (isDescending) thisCounts.reverse();
      break;

    case 'subreddit':
      thisCounts.sort((a, b) => a.subreddit > b.subreddit ? 1 : b.subreddit > a.subreddit ? -1 : 0);
      if (isDescending) thisCounts.reverse();
      break;

    default:
      thisCounts.sort((a, b) => a.title > b.title ? 1 : b.title > a.title ? -1 : 0);
      if (isDescending) thisCounts.reverse();
      break;
  }

  let rows = 0;

  for (const {
    subscriptionDate,
    updateTime,
    id,
    url,
    title,
    subreddit
  } of thisCounts) {
    if (subscriptionDate) {
      const thisUpdateTime = new Date(updateTime);
      const {
        button: thisTrashButton,
        promise: thisTrashPromise
      } = createButton(id, 'delete');
      thisTrashPromise.then(drawSubscriptionsTable);
      const {
        button: thisRenewButton,
        promise: thisRenewPromise
      } = createButton(id, 'renew');
      thisRenewPromise.then(drawSubscriptionsTable);
      const {
        button: thisUnsubButton,
        promise: thisUnsubPromise
      } = createButton(id, 'unsubscribe');
      thisUnsubPromise.then(drawSubscriptionsTable);
      const thisExpires = new Date(subscriptionDate + DAY * parseInt(newCommentCount_module.options.subscriptionLength.value, 10));
      const thisExpiresContent = `<abbr title="${formatDateTime(thisExpires)}">${formatRelativeTime(thisExpires)}</abbr>`;
      const thisROW = `
				<tr data-id="${id}"><td><a href="${url}">${escapeHTML(title)}</a></td>
				<td><a href="/r/${subreddit}">/r/${subreddit}</a></td>
				<td><abbr title="${formatDateTime(thisUpdateTime)}">${formatRelativeTime(thisUpdateTime)}</abbr></td>
				<td>${thisExpiresContent}</td><td></td></tr>
			`;
      const $thisROW = $(thisROW);
      $thisROW.find('td:last-of-type').append(thisTrashButton);
      $thisROW.find('td:last-of-type').append(thisRenewButton).append(' ');
      $thisROW.find('td:last-of-type').append(thisUnsubButton);
      $('#newCommentsTable tbody').append($thisROW);
      rows++;
    }
  }

  if (rows === 0) {
    $('#newCommentsTable tbody').append('<td colspan="5">You are currently not subscribed to any threads. To subscribe to a thread, click the "subscribe" button found near the top of the comments page.</td>');
    $('#openOnReddit').hide();
  } else {
    $('#openOnReddit').show();
  }
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/NewCommentCount.js




class NewCommentCount_NewCommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `new comments ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `new comments ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    return String(((await hasEntry(thing)) ? await getNewCount(thing) : thing.getCommentCount()) || 0);
  }

  static get disabled() {
    return !modules_isEnabled(newCommentCount_namespaceObject);
  }

  isValid() {
    return parseInt(this.value.val, 10) >= 0;
  }

  async evaluate(thing) {
    const newCount = await getNewCount(thing);
    const count = typeof newCount === 'number' ? newCount : thing.getCommentCount();
    return numericalCompare(this.value.op, count, this.value.val);
  }

}
NewCommentCount_NewCommentCount.text = 'New comment count';
NewCommentCount_NewCommentCount.defaultConditions = {
  op: '>',
  val: 0
};
NewCommentCount_NewCommentCount.fields = ['has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' new comments'];
NewCommentCount_NewCommentCount.slow = 1;
NewCommentCount_NewCommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentsOpened.js



class CommentsOpened_CommentsOpened extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'comments opened';
  }

  async evaluate(thing) {
    if (await hasEntry(thing)) return true;
    const link = thing.getCommentsLink();
    if (!link) return null;
    return isURLVisited(link.href);
  }

}
CommentsOpened_CommentsOpened.text = 'Comments opened';
CommentsOpened_CommentsOpened.fields = ['comments page has been visited'];
CommentsOpened_CommentsOpened.slow = 2;
CommentsOpened_CommentsOpened.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Domain.js

class Domain_Domain extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `domain ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getPostDomain();
  }

  evaluate(thing) {
    const domain = thing.getPostDomain();
    if (!domain) return null;
    return this.value.some(v => v.test(domain));
  }

}
Domain_Domain.text = 'Link domain name';
Domain_Domain.fields = ['post links to the domain ', {
  type: 'text',
  id: 'patt'
}];
// EXTERNAL MODULE: ./node_modules/lodash/fp/sortBy.js
var fp_sortBy = __webpack_require__(54);
var fp_sortBy_default = /*#__PURE__*/__webpack_require__.n(fp_sortBy);

// EXTERNAL MODULE: ./node_modules/lodash/fp/filter.js
var fp_filter = __webpack_require__(20);
var filter_default = /*#__PURE__*/__webpack_require__.n(fp_filter);

// EXTERNAL MODULE: ./node_modules/lodash/compact.js
var compact = __webpack_require__(55);
var compact_default = /*#__PURE__*/__webpack_require__.n(compact);

// EXTERNAL MODULE: ./node_modules/lodash/without.js
var without = __webpack_require__(56);
var without_default = /*#__PURE__*/__webpack_require__.n(without);

// EXTERNAL MODULE: ./node_modules/lodash/intersection.js
var intersection = __webpack_require__(57);
var intersection_default = /*#__PURE__*/__webpack_require__.n(intersection);

// EXTERNAL MODULE: ./node_modules/resize-observer-lite/lib/index.js
var lib = __webpack_require__(84);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./lib/core/host.js
class Host {
  constructor(moduleID, {
    name,
    domains,
    permissions,
    logo,
    landingPage,
    attribution = true,
    options,
    detect,
    handleLink,
    getVideoData
  }) {
    this.moduleID = void 0;
    this.name = void 0;
    this.domains = void 0;
    this.permissions = void 0;
    this.logo = void 0;
    this.landingPage = void 0;
    this.attribution = void 0;
    this.options = void 0;
    this.detect = void 0;
    this.handleLink = void 0;
    this.getVideoData = void 0;
    this.moduleID = moduleID;
    this.name = name;
    this.domains = domains;
    this.permissions = permissions;
    this.logo = logo;
    this.landingPage = landingPage;
    this.attribution = attribution;
    this.options = options;
    this.detect = detect;
    this.handleLink = handleLink;
    this.getVideoData = getVideoData;
  }

}
// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var lodash_throttle = __webpack_require__(37);
var throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// CONCATENATED MODULE: ./lib/constants/sessionStorage.js
const LAST_SELECTED_ENTRY_KEY = 'RES.lastSelectedEntry';
// CONCATENATED MODULE: ./lib/modules/selectedEntry.js








const selectedEntry_module = new Module('selectedEntry');
selectedEntry_module.moduleName = 'selectedEntryName';
selectedEntry_module.category = 'browsingCategory';
selectedEntry_module.include = ['comments', 'linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'];
selectedEntry_module.description = 'selectedEntryDesc';
selectedEntry_module.options = {
  autoSelectOnScroll: {
    title: 'selectedEntryAutoSelectOnScrollTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAutoSelectOnScrollDesc'
  },
  scrollToSelectedThingOnLoad: {
    title: 'selectedEntryScrollToSelectedThingOnLoadTitle',
    type: 'boolean',
    value: false,
    advanced: true,
    description: 'selectedEntryScrollToSelectedThingOnLoadDesc'
  },
  addLine: {
    title: 'selectedEntryAddLineTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAddLineDesc'
  },
  setColors: {
    title: 'selectedEntrySetColorsTitle',
    type: 'boolean',
    value: true,
    description: 'selectedEntrySetColorsDesc'
  },
  backgroundColor: {
    title: 'selectedEntryBackgroundColorTitle',
    type: 'color',
    value: '#F0F3FC',
    description: 'selectedEntryBackgroundColorDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  backgroundColorNight: {
    title: 'selectedEntryBackgroundColorNightTitle',
    type: 'color',
    value: '#373737',
    description: 'selectedEntryBackgroundColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  textColorNight: {
    title: 'selectedEntryTextColorNightTitle',
    type: 'color',
    value: '#DDDDDD',
    description: 'selectedEntryTextColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  outlineStyle: {
    title: 'selectedEntryOutlineStyleTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleDesc',
    advanced: true
  },
  outlineStyleNight: {
    title: 'selectedEntryOutlineStyleNightTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleNightDesc',
    advanced: true
  }
};
const lastSelectedKey = `${LAST_SELECTED_ENTRY_KEY}-${location.pathname}`;
const getLastSelectedId = () => sessionStorage[lastSelectedKey];
let selectedContainer;
let oldSelected;

selectedEntry_module.beforeLoad = () => {
  if (selectedEntry_module.options.addLine.value) styleLine();
  if (selectedEntry_module.options.setColors.value) styleColor();
  styleOutline();
};

selectedEntry_module.always = () => {
  addScrollStyleListener();
  const lastSelectedId = getLastSelectedId();
  watchForThings(null, thing => {
    if (Thing_Thing.selected) return;
    if (!lastSelectedId) return selectedEntry_select(thing);
    if (thing.getFullname() !== lastSelectedId) return;
    if (selectedEntry_module.options.scrollToSelectedThingOnLoad.value) history.scrollRestoration = 'manual';
    selectedEntry_select(thing, {
      scrollStyle: history.scrollRestoration === 'manual' ? 'legacy' : 'none'
    });
  }, {
    immediate: true
  });
  selectedEntry_addListener((selected, unselected, {
    scrollStyle,
    direction
  }) => {
    if (scrollStyle === 'none') return;
    Thing_Thing.runTasksRange(selected, direction === 'down' ? unselected : undefined, 10, 10);
  }, 'instantly');
};

selectedEntry_module.contentStart = () => {
  $(document.body).on('mouseup', Thing_Thing.thingSelector, throttle_default()(e => {
    if (click.isProgrammaticEvent(e)) return;
    const thing = Thing_Thing.from(e.target);
    if (thing) selectedEntry_select(thing);
  }, 50, {
    leading: true,
    trailing: false
  }));

  if (selectedEntry_module.options.autoSelectOnScroll.value) {
    window.addEventListener('scroll', () => {
      autoSelect();
    });
  }
};

selectedEntry_module.afterLoad = () => {
  if (!Thing_Thing.selected || !Thing_Thing.selected.isVisible()) autoSelect();
  watchForThings(['comment'], throttle_default()(thing => {
    if (Thing_Thing.selected && document.contains(Thing_Thing.selected.element)) return;
    if (selectedContainer && selectedContainer !== thing.element.closest('.sitetable')) return;
    selectedEntry_select(thing);
  }, 100, {
    leading: true,
    trailing: false
  }), {
    immediate: true
  });
  selectedEntry_addListener(selected => {
    const id = selected.getFullname();
    if (!id) return;
    sessionStorage[lastSelectedKey] = id;
  }, 'beforePaint');
};

const listeners = {
  instantly: [],
  beforePaint: [],
  idle: []
};
function selectedEntry_addListener(callback, when = 'idle', priority = 0) {
  callback.priority = priority;
  listeners[when].push(callback);
  listeners[when].sort((a, b) => a.priority - b.priority);
}

const runCallbacks = (() => {
  function runListeners(listeners, new_, old, opt) {
    for (const listener of listeners) try {
      listener(new_, old, opt);
    } catch (e) {
      console.error(e);
    }
  }

  function throttle(throttler, listeners) {
    let oldest;
    const throttled = throttler((new_, old, opt) => {
      runListeners(listeners, new_, oldest, opt);
      oldest = null;
    });
    return (new_, old, opt) => {
      if (!oldest) oldest = old;
      throttled(new_, old, opt);
    };
  }

  const runBeforePaint = throttle(frameThrottle, listeners.beforePaint);
  const runIdle = throttle(idleThrottle, listeners.idle);
  return (new_, old, opt) => {
    if (listeners.instantly.length) runListeners(listeners.instantly, new_, old, opt);
    if (listeners.beforePaint.length) runBeforePaint(new_, old, opt);
    if (listeners.idle.length) runIdle(new_, old, opt);
  };
})();

function selectedEntry_select(newSelected, options = {
  scrollStyle: 'none'
}, force = false) {
  if (!force && newSelected === Thing_Thing.selected) return;
  oldSelected = Thing_Thing.selected;
  Thing_Thing.selected = newSelected;
  selectedContainer = newSelected.element.closest('.sitetable');
  const direction = oldSelected && oldSelected.getDirectionOf(newSelected);
  runCallbacks(newSelected, oldSelected, { ...options,
    ...(direction ? {
      direction
    } : undefined)
  });
}
const autoSelect = frameDebounce(() => {
  if (Thing_Thing.selected && getPercentageVisibleYAxis(Thing_Thing.selected.entry)) return;
  const closestToCurrent = Thing_Thing.selected && Thing_Thing.selected.getClosestVisible();

  if (closestToCurrent && getPercentageVisibleYAxis(closestToCurrent.entry)) {
    selectedEntry_select(closestToCurrent);
    return;
  }

  const things = Thing_Thing.visibleThings();
  const currentIndex = things.indexOf(Thing_Thing.selected);

  const closestThings = sortBy_default()(things.filter(thing => thing.isVisible()), thing => Math.abs(things.indexOf(thing) - currentIndex));

  const closestVisible = maxBy_default()(closestThings, ({
    entry
  }) => getPercentageVisibleYAxis(entry));

  if (closestVisible) selectedEntry_select(closestVisible);
});
function refreshSelect() {
  if (!Thing_Thing.selected || Thing_Thing.selected.isVisible()) return;
  autoSelect();
}
const movers = {
  closestVisible: thing => thing.getClosestVisible(),
  up: thing => thing.getNext({
    direction: 'up'
  }),
  down: thing => thing.getNext({
    direction: 'down'
  }),
  top: () => Thing_Thing.visibleThings()[0],
  bottom: () => Thing_Thing.visibleThings().slice(-1)[0],
  upSibling: thing => thing.getNextSibling({
    direction: 'up'
  }) || thing.parent,
  downSibling: thing => thing.getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  downParentSibling: thing => (thing.parent || thing).getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  upThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'up'
  }) || thing.getThreadTop(),
  downThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'down'
  }),
  toTopComment: thing => thing.getThreadTop(),
  toParent: thing => thing.parent,
  previous: () => oldSelected
};
function move(direction, options, fallback) {
  if (!Thing_Thing.selected || !Thing_Thing.selected.element.offsetParent) {
    autoSelect();
    return;
  }

  const targetFn = movers[direction];

  if (!Thing_Thing.selected && targetFn.length) {
    if (!fallback || !fallback()) throw new Error('Function only works when an entry is selected');
  }

  const target = targetFn(Thing_Thing.selected);

  if (!target) {
    if (fallback && fallback()) return;
    if (Thing_Thing.selected) return selectedEntry_select(Thing_Thing.selected, {
      scrollStyle: 'middle'
    });
    throw new Error('Could not find a target');
  } else if (Thing_Thing.selected === target) {
    if (Thing_Thing.selected) return selectedEntry_select(Thing_Thing.selected, {
      scrollStyle: 'middle'
    });
    throw new Error('Target already selected');
  }

  selectedEntry_select(target, options);
}

function addScrollStyleListener() {
  let anchor;
  selectedEntry_addListener((selected, unselected, {
    scrollStyle
  }) => {
    if (unselected && selected !== unselected && ['none', 'adopt'].includes(scrollStyle) && (selected.element.classList.contains('res-thing-partial') || unselected.element.classList.contains('res-thing-partial'))) {
      anchor = {
        to: selected.entry.getBoundingClientRect().top,
        from: unselected.entry.getBoundingClientRect().top
      };
    } else {
      anchor = undefined;
    }
  }, 'instantly', -Infinity);
  selectedEntry_addListener((selected, unselected, {
    direction,
    scrollStyle
  }) => {
    scrollToElement(selected.entry, unselected && unselected.entry, {
      scrollStyle,
      direction,
      anchor,
      waitTillVisible: true
    });
  }, 'beforePaint', 9);
}

const installUpdateSelectedElementClassListener = once_default()(() => selectedEntry_addListener((selected, last) => {
  if (last) {
    last.entry.classList.remove('res-selected');
    last.element.classList.remove('res-selected');
  }

  if (selected) {
    selected.entry.classList.add('res-selected');
    selected.element.classList.add('res-selected');
  }
}, 'instantly'));

function styleLine() {
  addCSS(`
		.entry.res-selected { box-shadow: 3px 0 0 -1px #c2d2e0 !important; }
		.res-nightmode .entry.res-selected { box-shadow: 3px 0 0 -1px grey !important; }
	`);
  installUpdateSelectedElementClassListener();
}

function styleColor() {
  selectedEntry_addListener((selected, last) => {
    if (last) {
      last.entry.classList.remove('RES-keyNav-activeElement');
      last.element.classList.remove('RES-keyNav-activeThing');
    }

    if (selected) {
      selected.entry.classList.add('RES-keyNav-activeElement');
      selected.element.classList.add('RES-keyNav-activeThing');
    }
  }, 'instantly');
  const backgroundColor = selectedEntry_module.options.backgroundColor.value ? `
		.entry.res-selected,
		.entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColor.value} !important;
		}` : '';
  const backgroundColorNight = selectedEntry_module.options.backgroundColorNight.value ? `
		.res-nightmode .entry.res-selected,
		.res-nightmode .entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColorNight.value} !important;
		}` : '';
  const textColorNight = selectedEntry_module.options.textColorNight.value ? `
		.res-nightmode .entry.res-selected > .tagline,
		.res-nightmode .entry.res-selected .md-container > .md,
		.res-nightmode .entry.res-selected .md-container > .md p {
			color: ${selectedEntry_module.options.textColorNight.value} !important;
		}` : '';
  addCSS(backgroundColor + backgroundColorNight + textColorNight);
  installUpdateSelectedElementClassListener();
}

function styleOutline() {
  const outlineStyle = selectedEntry_module.options.outlineStyle.value ? `
		.entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyle.value};
		}` : '';
  const outlineStyleNight = selectedEntry_module.options.outlineStyleNight.value ? `
		.res-nightmode .entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyleNight.value};
		}
	` : '';
  const style = outlineStyle + outlineStyleNight;

  if (style) {
    addCSS(style);
    installUpdateSelectedElementClassListener();
  }
}
// CONCATENATED MODULE: ./lib/modules/showImages/templates.js


const audioTemplate = ({
  loop,
  sources
}) => string_namespaceObject.html`
	<div>
		<audio controls ${loop && 'loop'}>
			${sources.map(({
  file,
  type
}) => string_namespaceObject._html`
				<source src="${file}" type="${type}">
			`)}
		</audio>
	</div>
`;
const galleryTemplate = ({
  title,
  caption,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-gallery">
		${title && string_namespaceObject._html`
		<h3 class="res-title res-gallery-title">${title}</h3>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption res-gallery-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-gallery-individual-controls">
			<div class="res-step res-gallery-previous"></div>
			<div class="res-step-progress">
				<span class="res-gallery-position">1</span> of ${src.length}
			</div>
			<div class="res-step res-step-reverse res-gallery-next"></div>
			<div class="res-gallery-to-filmstrip" title="View as filmstrip"></div>
		</div>
		<div class="res-gallery-pieces"></div>
		<div class="res-gallery-below">
			<div>
				<div class="res-expando-siteAttribution"></div>
				<div class="res-gallery-increase-concurrent"></div>
			</div>
		</div>
	</div>
`;
const imageTemplate = ({
  title,
  caption,
  credits,
  src,
  href,
  openInNewWindow
}) => string_namespaceObject.html`
	<div class="res-image">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<a class="res-expando-link noKeyNav" href="${href}" ${openInNewWindow && string_namespaceObject._html`target="_blank" rel="noopener noreferrer"`}>
			<img class="res-image-media" src="${src}">
		</a>
	</div>
`;
const iframeTemplate = ({
  url,
  width,
  height
}) => string_namespaceObject.html`
	<div class="res-iframe-expando">
		<div>
			<iframe src="${url}" style="width: ${width}; height: ${height}" allowFullscreen="true"></iframe>
			<div class="res-iframe-expando-drag-handle">
				<div class="res-icon"></div>
				<div class="res-expando-siteAttribution"></div>
			</div>
		</div>
	</div>
`;
const textTemplate = ({
  title,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-text usertext-body">
		${title && string_namespaceObject._html`
		<h3 class="res-title">${title}</h3>
		`}
		<div class="res-text-media md">${string_namespaceObject.safe(src)}</div>
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
	</div>
`;
const videoTemplate = ({
  title,
  caption,
  credits,
  href,
  source,
  poster,
  hasAudio,
  loop,
  reversable,
  formattedPlaybackRate,
  openInNewWindow
}) => string_namespaceObject.html`
	<div class="res-video">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-video-container">
			<a class="noKeyNav" href="${href}" ${openInNewWindow && string_namespaceObject._html`target="_blank" rel="noopener noreferrer"`}>
				<video ${!hasAudio && 'muted'} ${loop && 'loop'} poster="${poster}"></video>
			</a>
			<div class="res-video-interface">
				<div class="res-video-progress">
					<div class="res-video-position"></div>
					<div class="res-video-position-thumb"></div>
				</div>
				<div class="res-video-main">
					<div class="res-video-controls">
						<div title="Toggle pause" class="res-icon res-video-button res-video-toggle-pause"></div>
						${reversable && string_namespaceObject._html`
						<div title="Reverse video" class="res-icon res-video-button res-video-reverse"></div>
						`}
						${hasAudio && string_namespaceObject._html`
							<div title="Adjust volume" class="res-icon res-video-button res-video-volume">
								<div class="res-video-volume-level">
									<div class="res-video-volume-percentage"></div>
								</div>
							</div>
						`}
						<div class="res-video-controls-group res-video-current-time">
							<div title="Select previous frame" class="res-icon res-video-button res-video-time-decrease"></div>
							<div class="res-video-time">1.00s</div>
							<div title="Select next frame" class="res-icon res-video-button res-video-time-increase"></div>
						</div>
						<div class="res-video-controls-group res-video-playback-rate">
							<div title="Decrease speed by 10%" class="res-icon res-video-button res-video-speed-decrease"></div>
							<div class="res-video-speed">${string_namespaceObject.safe(formattedPlaybackRate)}</div>
							<div title="Increase speed by 10%" class="res-icon res-video-button res-video-speed-increase"></div>
						</div>
					</div>
					<div hidden class="res-video-error">
						<div class="res-icon">&#xf15b</div>
					</div>
					<div class="res-video-info">
						${source && string_namespaceObject._html`
						<a class="res-video-link res-video-source" href="${source}">source</a>
						`}
						<div class="res-expando-siteAttribution"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
`;
const mediaControlsTemplate = ({
  x,
  y,
  downloadUrl,
  lookupUrl,
  clippy
}) => string_namespaceObject.html`
	<div class="res-media-with-controls-wrapper">
		<div class="res-media-controls res-media-controls-${x} res-media-controls-${y}">
			<button class="res-icon gearIcon" title="Settings" data-action="showImageSettings"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-left res-icon" title="Rotate image counter-clockwise" data-action="rotateLeft"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-right res-icon" title="Rotate image clockwise" data-action="rotateRight"></button>
			${downloadUrl && string_namespaceObject._html`
			<button class="res-media-controls-download res-icon title="Download image" data-action="download"></button>
			`}
			${lookupUrl && string_namespaceObject._html`
			<button class="res-media-controls-lookup res-icon" title="Reverse image search" data-action="imageLookup"></button>
			`}
			${clippy && string_namespaceObject._html`
			<button class="res-media-controls-clippy" title="Show educational info" data-action="clippy"></button>
			`}
		</div>
	</div>
`;
const siteAttributionTemplate = ({
  url,
  name,
  logoUrl,
  settingsLink
}) => string_namespaceObject.html`
	<cite class="res-expando-siteAttribution">
		<a href="${url}" target="_blank" rel="noopener noreferer">
			${logoUrl && string_namespaceObject._html`<img src="${logoUrl}" alt="Hosted on ${name}" title="Hosted on ${name}" />`}
			<span>hosted on ${name}</span>
			<a href="${settingsLink}" class="gearIcon" title="Disable or change settings for ${name}"></a>
		</a>
	</cite>
`;
const crosspostMetadataTemplate = data => string_namespaceObject.html`
	<div class="crosspost-preview res-crosspost-preview">
		<div class="crosspost-preview-header">
			<a href="${data.url}" class="content-link may-blank" data-event-action="title" tabindex="1"></a>
			<div class="text-content">
				<p class="title">${data.crosspostRootTitle}</p>
				<div class="crosspost-preview-tagline tagline">
					<span>${i18n('numPoints', parseInt(data.crosspostRootScore, 10))}</span>
					<span class="dot">•</span>
					<a href="/r/${data.crosspostRootSubreddit}/comments/${(data.targetParentFullname || '').slice(3)}" class="comments may-blank">${i18n('numComments', parseInt(data.crosspostRootNumComments, 10))}</a>
					<span class="dot">•</span>
					${i18n('submittedAtTime')} <time>${data.crosspostRootTime}</time>
					${i18n('submittedByAuthor')} <a href="/user/${data.crosspostRootAuthor}/" class="author may-blank">${data.crosspostRootAuthor}</a>
					${i18n('submittedToSubreddit')} <a href="/r/${data.crosspostRootSubreddit}/" class="subreddit hover may-blank">r/${data.crosspostRootSubreddit}</a>
				</div>
			</div>
		</div>
	</div>
`;
// CONCATENATED MODULE: ./lib/modules/showImages/expando.js



const expando_expandos = new WeakMap();
const primaryExpandos = new Map();
class expando_Expando {
  static getEntryExpandoFrom(thing) {
    if (!thing) return null;
    const button = thing.entry.querySelector('.expando-button');
    if (!button) return null;
    let expando = expando_expandos.get(button);

    if (!expando) {
      const box = thing.entry.querySelector('.expando');
      if (!box) return null;
      const buttonPlaceholder = document.createElement('span');
      const boxPlaceholder = document.createElement('span');
      expando = {
        button,

        get open() {
          return button.classList.contains('expanded');
        },

        collapse() {
          if (this.open) this.toggle();
        },

        expand() {
          if (!this.open) this.toggle();
        },

        toggle() {
          click(button);
        },

        detach() {
          button.replaceWith(buttonPlaceholder);
          box.replaceWith(boxPlaceholder);
        },

        reattach() {
          buttonPlaceholder.replaceWith(button);
          boxPlaceholder.replaceWith(box);
        },

        types: flatten_default()(['native', button.classList.contains('selftext') ? 'selftext' : (box.dataset.cachedhtml || '').match(/\bvideo-player\b/) ? ['video', 'non-muted'] : (box.dataset.cachedhtml || '').match(/\<iframe\b/) ? ['iframe', 'non-muted'] : ['image', 'muted']]).filter(Boolean),
        ready: true
      };
      expando_expandos.set(button, expando);
    }

    return expando;
  }

  static getTextExpandosFrom(thing) {
    if (!thing) return [];
    const md = thing.entry.querySelector('.md');
    if (!md) return [];
    return filterMap(Array.from(md.querySelectorAll(expando_Expando.expandoSelector)), v => {
      const exp = expando_expandos.get(v);
      if (exp) return [exp];
    });
  }

  static getAllExpandosFrom(thing) {
    return compact_default()([...expando_Expando.getTextExpandosFrom(thing), expando_Expando.getEntryExpandoFrom(thing)]);
  }

  constructor(href) {
    this.href = void 0;
    this.inText = void 0;
    this.ready = false;
    this.lock = null;
    this.box = void 0;
    this.button = void 0;
    this.open = false;
    this.expandWanted = false;
    this.expandCallbacks = [];
    this.media = void 0;
    this.generateMedia = void 0;
    this.types = [];
    this.buttonInfo = {
      title: 'Expando is not yet ready',
      mediaClass: ''
    };
    this.setLock = mutex(async lock => {
      this.lock = lock;
      this.updateButton();
      await lock.promise;
      this.lock = null;
      this.updateButton();
    });
    this.href = href;
    this.box = document.createElement('div');
    this.box.classList.add('res-expando-box');
    this.box.hidden = true;
    this.button = document.createElement('a');
    this.button.addEventListener('click', () => {
      this.toggle();
    });
    this.updateButton();
    expando_expandos.set(this.button, this);
  }

  onExpand(callback) {
    this.expandCallbacks.push(callback);
  }

  updateButton() {
    let {
      mediaClass,
      title
    } = this.buttonInfo;

    if (this.lock) {
      mediaClass = 'expando-button-requires-permission';
      title = 'Click to request required permissions';
    }

    this.button.className = ['expando-button toggleImage', mediaClass || 'expando-button-loading', this.open || this.expandWanted ? 'expanded' : 'collapsed collapsedExpando'].join(' ');
    this.button.title = title;

    if (this.ready && !this.isPrimary()) {
      this.button.classList.add('expando-button-duplicate');
      this.button.title += ' (duplicate link)';
    }
  }

  getPrimary() {
    return primaryExpandos.get(this.href);
  }

  isPrimary() {
    return this.getPrimary() === this;
  }

  setAsPrimary() {
    const lastPrimary = this.getPrimary();
    primaryExpandos.set(this.href, this);

    if (lastPrimary && lastPrimary !== this) {
      this.media = lastPrimary.media;
      lastPrimary.empty();
    }
  }

  initialize(options) {
    this.generateMedia = options.generateMedia;
    this.buttonInfo = options.buttonInfo;
    this.types = options.types;
    this.ready = true;
    if (!this.getPrimary()) this.setAsPrimary();
    if (this.expandWanted) this.expand();else this.updateButton();
  }

  toggle() {
    if (this.open) this.collapse();else this.expand();
  }

  expand() {
    this.setAsPrimary();

    if (this.lock || !this.ready) {
      this.expandWanted = true;
      if (this.lock) this.lock.open();
      this.updateButton();
      return;
    }

    this.box.hidden = false;
    this.attachMedia();
    if (this.media) this.media.expand();
    this.open = true;
    this.expandWanted = false;
    this.updateButton();

    for (const callback of this.expandCallbacks) callback();
  }

  collapse() {
    this.box.hidden = true;
    this.open = false;
    this.expandWanted = false;
    this.updateButton();

    if (this.media) {
      this.media.collapse();
    }
  }

  attachMedia() {
    const wrapper = this.box.firstElementChild || document.createElement('div');
    if (!this.generateMedia) throw new Error('Cannot attach media without `generateMedia`');
    this.media = this.media || this.generateMedia();
    wrapper.append(this.media.element);
    wrapper.classList.add('res-expando-box-inner');
    this.box.append(wrapper);
    if (this.media.onAttach) this.media.onAttach();
  }

  isAttached() {
    return document.body.contains(this.button) && document.body.contains(this.box);
  }

  destroy() {
    if (this.box) {
      this.box.remove();
      delete this.box;
    }

    if (this.button) {
      expando_expandos.delete(this.button);
      this.button.remove();
      delete this.button;
    }

    this.empty();
    if (primaryExpandos.get(this.href) === this) primaryExpandos.delete(this.href);
  }

  empty() {
    if (this.media) {
      this.media.element.remove();
      delete this.media;
    }

    if (this.button) {
      if (this.open) this.collapse();else this.updateButton();
    }
  }

}
expando_Expando.expandoSelector = '.expando-button, .search-expando-button';
// CONCATENATED MODULE: ./lib/modules/hosts/aarli.js



/* harmony default export */ var aarli = (new Host('aarli', {
  name: 'AAR Library',
  domains: ['aar.li'],
  logo: 'https://aar.li/favicon.ico',
  detect: ({
    pathname
  }) => /^\/a\/(\w+)/i.exec(pathname),

  async handleLink(href, [, aarId]) {
    const info = await ajax({
      url: 'https://aar.li/api.php',
      query: {
        aarId
      },
      type: 'json'
    });

    if (info.errors) {
      throw new Error(info.errors);
    }

    return {
      type: 'GALLERY',
      title: info.title,
      caption: info.description + (info.previousurl ? string_namespaceObject.escape`<br/><a href="${info.previousurl}">Previous part.</a>` : ''),
      credits: string_namespaceObject.escape`AAR by <a href="${info.authorurl}">${info.author}</a>`,
      src: info.slides.map(({
        desc,
        imglink
      }) => ({
        type: 'IMAGE',
        caption: desc,
        src: imglink
      }))
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/adultswim.js

/* harmony default export */ var adultswim = (new Host('adultswim', {
  name: 'Adult Swim',
  domains: ['adultswim.com'],
  logo: 'https://www.adultswim.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/videos\/([^\/]+\/[^\/]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://www.adultswim.com/utilities/embed/${path}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archilogic.js

/* harmony default export */ var archilogic = (new Host('archilogic', {
  name: 'archilogic',
  domains: ['spaces.archilogic.com'],
  logo: 'https://about.archilogic.com/wp-content/uploads/2017/01/favicon-96x96.png',
  detect: ({
    pathname
  }) => /^\/(3d|model)/.exec(pathname),

  handleLink(href) {
    const formattedUrl = href.replace('/model/', '/3d/').replace('http:', 'https:');
    return {
      type: 'IFRAME',
      embed: formattedUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archiveis.js

/* harmony default export */ var archiveis = (new Host('archive.is', {
  name: 'archive.is',
  domains: ['archive.is'],
  logo: 'https://archive.is/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://archive.fo/${code}/scr.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/bime.js

/* harmony default export */ var bime = (new Host('bime', {
  name: 'Bime Analytics Dashboards',
  domains: ['bime.io'],
  logo: 'https://a.bime.io/assets/favicons/favicon.ico',
  detect: ({
    href
  }) => /https?:\/\/([^.]+)\.bime\.io(?:\/([a-z0-9_-]+))+/i.exec(href),
  handleLink: (href, [, user, dashboardId]) => ({
    type: 'IFRAME',
    embed: `https://${user}.bime.io/dashboard/${dashboardId}`,
    expandoClass: 'selftext',
    width: '960px',
    height: '540px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/clyp.js

/* harmony default export */ var clyp = (new Host('clyp', {
  name: 'clyp',
  domains: ['clyp.it'],
  logo: 'https://d2cjvbryygm0lr.cloudfront.net/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(playlist\/)?([A-Za-z0-9]+)/i.exec(pathname),

  handleLink(href, [, playlist, id]) {
    return {
      type: 'IFRAME',
      embed: `https://clyp.it/${playlist ? 'playlist/' : ''}${id}/widget`,
      height: '160px',
      width: '600px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/codepen.js



/* harmony default export */ var codepen = (new Host('codepen', {
  name: 'CodePen',
  domains: ['codepen.io'],
  permissions: ['https://codepen.io/api/oembed'],
  logo: 'https://codepen.io/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?!anon)([a-z0-9_-]+)\/(?:pen|full|details|debug)\/([a-z]+)\b/i.exec(pathname),

  async handleLink(href, [, user, hash]) {
    const {
      html
    } = await ajax({
      url: 'https://codepen.io/api/oembed',
      query: {
        url: `https://codepen.io/${user}/pen/${hash}`,
        format: 'json',
        height: 500
      },
      type: 'json'
    });
    return {
      type: 'GENERIC_EXPANDO',
      muted: true,
      generate: () => $(html).get(0)
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/coub.js

/* harmony default export */ var coub = (new Host('coub', {
  name: 'Coub',
  domains: ['coub.com'],
  detect: ({
    pathname
  }) => /^\/(?:view|embed)\/(\w+)(\.gifv)?/i.exec(pathname),

  handleLink(href, [, hash, isGifv]) {
    const src = isGifv ? `https://coub.com/view/${hash}.gifv?res=true` : `https://coub.com/embed/${hash}?autoplay=true&res=true`;
    return {
      type: 'IFRAME',
      muted: !!isGifv,
      embed: src,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ctrlv.js

/* harmony default export */ var ctrlv = (new Host('ctrlv', {
  name: 'CtrlV.in',
  logo: 'https://ctrlv.in/favicon.ico',
  domains: ['ctrlv.in'],
  detect: ({
    pathname
  }) => /^\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://img.ctrlv.in/id/${id}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dailymotion.js

/* harmony default export */ var dailymotion = (new Host('dailymotion', {
  name: 'dailymotion',
  domains: ['dailymotion.com'],
  logo: 'https://static1.dmcdn.net/images/favicons/favicon-32x32.png.vb5b47df6329123929',
  detect: ({
    href
  }) => /^https?:\/\/(?:(?:www|touch)\.)?dailymotion.com[\w\-\/:#]+video[\/=]([a-z0-9]+)/i.exec(href),

  handleLink(href, [, hash]) {
    const embed = `https://www.dailymotion.com/embed/video/${hash}?api=postMessage`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}&autoplay=1`,
      pause: 'pause',
      play: 'play',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/default.js

/* harmony default export */ var hosts_default = (new Host('default', {
  name: 'default',
  domains: [],
  detect: ({
    pathname
  }) => /\.(gif|jpe?g|png|svg)$/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultAudio.js

/* harmony default export */ var defaultAudio = (new Host('defaultAudio', {
  name: 'defaultAudio',
  domains: [],
  detect: ({
    pathname
  }) => /\.(opus|weba|ogg|wav|mp3|flac)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'weba') extension = 'webm';
    if (extension === 'opus') extension = 'ogg';
    const format = `audio/${extension}`;
    return {
      type: 'AUDIO',
      autoplay: true,
      loop: false,
      sources: [{
        file: href,
        type: format
      }]
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultVideo.js

/* harmony default export */ var defaultVideo = (new Host('defaultVideo', {
  name: 'defaultVideo',
  domains: [],
  detect: ({
    pathname
  }) => /\.(webm|mp4|ogv|3gp|mkv)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'ogv') extension = 'ogg';
    const format = `video/${extension}`;
    return {
      type: 'VIDEO',
      sources: [{
        source: href,
        type: format
      }]
    };
  }

}));
// EXTERNAL MODULE: ./node_modules/lodash/keyBy.js
var lodash_keyBy = __webpack_require__(78);
var lodash_keyBy_default = /*#__PURE__*/__webpack_require__.n(lodash_keyBy);

// CONCATENATED MODULE: ./lib/modules/hosts/derpibooru.js




/* harmony default export */ var derpibooru = (new Host('derpibooru', {
  name: 'Derpibooru',
  logo: 'https://derpibooru.org/favicon.ico',
  domains: ['derpibooru.org', 'trixiebooru.org', 'derpiboo.ru', 'derpicdn.net'],
  detect: ({
    hostname,
    pathname
  }) => hostname === 'derpicdn.net' ? /^\/img\/view\/\d+\/\d+\/\d+\/(\d+)[._]/i.exec(pathname) : /^\/(?:images\/)?(\d+)$/i.exec(pathname),
  handleLink: (() => {
    const fetchInfo = batch(async requests => {
      const maxDepth = 10;
      const {
        images
      } = await ajax({
        url: 'https://derpibooru.org/api/v2/images/show.json',
        query: {
          ids: requests.map(r => r.id).join(',')
        },
        type: 'json'
      });

      const responseById = lodash_keyBy_default()(images, img => img.id);

      return requests.map(({
        id,
        depth = 0
      }) => {
        const result = responseById[id];

        if (!result) {
          return new Error('No result');
        } else if (result.duplicate_of) {
          if (depth > maxDepth) {
            return new Error(`Exceeded max duplicate depth: ${maxDepth}`);
          }

          return fetchInfo({
            id: result.duplicate_of,
            depth: depth + 1
          });
        } else if (result.image) {
          return result;
        } else {
          return new Error('Image deleted or other error');
        }
      });
    }, {
      size: 50
    });
    return async (href, [, id]) => {
      const {
        image,
        description,
        source_url: source
      } = await fetchInfo({
        id
      });
      return {
        type: 'IMAGE',
        src: image,
        caption: description,
        credits: source ? string_namespaceObject.escape`Source: <a href="${source}">${source}</a>` : undefined
      };
    };
  })()
}));
// CONCATENATED MODULE: ./lib/modules/hosts/deviantart.js


/* harmony default export */ var deviantart = (new Host('deviantart', {
  name: 'deviantART',
  logo: 'https://i.deviantart.net/icons/da_favicon.ico',
  domains: ['deviantart.com', 'fav.me', 'sta.sh'],
  permissions: ['https://backend.deviantart.com/oembed'],
  detect: ({
    href
  }) => /^https?:\/\/(?:fav\.me\/.*|sta\.sh.*|(?:.+\.)?deviantart\.com\/(?:(?:[\w-]+\/)?art\/.*|[^#]*#\/d.*))$/i.test(href),

  async handleLink(href) {
    const info = await ajax({
      url: 'https://backend.deviantart.com/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
      case 'link':
        let src;

        if (info.fullsize_url) {
          src = info.fullsize_url;
        } else if (/\.(jpg|jpeg|gif|png)/i.test(info.url)) {
          src = info.url;
        } else {
          src = info.thumbnail_url;
        }

        return {
          type: 'IMAGE',
          title: info.title,
          credits: `Art by: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`,
          src
        };

      case 'rich':
        return {
          type: 'TEXT',
          title: info.title,
          src: info.html + (/[^\s\.]\s*$/.test(info.html) ? '...' : ''),
          credits: `<a href="${href}">Click here to read the full text</a> - Written By: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`
        };

      default:
        throw new Error(`Unsupported deviantART post type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dropbox.js


/* harmony default export */ var dropbox = (new Host('dropbox', {
  name: 'dropbox',
  domains: ['dropbox.com'],
  logo: 'https://cfl.dropboxstatic.com/static/images/favicon-vflk5FiAC.ico',

  detect(url) {
    for (const host of genericHosts) {
      const result = host.detect(url);
      if (result) return [host.handleLink, result];
    }
  },

  handleLink(href, [handler, result]) {
    const originalURL = new URL(href);
    return handler(`${originalURL.origin}${originalURL.pathname}?raw=1`, result);
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/fiveHundredPx.js

/* harmony default export */ var fiveHundredPx = (new Host('fiveHundredPx', {
  name: 'fiveHundredPx',
  domains: ['500px.org', '500px.net', '500px.com'],
  logo: 'https://assetcdn.500px.org/assets/favicon-1e8257b93fb787f8ceb66b5522ee853c.ico',
  detect: ({
    href
  }) => /^https?:\/\/\w*cdn\.500px\.(?:net|com|org)\/(?:photo\/)?([0-9]+)\//.exec(href),

  handleLink(href, [, photoId]) {
    return {
      type: 'IMAGE',
      src: href.replace(/\/[0-9]+\.jpg$/, '/5.jpg'),
      credits: `View original and details at: <a href="https://500px.com/photo/${photoId}">500px.com</a>`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/flickr.js


/* harmony default export */ var flickr = (new Host('flickr', {
  name: 'flickr',
  domains: ['flickr.com', 'flic.kr', 'staticflickr.com'],
  logo: 'https://s.yimg.com/pw/favicon.ico',
  detect: (() => {
    function base58Encode(num) {
      let enc = '';
      let acc = num;

      do {
        const div = Math.floor(acc / 58);
        const mod = acc - 58 * div;
        enc = `${'123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'[mod]}${enc}`;
        acc = div;
      } while (acc);

      return enc;
    }

    return ({
      href
    }) => {
      if (/^https?:\/\/(?:\w+\.)?flickr\.com\/(?:.+)\/(\d{10,})(?:\/|$)/i.test(href) || /^https?:\/\/(?:\w+\.)?flic\.kr\/p\/(\w+)(?:\/|$)/i.test(href)) {
        return href;
      }

      const matches = /^https?:\/\/(?:\w+\.)?staticflickr\.com\/(?:.+\/)?\d{4}\/(\d{10,})_/i.exec(href);

      if (matches) {
        return `https://flic.kr/p/${base58Encode(parseInt(matches[1], 10))}`;
      }
    };
  })(),

  async handleLink(href, oembedTarget) {
    const info = await ajax({
      url: 'https://noembed.com/embed',
      query: {
        url: oembedTarget
      },
      type: 'json'
    });

    if (!info.media_url) {
      throw new Error('No media_url found.');
    }

    let src;

    if (/\.(jpg|jpeg|gif|png)/i.test(info.media_url)) {
      src = info.media_url;
    } else {
      src = info.thumbnail_url;
    }

    return {
      type: 'IMAGE',
      title: info.title,
      credits: `Picture by: <a href="${info.author_url}">${info.author_name}</a> @ Flickr`,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/futurism.js


/* harmony default export */ var futurism = (new Host('futurism', {
  name: 'futurism',
  attribution: false,
  domains: ['futurism.com', 'futurism.co'],
  detect: () => true,

  async handleLink(href) {
    const {
      data,
      success,
      status
    } = await ajax({
      url: 'https://www.futurism.com/wp-content/themes/futurism/res.php',
      query: {
        url: href,
        reverse: href.includes('wp-content/uploads')
      },
      type: 'json'
    });

    if (!success) {
      throw new Error(`Request failure: status ${status}`);
    }

    return {
      type: 'IMAGE',
      src: data.image_link
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gatherer.js

/* harmony default export */ var gatherer = (new Host('gatherer', {
  name: 'Gatherer MTG Card Images',
  domains: ['gatherer.wizards.com'],
  logo: 'http://gatherer.wizards.com/Images/favicon.ico',
  detect: ({
    pathname
  }) => /^\/Handlers\/Image\.ashx/i.exec(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/getyarn.js

/* harmony default export */ var getyarn = (new Host('getyarn', {
  name: 'getyarn.io',
  logo: 'https://getyarn.io/favicon.ico',
  domains: ['getyarn.io'],
  detect: ({
    pathname
  }) => /\/yarn-clip\/(?:embed\/)?([\w\-]+)/i.exec(pathname),

  handleLink(href, [, code]) {
    const embed = `https://getyarn.io/yarn-clip/embed/${code}`;
    return {
      type: 'IFRAME',
      embed: `${embed}?autoplay=false`,
      embedAutoplay: `${embed}?autoplay=true`,
      height: '600px',
      width: '768px',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gfycat.js



/* harmony default export */ var gfycat = (new Host('gfycat', {
  name: 'gfycat',
  domains: ['gfycat.com'],
  logo: 'https://gfycat.com/favicon.ico',
  options: {
    useMobileGfycat: {
      title: 'gfycatUseMobileGfycatTitle',
      description: 'gfycatUseMobileGfycatDesc',
      value: false,
      type: 'boolean'
    }
  },
  detect: ({
    pathname
  }) => /^\/(?:(?:ifr|gifs\/detail)\/)?(\w+)(?:\.gif)?/i.exec(pathname),

  async handleLink(href, [, id], info = null) {
    const isMobileResolution = this.options.useMobileGfycat.value;
    info = info || (await ajax({
      url: string_namespaceObject.encode`https://api.gfycat.com/v1/gfycats/${id}`,
      type: 'json',
      cacheFor: DAY
    })).gfyItem;
    return {
      type: 'VIDEO',
      frameRate: info.frameRate,
      loop: true,
      muted: !info.hasAudio,
      playbackRate: +(href.match(/[?|&]speed=([\d\.]+)/i) || [undefined, 1])[1],
      poster: isMobileResolution ? info.mobilePosterUrl : info.posterUrl,
      sources: [isMobileResolution && {
        source: info.mobileUrl,
        type: 'video/mp4'
      }, {
        source: info.webmUrl,
        type: 'video/webm'
      }, {
        source: info.mp4Url,
        type: 'video/mp4'
      }].filter(x => x),
      time: +(href.match(/[?|&]frameNum=([\d]+)/i) || [undefined, 0])[1] / info.frameRate
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gifyoutube.js



/* harmony default export */ var gifyoutube = (new Host('gifs', {
  name: 'gifs.com',
  domains: ['gifs.com', 'gifyoutube.com', 'gifyt.com'],
  logo: 'https://cdn.gifs.com/resources/favicon.png',
  detect: ({
    href
  }) => /^https?:\/\/(?:beta\.|www\.)?(?:gifyoutube|gifyt)\.com\/gif\/(\w+)\.?/i.exec(href) || /^https?:\/\/share\.gifyoutube\.com\/(\w+)\.gif/i.exec(href),

  async handleLink(href, [, id]) {
    const {
      sauce
    } = await ajax({
      url: `https://gifs.com/api/${id}`,
      type: 'json',
      cacheFor: DAY
    });
    return {
      type: 'VIDEO',
      loop: true,
      fallback: `https://share.gifyoutube.com/${id}.gif`,
      muted: true,
      source: sauce,
      sources: [{
        source: `https://share.gifyoutube.com/${id}.webm`,
        type: 'video/webm'
      }, {
        source: `https://share.gifyoutube.com/${id}.mp4`,
        type: 'video/mp4'
      }]
    };
  }

}));
// EXTERNAL MODULE: ./lib/images/hosts/giphy-logo.png
var giphy_logo = __webpack_require__(131);
var giphy_logo_default = /*#__PURE__*/__webpack_require__.n(giphy_logo);

// CONCATENATED MODULE: ./lib/modules/hosts/giphy.js



/* harmony default export */ var giphy = (new Host('giphy', {
  name: 'giphy',
  domains: ['giphy.com'],
  logo: giphy_logo_default.a,
  detect: ({
    pathname
  }) => /^(?:\/gifs|\/media|)\/(?:\w+-)*([^/.]+)(?:\/|\.gif|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      data
    } = await ajax({
      url: `https://api.giphy.com/v1/gifs/${id}`,
      query: {
        api_key: 'dc6zaTOxFJmzC'
      },
      type: 'json'
    });
    return {
      type: 'VIDEO',
      fallback: data.images.original.url,
      loop: true,
      muted: true,
      sources: [{
        source: data.images.original.mp4,
        type: 'video/mp4'
      }]
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/snudown-js/dist/snudown_es.js
var snudown_es_r;function snudown_es_e(r){for(;0<r.length;){var e=r.shift();if("function"==typeof e)e();else{var i=e.l;"number"==typeof i?void 0===e.j?o.dynCall_v(i):o.dynCall_vi(i,e.j):i(void 0===e.j?null:e.j);}}}function snudown_es_i(r){this.name="ExitStatus",this.message="Program terminated with exit("+r+")",this.status=r;}function snudown_es_a(){function r(){if(!o.calledRun&&(o.calledRun=!0,!snudown_es_v)){if(_||(_=!0,snudown_es_e(w)),snudown_es_e(p),o.onRuntimeInitialized&&o.onRuntimeInitialized(),o.postRun)for("function"==typeof o.postRun&&(o.postRun=[o.postRun]);o.postRun.length;)m.unshift(o.postRun.shift());snudown_es_e(m);}}if(o.preRun)for("function"==typeof o.preRun&&(o.preRun=[o.preRun]);o.preRun.length;)h.unshift(o.preRun.shift());snudown_es_e(h),o.calledRun||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("");},1),r();},1)):r());}function snudown_es_f(r){throw o.onAbort&&o.onAbort(r),r=void 0!==r?(u(r),snudown_es_c(r),JSON.stringify(r)):"",snudown_es_v=!0,"abort("+r+"). Build with -s ASSERTIONS=1 for more info.";}function l(r){var e=1+(r.length<<2),i=C(e),a=snudown_es_b,f=i;if(0<e){e=f+e-1;for(var n=0;n<r.length;++n){var t=r.charCodeAt(n);if(55296<=t&&t<=57343&&(t=65536+((1023&t)<<10)|1023&r.charCodeAt(++n)),t<=127){if(e<=f)break;a[f++]=t;}else{if(t<=2047){if(e<=f+1)break;a[f++]=192|t>>6;}else{if(t<=65535){if(e<=f+2)break;a[f++]=224|t>>12;}else{if(e<=f+3)break;a[f++]=240|t>>18,a[f++]=128|t>>12&63;}a[f++]=128|t>>6&63;}a[f++]=128|63&t;}}a[f]=0;}return i;}function n(r,e,i){var a=R();"string"!=typeof e&&(e="");for(var f=l(e),n=0,t=0;t<e.length;++t){var o=e.charCodeAt(t);55296<=o&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++t)),o<=127?++n:n=o<=2047?n+2:o<=65535?n+3:n+4;}if("object"==typeof i&&null!==i||(i={}),r=r(f,e=n,n=i.nofollow?1:0,t="string"==typeof i.target?l(i.target):0,o="string"==typeof i.tocIdPrefix?l(i.tocIdPrefix):0,i.enableToc?1:0))r:{for(f=(i=r)+NaN,e="";!(f<=i);){if(!(n=snudown_es_b[i++])){i=e;break r;}128&n?(t=63&snudown_es_b[i++],192==(224&n)?e+=String.fromCharCode((31&n)<<6|t):(o=63&snudown_es_b[i++],(n=224==(240&n)?(15&n)<<12|t<<6|o:(7&n)<<18|t<<12|o<<6|63&snudown_es_b[i++])<65536?e+=String.fromCharCode(n):e+=String.fromCharCode(55296|(n-=65536)>>10,56320|1023&n))):e+=String.fromCharCode(n);}i=void 0;}else i="";return snudown_es_g(r),S(a),i;}snudown_es_r||(snudown_es_r={});var snudown_es_t,o={},s={};for(snudown_es_t in o)o.hasOwnProperty(snudown_es_t)&&(s[snudown_es_t]=o[snudown_es_t]);o.arguments=[],o.thisProgram="./this.program",o.quit=function(r,e){throw e;},o.preRun=[],o.postRun=[],o.read=function(r){var e=new XMLHttpRequest();return e.open("GET",r,!1),e.send(null),e.responseText;},o.readAsync=function(r,e,i){var a=new XMLHttpRequest();a.open("GET",r,!0),a.responseType="arraybuffer",a.onload=function(){200==a.status||0==a.status&&a.response?e(a.response):i();},a.onerror=i,a.send(null);},o.setWindowTitle=function(r){document.title=r;};var u=o.print||(void 0!==console?console.log.bind(console):null),snudown_es_c=o.printErr||void 0!==console&&console.warn.bind(console)||u;for(snudown_es_t in s)s.hasOwnProperty(snudown_es_t)&&(o[snudown_es_t]=s[snudown_es_t]);s=void 0;var snudown_es_b,snudown_es_k=0,snudown_es_v=!1,snudown_es_d=o.TOTAL_MEMORY||16777216;snudown_es_d<5242880&&snudown_es_c("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+snudown_es_d+"! (TOTAL_STACK=5242880)"),o.buffer?s=o.buffer:(s=new ArrayBuffer(snudown_es_d),o.buffer=s),o.HEAP8=new Int8Array(s),o.HEAP16=new Int16Array(s),o.HEAP32=snudown_es_t=new Int32Array(s),o.HEAPU8=snudown_es_b=new Uint8Array(s),o.HEAPU16=new Uint16Array(s),o.HEAPU32=new Uint32Array(s),o.HEAPF32=new Float32Array(s),o.HEAPF64=new Float64Array(s);var h=[],w=[],p=[],m=[],_=!(snudown_es_t[2296]=5252320);o.preloadedImages={},o.preloadedAudios={},snudown_es_t=null,snudown_es_t='\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0æ\0\0\v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\0\0-\0\x005\0\0A\0\0M\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\0\0S\0\0\\\0\0c\0\0m\0\0o\0\0v\0\0\0\0\0\0\0\0\0\0\0\0§\0\0´\0\0\0\0\0\0\0\0\0\0À#\0\0Ø\0\0Ú\0\0Ý\0\0á\0\0æ\0\0À#\0\0ì\0\0ï\0\0ó\0\0ø\0\0\0\0\n\0\0\r\0\0À#\0\0\0\0À#\0\0\0\0\0\0À#\0\0À#\0\0 \0\0\'\0\0*\0\0À#\0\0~\0\x003\0\0:\0\0=\0\0À#\0\0À#\0\0À#\0\0A\0\0À#\0\0À#\0\0À#\0\0À#\0\0D\0\0G\0\0\0\0\0\0&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\b\n&&&&&&&&&&\0&\0&\0&&\0\n\0&&\0&&&&&&&&&&&&\0&\0&\0&&\0\n\0&&\0&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\t\0\0\0\n\0\0\0\v\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000123456789ABCDEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0À#\0\0Ê\0\0\0\0v\0\0|\0\0Ù\0\0R\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0$\0\0À#\0\0À#\0\0À#\0\0À#\0\0*\0\0À#\0\0À#\0\0À#\0\0À#\0\x000\0\x006\0\0=\0\0À#\0\0À#\0\0E\0\0À#\0\0À#\0\0À#\0\0À#\0\0K\0\0Q\0\0À#\0\0À#\0\0À#\0\0X\0\0^\0\0e\0\0m\0\0À#\0\0v\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0|\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0¦\0\0¬\0\0À#\0\0À#\0\0³\0\0¸\0\0¾\0\0À#\0\0À#\0\0Å\0\0À#\0\0Ê\0\0Ñ\0\0À#\0\0Ù\0\0Þ\0\0À#\0\0ä\0\0À#\0\0À#\0\0ì\0\0ò\0\0À#\0\0ù\0\0À#\0\0\0\0\b\0\0\0\0\0\0À#\0\0À#\0\0 \0\0À#\0\0%\0\0.\0\x008\0\0>\0\0C\0\0À#\0\0K\0\0À#\0\0P\0\0U\0\0À#\0\0À#\0\0]\0\0c\0\0j\0\0À#\0\0À#\0\0r\0\0À#\0\0}\0\0À#\0\0À#\0\0À#\0\0\0\0\0\0À#\0\0À#\0\0\0\0\0\0¡\0\0À#\0\0À#\0\0À#\0\0©\0\0°\0\0À#\0\0À#\0\0À#\0\0¸\0\0¿\0\0À#\0\0À#\0\0Ç\0\0Í\0\0Ò\0\0Ú\0\0À#\0\0ã\0\0é\0\0ð\0\0ø\0\0À#\0\0\0\0\b\0\0\0\0À#\0\0À#\0\0\0\0\0\0%\0\0-\0\0À#\0\x004\0\0À#\0\0:\0\0À#\0\0À#\0\0B\0\0I\0\0À#\0\0À#\0\0À#\0\0P\0\0V\0\0[\0\0c\0\0À#\0\0À#\0\0l\0\0À#\0\0s\0\0À#\0\0|\0\0\0\0\0\0\0\0À#\0\0\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0§\0\0À#\0\0À#\0\0À#\0\0°\0\0¸\0\0À#\0\0À#\0\0Á\0\0È\0\0Ð\0\0Ù\0\0À#\0\0Þ\0\0å\0\0í\0\0À#\0\0ö\0\0ü\0\0\0\0\v\0\0À#\0\0À#\0\0À#\0\0\0\0\0\0%\0\0À#\0\0À#\0\0-\0\x005\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0>\0\0À#\0\0À#\0\0À#\0\0E\0\0N\0\0S\0\0Y\0\0`\0\0f\0\0À#\0\0À#\0\0o\0\0v\0\0~\0\0À#\0\0À#\0\0\0\0\0\0À#\0\0À#\0\0À#\0\0\0\0\0\0¥\0\0À#\0\0®\0\0¶\0\0½\0\0Ã\0\0Ê\0\0Ñ\0\0Ù\0\0à\0\0è\0\0À#\0\0À#\0\0ñ\0\0ø\0\0\0\0\0\t\0\0\0\0\0\0\0\0À#\0\0À#\0\0%\0\0-\0\0À#\0\x004\0\0=\0\0E\0\0K\0\0À#\0\0À#\0\0R\0\0W\0\0]\0\0d\0\0À#\0\0n\0\0v\0\0\0\0\0\0\0\0À#\0\0\0\0 \0\0©\0\0À#\0\0³\0\0»\0\0Á\0\0È\0\0Ð\0\0Ù\0\0À#\0\0á\0\0À#\0\0ê\0\0À#\0\0À#\0\0ó\0\0ü\0\0À#\0\0À#\0\0\0\0\f\0\0À#\0\0\0\0À#\0\0\0\0&\0\0-\0\x005\0\0>\0\0E\0\0M\0\0T\0\0\\\0\0À#\0\0b\0\0j\0\0q\0\0y\0\0À#\0\0\0\0\0\0\0\0\0\0À#\0\0À#\0\0¢\0\0©\0\0±\0\0À#\0\0À#\0\0º\0\0Ã\0\0Ë\0\0À#\0\0À#\0\0Ô\0\0Û\0\0ã\0\0À#\0\0À#\0\0ê\0\0ñ\0\0ù\0\0À#\0\0\0\0\n\0\0\0\0\0\0À#\0\0À#\0\0$\0\0+\0\x003\0\0À#\0\0<\0\0À#\0\0C\0\0À#\0\0À#\0\0À#\0\0À#\0\0K\0\0S\0\0À#\0\0À#\0\0À#\0\0\\\0\0À#\0\0À#\0\0À#\0\0À#\0\0d\0\0n\0\0À#\0\0À#\0\0w\0\0À#\0\0~\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0À#\0\0À#\0\0À#\0\0À#\0\0\0\0¦\0\0À#\0\0À#\0\0À#\0\0®\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0·\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0¾\0\0À#\0\0À#\0\0Æ\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0Ï\0\0À#\0\0À#\0\0À#\0\0Ø\0\0à\0\0À#\0\0À#\0\0À#\0\0À#\0\0é\0\0À#\0\0ò\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0ú\0\0À#\0\0ÿ\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0\b \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0# \0\0+ \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\x003 \0\0< \0\0À#\0\0À#\0\0À#\0\0D \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0M \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0V \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0_ \0\0À#\0\0À#\0\0À#\0\0g \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0p \0\0y \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0À#\0\0 \0\0\0\0\0\0\0\0_\0Z\0\0\0\0\0s\0^\x007\0\0\0\0\0\0\0\0Ã\0\0\0\0#\0-\0-\0\n\0\0\x002\0}\0\0U\0K\0(\0A\0\0\0<\0ð\0ð\0ß\0\n\0f\0\0#\0\0\0\0\0\n\0·\0\0\0\0\x002\0K\0\n\0K\0¯\0U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\0\b\tÿÿÿÿÿÿÿ\n\v\f\r !"#ÿÿÿÿÿÿ\n\v\f\r !"#ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 rel="nofollow"\0 target="\0tr\0th\0td\0tbody\0thead\0tfoot\0caption\0colspan\0rowspan\0cellspacing\0cellpadding\0scope\0https://\0ftp://\0mailto://\0/\0git://\0steam://\0irc://\0news://\0mumble://\0ssh://\0ircs://\0ts3server://\0#\0www.\0?!.,\0.+-_\0all-\0reddit.com\0t:\0p\0dl\0div\0math\0table\0ul\0del\0form\0blockquote\0figure\0ol\0fieldset\0h1\0h6\0pre\0script\0h5\0noscript\0iframe\0h4\0ins\0h3\0h2\0span\0ï»¿http://\0\\`*_{}[]()#+-.!:|&<>/^~\0&#x27;\0&#39;\0&#47;\0</li>\n</ul>\n\0</div>\n\0<sup>\0</sup>\0<del>\0</del>\0<strong><em>\0</em></strong>\0<em>\0</em>\0<strong>\0</strong>\0<span class="md-spoiler-text">\0</span>\0<code>\0</code>\0<div class="toc">\n\0<ul>\n<li>\n\0</li>\n\0</ul>\n</li>\n\0<li>\n\0</li>\n<li>\n\0<a href="#\0toc_\0">\0</a>\n\0style\0a\0img\0="\0<a href="\0" title="\0</a>\0<br>\n\0<br/>\n\0<img src="\0" alt="\0"/>\0mailto:\0<th\0<td\0 colspan="\0" \0 align="center">\0 align="left">\0 align="right">\0>\0</th>\n\0</td>\n\0<tr>\n\0</tr>\n\0<table><thead>\n\0</thead><tbody>\n\0</tbody></table>\n\0<p>\0</p>\n\0<li>\0<ol>\n\0<ul>\n\0</ol>\n\0</ul>\n\0<hr>\n\0<hr/>\n\0<h\0 id="\0</h\0>\n\0<blockquote class="md-spoiler-text">\n\0</blockquote>\n\0<blockquote>\n\0<pre><code class="\0<pre><code>\0</code></pre>\n\0&or;\0&not;\0&int;\0&psi;\0&isin;\0&notin;\0&Rho;\0&phi;\0&prop;\0&rho;\0&nbsp;\0&thorn;\0&thinsp;\0&chi;\0&prod;\0&amp;\0&Psi;\0&iota;\0&omicron;\0&Phi;\0&and;\0&sdot;\0&nu;\0&Chi;\0&emsp;\0&Mu;\0&ensp;\0&ocirc;\0&lt;\0&uml;\0&icirc;\0&sup;\0&sup1;\0&Scaron;\0&cap;\0&part;\0&pound;\0&scaron;\0&ni;\0&lowast;\0&Omicron;\0&cup;\0&Xi;\0&crarr;\0&Nu;\0&pi;\0&theta;\0&tau;\0&nsub;\0&acirc;\0&thetasym;\0&Ocirc;\0&rarr;\0&ucirc;\0&loz;\0&darr;\0&trade;\0&para;\0&ecirc;\0&larr;\0&radic;\0&sub;\0&Pi;\0&kappa;\0&iquest;\0&eta;\0&supe;\0&rceil;\0&there4;\0&rArr;\0&uarr;\0&Kappa;\0&dArr;\0&euro;\0&Theta;\0&circ;\0&Tau;\0&lceil;\0&lArr;\0&ordm;\0&lrm;\0&xi;\0&acute;\0&ccedil;\0&sup3;\0&ntilde;\0&uArr;\0&sup2;\0&piv;\0&otilde;\0&shy;\0&Acirc;\0&curren;\0&Ucirc;\0&oacute;\0&sube;\0&nabla;\0&iacute;\0&mu;\0&bull;\0&oline;\0&Ccedil;\0&sum;\0&copy;\0&equiv;\0&Ntilde;\0&prime;\0&atilde;\0&tilde;\0&Ecirc;\0&Otilde;\0&apos;\0&aacute;\0&ne;\0&Eta;\0&macr;\0&sim;\0&Oacute;\0&Iota;\0&empty;\0&uacute;\0&ouml;\0&exist;\0&iuml;\0&Prime;\0&eacute;\0&rsquo;\0&cent;\0&zwj;\0&zwnj;\0&quot;\0&sbquo;\0&sect;\0&infin;\0&otimes;\0&cong;\0&Icirc;\0&brvbar;\0&le;\0&lsquo;\0&ordf;\0&clubs;\0&oplus;\0&perp;\0&Yacute;\0&micro;\0&ang;\0&auml;\0&gt;\0&rlm;\0&Ouml;\0&upsilon;\0&minus;\0&middot;\0&uuml;\0&aring;\0&Atilde;\0&divide;\0&rsaquo;\0&epsilon;\0&times;\0&ETH;\0&euml;\0&szlig;\0&frac14;\0&diams;\0&oslash;\0&Aacute;\0&lsaquo;\0&Delta;\0&rdquo;\0&spades;\0&Uacute;\0&raquo;\0&rang;\0&frasl;\0&rfloor;\0&harr;\0&ndash;\0&Yuml;\0&cedil;\0&eth;\0&ldquo;\0&real;\0&THORN;\0&plusmn;\0&laquo;\0&lang;\0&delta;\0&lfloor;\0&beta;\0&omega;\0&Eacute;\0&Oslash;\0&image;\0&weierp;\0&Zeta;\0&OElig;\0&hArr;\0&Auml;\0&asymp;\0&Lambda;\0&bdquo;\0&zeta;\0&Upsilon;\0&lambda;\0&Uuml;\0&Aring;\0&yacute;\0&Beta;\0&Gamma;\0&iexcl;\0&forall;\0&Omega;\0&Epsilon;\0&Iacute;\0&Euml;\0&frac34;\0&frac12;\0&yen;\0&yuml;\0&ograve;\0&AElig;\0&igrave;\0&Iuml;\0&alpha;\0&permil;\0&agrave;\0&mdash;\0&Ograve;\0&ugrave;\0&upsih;\0&ge;\0&egrave;\0&fnof;\0&reg;\0&deg;\0&Sigma;\0&sigma;\0&Alpha;\0&hearts;\0&oelig;\0&Agrave;\0&Ugrave;\0&hellip;\0&aelig;\0&Egrave;\0&Igrave;\0&gamma;\0&Dagger;\0&dagger;\0&alefsym;\0&sigmaf;\0\0',s=function(r,e,i){function t(r,e,i){e|=0;var a=112+(r|=0)|0;if(0|i){i=0|r;var f=0|a;for(ze[f>>2]=0,ze[f+4>>2]=0,ze[f+8>>2]=0,ze[f+12>>2]=0,ze[f+16>>2]=0,ze[f+20>>2]=0,ze[f+24>>2]=0,ze[f+28>>2]=0,ze[f+16>>2]=65,f=5128,e=i+112|0;ze[i>>2]=ze[f>>2],f=f+4|0,(0|(i=i+4|0))<(0|e););}else{i=0|r,e|=0,ze[(f=0|a)>>2]=0,ze[f+4>>2]=0,ze[f+8>>2]=0,ze[f+12>>2]=0,ze[f+16>>2]=0,ze[f+20>>2]=0,ze[f+24>>2]=0,ze[f+28>>2]=0,ze[f+16>>2]=e;for(var n=5240,t=(f=i)+112|0;ze[f>>2]=ze[n>>2],n=n+4|0,(0|(f=f+4|0))<(0|t););4&e|0&&(ze[i+68>>2]=0),8&e|0&&(ze[i+76>>2]=0,ze[i+48>>2]=0),513&e|0&&(ze[i+12>>2]=0);}if(ze[r+140>>2]=7,ze[r+132>>2]=16,ze[r+136>>2]=64,r|=0,a|=0,i=0|U(444)){for(f=(e=i)+112|0;ze[e>>2]=ze[r>>2],r=r+4|0,(0|(e=e+4|0))<(0|f););c(i+404|0,4),c(i+416|0,8),fr(i+148|0,0,256),(0!=(0|ze[i+64>>2])||0!=(0|ze[i+60>>2])||0|ze[i+84>>2])&&(je[i+190>>0]=1,je[i+243>>0]=1,je[i+210>>0]=1,je[i+274>>0]=1),0|ze[i+52>>2]&&(je[i+244>>0]=2),0|ze[i+72>>2]&&(je[i+158>>0]=3),(0!=(0|ze[i+68>>2])||0|ze[i+76>>2])&&(je[i+239>>0]=4),je[i+208>>0]=5,je[i+240>>0]=6,je[i+186>>0]=7,je[i+212>>0]=9,je[i+206>>0]=8,je[i+267>>0]=10,je[i+195>>0]=11,je[i+242>>0]=12,ze[i+428>>2]=155,ze[i+112>>2]=a,ze[i+432>>2]=16,ze[i+436>>2]=64,ze[i+440>>2]=0;}else i=0;return 0|i;}function o(r,e,i,a,f,n,t){r|=0,e|=0,f|=0,t|=0;var o=0|ze[8368+((n|=0)<<4)>>2],l=0|ze[8372+(n<<4)>>2],s=0|ze[8376+(n<<4)>>2],u=0|ze[8380+(n<<4)>>2];ze[s+144>>2]=0|i,ze[s+148>>2]=0|a;var c=0|C(128);return i=0|ze[(n=s+128|0)>>2],0|t&&(ze[(t=u+124|0)>>2]=f,b(c,r,e,l),ze[t>>2]=0,ze[n>>2]|=64),ze[(a=s+124|0)>>2]=f,b(c,r,e,o),ze[a>>2]=0,ze[n>>2]=i,i=0|U(1+(n=0|ze[c+4>>2])|0),(je[i+n>>0]=0)|(a=0|ze[c>>2])&&ar(0|i,0|a,0|n),S(c),0|i;}function k(r,e){r|=0,e|=0;var i=0;r:for(;;){if(14<=i>>>0){var a=0;break;}var f=0|X(a=0|ze[96+(i<<2)>>2]);if(f>>>0<e>>>0&&0==(0|W(r,a,f))){if(0|Ke(255&(a=0|je[r+f>>0]))){a=1;break;}switch(a<<24>>24){case 35:case 47:case 63:a=1;break r;}}i=i+1|0;}return 0|a;}function v(r,e){var i;if(!(0|Ke(0|Ne[(r|=0)>>0])))return 0;var a=(0|e)-1|0;for(e=0,i=1;!(a>>>0<=i>>>0);){var f=0|je[r+i>>0];if(46!=f<<24>>24){if(!(45==f<<24>>24|0!=(0|Ke(255&f))))break;}else e=e+1|0;i=i+1|0;}return 0|(0==(0|e)?0:i);}function h(r,e){r|=0,e|=0;var i,a,f=0,n=0,t=0,o=0;for(i=0;;){if(e>>>0<=i>>>0){i=e;break;}if(60==(0|je[r+i>>0]))break;i=i+1|0;}r:for(;;){if(!i){i=0;break;}if(!((e=0|je[r+(o=i+-1|0)>>0])<<24>>24))break;do{if(!(0|Y(5563,255&e,5))){switch(e<<24>>24){case 34:f=20;break r;case 39:f=21;break r;case 41:n=40,t=41,f=22;break r;case 93:f=18;break r;case 125:f=19;break r;case 59:break;default:break r;}for(i=e=i+-2|0;;){if(!i){i=0;break;}if(!(((32|Ne[r+i>>0])-97|0)>>>0<26|0))break;i=i+-1|0;}if(i>>>0<e>>>0&&38==(0|je[r+i>>0]))break;}i=o;}while(0);}if(18==(0|f)?(n=91,t=93,f=22):19==(0|f)?(n=123,t=125,f=22):20==(0|f)?(t=n=34,f=22):21==(0|f)&&(t=n=39,f=22),22==(0|f)){for(a=f=e=0;(0|e)!=(0|i);){var l=0|je[r+e>>0],s=(0|n)==(255&l|0);e=e+1|0,f=f+(1&s)|0,a=a+(l<<24>>24==t<<24>>24&(1^s)&1)|0;}i=(0|a)==(0|f)?i:o;}return 0|i;}function g(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0,f|=0;do{if(0==(0|e)|a>>>0<2||(0|Ne[r+-1>>0])!=(f<<24>>24|0))r=0;else{if(1<e>>>0){if(47==(r=(f=0|je[r+-2>>0])<<24>>24)){r=2;break;}if(0|G(r)){r=1;break;}return 0!=(0|B(r))|0;}r=2<i>>>0&&47==(0|je[r+-2>>0])&&92==(0|je[r+-3>>0])?0:1;}}while(0);return 0|r;}function A(r,e){if(r|=0,(e|=0)>>>0<=16777216){var i=r+8|0,a=0|ze[i>>2];if(a>>>0<e>>>0){for(var f=0|ze[r+12>>2],n=a;(n=n+f|0)>>>0<e>>>0;);a=(a=0|L(0|ze[r>>2],n))?(ze[r>>2]=a,ze[i>>2]=n,0):-1;}else a=0;}else a=-1;return 0|a;}function C(r){r|=0;var e=0|U(16);return 0|e&&(ze[e>>2]=0,ze[e+8>>2]=0,ze[e+4>>2]=0,ze[e+12>>2]=r),0|e;}function de(r,e,i){e|=0;var a=0,f=4+(r|=0)|0,n=0|ze[f>>2],t=n+(i|=0)|0;(0|ze[r+8>>2])>>>0<t>>>0?0<=(0|A(r,t))&&(n=0|ze[f>>2],a=4):a=4,4==(0|a)&&(ar((0|ze[r>>2])+n|0,0|e,0|i),ze[f>>2]=(0|ze[f>>2])+i);}function y(r,e){de(0|r,e|=0,0|X(e));}function he(r,e){e|=0;var i=0,a=4+(r|=0)|0,f=0|ze[a>>2],n=f+1|0;(0|ze[r+8>>2])>>>0<n>>>0?0<=(0|A(r,n))&&(f=0|ze[a>>2],i=4):i=4,4==(0|i)&&(je[(0|ze[r>>2])+f>>0]=e,ze[a>>2]=1+(0|ze[a>>2]));}function l(r,e){r|=0,e|=0;var i=Be;Be=Be+16|0;for(var a=i,f=a+14|0;(0|(a=a+1|(je[a>>0]=0)))<(0|f););var n=(0|e)<0,t=0;for(f=n?0|-e:e;a=t+1|0,je[i+t>>0]=(e=f)+(0|sr(f=(0|f)/10|0,-10))+48,!((0|e)<=9);)t=a;for(n&&(je[i+a>>0]=45,a=t+2|0),f=0;!((0|(a=a+-1|0))<=(0|f));)e=0|je[(t=i+f|0)>>0],je[t>>0]=0|je[(n=i+a|0)>>0],je[n>>0]=e,f=f+1|0;y(r,i),Be=i;}function S(r){0|(r|=0)&&(Me(0|ze[r>>2]),Me(r));}function R(r){0|(r|=0)&&(Me(0|ze[r>>2]),ze[r>>2]=0,ze[r+8>>2]=0,ze[r+4>>2]=0);}function E(r,e){(e|=0)>>>0<=(0|ze[(r=4+(0|r)|0)>>2])>>>0&&(ze[r>>2]=e);}function b(r,e,i,a){r|=0,e|=0,i|=0,a|=0;var f=0,n=Be;Be=Be+16|0;var t=0|C(64);if(0|t){A(t,i);var o=a+116|0;ze[o>>2]=0,ze[o+4>>2]=0,ze[o+8>>2]=0,ze[o+12>>2]=0,ze[o+16>>2]=0,ze[o+20>>2]=0,ze[o+24>>2]=0;for(var l=2<i>>>(ze[o+28>>2]=0)&&(l=0==(0|F(e,5708,3)))?3:0;!(i>>>0<=l>>>0);)r:do{var s=e,u=l,c=i,b=n,k=o;s|=0,c|=0,b|=0,k|=0;var v,d,h=0,w=3+(u|=0)|0;e:do{if(w>>>0<c>>>0){if(32==(0|je[s+u>>0])){if(32==(0|je[s+(u+1)>>0])){if(32==(0|je[s+(u+2)>>0])){if(32==(0|je[s+w>>0])){w=0;break;}w=3;}else w=2;}else w=1;}else w=0;if(91==(0|je[s+(w=w+u|0)>>0])){var p=d=w+1|0;i:for(;;){if(c>>>0<=p>>>0){w=0;break e;}switch(0|je[s+p>>0]){case 13:case 10:w=0;break e;case 93:break i;}p=p+1|0;}var m=p+1|0;if(m>>>0<c>>>0&&58==(0|je[s+m>>0])){w=p+2|0;i:for(;!(c>>>0<=w>>>0);){switch((u=0|je[s+w>>0])<<24>>24){case 13:case 10:h=17;break i;case 32:break;default:break i;}w=w+1|0;}if(17==(0|h)){var _=w+1|0;w=_>>>0<c>>>0&&10==u<<24>>24&&13==(0|je[s+_>>0])?w+2|0:_;}for(;;){if(c>>>0<=w>>>0){w=0;break e;}if(32!=(u=0|je[s+w>>0])<<24>>24)break;w=w+1|0;}w=m=w+(60==u<<24>>24&1)|0;i:for(;!(c>>>0<=w>>>0);){switch(0|je[s+w>>0]){case 13:case 10:case 32:break i;}w=w+1|0;}var y=w+-1|0;y=62==(0|je[s+y>>0])?y:w;i:for(;;){if(c>>>0<=w>>>0){h=31;break;}switch(0|je[s+w>>0]){case 10:case 13:h=31;break i;case 40:case 39:case 34:u=0;break i;case 32:break;default:w=0;break e;}w=w+1|0;}if(31==(0|h)&&(u=w),v=(_=w+1|0)>>>0<c>>>0&&10==(0|je[s+w>>0])&&13==(0|je[s+_>>0])?_:u){for(u=v;!(c>>>0<=(w=u+1|0)>>>0)&&32==(0|je[s+w>>0]);)u=w;_=u+2|0;}i:do{if(_>>>0<c>>>0){switch(0|je[s+w>>0]){case 40:case 34:case 39:break;default:_=c=0,w=v;break i;}u=_;a:for(;;){if(c>>>0<=u>>>0){h=44;break;}switch(w=u+1|0,0|je[s+u>>0]){case 10:case 13:break a;default:u=w;}}44==(0|h)&&(w=u+1|0),w>>>0<c>>>0&&10==(0|je[s+u>>0])&&13==(0|je[s+w>>0])||(w=u);a:for(;;){if((u=u+-1|0)>>>0<=_>>>0){c=_,_=w,w=v;break i;}switch(0|je[s+u>>0]){case 32:break;case 41:case 34:case 39:break a;default:c=_,_=w,w=v;break i;}}c=_,_=u;}else _=c=0,w=v;}while(0);w=(0|y)==(0|m)|0==(0|w)?0:(0|b&&(ze[b>>2]=w),k?(u=k,w=s+d|0,d=p-d|0,u|=0,w|=0,d|=0,(p=0|He(1,16))?(d=0|x(w,d),ze[p>>2]=d,ze[p+12>>2]=ze[(d=u+((7&d)<<2)|0)>>2],ze[d>>2]=p):p=0,(u=0|p)?(k=0|C(w=y-m|0),de(ze[u+4>>2]=k,s+m|0,w),w=_-c|0,c>>>0<_>>>0&&(k=0|C(w),de(ze[u+8>>2]=k,s+c|0,w)),1):0):1);}else w=0;}else w=0;}else w=0;}while(0);if(0|w)l=0|ze[n>>2];else{b=l;e:for(;!(i>>>0<=b>>>0);){switch(0|je[e+b>>0]){case 10:case 13:break e;}b=b+1|0;}if(l>>>0<(ze[n>>2]=b)>>>0){for(s=t,c=e+l|0,l=b-l|0,s|=0,c|=0,l|=0,b=_=0;!(l>>>0<=_>>>0);){for(y=_;;){if(l>>>0<=y>>>0){k=0;break;}if(9==(0|je[c+y>>0])){k=1;break;}y=y+1|0,b=b+1|0;}if(_>>>0<y>>>0&&de(s,c+_|0,y-_|0),!k)break;for(;he(s,32),0!=(3&(b=b+1|0)|0););_=y+1|0;}l=0|ze[n>>2];}else l=b;for(;;){if(i>>>0<=l>>>0)break r;switch(0|je[e+l>>0]){case 10:f=20;break;case 13:(l=l+1|0)>>>0<i>>>0&&10!=(0|je[e+l>>0])&&(f=20);break;default:break r;}20==(0|f)&&(f=0,he(t,10),l=1+(0|ze[n>>2])|0),ze[n>>2]=l;}}}while(0);if(A(r,((l=0|ze[(e=t+4|0)>>2])>>>1)+l|0),(b=0|ze[a+104>>2])&&(De[3&b](r,0|ze[a+112>>2]),l=0|ze[e>>2]),0|l){switch(0|je[(b=0|ze[t>>2])+(l+-1)>>0]){case 13:case 10:break;default:he(t,10),b=0|ze[t>>2],l=0|ze[e>>2];}we(r,a,b,l);}for(0|(l=0|ze[a+108>>2])&&De[3&l](r,0|ze[a+112>>2]),S(t),r=0|o,e=0;8!=(0|e);){for(i=0|ze[r+(e<<2)>>2];i;)a=0|ze[i+12>>2],S(0|ze[i+4>>2]),S(0|ze[i+8>>2]),Me(i),i=a;e=e+1|0;}}Be=n;}function we(r,e,i,a){r|=0,e|=0,i|=0,a|=0;var f=0,n=0,t=0,o=0,l=0,s=0,u=0,c=0,b=0,k=0;r:do{if(((0|ze[e+408>>2])+(0|ze[e+420>>2])|0)>>>0<=(0|ze[e+432>>2])>>>0)for(l=e+12|0,s=e+428|0,u=e+20|0,c=e+112|0,f=0;;){if(a>>>0<=f>>>0)break r;t=i+f|0,o=a-f|0;e:do{if(0|pe(e,t,o)){var v=r,d=e,h=t,w=o;v|=0,d|=0,h|=0,w|=0;var p=0,m=0,_=0,y=0,g=0;for(y=0;y>>>0<w>>>0&y>>>0<6&&35==(0|je[h+y>>0]);)y=y+1|0;for(_=y;!(w>>>0<=_>>>0)&&32==(0|je[h+_>>0]);)_=_+1|0;for(g=_;!(w>>>0<=g>>>0)&&10!=(0|je[h+g>>0]);)g=g+1|0;for(w=g;;){if(!w){w=0;break;}if(35!=(0|je[h+(p=w+-1|0)>>0]))break;w=p;}for(;w;){if(32!=(0|je[h+(p=w+-1|0)>>0])){m=19;break;}w=p;}19==(0|m)&&_>>>0<w>>>0&&(qe(p=0|Te(d,1),d,h+_|0,w-_|0),0|(w=0|ze[d+16>>2])&&Ye[7&w](v,p,y,0|ze[d+112>>2]),Oe(d,1)),f=(0|g)+f|0;}else if(60==(0|je[t>>0])&&0|ze[l>>2]&&0|(b=0|me(r,e,t,o,1)))f=b+f|0;else if(0|(n=0|_e(t,o)))f=n+f|0;else if(0|ye(t,o)){for(0|(n=0|ze[u>>2])&&De[3&n](r,0|ze[c>>2]);!(a>>>0<=f>>>0);){if(n=f+1|0,10==(0|je[i+f>>0])){f=n;break e;}f=n;}f=f+1|0;}else{if(4&(n=0|ze[s>>2])){var A=r,C=e,S=t,R=o;A|=0,C|=0,S|=0,R|=0;var E,I,x,T=0,q=0,O=0,P=0,U=0,M=0,H=0;if(Be=(x=Be)+32|0,ze[(I=(E=x)+16|0)>>2]=0,ze[I+4>>2]=0,ze[I+8>>2]=0,T=(ze[I+12>>2]=0)|xe(S,R,I)){for(H=0|Te(C,0),U=E+4|0;!(R>>>0<=T>>>0);){if(ze[E>>2]=0,ze[E+4>>2]=0,ze[E+8>>2]=0,(ze[E+12>>2]=0)!=(0|(q=0|xe(P=S+T|0,R-T|0,E)))&0==(0|ze[U>>2])){M=12;break;}for(q=T;!(R>>>0<=(O=q+1|0)>>>0)&&10!=(0|je[S+q>>0]);)q=O;T>>>0<=q>>>0&&(0|_e(P,T=O-T|0)?he(H,10):de(H,P,T)),T=O;}12==(0|M)&&(T=q+T|0),0|(M=0|ze[H+4>>2])&&10!=(0|je[(0|ze[H>>2])+(M+-1)>>0])&&he(H,10),0|(q=0|ze[C>>2])&&Ye[7&q](A,H,0==(0|ze[I+4>>2])?0:I,0|ze[C+112>>2]),Oe(C,0);}else T=0;if(Be=x,n=0|T){f=n+f|0;break e;}n=0|ze[s>>2];}var K;if(K=2&n|0){var L=r,j=e,z=t,N=o;L|=0,j|=0,z|=0,N|=0;var B,D,F,Y=0,G=0,X=0,W=0,V=0,Z=0;Be=(F=Be)+16|0,Y=F+4|0,B=(ze[(X=F)>>2]=0)|Te(j,1),D=0|Te(j,0);var $=void 0,J=void 0,Q=void 0,rr=void 0,er=void 0,ir=void 0,ar=B,fr=j,nr=z,tr=N,or=Y,lr=X;ar|=0,fr|=0,nr|=0,tr|=0,or|=0,lr|=0;var sr=0,ur=0,cr=0;for(rr=Q=0;!(tr>>>0<=Q>>>0)&&10!=(ir=0|je[nr+Q>>0])<<24>>24;)Q=Q+1|0,rr=rr+(124==ir<<24>>24&1)|0;i:do{if(0==(0|rr)|(0|Q)==(0|tr))ir=0;else{for(er=Q;;){if(!er){ur=0,er=rr,ir=nr;break;}if(!(0|Pe(0|Ne[(ir=nr+(sr=er+-1|0)|0)>>0]))){cr=9;break;}er=sr;}if(9==(0|cr)&&(ur=er,er=rr+((124==(0|je[nr>>0]))<<31>>31)|0),($=er+((124==(0|je[ir>>0]))<<31>>31)+1|0)>>>0<=(0|ze[fr+436>>2])>>>0){for(J=0|He(ze[or>>2]=$,4),ze[lr>>2]=J,(ir=Q+1|0)>>>0<tr>>>0&&(ir=124==(0|je[nr+ir>>0])?Q+2|0:ir),or=ir;!(tr>>>0<=or>>>0)&&10!=(0|je[nr+or>>0]);)or=or+1|0;for(rr=0;ir>>>0<or>>>0&(er=rr>>>0<$>>>0);){for(;ir>>>0<or>>>0&32==(er=0|je[nr+ir>>0])<<24>>24;)ir=ir+1|0;58==er<<24>>24?(ze[(er=J+(rr<<2)|0)>>2]|=1,ir=ir+(er=1)|0):er=0;a:for(;!(or>>>0<=ir>>>0);){switch(0|je[nr+ir>>0]){case 58:cr=28;break a;case 45:break;default:break a;}er=er+1|0,ir=ir+1|0;}for(28==(0|cr)&&(ze[(cr=J+(rr<<2)|0)>>2]|=2,er=er+1|0,ir=ir+1|0);;){if(or>>>0<=ir>>>0){cr=34;break;}if(32!=(sr=0|je[nr+ir>>0])<<24>>24){cr=33;break;}ir=ir+1|0;}if(33==(0|cr)){if((cr=0)==(0|er)|124!=sr<<24>>24){ir=0;break i;}}else if(34==(0|cr)&&(cr=0)==(0|er)){ir=0;break i;}rr=rr+1|0,ir=ir+1|0;}ir=er?0:(Ue(ar,fr,nr,ur,$,J,4),or+1|0);}else ir=0;}}while(0);if(G=0|ir){for(Z=0|ze[Y>>2],Y=0|ze[X>>2];!(N>>>0<=G>>>0);){for(X=0,W=G;!(N>>>0<=W>>>0)&&10!=(V=0|je[z+W>>0])<<24>>24;)X=X+(124==V<<24>>24&1)|0,W=W+1|0;if((0|W)==(0|N)|0==(0|X))break;Ue(D,j,z+G|0,W-G|0,Z,Y,0),G=W+1|0;}(X=0|ze[j+36>>2])&&Ye[7&X](L,B,D,0|ze[j+112>>2]);}else Y=(G=0)|ze[X>>2];Me(Y),Oe(j,1),Oe(j,0),Be=F,K=0|(k=0|G);}if(K)var br=k+f|0;else{if(0|ge(t,o)){var kr=r,vr=e,dr=t,hr=o;kr|=0,dr|=0,hr|=0;var wr,pr=0,mr=0,_r=0,yr=0,gr=0,Ar=0,Cr=0,Sr=0,Rr=0;wr=0|Te(vr|=0,0),mr=Rr=pr=0;i:for(;;){for(;;){if(hr>>>0<=mr>>>0)break i;for(Cr=mr;;){if(hr>>>0<=(Sr=Cr+1|0)>>>0){_r=0;break;}if(10==(0|je[dr+Cr>>0])){_r=1;break;}Cr=Sr;}if(Ar=0|ge(yr=dr+mr|0,gr=Sr-mr|0))mr=Ar+mr|0;else if(0|_e(yr,gr)){if(!_r){mr=Sr;break i;}if(0==(0|ge(_r=dr+Sr|0,yr=hr-Sr|0))&&0==(0|_e(_r,yr))){mr=Sr;break i;}}if(!(Cr>>>0<mr>>>0))break;mr=Sr;}_r=dr+mr|0,pr?(0|_r)!=(0|(yr=pr+Rr|0))&&Le(0|yr,0|_r,Sr-mr|0):pr=_r,Rr=Sr+Rr-mr|0,mr=Sr;}we(wr,vr,pr,Rr),0|(pr=0|ze[vr+4>>2])&&Fe[7&pr](kr,wr,0|ze[vr+112>>2]),Oe(vr,0);var Er=(0|mr)+f|0;}else{if(0|Ae(t,o)){var Ir=r,xr=e,Tr=t,qr=o;Ir|=0,Tr|=0,qr|=0;var Or,Pr=0,Ur=0,Mr=0,Hr=0,Kr=0,Lr=0,jr=0,zr=0,Nr=0;Or=0|Te(xr|=0,0),Ur=Nr=Pr=0;i:for(;;){for(;;){if(qr>>>0<=Ur>>>0)break i;for(jr=Ur;;){if(qr>>>0<=(zr=jr+1|0)>>>0){Mr=0;break;}if(10==(0|je[Tr+jr>>0])){Mr=1;break;}jr=zr;}if(Lr=0|Ae(Hr=Tr+Ur|0,Kr=zr-Ur|0))Ur=Lr+Ur|0;else if(0|_e(Hr,Kr)){if(!Mr){Ur=zr;break i;}if(0==(0|Ae(Mr=Tr+zr|0,Hr=qr-zr|0))&&0==(0|_e(Mr,Hr))){Ur=zr;break i;}}if(!(jr>>>0<Ur>>>0))break;Ur=zr;}Mr=Tr+Ur|0,Pr?(0|Mr)!=(0|(Hr=Pr+Nr|0))&&Le(0|Hr,0|Mr,zr-Ur|0):Pr=Mr,Nr=zr+Nr-Ur|0,Ur=zr;}we(Or,xr,Pr,Nr),0|(Pr=0|ze[xr+8>>2])&&Fe[7&Pr](Ir,Or,0|ze[xr+112>>2]),Oe(xr,0);var Br=(0|Ur)+f|0;}else{if(0|Ce(t,o)){var Dr=r,Fr=e,Yr=t,Gr=o;Dr|=0,Yr|=0,Gr|=0;var Xr,Wr=0,Vr=0,Zr=0,$r=0,Jr=0,Qr=0;for(Xr=0|Te(Fr|=0,0),Qr=0;!(Gr>>>0<=Qr>>>0);){for($r=Qr;!(Gr>>>0<=(Jr=$r+1|0)>>>0)&&10!=(0|je[Yr+$r>>0]);)$r=Jr;if(Zr=0|Ce(Wr=Yr+Qr|0,Vr=Jr-Qr|0))Wr=Zr+Qr|0;else{if(!(0|_e(Wr,Vr)))break;Wr=Qr;}Wr>>>0<=$r>>>0&&(0|_e(Vr=Yr+Wr|0,Wr=Jr-Wr|0)?he(Xr,10):de(Xr,Vr,Wr)),Qr=Jr;}for(Wr=0|ze[(Vr=Xr+4|0)>>2];Wr&&10==(0|je[(0|ze[Xr>>2])+(Wr=Wr+-1|0)>>0]);)ze[Vr>>2]=Wr;he(Xr,10),0|(Wr=0|ze[Fr>>2])&&Ye[7&Wr](Dr,Xr,0,0|ze[Fr+112>>2]),Oe(Fr,0);var re=(0|Qr)+f|0;}else{if(0|Se(t,o))var ee=(0|Re(r,e,t,o,0))+f|0;else{if(0|Ee(t,o))var ie=(0|Re(r,e,t,o,1))+f|0;else{var ae=r,fe=e,ne=t,te=o;ae|=0,ne|=0,te|=0;var oe,le,se=0,ue=0,ce=0,be=0,ke=0,ve=0;for(oe=428+(fe|=0)|0,le=fe+12|0,se=0;;){if(te>>>0<=se>>>0){ke=0,ve=se;break;}ve=se;do{if(te>>>0<=(ve=(ue=ve)+1|0)>>>0)break;}while(10!=(0|je[ne+ue>>0]));if(0|ge(ce=ne+se|0,ve-se|0)){ke=0,ve=se;break;}if(0|_e(ce,be=te-se|0)){ke=0;break;}if(0|(ue=0|Ie(ce,be))){ke=ue;break;}if(0|pe(fe,ce,be)){ke=0,ve=se;break;}if(0|ye(ce,be)){ke=0,ve=se;break;}if(0|ge(ce,be)){ke=0,ve=se;break;}if(256&(ue=0|ze[oe>>2])|0&&0==(0|Ke(255&(ke=0|je[ce>>0])))){if(0|Ee(ce,be)){ke=0,ve=se;break;}if(0|Se(ce,be)){ke=0,ve=se;break;}if(60==ke<<24>>24&&0!=(0|ze[le>>2])){if(0|me(ae,fe,ce,be,0)){ke=0,ve=se;break;}ue=0|ze[oe>>2];}if(4&ue|0&&0|xe(ce,be,0)){ke=0,ve=se;break;}}se=ve;}for(;;){if(!se){se=ue=0;break;}if(10!=(0|je[ne+(ue=se+-1|0)>>0])){ue=1;break;}se=ue;}if(ke){i:do{if(ue){for(be=se;;){if(!(ue=be+-1|0)){ue=0;break;}if(10==(0|je[ne+ue>>0]))break;be=ue;}for(;;){if(!ue)break i;if(10!=(0|je[ne+(ce=ue+-1|0)>>0]))break;ue=ce;}qe(ce=0|Te(fe,0),fe,ne,ue),0|(ue=0|ze[fe+32>>2])&&Fe[7&ue](ae,ce,0|ze[fe+112>>2]),Oe(fe,0),ne=ne+be|0,se=se-be|0;}else se=0;}while(0);qe(ue=0|Te(fe,1),fe,ne,se),0|(se=0|ze[fe+16>>2])&&Ye[7&se](ae,ue,ke,0|ze[fe+112>>2]),Oe(fe,1);}else qe(ue=0|Te(fe,0),fe,ne,se),0|(se=0|ze[fe+32>>2])&&Fe[7&se](ae,ue,0|ze[fe+112>>2]),Oe(fe,0);ie=(0|ve)+f|0;}ee=ie;}re=ee;}Br=re;}Er=Br;}br=Er;}f=br;}}while(0);}}while(0);}function pe(r,e,i){r|=0,e|=0,i|=0;var a,f=0;do{if(35==(0|je[e>>0])){if(64&ze[r+428>>2]){for(a=0;;){var n=a>>>0<i>>>0;if(!(n&a>>>0<6)){r=7;break;}if(35!=(r=0|je[e+a>>0])<<24>>24){f=r,r=9;break;}a=a+1|0;}if(7==(0|r)&&n&&(f=0|je[e+a>>0],r=9),9==(0|r)&&32!=f<<24>>24){r=0;break;}}r=1;}else r=0;}while(0);return 0|r;}function me(r,e,i,a,f){r|=0,e|=0,a|=0,f|=0;var n=0,t=0,o=0,l=0,s=0,u=Be;Be=Be+16|0,ze[u>>2]=i|=0;var c=u+4|0;ze[c>>2]=0,ze[u+8>>2]=0,ze[u+12>>2]=0;r:do{if(2<=a>>>0&&60==(0|je[i>>0])){var b,k=1;e:for(;!(a>>>0<=k>>>0);){switch(0|je[i+k>>0]){case 32:case 62:l=7;break e;}k=k+1|0;}if(b=7==(0|l)){b=i+1|0;var v=k+-1|0;b|=0,v|=0;var d=0;do{if((v+-1|0)>>>0<10){var h=b,w=v;if(h|=0,(h=(w=1==(0|(w|=0))?1:(0|Ne[1+(0|Ne[h+1>>0])+320>>0])+w|0)+(0|Ne[320+(0|Ne[h>>0])>>0])|0)>>>0<38&&0==(-33&(je[(d=0|ze[160+(h<<2)>>2])>>0]^je[b>>0]))<<24>>24&&0==(0|W(b,d,v))&&0==(0|je[d+v>>0]))break;}d=0;}while(0);b=0|(n=0|d);}if(b){if(!(k=0|q(n,i,a,1))){if(!(0|D(n,5693))){k=0;break;}if(!(0|D(n,5615))){k=0;break;}if(!(k=0|q(n,i,a,0))){k=0;break;}}ze[c>>2]=k,f&&(n=0|ze[e+12>>2])&&Fe[7&n](r,u,0|ze[e+112>>2]);}else{if(5<a>>>0){if(33==(k=0|je[i+1>>0])<<24>>24){if(45!=(0|je[i+2>>0])){k=0;break;}if(45!=(0|je[i+3>>0])){k=0;break;}for(k=5;;){if(a>>>0<=k>>>0){l=19;break;}if(45==(0|je[i+(k+-2)>>0])&&45==(0|je[i+(k+-1)>>0])){if(n=k+1|0,62==(0|je[i+k>>0])){k=n;break;}k=n;}else k=k+1|0;}if(19==(0|l)&&(k=k+1|0),k>>>0<a>>>0&&0!=(0|(t=0|_e(i+k|0,a-k|0)))){if(ze[c>>2]=k=t+k|0,!f)break;if(!(n=0|ze[e+12>>2]))break;Fe[7&n](r,u,0|ze[e+112>>2]),k=0|ze[c>>2];break;}l=25;}}else l=25;if(25==(0|l)){if(a>>>0<=4){k=0;break;}k=0|je[i+1>>0];}switch(k<<24>>24){case 72:case 104:break;default:k=0;break r;}switch(0|je[i+2>>0]){case 82:case 114:break;default:k=0;break r;}for(n=3;;){if(a>>>0<=n>>>0){l=31;break;}if(k=n+1|0,62==(0|je[i+n>>0]))break;n=k;}31==(0|l)&&(k=n+1|0),k>>>0<a>>>0&&0!=(0|(o=0|_e(i+k|0,a-k|0)))?(ze[c>>2]=k=o+k|0,0!=(0|f)&&0!=(0|(s=0|ze[e+12>>2]))&&(Fe[7&s](r,u,0|ze[e+112>>2]),k=0|ze[c>>2])):k=0;}}else k=0;}while(0);return Be=u,0|k;}function _e(r,e){r|=0,e|=0;var i=0,a=0;r:for(;;){if(e>>>0<=a>>>0){i=5;break;}switch(0|je[r+a>>0]){case 10:i=5;break r;case 32:break;default:a=0;break r;}a=a+1|0;}return 5==(0|i)&&(a=a+1|0),0|a;}function ye(r,e){var i;r|=0,e|=0;r:do{if(3<=e>>>0){var a=32==(0|je[r>>0])?32==(0|je[r+1>>0])?32==(0|je[r+2>>0])?3:2:1:0;if((a+2|0)>>>0<e>>>0){var f=0|je[r+a>>0];switch(f<<24>>24){case 95:case 45:case 42:break;default:a=0;break r;}for(i=0;!(e>>>0<=a>>>0);){var n=0|je[r+a>>0];if(10==n<<24>>24)break;if(n<<24>>24!=f<<24>>24){if(32!=n<<24>>24){a=0;break r;}}else i=i+1|0;a=a+1|0;}a=2<i>>>0&1;}else a=0;}else a=0;}while(0);return 0|a;}function ge(r,e){r|=0;var i=0,a=0,f=(e|=0)?32==(0|je[r>>0])&1:0;f>>>0<e>>>0&&(f=f+(32==(0|je[r+f>>0])&1)|0),f>>>0<e>>>0&&(f=f+(32==(0|je[r+f>>0])&1)|0);r:do{if(f>>>0<e>>>0&&62==(0|je[r+f>>0])&&(i=f+1|0)>>>0<e>>>0){switch(0|je[r+i>>0]){case 33:a=12;break r;case 32:break;default:break r;}i=f+2|0;}else a=12;}while(0);return 12==(0|a)&&(i=0),0|i;}function Ae(r,e){r|=0;var i=0,a=(e|=0)?32==(0|je[r>>0])&1:0;a>>>0<e>>>0&&(a=a+(32==(0|je[r+a>>0])&1)|0);var f=a>>>0<e>>>0?a+(32==(0|je[r+a>>0])&1)|0:a;if((a=f+1|0)>>>0<e>>>0&&62==(0|je[(i=r+f|0)>>0])&&33==(0|je[r+a>>0])){if(0!=(0|(a=0|T(i+1|0,e+-1-f|0,60)))&(i=a+f|0)>>>0<e>>>0&&33==(0|je[r+i>>0]))a=0;else if((a=f+2|0)>>>0<e>>>0)return 0|(32==(0|je[r+a>>0])?f+3|0:a);}else a=0;return 0|a;}function Ce(r,e){return r|=0,0|(3<(0|e)>>>0&&32==(0|je[r>>0])&&32==(0|je[r+1>>0])&&32==(0|je[r+2>>0])&&32==(0|je[r+3>>0])?4:0);}function Se(r,e){r|=0;var i=(e|=0)?32==(0|je[r>>0])&1:0;i>>>0<e>>>0&&(i=i+(32==(0|je[r+i>>0])&1)|0),i>>>0<e>>>0&&(i=i+(32==(0|je[r+i>>0])&1)|0);var a=i+1|0;r:do{if(a>>>0<e>>>0){var f=r+i|0;switch(0|je[f>>0]){case 45:case 43:case 42:break;default:break r;}if(32==(0|je[r+a>>0]))return 0|((e=0==(0|s(f,e-i|0)))?i+2|0:0);}}while(0);return 0;}function Re(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0;var n=Be;Be=Be+16|0,ze[n>>2]=0|f;var t=0|Te(e,0);f=0;do{if(a>>>0<=f>>>0)break;var o=t,l=e,s=i+f|0,u=a-f|0,c=n;o|=0,l|=0,s|=0,u|=0,c|=0;var b,k,v,d,h,w,p,m=0,_=0;for(p=0;p>>>0<3&p>>>0<u>>>0&&32==(0|je[s+p>>0]);)p=p+1|0;if((b=0|Se(s,u))?(m=b,_=7):(b=0|Ee(s,u))?(m=b,_=7):b=0,7==(0|_)){for(b=m;!(u>>>0<=b>>>0)&&10!=(0|je[s+(b+-1)>>0]);)b=b+1|0;var y=0|Te(l,1),g=0|Te(l,1);de(y,s+m|0,b-m|0);var A=l+428|0,C=y+4|0,S=k=d=0;r:for(;;){for(h=0;;){if(u>>>0<=b>>>0)break r;for(v=b;;){var R=v+1|0;if(u>>>0<=R>>>0)break;if(10==(0|je[s+v>>0]))break;v=R;}var E=s+b|0,I=R-b|0;if(!(0|_e(E,I)))break;h=1,b=R;}for(w=0;!(4<=w>>>0||v>>>0<(m=w+b|0)>>>0||32!=(0|je[s+m>>0]));)w=w+1|0;var x=E+w|0,T=I-w|0,q=4&ze[A>>2]?(q=0==(0|xe(x,T,0)))?d:0==(0|d)&1:d;if(q?E=v=0:(E=0|Se(x,T),v=0|Ee(x,T)),I=0!=(0|h)){if(0!=(0|E)&0!=(0|(m=1&(d=0|ze[c>>2])))){_=30;break;}if(0!=(0|v)&0==(0|m)){_=30;break;}}if(34==(0|(_=E?0!=(0|v)|0==(0|ye(x,T))?34:37:v?34:37))){if(k=I?1:k,((_=0)|w)==(0|p))break;b=S||0|ze[C>>2];}else if(37==(0|_)){if(I&(_=0)==(0|w)){_=38;break;}I?(he(y,10),b=S,k=1):b=S;}de(y,x,T),d=q,S=b,b=R;}30==(0|_)?ze[c>>2]=8|d:38==(0|_)&&(ze[c>>2]|=8),m=0|ze[c>>2],k&&(ze[c>>2]=m|=2),E=0!=(0|S)&S>>>0<(k=0|ze[C>>2])>>>0,v=0|ze[y>>2],2&m?E?(we(g,l,v,S),we(g,l,(0|ze[y>>2])+S|0,(0|ze[C>>2])-S|0)):we(g,l,v,k):E?(qe(g,l,v,S),we(g,l,(0|ze[y>>2])+S|0,(0|ze[C>>2])-S|0)):qe(g,l,v,k),0|(m=0|ze[l+28>>2])&&Ye[7&m](o,g,0|ze[c>>2],0|ze[l+112>>2]),Oe(l,1),Oe(l,1);}if(f=(o=0|b)+f|0,!o)break;}while(0==(8&ze[n>>2]|0));return 0|(i=0|ze[e+24>>2])&&Ye[7&i](r,t,0|ze[n>>2],0|ze[e+112>>2]),Oe(e,0),Be=n,0|f;}function Ee(r,e){r|=0;var i=0,a=0,f=0,n=(e|=0)?32==(0|je[r>>0])&1:0;if(n>>>0<e>>>0&&(n=n+(32==(0|je[r+n>>0])&1)|0),n>>>0<e>>>0&&(n=n+(32==(0|je[r+n>>0])&1)|0),n>>>0<e>>>0&&((0|je[r+n>>0])-48&255)<=9){for(;;){if(e>>>0<=n>>>0){f=11;break;}if(i=n+1|0,!(((0|je[r+n>>0])-48&255)<10))break;n=i;}if(11==(0|f)&&(i=n+1|0),i>>>0<e>>>0&&46==(0|je[(a=r+n|0)>>0])&&32==(0|je[r+i>>0]))return 0|((f=0==(0|s(a,e-n|0)))?n+2|0:0);}return 0;}function Ie(r,e){var i;r|=0,e|=0;r:do{switch(0|je[r>>0]){case 61:for(i=1;!(e>>>0<=i>>>0)&&61==(0|je[r+i>>0]);)i=i+1|0;for(;;){if(e>>>0<=i>>>0){i=1;break r;}var a=0|je[r+i>>0];if(32!=a<<24>>24)break;i=i+1|0;}i=10==a<<24>>24&1;break;case 45:for(i=1;!(e>>>0<=i>>>0)&&45==(0|je[r+i>>0]);)i=i+1|0;for(;;){if(e>>>0<=i>>>0){i=2;break r;}if(32!=(a=0|je[r+i>>0])<<24>>24)break;i=i+1|0;}i=10==a<<24>>24?2:0;break;default:i=0;}}while(0);return 0|i;}function xe(r,e,i){i|=0;var a,f=0,n=0|(r|=0),t=0|(e|=0);r:{if(3<=t>>>0){var o=32==(0|je[n>>0])?32==(0|je[n+1>>0])?32==(0|je[n+2>>0])?3:2:1:0;if((o+2|0)>>>0<t>>>0){var l=0|je[n+o>>0];switch(l<<24>>24){case 96:case 126:break;default:o=0;break r;}for(a=0;!(t>>>0<=o>>>0)&&(0|je[n+o>>0])==l<<24>>24;)a=a+1|0,o=o+1|0;o=a>>>0<3?0:o;}else o=0;}else o=0;}n=0|o;r:do{if(n){e:for(;;){if(o=r+n|0,e>>>0<=n>>>0){t=6;break;}switch(0|je[o>>0]){case 123:t=5;break e;case 32:break;default:t=6;break e;}n=n+1|0;}e:do{if(5==(0|t)){t=0;i:for(;!(e>>>0<=(f=n+1|0)>>>0);){switch(0|je[r+f>>0]){case 10:case 125:break i;}t=t+1|0,n=f;}if((0|f)==(0|e)){n=0;break r;}if(125!=(0|je[r+f>>0])){n=0;break r;}for(f=t,t=o;;){if(o=t+1|0,!f){f=0;break;}if(!(0|Pe(0|Ne[o>>0])))break;f=f+-1|0,t=o;}for(;;){if(!f){f=0;break;}if(!(0|Pe(0|Ne[t+f>>0])))break;f=f+-1|0;}n=n+2|0;}else if(6==(0|t))for(f=0;;){if(e>>>0<=n>>>0)break e;if(0|Pe(0|Ne[r+n>>0]))break e;n=n+1|0,f=f+1|0;}}while(0);for(0|i&&(ze[i>>2]=o,ze[i+4>>2]=f);!(e>>>0<=n>>>0)&&10!=(f=0|je[r+n>>0])<<24>>24;){if(!(0|Pe(255&f))){n=0;break r;}n=n+1|0;}n=n+1|0;}else n=0;}while(0);return 0|n;}function Te(r,e){var i=0,a=404+(r|=0)+(12*(e|=0)|0)|0,f=r+404+(12*e|0)+4|0,n=0|ze[f>>2];return n>>>0<(0|ze[r+404+(12*e|0)+8>>2])>>>0&&0!=(0|(i=0|ze[(0|ze[a>>2])+(n<<2)>>2]))?(ze[f>>2]=n+1,ze[i+4>>2]=0):(e=0|(i=0|C(0|ze[5120+(e<<2)>>2])),0<=(0|u(r=0|a,ze[(a=r+4|0)>>2]<<1))&&(f=0|ze[r>>2],ze[a>>2]=1+(r=0|ze[a>>2]),ze[f+(r<<2)>>2]=e)),0|i;}function qe(r,e,i,a){var f,n,t,o;r|=0,e|=0,i|=0,a|=0;var l=Be;Be=Be+16|0,ze[l>>2]=0,ze[l+4>>2]=0,ze[l+8>>2]=0,ze[l+12>>2]=0;r:do{if(((0|ze[e+408>>2])+(0|ze[e+420>>2])|0)>>>0<=(0|ze[e+432>>2])>>>0){var s=e+100|0,c=e+112|0;for(o=n=t=f=0;;){if(a>>>0<=o>>>0)break r;for(;;){if(a>>>0<=n>>>0){var b=0;break;}if((f=0|je[(0|Ne[i+n>>0])+(e+148)>>0])<<24>>24){b=1;break;}n=n+1|(f=0);}var k=0|ze[s>>2],v=i+o|0;if(k?(ze[l>>2]=v,ze[(l+4|0)>>2]=n-o,Fe[7&k](r,l,0|ze[c>>2])):de(r,v,n-o|0),!b)break r;v=0==(0|(o=0|gr[15&ze[592+((255&f)<<2)>>2]](r,e,i+n|0,n-t|0,n,a-n|0))),o=o+n|0,t=v?t:o,n=v?n+1|0:o;}}}while(0);Be=l;}function Oe(r,e){ze[(e=404+(0|r)+(12*(0|e)|0)+4|0)>>2]=(0|ze[e>>2])-1;}function Pe(r){return 1&(32==(0|(r|=0))|10==(0|r))|0;}function _(r,e){var i,a;r|=0;var f=4+(e|=0)|0;for(i=0;;){var n=0|ze[f>>2];if(n>>>0<=i>>>0)break;for(a=i;!(n>>>0<=a>>>0)&&92!=(0|je[(0|ze[e>>2])+a>>0]);)a=a+1|0;if(i>>>0<a>>>0&&(de(r,(0|ze[e>>2])+i|0,a-i|0),n=0|ze[f>>2]),n>>>0<=(i=a+1|0)>>>0)break;he(r,0|Ne[(0|ze[e>>2])+i>>0]),i=a+2|0;}}function I(r,e,i){for(e=(0|r)+((7&(i=0|x(0|e,0|i)))<<2)|0;;){if(!(e=0|ze[e>>2])){e=0;break;}if((0|ze[e>>2])==(0|i))break;e=e+12|0;}return 0|e;}function x(r,e){var i,a;for(r|=0,e|=0,a=i=0;(0|a)!=(0|e);)i=(65599*i|0)+(0|j(0|Ne[r+a>>0]))|0,a=a+1|0;return 0|i;}function p(r,e,i,a,f){var n;r|=0,i|=0,a|=0,f|=0;var t=64+(e|=0)|0;r:do{if(0|ze[t>>2]){var o=1<a>>>0&&(0|je[i>>0])==f<<24>>24?(0|je[i+1>>0])==f<<24>>24&1:0,l=e+428|0;for(n=95!=f<<24>>24;;){if(a>>>0<=o>>>0){o=0;break r;}var s=0|T(i+o|0,a-o|0,f);if(!s){o=0;break r;}if(a>>>0<=(o=s+o|0)>>>0){o=0;break r;}if((0|je[i+o>>0])==f<<24>>24&&0==(0|Pe(0|Ne[i+(o+-1)>>0]))){if(0==(1&ze[l>>2]|0)|n|(0|(s=o+1|0))==(0|a))break;var u=0|Ne[i+s>>0];if(0|Pe(u))break;if(0|G(u))break;}}qe(f=0|Te(e,1),e,i,o),o=0|mr[15&ze[t>>2]](r,f,0|ze[e+112>>2]),Oe(e,1),o=0==(0|o)?0:s;}else o=0;}while(0);return 0|o;}function m(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0;var n=0|ze[(126==(f|=0)<<24>>24?e+88|0:e+60|0)>>2];r:do{if(n){var t=0;do{if(a>>>0<=t>>>0){t=0;break r;}var o=0|T(i+t|0,a-t|0,f);if(!o){t=0;break r;}t=1+(o=o+t|0)|0;}while(!(t>>>0<a>>>0&&(0|je[i+o>>0])==f<<24>>24&&0|o&&(0|je[i+t>>0])==f<<24>>24&&0==(0|Pe(0|Ne[i+(o+-1)>>0]))));qe(t=0|Te(e,1),e,i,o),t=0|mr[15&n](r,t,0|ze[e+112>>2]),Oe(e,1),t=0==(0|t)?0:o+2|0;}else t=0;}while(0);return 0|t;}function T(r,e,i){r|=0,e|=0;var a,f=0,n=60==(i|=0)<<24>>24,t=1,o=0;r:for(;;){var l=t;e:for(;;){for(;;){if(e>>>0<=l>>>0){l=0;break r;}i:for(;;){if(e>>>0<=l>>>0){t=0;break;}if((t=0|je[r+l>>0])<<24>>24==i<<24>>24){t=1;break;}switch(t<<24>>24){case 91:case 96:t=1;break i;}l=l+1|0;}if((0|l)==(0|e)){l=0;break r;}var s=0|je[r+l>>0];if(n&t&60==s<<24>>24){if(33==(0|je[r+(l+-1)>>0]))break r;s=60;}if(s<<24>>24==i<<24>>24)break r;if(!l){t=0;break;}if(92!=(0|je[r+(l+-1)>>0])){t=l;break;}l=l+1|0;}switch(s<<24>>24){case 91:break e;case 96:for(f=0;;){if(e>>>0<=t>>>0){l=0;break r;}if(96!=(0|je[r+t>>0]))break;f=f+1|0,t=t+1|0;}for(a=l=0;(s=t>>>0<e>>>0)&a>>>0<f>>>0;)s=0|je[r+t>>0],l=0==(0|l)?s<<24>>24==i<<24>>24?t:0:l,a=96==s<<24>>24?a+1|0:0,t=t+1|0;if(!s)break r;l=t;break;default:l=t;}}for(l=0;!(e>>>0<=(s=t+1|0)>>>0)&&93!=(a=0|je[r+s>>0])<<24>>24;)l=0==(0|l)&&a<<24>>24==i<<24>>24?s:l,t=s;t=t+2|0;e:for(;;){if(e>>>0<=t>>>0)break r;switch(0|je[r+t>>0]){case 91:f=93,s=36;break e;case 40:s=35;break e;case 10:case 32:break;default:s=41;break e;}t=t+1|0;}if(35==(0|s))f=41,s=36;else if(41==(0|s)&&(l=(f=(s=0)==(0|l))?o:l,!f))break;if(36==(0|s)){for(;;){if(e>>>0<=(s=t+1|0)>>>0)break r;if((0|f)==(255&(a=0|je[r+s>>0])|0))break;l=0==(0|l)&&a<<24>>24==i<<24>>24?s:l,t=s;}l=o,t=t+2|0;}o=l;}return 0|l;}function s(r,e){r|=0,e|=0;var i,a=0,f=0;for(i=0;;){if(e>>>0<=i>>>0){f=3;break;}if(a=i+1|0,10==(0|je[r+i>>0]))break;i=a;}return 3==(0|f)&&(a=i+1|0),0|(a>>>0<e>>>0?0|Ie(r+a|0,e-a|0):0);}function Ue(r,e,i,a,f,n,t){r|=0,i|=0,a|=0,f|=0,n|=0,t|=0;var o,l,s,u,c=0,b=Be;Be=Be+16|0;var k=44+(e|=0)|0;if(0|ze[k>>2]&&0|ze[(c=e+40|0)>>2]){var v=0|Te(e,1),d=a?124==(0|je[i>>0])&1:0,h=e+112|0;for(u=0;u>>>0<f>>>0&d>>>0<a>>>0;){for(s=0|Te(e,1);!(a>>>0<=d>>>0)&&0|Pe(0|Ne[i+d>>0]);)d=d+1|0;for(l=d;!(a>>>0<=l>>>0)&&124!=(0|je[i+l>>0]);)l=l+1|0;for(o=l;;){var w=o+-1|0;if(w>>>0<=d>>>0)break;if(!(0|Pe(0|Ne[i+w>>0])))break;o=w;}qe(s,e,i+d|0,o-d|0),Ar[1&ze[k>>2]](v,s,ze[n+(u<<2)>>2]|t,0|ze[h>>2],0),Oe(e,1),u=u+1|0,d=l+1|0;}0|(d=f-u|0)&&(ze[b>>2]=0,ze[b+4>>2]=0,ze[b+8>>2]=0,ze[b+12>>2]=0,Ar[1&ze[k>>2]](v,b,ze[n+(u<<2)>>2]|t,0|ze[h>>2],d)),Fe[7&ze[c>>2]](r,v,0|ze[h>>2]),Oe(e,1);}Be=b;}function q(r,e,i,a){e|=0,i|=0;var f,n=0,t=0,o=0,l=0|X(r|=0),s=0!=(0|a),c=i+1|0;for(a=0,f=1;;){if(i>>>0<=f>>>0){a=0;break;}for(t=f;!(i>>>0<=(f=t+1|0)>>>0||47==(n=0|je[e+f>>0])<<24>>24&&60==(0|je[e+t>>0]));)a=a+(10==n<<24>>24&1)|0,t=f;if(!(s&0<(0|a)&&10!=(0|je[e+(t+-1)>>0]))){if(i>>>0<=((l+3|0)+t|0)>>>0){a=0;break;}n=r;var b=l,k=e+t|0,v=c+~t|0;k|=0;var d=0,h=3+(b|=0)|0;if(n=h>>>0<(v|=0)>>>0&&0==(0|W(k+2|0,0|n,b))&&62==(0|je[k+(b+2)>>0])&&0!=(0|(d=0|_e(k+h|0,v-h|0)))?(n=(b=d+h|0)>>>0<v>>>0?0|_e(k+b|0,v-b|0):0)+b|0:0,0|(n|=0)){o=12;break;}}}return 12==(0|o)&&(a=n+t|0),0|a;}function u(r,e){var i,a=8+(r|=0)|0;if((0|ze[a>>2])>>>0<(e|=0)>>>0){if(i=0|L(0|ze[r>>2],e<<2)){var f=0|ze[a>>2];fr(i+(f<<2)|0,0,e-f<<2|0),ze[r>>2]=i,(ze[a>>2]=e)>>>0<(0|ze[(r=r+4|0)>>2])>>>0&&(ze[r>>2]=e),r=0;}else r=-1;}else r=0;return 0|r;}function c(r,e){ze[(r|=0)>>2]=0,ze[r+4>>2]=0,u(r,(ze[r+8>>2]=0)|e);}function d(r,e,i){var a,f;e|=0;var n=Be;Be=Be+16|0,A(r|=0,((12*(i|=0)|0)>>>0)/10|0),je[n>>0]=37;for(a=0;!(i>>>0<=a>>>0);){for(f=a;;){if(i>>>0<=f>>>0){var l=0;break;}if(1!=(0|je[656+(0|Ne[e+f>>0])>>0])){l=1;break;}f=f+1|0;}if(a>>>0<f>>>0&&de(r,e+a|0,f-a|0),!l)break;l=255&(a=0|je[e+f>>0]);r:do{if(2!=(0|je[656+l>>0]))switch(a<<24>>24){case 38:de(r,6531,5);break r;case 39:de(r,5743,6);break r;default:je[(n+1|0)>>0]=0|je[912+(l>>>4)>>0],je[(n+2|0)>>0]=0|je[912+(15&a)>>0],de(r,n,3);break r;}}while(0);a=f+1|0;}Be=n;}function O(r,e,i){var a,f;r|=0,e|=0,i|=0;r:do{if(3<=e>>>0&&60==(0|je[r>>0])){for(a=f=47==(0|je[r+1>>0])?2:1;!(e>>>0<=a>>>0);){var n=0|je[i>>0];if(!(n<<24>>24))break;if((0|Ne[r+a>>0])!=(n<<24>>24|0))break r;i=i+1|0,a=a+1|0;}if((0|a)!=(0|e))return 0|((e=62==(e=0|je[r+a>>0])<<24>>24|0!=(0|B(255&e)))?f:0);}}while(0);return 0;}function n(r,e){ze[(e|=0)>>2]=0,ze[e+4>>2]=0,ze[e+8>>2]=0;}function P(r,e,i){e|=0;var a,f,n,t=0,o=0;for(A(r|=0,((12*(i|=0)|0)>>>0)/10|0),f=a=0;!(i>>>0<=f>>>0);){for(n=f;;){if(i>>>0<=n>>>0){t=0;break;}if((a=0|je[944+(0|Ne[e+n>>0])>>0])<<24>>24){o=7;break;}n=n+1|(a=0);}if(7==(0|o)&&(o=0,a=a<<24>>24,t=1),f>>>0<n>>>0&&de(r,e+f|0,n-f|0),!t)break;47!=(t=0|je[e+n>>0])<<24>>24?7!=(0|je[944+(255&t)>>0])&&y(r,0|ze[1200+(a<<2)>>2]):he(r,47),f=n+1|0;}}function w(r,e){return y(0|r,0==(256&ze[16+(0|e)>>2]|0)?6054:6060),1;}function U(r){var e=0,i=0,a=0;if(!(r|=0))return 0;var f=8<r>>>0?r:8,n=31-(0|ur(0|f))|0;n=(0==(0|f)?1:n)+(1!=(0|ir(0|r))&1)|0;r:{if(3<n>>>0&r>>>0<1<<n>>>0&&0!=(0|(e=0|ze[8400+(n+-1<<2)>>2]))){for(f=0;!(r>>>0<=(((0|ze[e+-8>>2])>>>1)-8|0)>>>0);)if(!((f=f+1|0)>>>0<32&0!=(0|(e=0|ze[e+4>>2])))){i=8;break r;}n=0|M(e,r);}else i=8;}r:do{if(8==(0|i)){e:do{if(n>>>0<32){for(;e=0|ze[8400+(n<<2)>>2],n=n+1|0,!(0|e);)if(32<=n>>>0)break e;n=0|M(e,r);break r;}}while(0);if(0|(n=0|ze[2287])&&0==(1&(a=0|ze[n>>2])|0)){if(ze[n>>2]=1|a,e=31-(0|ur(0|(f=8<(f=(a>>>1)-8|0)>>>0?f:8)))|0,e=8400+((0==(0|f)?1:e)<<2)|0,f=n+12|0,(0|ze[e>>2])==(0|(i=n+8|0))&&(ze[e>>2]=ze[f>>2]),0|(n=0|ze[i>>2])&&(ze[n+4>>2]=ze[f>>2]),0|(n=0|ze[f>>2])&&(ze[n>>2]=ze[i>>2]),r=0==(0|H(r)),n=0|ze[2287],r)return ze[n>>2]&=-2,(r=0)|r;if(n)break;return(n=0)|n;}if(-1==(0|(e=0|nr(0|(i=r+15&-8)))))return(r=0)|r;if((0|(f=e))!=(0|(a=n=f+7&-8))&&-1==(0|nr(n-f|0)))return(r=0)|r;(e=0|ze[2287])?ze[n+4>>2]=e:ze[2286]=a,ze[2287]=a,ze[n>>2]=i<<1|1;}}while(0);return n+8|0;}function M(r,e){e|=0;var i=(r|=0)-8|0,a=((0|ze[i>>2])>>>1)-8|0,f=31-(0|ur(0|(a=8<a>>>0?a:8)))|0;if(f=8400+((0==(0|a)?1:f)<<2)|0,a=r+4|0,(0|ze[f>>2])==(0|r)&&(ze[f>>2]=ze[a>>2]),0|(f=0|ze[r>>2])&&(ze[f+4>>2]=ze[a>>2]),0|(f=0|ze[a>>2])&&(ze[f>>2]=ze[r>>2]),ze[i>>2]=1|(a=0|ze[i>>2]),(0|ze[2287])==(0|i)&8==(-8&(f=(a>>>=1)+(-8-e)|0)|0)){if(!(0|H(a)))return 0|i;f=f+8|0;}return f>>>0<=15||(e=a=r=r+e+7&-8,ze[i>>2]=1&(f=0|ze[i>>2])|r-i<<1,ze[e>>2]=(r=i+(f>>>1)-r|0)<<1|1&ze[e>>2],ze[e+4>>2]=i,ze[((0|ze[2287])==(0|i)?9148:a+(2147483647&r)+4|0)>>2]=a,K(e)),0|i;}function H(r){var e=(15+(0|r)&-8)-((0|ze[ze[2287]>>2])>>>1)|0;if(-1==(0|nr(0|e)))return 0;var i=0|ze[2287];if(!(1&(r=0|ze[i>>2]))){var a=(r>>>1)-8|0;r=31-(0|ur(0|(a=8<a>>>0?a:8)))|0;var f=i+8|0;r=8400+((0==(0|a)?1:r)<<2)|0,a=i+12|0,(0|ze[r>>2])==(0|f)&&(ze[r>>2]=ze[a>>2]),0|(r=0|ze[f>>2])&&(ze[r+4>>2]=ze[a>>2]),0|(r=0|ze[a>>2])&&(ze[r>>2]=ze[f>>2]);}return 1&(ze[i>>2]=r=(0|ze[i>>2])+(e<<1)|0)|0||(e=31-(0|ur(0|(a=8<(a=(r>>>1)-8|0)>>>0?a:8)))|0,a=0|ze[(e=8400+((0==(0|a)?1:e)<<2)|0)>>2],ze[e>>2]=r=i+8|0,ze[r>>2]=0,(ze[i+12>>2]=a)&&(ze[a>>2]=r)),1;}function K(r){var e=0,i=0,a=0,f=0|ze[(r|=0)>>2];ze[r>>2]=-2&f;var n=0|ze[r+4>>2],t=0|ze[2287],o=(0|t)==(0|r),l=r+(f>>>=1)|0,s=o?0:l;if(l=o?0:l,0|n&&0==(1&(e=0|ze[n>>2])|0)){e=31-(0|ur(0|(o=8<(o=(e>>>1)-8|0)>>>0?o:8)))|0;var u=n+8|0;e=8400+((0==(0|o)?1:e)<<2)|0,o=n+12|0,(0|ze[e>>2])==(0|u)&&(ze[e>>2]=ze[o>>2]),0|(e=0|ze[u>>2])&&(ze[e+4>>2]=ze[o>>2]),0|(e=0|ze[o>>2])&&(ze[e>>2]=ze[u>>2]),ze[n>>2]=(0|ze[n>>2])+(-2&ze[r>>2]),l?(ze[l+4>>2]=n,1&(e=0|ze[l>>2])||(e=31-(0|ur(0|(f=8<(f=(e>>>1)-8|0)>>>0?f:8)))|0,e=8400+((0==(0|f)?1:e)<<2)|0,f=l+12|0,(0|ze[e>>2])==(0|(i=l+8|0))&&(ze[e>>2]=ze[f>>2]),0|(e=0|ze[i>>2])&&(ze[e+4>>2]=ze[f>>2]),(e=0|ze[f>>2])&&(ze[e>>2]=ze[i>>2],t=0|ze[2287]),ze[n>>2]=(0|ze[n>>2])+(-2&ze[l>>2]),e=(0|l)==(0|t)?9148:s+((0|ze[l>>2])>>>1)+4|0,a=19)):(e=9148,a=19),19==(0|a)&&(ze[e>>2]=n),l=31-(0|ur(0|(e=8<(e=((0|ze[n>>2])>>>1)-8|0)>>>0?e:8)))|0,e=0|ze[(l=8400+((0==(0|e)?1:l)<<2)|0)>>2],ze[l>>2]=u,ze[u>>2]=0,(ze[o>>2]=e)&&(ze[e>>2]=u);}else t=0|l&&0==(1&(i=0|ze[l>>2])|0)?(e=31-(0|ur(0|(f=8<(f=(i>>>1)-8|0)>>>0?f:8)))|0,e=8400+((0==(0|f)?1:e)<<2)|0,f=l+12|0,(0|ze[e>>2])==(0|(i=l+8|0))&&(ze[e>>2]=ze[f>>2]),0|(e=0|ze[i>>2])&&(ze[e+4>>2]=ze[f>>2]),(e=0|ze[f>>2])&&(ze[e>>2]=ze[i>>2],t=0|ze[2287]),ze[r>>2]=e=(0|ze[r>>2])+(-2&ze[l>>2])|0,(0|l)==(0|t)?ze[2287]=r:(ze[s+((0|ze[l>>2])>>>1)+4>>2]=r,e=0|ze[r>>2]),(e>>>1)-8|0):f+-8|0,l=31-(0|ur(0|(t=8<t>>>0?t:8)))|0,t=0|ze[(l=8400+((0==(0|t)?1:l)<<2)|0)>>2],ze[l>>2]=e=r+8|0,ze[e>>2]=0,(ze[r+12>>2]=t)&&(ze[t>>2]=e);}function Me(r){(r|=0)&&K(r+-8|0);}function He(r,e){var i=0,a=0,f=0,n=0|sr(0|e,0|r);if(!n)return 0;var t=8<n>>>0?n:8;r=31-(0|ur(0|t))|0,r=(0==(0|t)?1:r)+(1!=(0|ir(0|n))&1)|0;r:{if(3<r>>>0&n>>>0<1<<r>>>0&&0!=(0|(i=0|ze[8400+(r+-1<<2)>>2]))){for(t=0,e=i;!(n>>>0<=(((0|ze[e+-8>>2])>>>1)-8|0)>>>0);)if(!((t=t+1|0)>>>0<32&0!=(0|(e=0|ze[e+4>>2])))){a=8;break r;}r=0|M(e,n);}else a=8;}r:do{if(8==(0|a)){e:do{if(r>>>0<32){for(;e=0|ze[8400+(r<<2)>>2],r=r+1|0,!(0|e);)if(32<=r>>>0)break e;r=0|M(e,n);break r;}}while(0);if(0|(r=0|ze[2287])&&0==(1&(f=0|ze[r>>2])|0)){if(ze[r>>2]=1|f,e=31-(0|ur(0|(t=8<(t=(f>>>1)-8|0)>>>0?t:8)))|0,e=8400+((0==(0|t)?1:e)<<2)|0,t=r+12|0,(0|ze[e>>2])==(0|(i=r+8|0))&&(ze[e>>2]=ze[t>>2]),0|(r=0|ze[i>>2])&&(ze[r+4>>2]=ze[t>>2]),0|(r=0|ze[t>>2])&&(ze[r>>2]=ze[i>>2]),f=0==(0|H(n)),r=0|ze[2287],f)return ze[r>>2]&=-2,(n=0)|n;if(r)break;return(r=0)|r;}if(-1==(0|(e=0|nr(0|(i=n+15&-8)))))return(n=0)|n;if((0|(t=e))!=(0|(a=r=t+7&-8))&&-1==(0|nr(r-t|0)))return(n=0)|n;(e=0|ze[2287])?ze[r+4>>2]=e:ze[2286]=a,ze[2287]=a,ze[r>>2]=i<<1|1;}}while(0);return fr(0|(f=r+8|0),0,0|n),0|f;}function L(r,e){var i,a=0,f=0,n=0,t=0,o=0,l=0==(0|(e|=0));if(!(r|=0)){if(l)return 0;l=31-(0|ur(0|(r=8<e>>>0?e:8)))|0,l=(0==(0|r)?1:l)+(1!=(0|ir(0|e))&1)|0;r:{if(3<l>>>0&e>>>0<1<<l>>>0&&0!=(0|(a=0|ze[8400+(l+-1<<2)>>2]))){for(i=0;!(e>>>0<=(((0|ze[a+-8>>2])>>>1)-8|0)>>>0);)if(!((i=i+1|0)>>>0<32&0!=(0|(a=0|ze[a+4>>2])))){o=9;break r;}l=0|M(a,e);}else o=9;}r:do{if(9==(0|o)){e:do{if(l>>>0<32){for(;a=0|ze[8400+(l<<2)>>2],l=l+1|0,!(0|a);)if(32<=l>>>0)break e;l=0|M(a,e);break r;}}while(0);if(0|(l=0|ze[2287])&&0==(1&(f=0|ze[l>>2])|0)){if(ze[l>>2]=1|f,a=31-(0|ur(0|(i=8<(i=(f>>>1)-8|0)>>>0?i:8)))|0,a=8400+((0==(0|i)?1:a)<<2)|0,i=l+12|0,(0|ze[a>>2])==(0|(f=l+8|0))&&(ze[a>>2]=ze[i>>2]),0|(l=0|ze[f>>2])&&(ze[l+4>>2]=ze[i>>2]),0|(l=0|ze[i>>2])&&(ze[l>>2]=ze[f>>2]),e=0==(0|H(e)),l=0|ze[2287],e)return ze[l>>2]&=-2,(e=0)|e;if(l)break;return(l=0)|l;}if(-1==(0|(a=0|nr(0|(f=e+15&-8)))))return(e=0)|e;var s=l=(i=a)+7&-8;if((0|a)!=(0|s)&&-1==(0|nr(l-i|0)))return(e=0)|e;(a=0|ze[2287])?ze[l+4>>2]=a:ze[2286]=s,ze[2287]=s,ze[l>>2]=f<<1|1;}}while(0);return l+8|0;}var u=r+-8|0;if(l)return K(u),0;if(e>>>0<=((a=(l=0|ze[u>>2])>>>1)-8|0)>>>0){if(ze[u>>2]=1|l,8==(-8&(l=a+(-8-e)|0)|0)&(0|ze[2287])==(0|u)){if(!(0|H(a)))return 0|r;l=l+8|0;}return l>>>0<=15||(e=t=o=r+e+7&-8,ze[u>>2]=1&(n=0|ze[u>>2])|o-u<<1,ze[e>>2]=(o=u+(n>>>1)-o|0)<<1|1&ze[e>>2],ze[e+4>>2]=u,ze[((0|ze[2287])==(0|u)?9148:t+(2147483647&o)+4|0)>>2]=t,K(e)),0|r;}if(f=(0|(s=0|ze[2287]))!=(0|u)?1&(a=0|ze[(f=u+a|0)>>2])?s:(l=31-(0|ur(0|(a=8<(a=(a>>>1)-8|0)>>>0?a:8)))|0,l=8400+((0==(0|a)?1:l)<<2)|0,a=f+12|0,(0|ze[l>>2])==(0|(i=f+8|0))&&(ze[l>>2]=ze[a>>2]),0|(l=0|ze[i>>2])&&(ze[l+4>>2]=ze[a>>2]),0|(l=0|ze[a>>2])&&(ze[l>>2]=ze[i>>2]),ze[u>>2]=l=(0|ze[u>>2])+(-2&ze[f>>2])|0,(0|s)==(0|f)?ze[2287]=u:(ze[f+((0|ze[f>>2])>>>1)+4>>2]=u,s)):u,e>>>0<=((a=l>>>1)-8|0)>>>0){if(ze[u>>2]=1|l,(0|f)==(0|u)&8==(-8&(l=a+(-8-e)|0)|0)){if(!(0|H(a)))return 0|r;l=l+8|0;}return l>>>0<=15||(e=t=o=r+e+7&-8,ze[u>>2]=1&(n=0|ze[u>>2])|o-u<<1,ze[e>>2]=(o=u+(n>>>1)-o|0)<<1|1&ze[e>>2],ze[e+4>>2]=u,ze[((0|ze[2287])==(0|u)?9148:t+(2147483647&o)+4|0)>>2]=t,K(e)),0|r;}l=31-(0|ur(0|(s=8<e>>>0?e:8)))|0,l=(0==(0|s)?1:l)+(1!=(0|ir(0|e))&1)|0;r:{if(3<l>>>0&e>>>0<1<<l>>>0&&0!=(0|(n=0|ze[8400+(l+-1<<2)>>2]))){for(i=0,a=n;!(e>>>0<=(((0|ze[a+-8>>2])>>>1)-8|0)>>>0);)if(!((i=i+1|0)>>>0<32&0!=(0|(a=0|ze[a+4>>2])))){o=64;break r;}l=0|M(a,e);}else o=64;}r:do{if(64==(0|o)){e:do{if(l>>>0<32){for(;a=0|ze[8400+(l<<2)>>2],l=l+1|0,!(0|a);)if(32<=l>>>0)break e;l=0|M(a,e);break r;}}while(0);if((0|f)==(0|u)){if(0|H(e))return 0|r;l=0|ze[2287];}else l=f;if(0|l&&0==(1&(t=0|ze[l>>2])|0)){if(ze[l>>2]=1|t,a=31-(0|ur(0|(i=8<(i=(t>>>1)-8|0)>>>0?i:8)))|0,a=8400+((0==(0|i)?1:a)<<2)|0,i=l+12|0,(0|ze[a>>2])==(0|(f=l+8|0))&&(ze[a>>2]=ze[i>>2]),0|(l=0|ze[f>>2])&&(ze[l+4>>2]=ze[i>>2]),0|(l=0|ze[i>>2])&&(ze[l>>2]=ze[f>>2]),o=0==(0|H(e)),l=0|ze[2287],o)return ze[l>>2]&=-2,(e=0)|e;if(l)break;return(l=0)|l;}if(-1==(0|(a=0|nr(0|(f=e+15&-8)))))return(e=0)|e;if((0|(i=a))!=(0|(s=l=i+7&-8))&&-1==(0|nr(l-i|0)))return(e=0)|e;(a=0|ze[2287])?ze[l+4>>2]=a:ze[2286]=s,ze[2287]=s,ze[l>>2]=f<<1|1;}}while(0);return ar(0|(o=l+8|0),0|r,0|(e>>>0<(t=((0|ze[u>>2])>>>1)-8|0)>>>0?e:t)),K(u),0|o;}function j(r){return 0|(0==(((0|(r|=0))-65|0)>>>0<26|0)?r:32|r);}function z(r){var e=(ze[104+(r|=0)>>2]=0)|ze[r+8>>2];ze[r+108>>2]=e-(0|ze[r+4>>2]),ze[r+100>>2]=e;}function N(r){var e=0,i=0,a=104+(r|=0)|0,f=0|ze[a>>2];if(0!=(0|f)&&(0|f)<=(0|ze[r+108>>2]))i=4;else{var n=Be;Be=Be+16|0;var t=e=0|r,o=74+(t|=0)|0;je[o>>0]=255+(f=0|je[o>>0])|f,(0|ze[(f=t+28|0)>>2])>>>0<(0|ze[(o=t+20|0)>>2])>>>0&&mr[15&ze[t+36>>2]](t,0,0),ze[t+16>>2]=0,ze[f>>2]=0,e=(ze[o>>2]=0)==(0|(o=4&(o=0|ze[t>>2])?(ze[t>>2]=32|o,-1):(ze[t+8>>2]=f=(0|ze[t+44>>2])+(0|ze[t+48>>2])|0,ze[t+4>>2]=f,o<<27>>31)))&&1==(0|mr[15&ze[e+32>>2]](e,n,1))?0|Ne[n>>0]:-1,Be=n,0<=(0|(e|=0))?(f=0|ze[r+8>>2],(a=0|ze[a>>2])?(t=a-(0|ze[r+108>>2])|0,((a=f)-(o=0|ze[(n=r+4|0)>>2])|0)<(0|t)?i=9:ze[r+100>>2]=o+(t+-1)):(n=r+4|0,a=f,i=9),9==(0|i)&&(ze[r+100>>2]=f),a=a?(ze[(r=r+108|0)>>2]=a+1-(f=0|ze[n>>2])+(0|ze[r>>2]),f):0|ze[n>>2],(0|e)!=(0|Ne[(a=a+-1|0)>>0])&&(je[a>>0]=e)):i=4;}return 4==(0|i)&&(ze[r+100>>2]=0,e=-1),0|e;}function B(r){return 1&(32==(0|(r|=0))|(r+-9|0)>>>0<5)|0;}function D(r,e){var i=0|je[(r|=0)>>0],a=0|je[(e|=0)>>0];if(0!=i<<24>>24&&i<<24>>24==a<<24>>24)for(;i=0|je[(r=r+1|0)>>0],a=0|je[(e=e+1|0)>>0],0!=i<<24>>24&&i<<24>>24==a<<24>>24;);return(255&i)-(255&a)|0;}function F(r,e,i){r|=0,e|=0,i|=0;for(var a,f,n=0;;){if((a=0|je[r>>0])<<24>>24!=(f=0|je[e>>0])<<24>>24){n=4;break;}if(!(i=i+-1|0)){r=0;break;}r=r+1|0,e=e+1|0;}return 4==(0|n)&&(r=(255&a)-(255&f)|0),0|r;}function Y(r,e,i){r|=0,i|=0;var a=255&(e|=0),f=255&e;r:{if(3&r){do{if((0|je[r>>0])==f<<24>>24){var n=6;break r;}r=r+1|0,e=0!=(0|(i=i+-1|0));}while(e&0!=(3&r|0));n=e?6:16;}else n=6;}r:do{if(6==(0|n))if((0|je[r>>0])==f<<24>>24)i||(n=16);else{e=0|sr(a,16843009);e:do{if(3<i>>>0)for(;;){if((-2139062144&(a=ze[r>>2]^e)^-2139062144)&a+-16843009|0)break e;if(r=r+4|0,(i=i+-4|0)>>>0<=3){n=11;break;}}else n=11;}while(0);if(11!=(0|n)||i)for(;;){if((0|je[r>>0])==f<<24>>24)break r;if(!(i=i+-1|0)){n=16;break;}r=r+1|0;}else n=16;}}while(0);return 16==(0|n)&&(r=0),0|r;}function Ke(r){return 0|(((32|(r|=0))-97|0)>>>0<26|0?1:0!=(((0|r)-48|0)>>>0<10|0)&1);}function G(r){return 0|(((0|(r|=0))-33|0)>>>0<94|0?0==(0|Ke(r))&1:0);}function X(r){var e,i=0,a=r|=0;r:do{if(3&a)for(e=a;;){if(!(0|je[r>>0])){r=e;break r;}if(!(3&(e=r=r+1|0))){i=5;break;}}else i=5;}while(0);if(5==(0|i)){for(;!((-2139062144&(e=0|ze[r>>2])^-2139062144)&e+-16843009);)r=r+4|0;if((255&e)<<24>>24)for(;0!=(0|je[(r=r+1|0)>>0]););}return r-a|0;}function W(r,e,i){if(r|=0,e|=0,i|=0){var a=0|je[r>>0];r:do{if(a<<24>>24){var f=r;for(r=a,a&=255;;){var n=0|je[e>>0];if(!(0!=(0|(i=i+-1|0))&0!=n<<24>>24))break r;if(r<<24>>24!=n<<24>>24&&(0|(a=0|j(a)))!=(0|j(255&n)))break r;if(e=e+1|0,!((a=0|je[(f=f+1|0)>>0])<<24>>24)){r=0;break;}r=a,a&=255;}}else r=0;}while(0);r=(r=0|j(255&r))-(0|j(0|Ne[e>>0]))|0;}else r=0;return 0|r;}function V(r,e,i,a){e|=0,a|=0;var f=0|r,n=0|i,t=65535&(r=0|f),o=65535&(i=0|n),l=0|sr(o,t),s=r>>>16;return r=(l>>>16)+(0|sr(o,s))|0,i=0|sr(o=i>>>16,t),i=0|(br((r>>>16)+(0|sr(o,s))+(((65535&r)+i|0)>>>16)|0),r+i<<16|65535&l|0),r=0|kr(),0|(br((0|sr(e,n))+(0|sr(a,f))+r|0&r|0),0|i);}function Z(r,e,i,a){return 0|(br((0|e)+(0|a)+((i=(r|=0)+(0|i)>>>0)>>>0<r>>>0|0)>>>0|0),0|i);}function $(r,e,i,a){return 0|(br((0|e)-(0|a)-((r|=0)>>>0<(i|=0)>>>0|0)>>>0|0),r-i>>>0|0);}function J(r){return 0|((r|=0)?31-(0|ur(r^r-1))|0:32);}function Q(r,e,i,a){return 0|function(r,e,i,a,f){var n,t;f|=0;var o=r|=0,l=n=e|=0,s=i|=0,u=t=a|=0;if(!l){var c=0!=(0|f);if(u){if(!c)return(f=0)|(br(0),f);ze[f>>2]=0|r,ze[f+4>>2]=0&e,f=t=0;}else c&&(ze[f>>2]=(o>>>0)%(s>>>0),ze[f+4>>2]=0),f=(o>>>(t=0))/(s>>>0)>>>0;return 0|(br(0|t),f);}c=0==(0|u);do{if(s){if(!c){if((c=(0|ur(0|u))-(0|ur(0|l))|0)>>>0<=31){var b=c+1|0;r=o>>>((s=b)>>>0)&(e=c-31>>31)|l<<(u=31-c|0),e&=l>>>(b>>>0),c=0,u=o<<u;break;}return f&&(ze[f>>2]=0|r,ze[f+4>>2]=n|0&e),f=t=0,0|(br(0|t),f);}if((c=s-1|0)&s|0){var k=64-(u=33+(0|ur(0|s))-(0|ur(0|l))|0)|0,v=u-32|0;r=(b=32-u|0)-1>>31&l>>>(v>>>0)|(l<<b|o>>>((s=u)>>>0))&(e=v>>31),e&=l>>>(u>>>0),c=o<<k&(n=b>>31),u=(l<<k|o>>>(v>>>0))&n|o<<b&u-33>>31;break;}0|f&&(ze[f>>2]=c&o,ze[f+4>>2]=0),k=1==(0|s)?(v=n|0&e,0|r):(v=l>>>((k=0|J(0|s))>>>0)|0,l<<32-k|o>>>(k>>>0)|0);}else{if(c)return 0|f&&(ze[f>>2]=(l>>>0)%(s>>>0),ze[f+4>>2]=0),k=(l>>>(v=0))/(s>>>0)>>>0,0|(br(0|v),k);if(!o)return 0|f&&(ze[f>>2]=0,ze[f+4>>2]=(l>>>0)%(u>>>0)),k=(l>>>(v=0))/(u>>>0)>>>0,0|(br(0|v),k);if(!((c=u-1|0)&u))return 0|f&&(ze[f>>2]=0|r,ze[f+4>>2]=c&l|0&e),k=l>>>(((v=0)|J(0|u))>>>0),0|(br(0|v),k);if((c=(0|ur(0|u))-(0|ur(0|l))|0)>>>0<=30){r=l<<(u=31-c|0)|o>>>((s=e=c+1|0)>>>0),e=l>>>(e>>>0),c=0,u=o<<u;break;}if(!f)return k=v=0,0|(br(0|v),k);ze[f>>2]=0|r,ze[f+4>>2]=n|0&e,k=v=0;}return 0|(br(0|v),k);}while(0);if(s){for(l=0|Z(0|(b=0|i),0|(o=t|0&a),-1,-1),i=0|kr(),n=u,u=0;n=c>>>31|(a=n)<<1,c=u|c<<1,$(0|l,0|i,0|(a=r<<1|a>>>31|0),0|(t=r>>>31|e<<1|0)),u=1&(v=(k=0|kr())>>31|((0|k)<0?-1:0)<<1),r=0|$(0|a,0|t,v&b|0,(((0|k)<0?-1:0)>>31|((0|k)<0?-1:0)<<1)&o|0),e=0|kr(),0!=(0|(s=s-1|0)););l=n,n=0;}else l=u,u=n=0;return(s=0)|f&&(ze[f>>2]=r,ze[f+4>>2]=e),k=-2&(c<<1|0)|u,0|(br((0|c)>>>31|(l|s)<<1|0&(s<<1|c>>>31)|n|0),k);}(0|r,0|e,0|i,0|a,0);}function rr(r,e,i){return r|=0,e|=0,(0|(i|=0))<32?(br(e>>>i|0),r>>>i|(e&(1<<i)-1)<<32-i):(br(0),e>>>i-32|0);}function er(r,e,i){return r|=0,(0|(i|=0))<32?(br((e|=0)<<i|(r&(1<<i)-1<<32-i)>>>32-i|0),r<<i):(br(r<<i-32|0),0);}function ir(r){return sr((r=(858993459&(r=(r|=0)-(r>>>1&1431655765)|0))+(r>>>2&858993459)|0)+(r>>>4)&252645135,16843009)>>>24|0;}function ar(r,e,i){if(r|=0,e|=0,8192<=(0|(i|=0)))return hr(0|r,0|e,0|i),0|r;var a=0|r,f=r+i|0;if((3&r)==(3&e)){for(;3&r;){if(!i)return 0|a;je[r>>0]=0|je[e>>0],r=r+1|0,e=e+1|0,i=i-1|0;}for(i=-4&f|0;(0|r)<(0|i);)ze[r>>2]=ze[e>>2],r=r+4|0,e=e+4|0;}else for(i=f-4|0;(0|r)<(0|i);)je[r>>0]=0|je[e>>0],je[r+1>>0]=0|je[e+1>>0],je[r+2>>0]=0|je[e+2>>0],je[r+3>>0]=0|je[e+3>>0],r=r+4|0,e=e+4|0;for(;(0|r)<(0|f);)je[r>>0]=0|je[e>>0],r=r+1|0,e=e+1|0;return 0|a;}function Le(r,e,i){if((0|(e|=0))<(0|(r|=0))&(0|r)<(e+(i|=0)|0)){var a=r;for(e=e+i|0,r=r+i|0;0<(0|i);)i=i-1|0,je[(r=r-1|0)>>0]=0|je[(e=e-1|0)>>0];r=a;}else ar(r,e,i);return 0|r;}function fr(r,e,i){var a,f=(r|=0)+(i|=0)|0;if(e=255&(0|e),67<=(0|i)){for(;3&r;)je[r>>0]=e,r=r+1|0;for(a=e|e<<8|e<<16|e<<24;(0|r)<(0|(-4&f|0));)ze[r>>2]=a,r=r+4|0;}for(;(0|r)<(0|f);)je[r>>0]=e,r=r+1|0;return f-i|0;}function nr(r){var e=0|ze[lr>>2],i=e+(r|=0)|0;if(0<(0|r)&(0|i)<(0|e)|(0|i)<0)return vr(12),-1;if((0|i)>(0|dr())){if(!(0|wr(0|i)))return vr(12),-1;}else ze[lr>>2]=i;return 0|e;}function a(){return cr(1),0;}function f(){return cr(4),0;}function tr(){cr(7);}var je=new r.Int8Array(i);new r.Int16Array(i);var ze=new r.Int32Array(i),Ne=new r.Uint8Array(i),or=new r.Uint16Array(i),lr=0|e.i,sr=r.Math.imul,ur=r.Math.clz32,cr=e.a,br=e.b,kr=e.c,vr=e.d,dr=e.e,hr=e.f,wr=e.g,Be=9440,pr=[function(){return cr(0),0;},w],mr=[a,function(r,e){return e|=0,de(r|=0,5906,6),0|e&&P(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,5913,7),1;},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5867,30),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5898,7),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5848,8),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5857,9),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5837,4),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5842,5),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5809,12),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5822,14),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5796,5),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5802,6),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5783,5),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5789,6),1):0);},function(r,e,i){r|=0,e|=0;var a,f,n=0,t=0|ze[20+(i|=0)>>2],o=0|ze[i+16>>2];r:do{if(0!=(0|t)&0!=(1024&o|0)){var l=e+4|0;for(a=0;;){var s=0|ze[t+(a<<2)>>2];if(!s){n=6;break r;}if(f=0|O(0|ze[e>>2],0|ze[l>>2],s))break;a=a+1|0;}a=r,l=e;var u=0|ze[i+24>>2];l|=0,s|=0,u|=0,f|=0;var c,b,k=0;if(he(a|=0,60),2==(0|f))he(a,47),y(a,s);else{y(a,s),s=0|X(s);var v=0|C(16),d=0|C(16),h=l+4|0,w=v+4|0,p=d+4|0;for(f=1,c=b=0;;){var m=s+1|0;if(!(f&m>>>0<(0|ze[h>>2])>>>0))break;var _=0|je[(0|ze[l>>2])+m>>0];e:do{switch(0|_){case 62:f=0;break;case 34:case 39:if(b){if(c){if((0|c)!=(0|_)){he(d,_),f=1;break e;}for(f=0;;){if(!(c=0|ze[u+(f<<2)>>2])){k=27;break e;}if((0|(_=0|X(c)))==(0|ze[w>>2])){for(s=0;!(_>>>0<=s>>>0)&&(0|(k=0|j(0|je[c+s>>0])))==(0|j(0|Ne[(0|ze[v>>2])+s>>0]));)s=s+1|0;if((0|s)==(0|_))break;}f=f+1|0;}0==(0|_)|0==(0|ze[p>>2])||(he(a,32),P(a,0|ze[v>>2],0|ze[w>>2]),y(a,6026),P(a,0|ze[d>>2],0|ze[p>>2]),he(a,34)),k=27;}else f=1,c=_;}else k=27;break;case 32:c?(he(d,32),f=1):k=27;break;case 61:b?k=27:b=f=1;break;default:0==(0|c)&(s=0!=(0|b))?(f=1,c=0):(he(s?d:v,_),f=1);}}while(0);27==(0|k)&&(k=0,R(v),R(d),f=1,c=b=0),s=m;}S(v),S(d);}he(a,62);}else n=6;}while(0);return 6==(0|n)&&(512&o|0?P(r,0|ze[e>>2],0|ze[e+4>>2]):1&o||2&o|0&&0|O(0|ze[e>>2],0|ze[e+4>>2],6014)||(l=0|ze[e>>2],a=0|ze[e+4>>2],8&o|0&&0|O(l,a,6020)||4&o|0&&0|O(l,a,6022)||de(r,l,a))),1;},a,a,a,a,a,a,a],_r=[function(){return cr(2),0;},function(r,e,i,a){r|=0,i|=0,a|=0;var f=0,n=0;if(0!=(0|(e|=0))&&0!=(0|(f=0|ze[(n=e+4|0)>>2]))){if(32&ze[a+16>>2]|0&&2!=(0|i)&0==(0|k(0|ze[e>>2],f)))i=0;else{de(r,6029,9),2==(0|i)&&de(r,6090,7),d(0|r,0|ze[e>>2],0|ze[n>>2]),0|ze[(i=a+28|0)>>2]?(he(r,34),Fe[7&ze[i>>2]](r,e,a),he(r,62)):de(r,6005,2);var t=f=0,o=0,l=0|ze[4+(i=0|e)>>2];for(a=0;;){if(l>>>0<=a>>>0){a=0;break;}if(t=0|je[6090+a>>0],7==(0|a)){a=0;break;}if((0|(f=0|Ne[(0|ze[i>>2])+a>>0]))!=(0|t)){o=5;break;}a=a+1|0;}5==(0|o)&&(a=f-t|0),i=0|ze[e>>2],0==(0|a)?P(r,i+7|0,(0|ze[n>>2])-7|0):P(r,i,0|ze[n>>2]),de(r,6049,4),i=1;}}else i=0;return 0|i;}],yr=[function(){return cr(3),0;},function(r,e,i,a){return(e=0)|(a|=0)&&0|(e=0|ze[a+4>>2])&&de(0|r,0|ze[a>>2],e),1;},function(r,e,i,a,f){r|=0,i|=0,a|=0,f|=0;var n=0,t=0,o=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(o=e+4|0)>>2])?(de(r,6067,10),d(0|r,0|ze[e>>2],0|ze[o>>2]),de(r,6078,7),0|a&&0|(n=0|ze[a+4>>2])&&P(r,0|ze[a>>2],n),0|i&&0|ze[(t=i+4|0)>>2]&&(de(r,6039,9),P(r,0|ze[i>>2],0|ze[t>>2])),y(r,0==(256&ze[f+16>>2]|0)?6005:6086),1):0);},function(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0,f|=0;var n=0,t=0,o=0,l=0;do{if(e){if(32&ze[f+16>>2]){if(!(0|k(0|ze[e>>2],0|ze[(n=e+4|0)>>2]))){n=0;break;}}else n=e+4|0;de(r,6029,9),(n=0|ze[n>>2])&&d(0|r,0|ze[e>>2],0|n);}else de(r,6029,9);t=8;}while(0);return 8==(0|t)&&(0|i&&0|ze[(o=i+4|0)>>2]&&(de(r,6039,9),P(r,0|ze[i>>2],0|ze[o>>2])),0|ze[(n=f+28|0)>>2]?(he(r,34),Fe[7&ze[n>>2]](r,e,f),he(r,62)):de(r,6005,2),0|a&&0|(l=0|ze[a+4>>2])&&de(r,0|ze[a>>2],l),de(r,6049,4),n=1),0|n;}],gr=[f,function(r,e,i,a,f,n){r|=0,e|=0,a|=0,f|=0;var t=0,o=0,l=0,s=0|je[(i|=0)>>0],u=3<(n|=0)>>>0;if(u&62==s<<24>>24){if(33==(f=0|je[(a=i+1|0)>>0])<<24>>24){if(!(0|Pe(0|Ne[(a=i+2|0)>>0]))){r:{r|=0,i=0|a,n=n+-2|0,o=(t=0)|ze[56+(e|=0)>>2];e:do{if(0|o){for(u=0;;){if(n>>>0<=u>>>0)break e;if(!(s=0|T(i+u|0,n-u|0,60)))break e;if((u=s+u|0)>>>0<n>>>0&&60==(0|je[i+u>>0])&&33==(0|je[i+(t=u+-1|0)>>0]))break;u=u+1|0;}qe(n=0|Te(e,1),e,i,t),o=0|mr[15&o](r,n,0|ze[e+112>>2]),Oe(e,1),n=0|(0==(0|o)?0:u+1|0);break r;}}while(0);n=0;}return 0|(0==(0|(n|=0))?0:n+2|0);}a=0;}else l=7;}else l=2<n>>>0?(a=f=i+1|0,f=0|je[f>>0],7):11;r:{if(7==(0|l)){var c=255&f;if(f<<24>>24!=s<<24>>24){switch(s<<24>>24){case 62:case 126:a=0;break r;}a=0|Pe(c)?0:0==(0|(a=0|p(r,e,a,n+-1|0,s)))?0:a+1|0;}else l=11;}}r:do{if(11==(0|l))if(u&&(0|je[i+1>>0])==s<<24>>24){if((f=0|je[(a=i+2|0)>>0])<<24>>24!=s<<24>>24)a=0|Pe(255&f)?0:0==(0|(a=0|m(r,e,a,n+-2|0,s)))?0:a+2|0;else if(5<=n>>>0&&(o=255&(l=0|je[(t=i+3|0)>>0]),l<<24>>24!=s<<24>>24)){switch(s<<24>>24){case 62:case 126:a=0;break r;}if(0|Pe(o))a=0;else{e:{a=r,f=e,c=t;var b=n+-3|0,k=s;a|=0,f|=0,c|=0,b|=0,k|=0;var v,d=0,h=0,w=0;for(v=0;;){if(b>>>0<=v>>>0){v=0;break;}if(!(d=0|T(c+v|0,b-v|0,k))){v=0;break;}if((0|je[c+(d=d+v|0)>>0])==k<<24>>24&&0==(0|Pe(0|Ne[c+(d+-1)>>0]))){w=7;break;}v=d;}if(7==(0|w))if(v=d+1|0,(w=d+2|0)>>>0<b>>>0&&(0|je[c+v>>0])==k<<24>>24&&(0|je[c+w>>0])==k<<24>>24&&0|ze[(h=f+84|0)>>2])qe(v=0|Te(f,1),f,c,d),v=0|mr[15&ze[h>>2]](a,v,0|ze[f+112>>2]),Oe(f,1),v=0==(0|v)?0:d+3|0;else{if(v>>>0<b>>>0&&(0|je[c+v>>0])==k<<24>>24){a=0|(0==(0|(w=0|p(a,f,c+-2|0,b+2|0,k)))?0:w+-2|0);break e;}v=0==(0|(v=0|m(a,f,c+-1|0,b+1|0,k)))?0:v+-1|0;}a=0|v;}a=0==(0|(a|=0))?0:a+3|0;}}else a=0;}else a=0;}while(0);return 0|a;},function(r,e,i,a,f,n){var t,o;r|=0,e|=0,i|=0,n|=0;var l=Be;for(Be=Be+16|0,t=0;!(n>>>0<=t>>>0)&&96==(0|je[i+t>>0]);)t=t+1|0;for(a=0,o=t;(f=o>>>0<n>>>0)&a>>>0<t>>>0;)a=96==(0|je[i+o>>0])?a+1|0:0,o=o+1|0;if(f|t>>>0<=a>>>0){for(f=t;!(o>>>0<=f>>>0)&&32==(0|je[i+f>>0]);)f=f+1|0;for(a=o-t|0;!(a>>>0<=t>>>0)&&32==(0|je[i+(n=a+-1|0)>>0]);)a=n;if(!(f>>>0<a>>>0))return i=0==(0|mr[15&ze[e+52>>2]](r,0,0|ze[e+112>>2])),Be=l,0|(i?0:o);ze[l>>2]=i+f,ze[l+4>>2]=a-f,ze[l+8>>2]=0,a=(a=(ze[l+12>>2]=0)==(0|mr[15&ze[e+52>>2]](r,l,0|ze[e+112>>2])))?0:o;}else a=0;return Be=l,0|a;},function(r,e,i,a){if(r|=0,e|=0,i|=0,2<=(0|a)>>>0&&32==(0|je[i+-1>>0])&&32==(0|je[i+-2>>0])){for(i=0|ze[(a=r+4|0)>>2];i&&32==(0|je[(0|ze[r>>2])+(i=i+-1|0)>>0]);)ze[a>>2]=i;i=0!=(0|pr[1&ze[e+72>>2]](r,0|ze[e+112>>2]))&1;}else i=0;return 0|i;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=0,o=0,l=0,s=0,u=0,c=0,b=0;if(0|a){if(f=0|ze[(a=e+420|0)>>2],33==(0|je[i+-1>>0])){if(0|ze[e+68>>2]){c=f,u=a,s=1;var k=6;}else k=89;}else k=5;}else f=0|ze[(a=e+420|0)>>2],k=5;5==(0|k)&&(k=0|ze[e+76>>2]?(c=f,u=a,s=0,6):89);r:do{if(6==(0|k)){var v=a=1;f=0;e:for(;;){if(n>>>0<=v>>>0){f=c,a=u,k=89;break r;}var d=0|je[i+v>>0];i:do{if(10!=d<<24>>24){var h=v+-1|0;if(92!=(0|je[i+h>>0]))switch(d<<24>>24){case 91:a=a+1|0;break i;case 93:if((0|a)<2)break e;a=a+-1|0;break i;default:break i;}}else f=1;}while(0);v=v+1|0;}for(d=a=v+1|0;;){if(n>>>0<=d>>>0){k=66;break;}if(!(0|Pe(255&(t=0|je[i+d>>0])))){k=18;break;}d=d+1|0;}e:do{if(18==(0|k)){switch(t<<24>>24){case 40:break;case 91:for(t=a=d+1|0;;){if(n>>>0<=t>>>0){f=c,a=u,k=89;break r;}if(93==(0|je[i+t>>0]))break;t=t+1|0;}if((0|t)==(0|a)){if(f){for(d=0|Te(e,1),a=1;!(v>>>0<=a>>>0);)10==(f=0|je[i+a>>0])<<24>>24?32!=(0|je[i+(a+-1)>>0])&&he(d,32):he(d,255&f),a=a+1|0;f=0|ze[d>>2],a=0|ze[d+4>>2];}else f=i+1|0,a=h;}else f=i+a|0,a=t-a|0;if(!(f=0|I(e+116|0,f,a))){f=c,a=u,k=89;break r;}a=t+1|0,o=0|ze[f+8>>2],d=0|ze[f+4>>2];break e;default:k=66;break e;}for(;;){var w=d+1|0;if(n>>>0<=w>>>0)break;if(!(0|Pe(0|Ne[i+w>>0])))break;d=w;}var p=w;i:for(;;){if(n>>>0<=p>>>0){f=c,a=u,k=89;break r;}switch((t=0|je[i+p>>0])<<24>>24){case 41:n=l=0,o=a=p;break i;case 92:a=2;break;default:if(0!=(0|p)&&0!=(0|Pe(0|Ne[i+(p+-1)>>0])))switch(t<<24>>24){case 34:case 39:k=29;break i;default:a=1;}else a=1;}p=p+a|0;}i:do{if(29==(0|k)){var m=p+1|0;for(a=1,o=m;;){if(n>>>0<=o>>>0){f=c,a=u,k=89;break r;}if(92!=(f=0|je[i+o>>0])<<24>>24){if(f<<24>>24!=t<<24>>24){if(!(0!=(0|a)|41!=f<<24>>24))break;f=1;}else a=0,f=1;}else f=2;o=o+f|0;}f=o;do{if(a=0|je[i+(f=f+-1|0)>>0],f>>>0<=m>>>0)break;}while(0!=(0|Pe(255&a)));switch(a<<24>>24){case 34:case 39:a=p,l=m,n=f;break i;}a=o,n=l=0;}}while(0);for(;m=0|je[i+(t=a+-1|0)>>0],!(a>>>0<=w>>>0)&&0|Pe(255&m);)a=t;(f=60==(0|je[i+w>>0])?d+2|0:w)>>>0<(a=62==m<<24>>24?t:a)>>>0?de(d=0|Te(e,1),i+f|0,a-f|0):d=0,l>>>0<n>>>0?de(f=0|Te(e,1),i+l|0,n-l|0):f=0,a=o+1|0,o=f;}}while(0);if(66==(0|k)){if(f){for(t=0|Te(e,1),f=1;!(v>>>0<=f>>>0);)10==(d=0|je[i+f>>0])<<24>>24?32!=(0|je[i+(f+-1)>>0])&&he(t,32):he(t,255&d),f=f+1|0;d=0|ze[t>>2],f=0|ze[t+4>>2];}else d=i+1|0,f=h;if(!(f=0|I(e+116|0,d,f))){f=c,a=u,k=89;break;}o=0|ze[f+8>>2],d=0|ze[f+4>>2];}t=1<v>>>0?(f=0|Te(e,1),s?de(f,i+1|0,h):(qe(f,e,i+(ze[(t=e+440|0)>>2]=1)|0,h),ze[t>>2]=0),f):0,d?(_(m=0|Te(e,1),d),f=s?(0|(d=0|ze[(f=r+4|0)>>2])&&33==(0|je[(0|ze[r>>2])+(b=d+-1|0)>>0])&&(ze[f>>2]=b),0|yr[3&ze[e+68>>2]](r,m,o,t,0|ze[e+112>>2])):0|yr[3&ze[e+76>>2]](r,m,o,t,0|ze[e+112>>2]),ze[u>>2]=c,f||(k=91)):(f=c,a=u,k=89);}}while(0);return 89==(0|k)&&(ze[a>>2]=f,k=91),91==(0|k)&&(a=0),0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0;var t=0,o=Be;Be=Be+32|0,a=(ze[(f=o+16|0)>>2]=0)|i,n|=0;var l=0|f,s=0,u=0,c=0;r:do{if(3<=n>>>0&&60==(0|je[a>>0])&&0!=(0|Ke(0|Ne[a+(s=47==(0|je[a+1>>0])?2:1)>>0]))){ze[l>>2]=0;e:for(;!(n>>>0<=s>>>0);){var b=0|je[a+s>>0];if(!(0|Ke(255&b)))switch(b<<24>>24){case 45:case 43:case 46:break;default:break e;}s=s+1|0;}if(1<s>>>0){var k,v=0|je[(b=a+s|0)>>0];if(k=64==v<<24>>24){var d,h=b,w=n-s|0;h|=0,w|=0;var p=0;b=d=0;e:for(;;){if(w>>>0<=b>>>0){d=0;break;}k=0|je[h+b>>0];i:do{if(!(0|Ke(255&k))){switch(k<<24>>24){case 62:p=6;break e;case 95:case 46:case 45:break i;case 64:break;default:d=0;break e;}d=d+1|0;}}while(0);b=b+1|0;}6==(0|p)&&(d=1==(0|d)?b+1|0:0),k=0|(u=0|d);}if(k){ze[l>>2]=2,b=u+s|0;break;}b=2<s>>>0?58==v<<24>>24?(s=s+(ze[l>>2]=1)|0,1):0:(s=2,0);}else b=0;if(s>>>0<n>>>0){if(b){v=s;e:for(;;){if(n>>>0<=v>>>0){b=0;break r;}switch((b=0|je[a+v>>0])<<24>>24){case 10:case 32:case 34:case 39:case 62:break e;case 92:b=2;break;default:b=1;}v=v+b|0;}if(s>>>0<v>>>0&62==b<<24>>24){b=v+1|0;break;}s=v,c=25;}}else c=25;for(25==(0|c)&&(ze[l>>2]=0);;){if(n>>>0<=s>>>0){b=0;break r;}if(b=s+1|0,62==(0|je[a+s>>0]))break;s=b;}}else b=0;}while(0);a=0|b,ze[o>>2]=i,ze[(l=o+4|0)>>2]=a,ze[o+8>>2]=0,ze[o+12>>2]=0;do{if(2<a>>>0){if(0!=(0|ze[(n=e+48|0)>>2])&0!=(0|(f=0|ze[f>>2])))s=0|Te(e,1),ze[o>>2]=i+1,ze[l>>2]=a+-2,_(s,o),f=0|_r[1&ze[n>>2]](r,s,f,0|ze[e+112>>2]),Oe(e,1);else{if(!(f=0|ze[e+80>>2])){t=7;break;}f=0|mr[15&f](r,o,0|ze[e+112>>2]);}f||(t=7);}else t=7;}while(0);return 7==(0|t)&&(a=0),Be=o,0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=Be;return Be=Be+16|0,ze[t>>2]=0,ze[t+4>>2]=0,ze[t+8>>2]=0,a=1<n>>>(ze[t+12>>2]=0)?0|Y(5719,a=0|Ne[(i=i+1|0)>>0],24)?((f=0|ze[e+100>>2])?(ze[t>>2]=i,ze[t+4>>2]=1,Fe[7&f](r,t,0|ze[e+112>>2])):he(r,a),2):0:(1==(0|n)&&he(r,0|Ne[i>>0]),2),Be=t,0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=0,o=Be;if(Be=Be+16|0,ze[o>>2]=0,ze[o+4>>2]=0,ze[o+8>>2]=0,1<n>>>(ze[o+12>>2]=0)){if(f=(a=35==(0|je[i+1>>0]))?2:1,a&f>>>0<n>>>0){var l=120==(0|j(0|Ne[i+f>>0])),s=1^l,u=1;l=f+(1&l)|0;}else s=1,u=a,l=f;}else u=0,l=s=1;var c=l;r:for(;;){if(n>>>0<=c>>>0){a=0;break;}if(f=(a=0|je[i+c>>0])<<24>>24,s){if(u){if(!((f+-48|0)>>>0<10)){t=12;break r;}}else if(!(0|Ke(f))){t=12;break r;}}else if(!(1&(((32|(f|=0))-97|0)>>>0<6|0!=(((0|f)-48|0)>>>0<10|0))|0)){t=12;break r;}c=c+1|0;}do{if(12==(0|t))if(l>>>0<c>>>0&59==a<<24>>24){if(a=c+1|0,u){if(7<(c-l|0)>>>0){a=0;break;}f=i+l|0;var b=0|(n=s?10:16);f|=0,b|=0,Be=(n=Be)+128|0;var k,v=n;ze[v>>2]=0,ze[v+4>>2]=f,ze[v+44>>2]=f,ze[v+8>>2]=(0|f)<0?-1:f+2147483647|0,ze[v+76>>2]=-1,z(v),f=v;var d=b;f|=0,d|=0;var h=0;r:do{if(36<d>>>0)var w=k=0;else{for(v=f+4|0,b=f+100|0;0!=(0|B(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f))););e:{switch(0|k){case 43:case 45:if(k=(45==(0|k))<<31>>31,(w=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0){ze[v>>2]=w+1;var p=k;k=0|Ne[w>>0];}else p=k,k=0|N(f);break e;default:p=0;}}if(w=0==(0|d),16==(16|d)&48==(0|k)){if(120!=(32|(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f)))){if(w){w=8;var m=42;}else w=d,m=27;}else{if(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),15<(0|Ne[4849+k>>0])){if(!(0|ze[b>>2])){w=k=0;break r;}ze[v>>2]=(0|ze[v>>2])-2,w=k=0;break r;}w=16,m=42;}}else{if(!((0|Ne[4849+k>>0])>>>0<(w=w?10:d)>>>0)){0|ze[b>>2]&&(ze[v>>2]=(0|ze[v>>2])-1),z(f),w=k=0;break r;}m=27;}e:{if(27==(0|m))if(10==(0|w)){if((k=k+-48|0)>>>0<10){d=0;for(var _=k;d=(10*d|0)+_|0,(w=(_=(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f))-48|0)>>>0<10)&d>>>0<429496729;);if(w){var y=d;d=0;do{w=0|V(0|y,0|d,10,0);var g=((0|_)<0)<<31>>31,A=~g;if(A>>>0<(h=0|kr())>>>0|(0|h)==(0|A)&~_>>>0<w>>>0){w=10,h=y,m=71;break e;}y=0|Z(0|w,0|h,0|_,0|g),d=0|kr(),_=(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f))-48|0;}while(_>>>0<10&(d>>>0<429496729|429496729==(0|d)&y>>>0<2576980378));9<_>>>0?(w=d,k=y):(w=10,h=y,m=71);}else w=0,k=d;}else k=w=0;}else m=42;}e:do{if(42==(0|m)){if(!(w+-1&w)){if(A=0|je[8358+((23*w|0)>>>5&7)>>0],(d=255&(_=0|je[4849+k>>0]))>>>0<w>>>0){for(h=0;h=d|h<<A,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),h>>>0<134217728&(d=255&(_=0|je[4849+k>>0]))>>>0<w>>>0;);g=d,d=0;}else g=d,h=d=0;if(y=0|rr(-1,-1,0|A),w>>>0<=g>>>0|(m=0|kr())>>>0<d>>>0|(0|m)==(0|d)&y>>>0<h>>>0){m=71;break;}for(;;)if(h=0|er(0|h,0|d,0|A),d=0|kr(),h|=255&_,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),w>>>0<=(255&(_=0|je[4849+k>>0]))>>>0|m>>>0<d>>>0|(0|d)==(0|m)&y>>>0<h>>>0){m=71;break e;}}if((_=255&(d=0|je[4849+k>>0]))>>>0<w>>>0){for(h=0;h=_+(0|sr(h,w))|0,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),h>>>0<119304647&(_=255&(d=0|je[4849+k>>0]))>>>0<w>>>0;);g=d;}else g=d,h=0;if(_>>>(d=0)<w>>>0)for(m=0|Q(-1,-1,0|w,0),A=0|kr(),_=g;;){if(A>>>0<d>>>0|(0|d)==(0|A)&m>>>0<h>>>0){m=71;break e;}if(g=0|V(0|h,0|d,0|w,0),4294967295<(y=0|kr())>>>0|-1==(0|y)&~(_&=255)>>>0<g>>>0){m=71;break e;}if(h=0|Z(0|g,0|y,0|_,0),d=0|kr(),k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),w>>>0<=(255&(_=0|je[4849+k>>0]))>>>0){m=71;break;}}else m=71;}}while(0);if(71==(0|m))if((0|Ne[4849+k>>0])>>>0<w>>>0){for(;k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Ne[k>>0]):0|N(f),(0|Ne[4849+k>>0])>>>0<w>>>0;);w=0,k=-2147483648;}else w=d,k=h;if(0|ze[b>>2]&&(ze[v>>2]=(0|ze[v>>2])-1),!(w>>>0<0|0==(0|w)&k>>>0<2147483648)){if(!p){k=0,w=2147483647;break;}if(0<w>>>0|0==(0|w)&2147483648<k>>>0){k=0,w=-2147483648;break;}}w=0|$(k^p|0,w^(b=((0|p)<0)<<31>>31)|0,0|p,0|b),k=0|kr();}}while(0);if(br(0|k),b=0|w,br(0|kr()),Be=n,n=0|b,kr(),n|=0,!(0|(17<((n|=0)-14|0)>>>0&8<n>>>0&1<(n+-11|0)>>>0?n>>>0<1114112&65535!=(1|n)&55296!=(-2048&n|0)&1|0:0))){a=0;break;}}else{n=i,f=a,n|=0,f|=0,b=0;do{if((f+-4|0)>>>0<7){switch(v=n,p=f,v|=0,(A=0)|(p|=0)){case 6:p=6,A=3;break;case 5:p=5,A=4;break;case 4:p=4,A=5;break;case 3:p=3,A=6;break;case 2:p=2;break;default:p=(0|or[4320+((0|Ne[v+6>>0])<<1)>>1])+p|0,A=3;}if(3==(0|A)&&(p=p+(0|or[4320+((0|Ne[v+5>>0])<<1)>>1])|0,A=4),4==(0|A)&&(p=p+(0|or[4320+((0|Ne[v+4>>0])<<1)>>1])|0,A=5),5==(0|A)&&(p=p+(0|or[4320+((0|Ne[v+3>>0])<<1)>>1])|0,A=6),6==(0|A)&&(p=p+(0|or[4320+(1+(0|Ne[v+2>>0])<<1)>>1])|0),v=(v=p+(0|or[4320+((0|Ne[v+1>>0])<<1)>>1])|0)>>>0<771&&(0|je[n>>0])==(0|je[(b=0|ze[1232+(v<<2)>>2])>>0])){if(A=n+1|0,m=b+1|0,y=f+-1|0,A|=0,m|=0,y|=0){p=0|je[A>>0];r:do{if(p<<24>>24)for(;;){if(!(p<<24>>24==(v=0|je[m>>0])<<24>>24&0!=(0|(y=y+-1|0))&0!=v<<24>>24))break r;if(m=m+1|0,!((p=0|je[(A=A+1|0)>>0])<<24>>24)){p=0;break;}}else p=0;}while(0);p=(255&p)-(0|Ne[m>>0])|0;}else p=0;v=0==(0|p);}if(v&&0==(0|je[b+f>>0]))break;}b=0;}while(0);if(!(0|b)){a=0;break;}}0|(f=0|ze[e+96>>2])?(ze[o>>2]=i,ze[o+4>>2]=a,Fe[7&f](r,o,0|ze[e+112>>2])):(he(r,38),u&&he(r,35),s||he(r,120),de(r,i+l|0,a-l|0));}else a=0;}while(0);return Be=o,0|a;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=Be;Be=Be+16|0;var o=48+(e|=0)|0;if(0!=(0|ze[o>>2])&&0==(0|ze[e+440>>2])){var l=0|Te(e,1);f=0|t;i|=0,a|=0;var u,c=0;if(4<=(n|=0)>>>0&&47==(0|je[i+1>>0])&&47==(0|je[i+2>>0])){for(u=0;!(a>>>0<=u>>>0)&&((32|Ne[i+~u>>0])-97|0)>>>0<26|0;)u=u+1|0;var b=i+-u|0;if(0!=(0|k(b,u+n|0))&&0!=(0|(c=0|v(i+3|0,n+-3|0)))){for(a=c+3|0;!(n>>>0<=a>>>0||0|B(0|Ne[i+a>>0]));)a=a+1|0;(a=0|h(i,a))?(de(0|l,b,a+u|0),ze[f>>2]=u):a=0;}else a=0;}else a=0;0|(f=0|a)&&(E(r,(0|ze[r+4>>2])-(0|ze[t>>2])|0),_r[1&ze[o>>2]](r,l,1,0|ze[e+112>>2])),Oe(e,1);}else f=0;return Be=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=Be;Be=Be+16|0;var o=48+(e|=0)|0;if(0!=(0|ze[o>>2])&&0==(0|ze[e+440>>2])){var l=0|Te(e,1);f=0|t;i|=0,a|=0,n|=0;var u,c,b=0;for(c=0;!(a>>>0<=c>>>0);){var k=0|je[i+~c>>0],v=255&k;if(!(k<<24>>24))break;if(0==(0|Ke(v))&&0==(0|Y(5568,v,5)))break;c=c+1|0;}if(c){k=n+-1|0,v=a=u=0;r:for(;!(n>>>0<=u>>>0);){var d=0|je[i+u>>0];e:do{if(!(0|Ke(255&d))){switch(d<<24>>24){case 95:case 45:break e;case 64:v=v+1|0;break e;case 46:break;default:break r;}if(k>>>0<=u>>>0)break r;a=a+1|0;}}while(0);u=u+1|0;}0==(0|a)|1!=(0|v)|u>>>0<2||0==(0|(b=0|h(i,u)))?b=0:(de(0|l,i+-c|0,b+c|0),ze[f>>2]=c);}else b=0;0|(f=0|b)&&(E(r,(0|ze[r+4>>2])-(0|ze[t>>2])|0),_r[1&ze[o>>2]](r,l,2,0|ze[e+112>>2])),Oe(e,1);}else f=0;return Be=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=Be;Be=Be+16|0;var o=t,l=76+(e|=0)|0;if(0!=(0|ze[l>>2])&&0==(0|ze[e+440>>2])){var s=0|Te(e,1);f=0|o;i|=0,n|=0;var c=0,b=0,k=0;if(0!=(0|a)&&0==(0|G(b=0|Ne[i+-1>>0]))?n>>>0<4|0==(0|B(b))?c=0:k=5:n>>>0<4?c=0:k=5,5==(0|k))if(0==(0|F(i,5558,4))&&0!=(0|(c=0|v(i,n)))){for(;!(n>>>0<=c>>>0||0|B(0|Ne[i+c>>0]));)c=c+1|0;(c=0|h(i,c))?(de(0|s,i,c),ze[f>>2]=0):c=0;}else c=0;0|(f=0|c)&&(de(a=0|Te(e,1),5711,7),de(a,0|ze[s>>2],0|ze[s+4>>2]),E(r,(0|ze[r+4>>2])-(0|ze[o>>2])|0),0|ze[(i=e+100|0)>>2]?(n=0|Te(e,1),Fe[7&ze[i>>2]](n,s,0|ze[(o=e+112|0)>>2]),yr[3&ze[l>>2]](r,a,0,n,0|ze[o>>2]),Oe(e,1)):yr[3&ze[l>>2]](r,a,0,s,0|ze[e+112>>2]),Oe(e,1)),Oe(e,1);}else f=0;return Be=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,f|=0,n|=0;var t=0,o=Be;Be=Be+16|0;var l=o+4|0,s=o;if(0!=(0|ze[48+(e|=0)>>2])&&0==(0|ze[e+440>>2])){var u,c=0|Te(e,1),b=0|l,k=0|c,v=0|i,d=0|n,h=0|s,w=0,p=0|g(v,0|a,0|f,d,114);r:do{if(p){for(w=4<d>>>0?0==(0|W(v+1|0,5573,4)):0,u=1;;){var m=u+10|0;if(m>>>0<=d>>>0&&0==(0|W(v+u|0,5578,10)))var _=10;else{if(m=(m=u+2|0)>>>0<d>>>0&&(_=0==(0|W(v+u|0,5589,2)))?m:u,!(0|Ke(0|Ne[v+m>>0]))){m=0;break r;}_=24,m=m+1|0;}for(;;){if(d>>>0<=m>>>0){var y=0;break;}if(!(95==(y=0|je[v+m>>0])<<24>>24|0!=(0|Ke(255&y)))){y=1;break;}m=m+1|0;}if(!((u=m-u|0)>>>0<=_>>>0&1<u>>>0)){m=0;break r;}if(!y)break;if(!(43==(u=0|je[v+m>>0])<<24>>24|w&45==u<<24>>24))break;if(!m){m=1;break;}u=m+1|0;}e:do{if(m>>>0<d>>>0&&47==(0|je[v+m>>0]))for(;;){if(d>>>0<=m>>>0)break e;if(!(0|Ke(255&(y=0|je[v+m>>0]))))switch(y<<24>>24){case 45:case 47:case 95:break;default:break e;}m=m+1|0;}}while(0);de(k,v+-p|0,m+p|0),ze[h>>2]=1==(0|p)&1,ze[b>>2]=p;}else m=0;}while(0);if(b=0|m)t=5;else{b=0|l,k=0|c,i|=0,a|=0,f|=0,n|=0,v=0|s,m=0;r:do{if(3<=n>>>0&&0!=(0|(m=0|g(i,a,f,n,117)))){if(!(0|Ke(255&(a=0|je[i+1>>0]))))switch(a<<24>>24){case 45:case 95:break;default:a=0;break r;}a=2;e:for(;!(n>>>0<=a>>>0);){if(!(0|Ke(255&(f=0|je[i+a>>0]))))switch(f<<24>>24){case 45:case 47:case 95:break;default:break e;}a=a+1|0;}de(k,i+-m|0,a+m|0),ze[v>>2]=1==(0|m)&1,ze[b>>2]=m;}else a=0;}while(0);(b=0|a)?t=5:b=0;}5==(0|t)&&(a=0|Te(e,1),0|ze[s>>2]&&he(a,47),de(a,0|ze[c>>2],0|ze[c+4>>2]),E(r,(0|ze[r+4>>2])-(0|ze[l>>2])|0),0|ze[(i=e+100|0)>>2]?(s=0|Te(e,1),Fe[7&ze[i>>2]](s,c,0|ze[(t=e+112|0)>>2]),yr[3&ze[e+76>>2]](r,a,0,s,0|ze[t>>2]),Oe(e,1)):yr[3&ze[e+76>>2]](r,a,0,c,0|ze[e+112>>2]),Oe(e,1)),Oe(e,1);}else b=0;return Be=o,0|b;},function(r,e,i,a,f,n){r|=0,i|=0,n|=0;var t=92+(e|=0)|0;r:do{if(n>>>0<2|0==(0|ze[t>>2]))a=0;else{e:do{if(40==(0|je[i+1>>0])){for(a=2;!(n>>>0<=a>>>0)&&41!=(0|je[i+a>>0])&&92!=(0|je[i+(a+-1)>>0]);)a=a+1|0;if((0|a)==(0|n)){a=0;break r;}n=2;}else for(a=1;;){if(n>>>0<=a>>>0){n=1;break e;}if(0|Pe(0|Ne[i+a>>0])){n=1;break e;}a=a+1|0;}}while(0);if(f=a-n|0){var o=0|Te(e,1);qe(o,e,i+n|0,f),mr[15&ze[t>>2]](r,o,0|ze[e+112>>2]),Oe(e,1),a=a+(2==(0|n)&1)|0;}else a=2==(0|n)?3:0;}}while(0);return 0|a;},f,f,f],De=[function(){cr(5);},function(r,e){var i;r|=0;var a=4+(e|=0)|0,f=0;for(i=0|ze[a>>2];!((0|i)<=0);)de(r,5762,12),ze[a>>2]=i=(0|ze[a>>2])-1|0,f=1;f&&de(r,5775,7),n(0,e);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),y(r,0==(256&ze[e+16>>2]|0)?6289:6295);},n],Fe=[function(){cr(6);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6371,13),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6356,14);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6318,37),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6356,14);},function(r,e,i){var a;r|=0,e|=0;r:do{if(0|e){for(i=0|ze[e+4>>2];;){if(!i){i=0;break;}var f=i+-1|0;if(10!=(0|je[(0|ze[e>>2])+f>>0]))break;i=f;}for(a=0;;){if(i>>>0<=a>>>0)break r;if(10!=(0|je[(f=(0|ze[e>>2])+a|0)>>0]))break;a=a+1|0;}0|ze[r+4>>2]&&(he(r,10),f=(0|ze[e>>2])+a|0),de(r,f,i-a|0),he(r,10);}}while(0);},function(r,e,i){e|=0,i|=0;var a,f,n=0,t=0;if(0|ze[4+(r|=0)>>2]&&he(r,10),0|e&&0|(n=0|ze[(t=e+4|0)>>2])){for(a=0;!(n>>>0<=a>>>0)&&0|B(0|Ne[(0|ze[e>>2])+a>>0]);)a=a+1|0;if((0|a)!=(0|n)){de(r,6248,3);r:do{if(128&ze[i+16>>2])for(;;){if((n=0|ze[t>>2])>>>0<=a>>>0)break r;for(f=a;!(n>>>0<=f>>>0)&&10!=(0|je[(0|ze[e>>2])+f>>0]);)f=f+1|0;if(((a=a>>>0<f>>>0?(de(r,(0|ze[e>>2])+a|0,f-a|0),0|ze[t>>2]):n)+-1|0)>>>0<=f>>>0)break r;w(r,i),a=f+1|0;}else de(r,(0|ze[e>>2])+a|0,(0|ze[t>>2])-a|0);}while(0);de(r,6252,5);}}},function(r,e){e|=0,de(r|=0,6184,5),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6190,6);},function(r,e){0|(e|=0)&&P(0|r,0|ze[e>>2],0|ze[e+4>>2]);},function(r,e,i){r|=0,0|ze[32+(i|=0)>>2]&&de(r,5352,15),0|ze[(e=i+36|0)>>2]&&(de(r,5368,9),y(r,0|ze[e>>2]),he(r,34));}],Ye=[tr,function(r,e,i,a){r|=0,e|=0,i|=0;var f=4+(a|=0)|0,n=0|ze[f>>2],t=a+8|0;n?t=0|ze[t>>2]:(n=i+-1|0,de(r,5921,18),t=ze[t>>2]=n,n=0|ze[f>>2]),t=i-t|0;r:do{if((0|n)<(0|t))for(;;){if((0|t)<=(0|n))break r;de(r,5940,10),ze[f>>2]=n=1+(0|ze[f>>2])|0;}else if((0|n)<=(0|t))de(r,5977,11);else{for(de(r,5951,6),n=0|ze[f>>2];!((0|n)<=(0|t));)de(r,5958,12),ze[f>>2]=n=(0|ze[f>>2])-1|0;de(r,5971,5);}}while(0);de(r,5989,10),0|(n=0|ze[a+12>>2])&&y(r,n),de(r,6e3,4),ze[a>>2]=1+(f=0|ze[a>>2]),l(r,f),de(r,6005,2),0|e&&P(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6008,5);},function(r,e,i,a){e|=0,i|=0;var f,n,t=0,o=0,l=0,s=0;if(0|ze[4+(r|=0)>>2]&&he(r,10),0!=(0|i)&&0!=(0|ze[(l=i+4|0)>>2])){for(de(r,6385,18),a=n=0;;){var u=0|ze[l>>2];if(u>>>0<=a>>>0)break;for(;!(u>>>0<=a>>>0);){if(!(0|B(255&(t=0|je[(o=0|ze[i>>2])+a>>0])))){s=10;break;}a=a+1|0;}if(10==(0|s)){for(s=0,f=a;!(u>>>0<=f>>>0||0|B(0|Ne[o+f>>0]));)f=f+1|0;t=a+(46==t<<24>>24&1)|0,P(r,(a=n?(he(r,32),0|ze[i>>2]):o)+t|0,f-t|0),a=f;}n=n+1|0,a=a+1|0;}de(r,6005,2);}else de(r,6404,11);0|e&&P(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6416,14);},function(r,e,i,a){e|=0,i|=0,a|=0,0|ze[4+(r|=0)>>2]&&he(r,10);var f=0==(64&ze[a+16>>2]|0);de(r,6302,2),l(r,i),f?de(r,6168,1):(de(r,6305,5),0|(f=0|ze[a+12>>2])&&y(r,f),de(r,6e3,4),ze[a>>2]=1+(f=0|ze[a>>2]),l(r,f),de(r,6005,2)),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6311,3),l(r,i),de(r,6315,2);},function(r,e,i){e|=0,i|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,(i=0!=(1&i|0))?6263:6269,5),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,i?6275:6282,6);},function(r,e,i,a){if(e|=0,de(r|=0,6258,4),0|e){var f=0|ze[e>>2];for(i=0|ze[e+4>>2];;){if(!i){i=0;break;}if(10!=(0|je[f+(a=i+-1|0)>>0]))break;i=a;}de(r,f,i);}de(r,5951,6);},function(r,e,i){e|=0,i|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6197,15),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6213,16),0|i&&de(r,0|ze[i>>2],0|ze[i+4>>2]),de(r,6230,17);},tr],Ar=[function(){cr(8);},function(r,e,i,a,f){switch(r|=0,e|=0,f|=0,(a=0!=(4&(i|=0)|0))?de(r,6098,3):de(r,6102,3),1<(0|f)&&(de(r,6106,10),l(r,f),de(r,6117,2)),3&i){case 3:de(r,6120,16);break;case 1:de(r,6137,14);break;case 2:de(r,6152,15);break;default:de(r,6168,1);}0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,a?6170:6177,6);}];return{___muldi3:V,___udivdi3:Q,_bitshift64Lshr:rr,_bitshift64Shl:er,_default_renderer:function(r,e,i,a,f,n){return r|=0,e|=0,i|=0,a|=0,f|=0,n|=0,0|ze[2284]||(ze[2284]=1,ze[2092]=0|t(8528,805,0),ze[2093]=0|t(8680,805,1),ze[2094]=8528,ze[2095]=8680),0|o(r,e,i,a,f,0,n);},_free:Me,_i64Add:Z,_i64Subtract:$,_llvm_ctpop_i32:ir,_malloc:U,_memcpy:ar,_memmove:Le,_memset:fr,_sbrk:nr,_wiki_renderer:function(r,e,i,a,f,n){return r|=0,e|=0,i|=0,a|=0,f|=0,n|=0,0|ze[2285]||(ze[2285]=1,ze[2096]=0|t(8832,1825,0),ze[2097]=0|t(8984,1825,1),ze[2098]=8832,ze[2099]=8984),0|o(r,e,i,a,f,1,n);},dynCall_iii:function(r,e,i){return 0|pr[1&(0|r)](0|e,0|i);},dynCall_iiii:function(r,e,i,a){return 0|mr[15&(0|r)](0|e,0|i,0|a);},dynCall_iiiii:function(r,e,i,a,f){return 0|_r[1&(0|r)](0|e,0|i,0|a,0|f);},dynCall_iiiiii:function(r,e,i,a,f,n){return 0|yr[3&(0|r)](0|e,0|i,0|a,0|f,0|n);},dynCall_iiiiiii:function(r,e,i,a,f,n,t){return 0|gr[15&(0|r)](0|e,0|i,0|a,0|f,0|n,0|t);},dynCall_vii:function(r,e,i){De[3&(0|r)](0|e,0|i);},dynCall_viii:function(r,e,i,a){Fe[7&(0|r)](0|e,0|i,0|a);},dynCall_viiii:function(r,e,i,a,f){Ye[7&(0|r)](0|e,0|i,0|a,0|f);},dynCall_viiiii:function(r,e,i,a,f,n){Ar[1&(0|r)](0|e,0|i,0|a,0|f,0|n);},establishStackSpace:function(r){Be=0|r;},stackAlloc:function(r){var e=Be;return Be=15+(Be=Be+(0|r)|0)&-16,0|e;},stackRestore:function(r){Be=0|r;},stackSave:function(){return 0|Be;}};}({Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array},{a:snudown_es_f,b:function(r){snudown_es_k=r;},c:function(){return snudown_es_k;},d:function(){return 0;},e:function(){return snudown_es_d;},f:function(r,e,i){snudown_es_b.set(snudown_es_b.subarray(e,e+i),r);},g:function(){return!1;},h:9424,i:9184},s),o.___muldi3=s.___muldi3,o.___udivdi3=s.___udivdi3,o._bitshift64Lshr=s._bitshift64Lshr,o._bitshift64Shl=s._bitshift64Shl;var snudown_es_y=o._default_renderer=s._default_renderer,snudown_es_g=o._free=s._free;o._i64Add=s._i64Add,o._i64Subtract=s._i64Subtract,o._llvm_ctpop_i32=s._llvm_ctpop_i32,o._malloc=s._malloc,o._memcpy=s._memcpy,o._memmove=s._memmove,o._memset=s._memset,o._sbrk=s._sbrk;var A=o._wiki_renderer=s._wiki_renderer;o.establishStackSpace=s.establishStackSpace;var C=o.stackAlloc=s.stackAlloc,S=o.stackRestore=s.stackRestore,R=o.stackSave=s.stackSave;if(o.dynCall_iii=s.dynCall_iii,o.dynCall_iiii=s.dynCall_iiii,o.dynCall_iiiii=s.dynCall_iiiii,o.dynCall_iiiiii=s.dynCall_iiiiii,o.dynCall_iiiiiii=s.dynCall_iiiiiii,o.dynCall_vii=s.dynCall_vii,o.dynCall_viii=s.dynCall_viii,o.dynCall_viiii=s.dynCall_viiii,o.dynCall_viiiii=s.dynCall_viiiii,o.asm=s,snudown_es_t&&function(r){var e,i=r.length;for(e=0;e<i;++e)snudown_es_b[8+e]=r.charCodeAt(e);}(snudown_es_t),(snudown_es_i.prototype=Error()).constructor=snudown_es_i,o.run=snudown_es_a,o.abort=snudown_es_f,o.preInit)for("function"==typeof o.preInit&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();o.noExitRuntime=!0,snudown_es_a();function snudown_es_markdown(r,e){return n(snudown_es_y,r,e);}function markdownWiki(r,e){return n(A,r,e);}
// CONCATENATED MODULE: ./lib/modules/hosts/github.js




/* harmony default export */ var github = (new Host('github', {
  domains: ['gist.github.com'],
  logo: 'https://assets-cdn.github.com/favicon.ico',
  name: 'github gists',
  detect: ({
    pathname
  }) => /^\/(?:[\w-]+\/)?([a-z0-9]{20,}|\d+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      files,
      description
    } = await ajax({
      url: `https://api.github.com/gists/${id}`,
      type: 'json',
      cacheFor: DAY
    });
    let src = '';

    for (const [filename, {
      content,
      language,
      truncated
    }] of Object.entries(files)) {
      src += string_namespaceObject.escape`<h5>${filename}:</h5>`;

      if (language === 'Markdown') {
        src += snudown_es_markdown(content);
      } else {
        src += string_namespaceObject.escape`<pre><code>${content}</code></pre>`;
      }

      if (truncated) {
        src += '<p>&lt;file truncated&gt;</p>';
      }
    }

    return {
      type: 'TEXT',
      title: description,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/googlemaps.js

/* harmony default export */ var googlemaps = (new Host('googlemaps', {
  domains: ['maps.google.ca', 'maps.google.com', 'google.co.uk', 'google.com', 'google.ca'],
  logo: 'https://maps.google.com/favicon.ico',
  name: 'Google Maps',
  detect: ({
    host,
    searchParams,
    pathname
  }) => {
    if (host.startsWith('maps.') || pathname.startsWith('/maps')) {
      const coords = searchParams.get('ll') || searchParams.get('q');

      if (coords) {
        return [coords, searchParams.get('z'), searchParams.has('maptype') ? searchParams.get('maptype') : 'roadmap'];
      } else {
        const location = pathname.split('/').find(part => part.startsWith('@'));

        if (location) {
          const [long, lat, zoom] = location.substring(1).split(',');
          return [`${long},${lat}`, zoom.endsWith('z') ? zoom : 16, zoom.endsWith('z') ? 'roadmap' : 'satellite'];
        }
      }
    }
  },

  handleLink(href, [coords, zoom, mapType]) {
    let embed = `https://www.google.com/maps/embed/v1/view?center=${coords}&key=AIzaSyCtnLZP1XwkgIK53Asx_5qtZa2k9eZcdDc`;
    if (zoom) embed += `&zoom=${zoom}`;
    if (mapType) embed += `&maptype=${mapType}`;
    return {
      type: 'IFRAME',
      embed,
      muted: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/graphiq.js



/* harmony default export */ var graphiq = (new Host('graphiq', {
  name: 'graphiq',
  domains: ['graphiq.com'],
  logo: 'https://www.graphiq.com/favicon.ico',
  landingPage: 'https://www.graphiq.com/',
  detect: ({
    pathname
  }) => /^\/(?:w|wlp|vlp)\/([A-z0-9]+)/i.exec(pathname),

  async handleLink(href, [url, id]) {
    const {
      width = '640',
      height = '360'
    } = await ajax({
      url: 'https://oembed.graphiq.com/services/oembed',
      query: {
        url
      },
      type: 'json',
      cacheFor: DAY
    });
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.graphiq.com/w/${id}`,
      width: `${width}px`,
      height: `${height}px`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gyazo.js


/* harmony default export */ var gyazo = (new Host('gyazo', {
  name: 'gyazo',
  domains: ['gyazo.com'],
  permissions: ['https://api.gyazo.com/api/oembed'],
  logo: 'https://gyazo.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w{32})\b/i.exec(pathname),

  async handleLink(href, [, id]) {
    const info = await ajax({
      url: 'https://api.gyazo.com/api/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
        return {
          type: 'IMAGE',
          src: info.url
        };

      case 'video':
        return {
          type: 'VIDEO',
          muted: true,
          loop: true,
          fallback: `https://i.gyazo.com/${id}.gif`,
          sources: [{
            source: `https://i.gyazo.com/${id}.mp4`,
            type: 'video/mp4'
          }]
        };

      default:
        throw new Error(`Invalid media type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/hastebin.js

/* harmony default export */ var hastebin = (new Host('hastebin', {
  name: 'hastebin',
  domains: ['hastebin.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:raw\/)?([^\/]+)/i.exec(pathname),

  handleLink(href, [, filename]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://hastebin.com/${filename}`,
      height: '500px',
      width: '800px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/iloopit.js

/* harmony default export */ var iloopit = (new Host('iloopit', {
  name: 'iLoopit - gif maker',
  domains: ['iloopit.net'],
  logo: 'https://iloopit.net/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(\w+\.)?iloopit\.net\/.+?\/\?type=looplayer&loopid=(\d+)/i.exec(href) || /^https?:\/\/(\w+\.)?iloopit\.net(\/tube)?\/(\d+)\/.+?\/(\?type=(looplayer)|(embed))?/i.exec(href),

  handleLink(href) {
    let link = '';
    const testWithTitle = /iloopit\.net(?:\/tube)?\/(\d+)\/(.+)?\//;
    const titleResult = testWithTitle.exec(href);

    if (titleResult) {
      link = `https://iloopit.net/${titleResult[1]}/${titleResult[2]}/?type=embed`;
    } else {
      link = href.replace('type=looplayer', 'type=embed');
    }

    return {
      type: 'IFRAME',
      muted: true,
      embed: link,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgflip.js

/* harmony default export */ var imgflip = (new Host('imgflip', {
  name: 'imgflip',
  domains: ['imgflip.com'],
  logo: 'https://imgflip.com/favicon02.png',
  detect: ({
    pathname
  }) => /^\/(i|gif)\/([a-z0-9]+)/.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IMAGE',
      src: `https://i.imgflip.com/${id}.${type === 'gif' ? 'gif' : 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgur.js



/* harmony default export */ var imgur = (new Host('imgur', {
  name: 'imgur',
  domains: ['imgur.com'],
  logo: 'https://i.imgur.com/favicon.ico',
  options: {
    preferResAlbums: {
      title: 'imgurPreferResAlbumsTitle',
      description: 'imgurPreferResAlbumsDesc',
      value: true,
      type: 'boolean'
    },
    useGifOverGifv: {
      title: 'imgurUseGifOverGifVTitle',
      description: 'imgurUseGifOverGifVDesc',
      value: false,
      type: 'boolean'
    },
    preferredImgurLink: {
      title: 'imgurPreferredImgurLinkTitle',
      description: 'imgurPreferredImgurLinkDesc',
      type: 'enum',
      value: 'share',
      values: [{
        name: 'full page (imgur.com)',
        value: 'share'
      }, {
        name: 'direct image (i.imgur.com)',
        value: 'direct'
      }]
    },
    imgurImageResolution: {
      title: 'imgurImageResolutionTitle',
      description: 'imgurImageResolutionDesc',
      type: 'enum',
      value: '',
      values: [{
        name: 'Full Resolution',
        value: ''
      }, {
        name: 'Retina (1360px)',
        value: 'r'
      }, {
        name: 'Huge (1024px)',
        value: 'h'
      }, {
        name: 'Giant (680px)',
        value: 'g'
      }, {
        name: 'Large (640px)',
        value: 'l'
      }]
    }
  },

  detect({
    pathname,
    href
  }) {
    const hashRe = /^https?:\/\/(?:i\.|m\.|edge\.|www\.)*imgur\.com\/(r\/\w+\/)*(?!gallery)(?!removalrequest)(?!random)(?!memegen)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gifv?|png))?(\?.*)?$/i;
    const hostedHashRe = /^https?:(\/\/i\.\w+\.*imgur\.com\/)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gif|png))?(\?.*)?$/i;
    const galleryHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/gallery\/(\w+)(?:[/#]|$)/i;
    const albumHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/a\/(\w+)(?:[/#]|$)/i;
    if (pathname === '/rules' || pathname === '/inbox') return null;
    href = href.split('?')[0];
    let groups;

    if (groups = galleryHashRe.exec(href)) {
      const hash = groups[1];
      return () => _api(string_namespaceObject.encode`gallery/${hash}`).catch(() => _api(string_namespaceObject.encode`album/${hash}`));
    } else if (groups = albumHashRe.exec(href)) {
      if (this.options.preferResAlbums.value) {
        const hash = groups[1];
        return () => _api(string_namespaceObject.encode`album/${hash}`);
      }
    } else if (groups = hostedHashRe.exec(href)) {
      const hash = groups[2];
      return () => _handleImage(hash, href);
    } else if (groups = hashRe.exec(href)) {
      const [, subreddit, hash] = groups;
      if (subreddit) return () => _api(string_namespaceObject.encode`gallery/${subreddit}${hash}`);

      if (hash.search(/[&,]/) > -1) {
        return () => _handleImageCollection(hash.split(/[&,]/), href);
      } else {
        return () => _handleImage(hash, href);
      }
    }

    return false;

    async function _api(endpoint) {
      const {
        data
      } = await ajax({
        url: 'https://api.imgur.com/3/' + endpoint,
        type: 'json',
        headers: {
          Authorization: `Client-ID ${'1d8d9b36339e0e2'}`
        }
      });

      if (data.error) {
        throw new Error(`Imgur API error: ${data.error}`);
      }

      return data;
    }

    function _mockImageAPI(hash, url) {
      let thisCdnUrl = 'https://i.imgur.com/';
      let matches, extension;

      if (matches = hostedHashRe.exec(url)) {
        thisCdnUrl = matches[1];
        extension = matches[3];
      } else if (matches = hashRe.exec(url)) {
        extension = matches[3];
      }

      if (!extension) {
        extension = '.jpg';
      }

      return {
        id: hash,
        animated: false,
        looping: false,
        has_sound: false,
        link: `${thisCdnUrl}${hash}${extension}`,
        gifv: undefined,
        title: '',
        description: ''
      };
    }

    function _handleImage(hash, url) {
      const [,,, extension] = hashRe.exec(url) || [];

      if (['.png', '.jpg', '.jpeg'].includes(extension)) {
        return _mockImageAPI(hash, url);
      } else if (hostedHashRe.test(url)) {
        return _mockImageAPI(hash, url);
      } else {
        return _api(`image/${hash}`);
      }
    }

    function _handleImageCollection(hashes, url) {
      return {
        is_album: true,
        images: hashes.map(hash => _mockImageAPI(hash, url)),
        title: '',
        description: ''
      };
    }
  },

  async handleLink(href, getInfo) {
    const baseUrl = 'https://imgur.com/';
    const shareLinkPreferred = this.options.preferredImgurLink.value === 'share';
    const resolutionSuffix = this.options.imgurImageResolution.value;
    const useGif = this.options.useGifOverGifv.value;
    const info = await getInfo();

    if (info.images && info.images.length) {
      return _handleAlbum(href, info);
    } else if (info.gifv && !useGif) {
      return _handleGifv(info);
    } else if (info.link) {
      return _handleSingleImage(info);
    }

    throw new Error('could not handle info');

    function _handleAlbum(href, info) {
      return {
        type: 'GALLERY',
        title: info.title,
        caption: info.description,
        src: info.images.map(info => {
          const media = info.gifv && !useGif ? _handleGifv(info) : _handleSingleImage(info);
          media.href = shareLinkPreferred ? `${href.split('#')[0]}#${info.id}` : `${info.link}`;
          return media;
        })
      };
    }

    function _handleSingleImage(info) {
      const src = info.link.replace('http:', 'https:').replace(`/${info.id}.`, `/${info.id}${resolutionSuffix}.`);
      return {
        src,
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        type: 'IMAGE',
        caption: info.description,
        title: info.title
      };
    }

    function _handleGifv(info) {
      return {
        type: 'VIDEO',
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        fallback: info.link.replace('http:', 'https:'),
        caption: info.description,
        title: info.title,
        loop: info.looping !== false,
        muted: !info.has_sound,
        sources: [{
          source: info.mp4.replace('http:', 'https:'),
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/instagram.js

/* harmony default export */ var instagram = (new Host('instagram', {
  name: 'Instagram',
  domains: ['instagram.com', 'instagr.am'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/p\/([a-z0-9_\-]{10,})(?:\/|$)/i.exec(pathname),
  handleLink: (href, [, id]) => ({
    type: 'IFRAME',
    expandoClass: 'image',
    embed: `https://instagram.com/p/${id}/embed/captioned/`,
    width: '600px',
    height: '700px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/ireddit.js


/* harmony default export */ var ireddit = (new Host('ireddit', {
  name: 'i.redd.it',
  domains: ['i.redd.it'],
  attribution: false,

  detect({
    pathname
  }, thing) {
    return pathname.endsWith('.gif') && thing && thing.isLinkPost() && thing.getFullname();
  },

  async handleLink(href, fullname) {
    const postMetadata = await getPostMetadata({
      id: fullname.replace('t3_', '')
    });
    if (!postMetadata.preview) throw new Error('Post has no preview.');
    const preview = postMetadata.preview.images[0];

    if (preview.variants.mp4) {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        fallback: preview.variants.gif && preview.variants.gif.source.url,
        sources: [{
          source: preview.variants.mp4.source.url,
          type: 'video/mp4'
        }]
      };
    } else {
      return {
        type: 'IMAGE',
        src: preview.source.url
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/jsfiddle.js

/* harmony default export */ var jsfiddle = (new Host('jsfiddle', {
  name: 'jsfiddle',
  domains: ['jsfiddle.net'],
  logo: 'https://jsfiddle.net/favicon.png',
  detect: ({
    pathname
  }) => /^(\/(?:\w+\/(?!embedded\/))?[a-z0-9]{5,}(?:\/\d+)?(?=\/|$))(\/embedded\/[\w,]+\/)?/i.exec(pathname),

  handleLink(href, [, path, categories]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://jsfiddle.net${path}${categories || '/embedded/result,js,resources,html,css/'}`,
      width: '800px',
      height: '500px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/liveleak.js

/* harmony default export */ var liveleak = (new Host('liveleak', {
  name: 'LiveLeak',
  domains: ['liveleak.com'],
  logo: 'https://www.liveleak.com/favicon.ico',
  detect: ({
    pathname,
    search
  }) => pathname === '/view' && search,
  handleLink: (href, query) => ({
    type: 'IFRAME',
    embed: `https://www.liveleak.com/ll_embed${query}`,
    embedAutoplay: `https://www.liveleak.com/ll_embed${query}&autostart=true`,
    fixedRatio: true
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/livememe.js

/* harmony default export */ var livememe = (new Host('livememe', {
  name: 'livememe',
  domains: ['livememe.com'],
  logo: 'https://livememe.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?!edit)(\w{7})(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://e.lvme.me/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/makeameme.js

/* harmony default export */ var makeameme = (new Host('makeameme', {
  name: 'makeameme',
  domains: ['makeameme.org'],
  logo: 'https://makeameme.org/images/favicons/favicon-32x32.png',
  detect: ({
    pathname
  }) => /^\/meme\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://makeameme.org/media/created/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/masterypoints.js

/* harmony default export */ var masterypoints = (new Host('masterypoints', {
  name: 'MasteryPoints',
  domains: ['masterypoints.com'],
  logo: 'https://www.masterypoints.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/player\/(.{3,30})\/([a-zA-Z]{0,4})\b/i.exec(pathname),

  handleLink(href, [, player, server]) {
    return {
      type: 'IFRAME',
      muted: true,
      expandoClass: 'selftext',
      embed: `https://www.masterypoints.com/oembed/player/${player}/${server}`,
      height: '600px',
      width: '600px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memecrunch.js

/* harmony default export */ var memecrunch = (new Host('memecrunch', {
  name: 'memecrunch',
  domains: ['memecrunch.com'],
  logo: 'https://memecrunch.com/static/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9A-Z]+)\/([\w\-]+)(\/image\.(png|jpg))?/i.exec(pathname),

  handleLink(href, [, id, format]) {
    return {
      type: 'IMAGE',
      src: `https://memecrunch.com/meme/${id}/${format || 'null'}/image.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memedad.js

/* harmony default export */ var memedad = (new Host('memedad', {
  name: 'memedad',
  domains: ['memedad.com'],
  logo: 'https://memedad.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://memedad.com/memes/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memegen.js

/* harmony default export */ var memegen = (new Host('memegen', {
  name: 'memegen',
  domains: ['memegen.com', 'memegen.de', 'memegen.nl', 'memegen.fr', 'memegen.it', 'memegen.es', 'memegen.se', 'memegen.pl'],
  logo: 'http://www.memegen.com/favicon.ico',
  detect: ({
    pathname
  }) => /^(\/a)?\/(?:meme|mem|mim)\/([A-Za-z0-9]+)/i.exec(pathname),

  handleLink(href, [, isAnimated, id]) {
    return {
      type: 'IMAGE',
      src: `http://${isAnimated ? 'a' : 'm'}.memegen.com/${id}.${isAnimated ? 'gif' : 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/mixer.js

/* harmony default export */ var mixer = (new Host('mixer', {
  name: 'Mixer',
  domains: ['beam.pro', 'mixer.com'],
  logo: 'https://mixer.com/_latest/assets/favicons/favicon-32x32.png',
  detect: ({
    pathname
  }) => /^\/(\w+)$/.exec(pathname),

  handleLink(href, [, clipId]) {
    return {
      type: 'IFRAME',
      muted: true,
      embed: `https://mixer.com/embed/player/${clipId}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/onedrive.js



/* harmony default export */ var onedrive = (new Host('onedrive', {
  domains: ['onedrive.live.com', '1drv.ms'],
  name: 'Microsoft OneDrive',
  detect: () => true,

  async handleLink(href) {
    const encodedUrl = `u!${btoa(href)}`.replace(/=+$/g, '').replace(/\//g, '_').replace(/\+/g, '-');
    const json = await ajax({
      url: `https://api.onedrive.com/v1.0/shares/${encodedUrl}/root?expand=children`,
      type: 'json',
      cacheFor: DAY
    });

    if (json.children.length) {
      return {
        type: 'GALLERY',
        src: json.children.map(processFile)
      };
    } else {
      return processFile(json);
    }

    function processFile({
      name,
      description,
      webUrl,
      '@content.downloadUrl': src,
      file: {
        mimeType
      }
    }) {
      const type = mimeType.slice(0, mimeType.indexOf('/'));

      switch (type) {
        case 'image':
          return {
            type: 'IMAGE',
            title: name,
            caption: description,
            src,
            href: webUrl
          };

        case 'video':
          return {
            type: 'VIDEO',
            title: name,
            caption: description,
            loop: false,
            sources: [{
              source: src,
              type: mimeType
            }]
          };

        case 'audio':
          return {
            type: 'AUDIO',
            loop: false,
            sources: [{
              file: src,
              type: mimeType
            }]
          };

        default:
          throw new Error(`Invalid type: ${type}`);
      }
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pastebin.js

/* harmony default export */ var pastebin = (new Host('pastebin', {
  name: 'pastebin',
  domains: ['pastebin.com'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?pastebin\.com\/(?:raw\.php\?i=|index\/)?([a-z0-9]{8})/i.exec(href),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://pastebin.com/embed_iframe.php?i=${id}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/peertube.js

/* harmony default export */ var peertube = (new Host('peertube', {
  name: 'peertube',
  domains: ['peervideo.net', 'peertube.social', 'peertube.mastodon.host', 'evertron.tv', 'mplayer.demouliere.eu', 'cloud.allplayer.tk', 'video.tedomum.net', 'peertube.fr', 'hostyour.tv', 'videobit.cc', 'videoshare.cc', 'peertube.openstreetmap.fr', 'video.ploud.fr', 'tube.kdy.ch', 'lostpod.space', 'pe.ertu.be', 'peertube.live', 'peer.tube', 'watching.cypherpunk.observer', 'queertube.org', 'exode.me', 'framatube.org'],
  attribution: false,
  detect: ({
    hostname,
    pathname
  }) => {
    const [, route,, id] = pathname.split('/');

    if (route === 'videos') {
      return [hostname, id];
    }
  },

  handleLink(href, [hostname, id]) {
    const embed = `https://${hostname}/videos/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/photobucket.js


/* harmony default export */ var photobucket = (new Host('photobucket', {
  name: 'photobucket',
  domains: ['photobucket.com'],
  logo: 'https://pic2.pbsrc.com/common/favicon.ico',
  detect: ({
    href
  }) => /([is]?)[0-9]+|media|smg|img(?=.photobucket.com)/i.exec(href),

  async handleLink(href, [, prefix]) {
    let src = href.replace('.html', '');

    if (prefix !== 'i') {
      const {
        imageUrl
      } = await ajax({
        url: 'https://api.photobucket.com/v2/media/fromurl',
        query: {
          url: src
        },
        type: 'json'
      });
      src = imageUrl.replace('http:', 'https:');
    }

    return {
      type: 'IMAGE',
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/picshd.js

/* harmony default export */ var picshd = (new Host('picshd', {
  name: 'picshd',
  domains: ['picshd.com'],
  logo: 'http://picshd.com/assets/ico/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w{5,})(?:\.\w+)?$/i.exec(pathname),

  handleLink(href, [, hash]) {
    return {
      type: 'IMAGE',
      src: `http://i.picshd.com/${hash}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pixiv.js

/* harmony default export */ var pixiv = (new Host('pixiv', {
  name: 'pixiv',
  domains: ['pixiv.net'],
  logo: 'https://www.pixiv.net/favicon.ico',
  detect: ({
    pathname,
    searchParams
  }) => pathname === '/member_illust.php' && searchParams.get('illust_id'),

  handleLink(href, id) {
    return {
      type: 'IFRAME',
      expandoClass: 'image',
      muted: true,
      embed: `https://embed.pixiv.net/embed_mk2.php?id=${id}&size=large`,
      width: '700px',
      height: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/poly.js

/* harmony default export */ var poly = (new Host('poly', {
  name: 'Poly',
  domains: ['poly.google.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/view\/([a-zA-Z0-9-]+)\/?$/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://poly.google.com/view/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pornbot.js



/* harmony default export */ var pornbot = (new Host('pornbot', {
  name: 'pornbot',
  domains: ['pornbot.net'],
  logo: 'https://pornbot.net/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([a-z0-9]{8,})/i.exec(pathname),

  async handleLink(href, [, hash]) {
    const info = await ajax({
      url: 'https://pornbot.net/ajax/info.php',
      query: {
        v: hash
      },
      type: 'json',
      cacheFor: DAY
    });
    return {
      type: 'VIDEO',
      loop: true,
      muted: true,
      poster: info.poster,
      sources: [{
        source: info.mp4Url,
        type: 'video/mp4'
      }]
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pornhub.js

/* harmony default export */ var pornhub = (new Host('pornhub', {
  name: 'Pornhub',
  domains: ['www.pornhub.com', 'www.pornhubpremium.com'],
  attribution: false,
  detect: ({
    searchParams
  }) => searchParams.get('viewkey'),

  handleLink(href, path) {
    const url = `https://www.pornhub.com/embed/${path}`;
    return {
      type: 'IFRAME',
      embed: url,
      embedAutoplay: `${url}?autoplay=1`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ppy.js

/* harmony default export */ var ppy = (new Host('ppy.sh', {
  name: 'ppy.sh',
  domains: ['osu.ppy.sh'],
  logo: 'https://s.ppy.sh/favicon.ico',
  detect: ({
    pathname
  }) => /^\/ss\/(\d+)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://osu.ppy.sh/ss/${code}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/qwipit.js

/* harmony default export */ var qwipit = (new Host('qwipit', {
  name: 'qwipit',
  domains: ['qwip.it'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/\w+\/(\w+)/i.exec(pathname),

  handleLink(href, [, hash]) {
    return {
      type: 'IFRAME',
      embed: `https://qwip.it/reddit/${hash}`,
      height: '375px',
      width: '485px',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/rawprogress.js

/* harmony default export */ var rawprogress = (new Host('rawprogress', {
  name: 'Raw progress',
  domains: ['rawprogress.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/e(?:mbed)?\/([^\/]+)/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'image',
      embed: `https://rawprogress.com/embed/${id}`,
      muted: true,
      height: '700px',
      width: '800px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditbooru.js


/* harmony default export */ var redditbooru = (new Host('redditbooru', {
  name: 'redditbooru',
  domains: ['redditbooru.com'],
  logo: 'https://redditbooru.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/gallery\/([\w]+)(\/[\w\-]+)?/i.exec(pathname),

  async handleLink(href, [, id, base36]) {
    if (base36) {
      id = parseInt(id, 36);
    }

    const info = await ajax({
      url: 'https://redditbooru.com/images/',
      query: {
        postId: id
      },
      type: 'json'
    });

    if (!info.length) {
      throw new Error('Gallery was empty.');
    }

    const src = info.map(({
      caption,
      cdnUrl,
      sourceUrl
    }) => ({
      type: 'IMAGE',
      title: caption,
      src: cdnUrl,
      caption: sourceUrl ? `Source: <a href="${sourceUrl}">${sourceUrl}</a>` : ''
    }));
    return {
      type: 'GALLERY',
      title: info[0].title,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditmedia.js

/* harmony default export */ var redditmedia = (new Host('redditmedia', {
  name: 'redditmedia',
  domains: ['redditmedia.com'],
  attribution: false,
  detect: ({
    hostname,
    searchParams
  }) => hostname !== 'pixel.redditmedia.com' && searchParams,

  handleLink(href, searchParams) {
    if (searchParams.get('fm') === 'mp4') {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: href,
          type: 'video/mp4'
        }]
      };
    }

    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/reddituploads.js

/* harmony default export */ var reddituploads = (new Host('reddituploads', {
  name: 'reddituploads',
  domains: ['reddituploads.com'],
  attribution: false,
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ridewithgps.js

/* harmony default export */ var ridewithgps = (new Host('ridewithgps', {
  name: 'ridewithgps',
  domains: ['ridewithgps.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(trips|routes)\/(\d+)/i.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IFRAME',
      embed: `https://ridewithgps.com/${type}/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/simplecove.js


/* harmony default export */ var simplecove = (new Host('simplecove', {
  name: 'SimpleCove',
  domains: ['simplecove.com'],
  logo: 'https://simplecove.com/static/images/reslogo.jpg',
  detect: ({
    pathname
  }) => /^\/(\d+)/i.exec(pathname),

  async handleLink(elem, [, id]) {
    const data = await ajax({
      url: `https://www.simplecove.com/resapi/${id}`,
      type: 'json'
    });
    const images = data.map(x => ({
      src: x.photo_src.replace('http:', 'https:'),
      caption: x.photo_caption,
      type: 'IMAGE'
    }));
    return {
      type: 'GALLERY',
      src: images
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/snag.js

/* harmony default export */ var snag = (new Host('snag', {
  name: 'snag.gy',
  logo: 'https://snaggys3static-snaggy.netdna-ssl.com/favicon.png',
  domains: ['snag.gy'],
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\.(\w+))?$/i.exec(pathname),

  handleLink(href, [, id, extension]) {
    return {
      type: 'IMAGE',
      src: `https://i.snag.gy/${id}.${extension || 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/soundcloud.js


/* harmony default export */ var soundcloud = (new Host('soundcloud', {
  name: 'soundcloud',
  domains: ['soundcloud.com'],
  logo: 'https://a-v2.sndcdn.com/assets/images/sc-icons/favicon-2cadd14b.ico',
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IFRAME',
      embed: string_namespaceObject.encode`https://w.soundcloud.com/player/?url=${href}`,
      height: '166px',
      width: '700px',
      pause: '{"method":"pause"}',
      play: '{"method":"play"}'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/spotify.js

/* harmony default export */ var spotify = (new Host('spotify', {
  name: 'spotify',
  domains: ['spotify.com'],
  logo: 'https://spotify.com/favicon.ico',
  detect: ({
    href
  }) => /^https:\/\/(?:open|play)\.spotify\.com\/((?:track|artist|album|user\/\w+\/playlist)\/[a-zA-z0-9]+)$/i.exec(href),

  handleLink(href, [, uri]) {
    return {
      type: 'IFRAME',
      embed: `https://embed.spotify.com/?uri=spotify:${uri.replace(/\//g, ':')}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steamcommunity.js


/* harmony default export */ var steamcommunity = (new Host('steamcommunity', {
  name: 'Steam Community',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steamcommunity.com'],
  detect: ({
    pathname,
    searchParams
  }) => pathname.startsWith('/sharedfiles/filedetails') && searchParams.get('id'),
  permissions: ['https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/*'],

  async handleLink(href, id) {
    const {
      response: {
        publishedfiledetails: [{
          title,
          description: caption,
          preview_url: previewUrl,
          file_url: fileUrl,
          filename
        }]
      }
    } = await ajax({
      method: 'POST',
      url: 'https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v0001/?format=json',
      data: {
        itemcount: '1',
        'publishedfileids[0]': id
      },
      type: 'json'
    });
    if (!filename) throw new Error('Response missing filename. (Private Steam Community profile?)');
    return {
      type: 'IMAGE',
      title,
      caption,
      src: ['.png', '.jpg', '.gif'].some(ext => filename.endsWith(ext)) ? fileUrl : previewUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steampowered.js

/* harmony default export */ var steampowered = (new Host('steampowered', {
  name: 'Steam',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steampowered.com', 'steamusercontent.com'],
  detect: ({
    pathname
  }) => /^\/ugc\/(\d{15,20}\/\w{40})(?:$|\/)/i.exec(pathname),

  handleLink(href, [pathname]) {
    return {
      type: 'IMAGE',
      src: `http://images.akamai.steamusercontent.com${pathname}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollcom.js

/* harmony default export */ var strawpollcom = (new Host('strawpoll.com', {
  name: 'strawpoll.com',
  domains: ['strawpoll.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed\/)?([a-z0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.strawpoll.com/embed/${id}`,
      height: '450px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollme.js

/* harmony default export */ var strawpollme = (new Host('strawpoll', {
  name: 'strawpoll.me',
  domains: ['strawpoll.me'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed_\d\/)?(\d+)/i.exec(pathname),

  handleLink(href, [, uid]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.strawpoll.me/embed_1/${uid}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamable.js


/* harmony default export */ var streamable = (new Host('streamable', {
  name: 'streamable',
  domains: ['streamable.com'],
  logo: 'https://cdn-e2.streamable.com/static/14a98f7cb1ddc5213329c039dc39cac543ba410f/img/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:[es]\/)?(\w+)(?:\/\w+)?$/i.exec(pathname),

  async handleLink(href, [, hash]) {
    const {
      title,
      files: {
        mp4: {
          url
        }
      },
      thumbnail_url: thumbnail,
      source
    } = await ajax({
      url: `https://api.streamable.com/videos/${hash}`,
      type: 'json'
    });
    return {
      type: 'VIDEO',
      title,
      loop: true,
      sources: [{
        source: url,
        type: 'video/mp4'
      }],
      poster: thumbnail,
      source
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamja.js

/* harmony default export */ var streamja = (new Host('streamja', {
  name: 'streamja',
  domains: ['streamja.com'],
  logo: 'https://streamja.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([^\/]+)$/i.exec(pathname),

  handleLink(href, [, code]) {
    const short = code.substring(0, 2).toLowerCase();
    return {
      type: 'VIDEO',
      loop: true,
      sources: [{
        source: `https://upload.streamja.com/mp4/${short}/${code}.mp4`,
        type: 'video/mp4'
      }],
      poster: `https://upload.streamja.com/i/${short}/${code}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supgif.js

/* harmony default export */ var supgif = (new Host('supgif', {
  name: 'Supgif',
  domains: ['supgif.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/c\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://www.supgif.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supload.js



/* harmony default export */ var supload = (new Host('supload', {
  name: 'supload',
  domains: ['supload.com'],
  logo: 'https://supload.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([A-Za-z0-9_-]+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const data = await ajax({
      url: 'https://www.supload.com/oembed',
      query: {
        url: `https://supload.com/${id}`,
        format: 'json'
      },
      type: 'json',
      cacheFor: DAY
    });

    if (data.type === 'photo') {
      return {
        type: 'IMAGE',
        src: data.url
      };
    } else {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: data.webmUrl,
          type: 'video/webm'
        }, {
          source: data.mp4Url,
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tenor.js


/* harmony default export */ var tenor = (new Host('tenor', {
  name: 'tenor',
  domains: ['tenor.co'],
  logo: 'https://www.tenor.co/favicon.ico',
  detect: (() => {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const alphabetMap = alphabet.split('').reduce((obj, c, i) => {
      obj[c] = i;
      return obj;
    }, {});

    function parseViewShortId(s) {
      return s.split('').reduce((n, c) => n * alphabet.length + alphabetMap[c], 0);
    }

    return ({
      hostname,
      pathname
    }) => {
      if (hostname === 'tenor.co') {
        const pathMatch = /^\/([a-zA-Z0-9]+)\.gif$/i.exec(pathname);
        return pathMatch && {
          id: parseViewShortId(pathMatch[1])
        };
      } else if (hostname === 'media.tenor.co') {
        return {
          id: null
        };
      } else {
        const pathMatch = /^\/view\/.+\-(\d+)(\.gif)?$/i.exec(pathname);
        return pathMatch && {
          id: pathMatch[1]
        };
      }
    };
  })(),

  async handleLink(href, {
    id
  }) {
    if (id === null) {
      return {
        type: 'IMAGE',
        src: href
      };
    }

    const {
      results: [gif]
    } = await ajax({
      url: 'https://api.tenor.co/v1/gifs',
      query: {
        key: 'JJHDC7UK73EH',
        ids: id
      },
      type: 'json'
    });
    return {
      type: 'IMAGE',
      src: gif.media[0].gif.url,
      title: gif.h1_title,
      caption: gif.generatedcaption
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tumblr.js



/* harmony default export */ var tumblr = (new Host('tumblr', {
  name: 'tumblr',
  domains: ['tumblr.com'],
  permissions: ['https://api.tumblr.com/v2/blog/*/posts'],
  logo: 'https://secure.assets.tumblr.com/images/favicons/favicon.ico',

  detect({
    hostname,
    pathname
  }) {
    const pathMatch = /^\/(?:post|image)\/(\d+)(?:\/|$)/i.exec(pathname);
    return pathMatch && [hostname, pathMatch[1]];
  },

  async handleLink(href, [blog, id]) {
    const {
      response
    } = await ajax({
      url: `https://api.tumblr.com/v2/blog/${blog}/posts`,
      query: {
        api_key: 'WeJQquHCAasi5EzaN9jMtIZkYzGfESUtEvcYDeSMLICveo3XDq',
        id,
        filter: 'raw'
      },
      type: 'json'
    });
    const post = response.posts[0];

    function render(string) {
      return post.format === 'markdown' ? snudown_es_markdown(string) : string;
    }

    const defaults = {
      title: post.title,
      caption: post.caption,
      credits: `Posted by: <a href="${response.blog.url}">${response.blog.name}</a> @ Tumblr`
    };

    switch (post.type) {
      case 'photo':
        if (!post.photos.length) throw new Error('No images in gallery.');
        return {
          type: 'GALLERY',
          ...defaults,
          src: post.photos.map(photo => ({
            type: 'IMAGE',
            src: photo.original_size.url,
            caption: photo.caption
          }))
        };

      case 'text':
        return {
          type: 'TEXT',
          ...defaults,
          src: render(post.body)
        };

      case 'quote':
        return {
          type: 'TEXT',
          ...defaults,
          credits: post.source,
          src: `<blockquote><p>${render(post.text)}</p></blockquote>`
        };

      case 'link':
        return {
          type: 'TEXT',
          ...defaults,
          title: `<a href="${post.url}">${post.title}</a>`,
          src: render(post.description)
        };

      case 'chat':
        return {
          type: 'TEXT',
          ...defaults,
          src: post.dialogue.reduce((prev, {
            label,
            phrase
          }) => `${prev}<blockquote><p><b>${label}</b> ${phrase}</p></blockquote>`, '')
        };

      case 'answer':
        const asking = post.asking_url ? `<a href="${post.asking_url}">${post.asking_name}</a>` : post.asking_name;
        return {
          type: 'TEXT',
          ...defaults,
          src: `<blockquote><p>${asking} sent: ${post.question}</p></blockquote>${render(post.answer)}`
        };

      default:
        throw new Error(`Unsupported post type: ${post.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twimg.js

/* harmony default export */ var twimg = (new Host('twimg', {
  name: 'twimg',
  domains: ['pbs.twimg.com'],
  logo: 'https://twitter.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/media\/[\w\-]+\.\w+/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitch.js

/* harmony default export */ var twitch = (new Host('twitch', {
  name: 'twitch.tv',
  domains: ['twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?twitch\.tv\/(\w+)(?:\/([cbv])\/([0-9]+))?\/?(?:\?t=(?:([0-9]+)h)?(?:([0-9]+)m)?(?:([0-9]+)s)?)?$/i.exec(href),

  handleLink(href, [, channel, typeId, videoId, h, m, s]) {
    const channelOrVideo = videoId ? `video=${typeId.replace('b', 'a')}${videoId}` : `channel=${channel}`;
    const embed = `https://player.twitch.tv/?${channelOrVideo}&time=${+h || 0}h${+m || 0}m${+s || 0}s`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitchclips.js

/* harmony default export */ var twitchclips = (new Host('twitchclips', {
  name: 'twitch.tv clips',
  domains: ['clips.twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w+(?:\/[A-Z]\w+)?)(?:\/|$)/.exec(pathname),

  handleLink(href, [, clipId]) {
    const embed = `https://clips.twitch.tv/embed?clip=${clipId}`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitter.js




/* harmony default export */ var twitter = (new Host('twitter', {
  name: 'twitter',
  domains: ['twitter.com'],
  permissions: ['https://api.twitter.com/1/statuses/oembed.json'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:mobile\.)?twitter\.com\/(?:#!\/)?[\w]+\/status(?:es)?\/([\d]+)/i.exec(href),

  async handleLink(href, [, id]) {
    const {
      html
    } = await ajax({
      url: 'https://api.twitter.com/1/statuses/oembed.json',
      query: {
        id,
        omit_script: false
      },
      type: 'json'
    });
    const $dummy = $('<div>');
    return {
      type: 'GENERIC_EXPANDO',
      muted: true,
      expandoClass: 'selftext',
      generate: () => $dummy[0],
      onAttach: once_default()(() => {
        $dummy.replaceWith(html);
      })
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vidble.js



/* harmony default export */ var vidble = (new Host('vidble', {
  name: 'vidble',
  domains: ['vidble.com'],
  logo: 'https://vidble.com/assets/ico/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(show|album)\/([a-z0-9]+)/i.exec(pathname),

  async handleLink(href, [, type, hash]) {
    switch (type) {
      case 'show':
        return {
          type: 'IMAGE',
          src: `https://vidble.com/${hash}_med.jpg`
        };

      case 'album':
        const urlObj = new URL(href);
        const {
          pics
        } = await ajax({
          url: string_namespaceObject.encode`https://vidble.com/album/album/${hash}?json=1`,
          type: 'json'
        });
        if (!pics.length) throw new Error('No images in gallery.');
        const src = pics.map((src, i) => {
          urlObj.hash = `#pic_${i}`;
          return {
            type: 'IMAGE',
            src,
            href: urlObj.href
          };
        });
        return {
          type: 'GALLERY',
          src
        };

      default:
        throw new Error(`This should never happen. Invalid type: ${type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vimeo.js

/* harmony default export */ var vimeo = (new Host('vimeo', {
  name: 'vimeo',
  domains: ['vimeo.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://player.vimeo.com/video/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      pause: '{"method":"pause"}',
      play: '{"method":"play"}',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlipsy.js

/* harmony default export */ var vlipsy = (new Host('vlipsy', {
  name: 'Vlipsy',
  domains: ['vlipsy.com'],
  logo: 'https://vlipsy.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/vlip\/(?:\w+-)*(\w+)$/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://vlipsy.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlive.js

/* harmony default export */ var vlive = (new Host('vlive', {
  name: 'VLive',
  domains: ['vlive.tv'],
  logo: 'https://www.vlive.tv/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:video)\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://vlive.tv/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoPlay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/exec-loader?cache!./lib/core/metadata/packageInfo.js
/* harmony default export */ var packageInfo = ({"announcementsSubreddit":"RESAnnouncements","name":"Reddit Enhancement Suite","version":"5.16.9","isBeta":false,"isPatch":true,"isMinor":false,"isMajor":false,"updatedURL":"https://redditenhancementsuite.com/releases/#v5.16.9","homepageURL":"https://redditenhancementsuite.com","gitDescription":"v5.16.9"});
// CONCATENATED MODULE: ./lib/core/metadata/index.js

const {
  announcementsSubreddit,
  name: metadata_name,
  version: metadata_version,
  isBeta,
  isPatch,
  isMinor,
  isMajor,
  updatedURL,
  homepageURL,
  gitDescription: metadata_gitDescription
} = packageInfo;
// CONCATENATED MODULE: ./lib/modules/hosts/wikipedia.js




/* harmony default export */ var wikipedia = (new Host('wikipedia', {
  name: 'wikipedia',
  domains: ['wikipedia.org', 'wikipedia.com'],
  logo: 'https://en.wikipedia.org/static/favicon/wikipedia.ico',
  detect: url => url.pathname.startsWith('/wiki/') && {
    article: url.pathname.substr(6),
    language: url.host.split('.')[0],
    hash: url.hash.substr(1)
  },

  async handleLink(href, {
    language,
    article,
    hash
  }) {
    let sectionId = 0;
    if (language === 'www' || language === 'wikipedia') language = 'en';

    if (hash !== '') {
      const sections = await ajax({
        url: `https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=sections&page=${article}&origin=*`,
        type: 'json',
        headers: {
          'Api-User-Agent': `Reddit-Enhancement-Suite/${metadata_version} ( ${homepageURL} )`
        }
      });

      for (const section of sections.parse.sections) {
        if (section.anchor === hash) {
          sectionId = section.index;
          break;
        }
      }
    }

    const data = await ajax({
      url: `https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=text|displaytitle&section=${sectionId}&page=${article}&origin=*`,
      type: 'json',
      headers: {
        'Api-User-Agent': `Reddit-Enhancement-Suite/${metadata_version} ( ${homepageURL} )`
      }
    });
    const cleanDoc = new DOMParser().parseFromString(data.parse.text['*'], 'text/html');

    for (const e of cleanDoc.querySelectorAll('.metadata, .hatnote, .mw-editsection, .mwe-math-mathml-inline, .reference, .references')) e.remove();

    for (const e of cleanDoc.querySelectorAll('a')) {
      e.href = new URL(e.getAttribute('href'), `https://${language}.wikipedia.org/wiki/${article}`).href;
    }

    return {
      type: 'TEXT',
      title: $('<div>', {
        html: data.parse.displaytitle || data.parse.title
      }).text(),
      src: cleanDoc.body.innerHTML
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xboxdvr.js

/* harmony default export */ var xboxdvr = (new Host('xboxdvr', {
  name: 'XboxDVR',
  domains: ['xboxdvr.com'],
  logo: 'https://xboxdvr.com/assets/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://xboxdvr.com/${path}/embed`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xkcd.js


/* harmony default export */ var xkcd = (new Host('xkcd', {
  name: 'xkcd',
  domains: ['xkcd.com'],
  permissions: ['https://xkcd.com/*/info.0.json'],
  logo: 'https://xkcd.com/favicon.ico',
  detect: ({
    hostname,
    pathname
  }) => ['xkcd.com', 'www.xkcd.com'].includes(hostname) && /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      title,
      alt,
      img
    } = await ajax({
      url: `https://xkcd.com/${id}/info.0.json`,
      type: 'json'
    });
    return {
      type: 'IMAGE',
      title,
      caption: alt,
      src: img
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/youtube.js



/* harmony default export */ var youtube = (new Host('youtube', {
  name: 'youtube',
  attribution: false,
  domains: ['youtube.com', 'youtu.be'],
  detect: ({
    pathname,
    hostname,
    searchParams
  }) => {
    const split = pathname.substring(1).split('/');
    if (split[0] === 'channel' && split[2] === 'live') return [`live_stream?channel=${split[1]}`, searchParams];
    if (hostname.endsWith('youtu.be')) return [split[0], searchParams];
    const vParam = searchParams.get('v');
    if (vParam) return [vParam, searchParams];
    if (/watch|embed|v/i.exec(split[0])) return [split[1], searchParams];
    const uParam = searchParams.get('u');

    if (split[0] === 'attribution_link' && uParam !== null) {
      const vParam = new URLSearchParams(uParam.split('?')[1]).get('v');
      if (vParam) return [vParam, searchParams];
    }
  },

  handleLink(href, [id, searchParams]) {
    const url = new URL(`https://www.youtube.com/embed/${id}`);
    url.searchParams.set('version', '3');
    url.searchParams.set('rel', '0');
    const tParam = searchParams.get('t');

    if (tParam) {
      let start = 0;
      const timeBlocks = {
        h: 3600,
        m: 60,
        s: 1
      };
      const timeRe = /[0-9]+[hms]/ig;
      const timeMatch = tParam.match(timeRe);

      if (timeMatch) {
        for (const ts of timeMatch) {
          const unit = timeBlocks[ts.slice(-1)];
          const amount = parseInt(ts.slice(0, -1), 10);
          start += unit * amount;
        }
      } else {
        start = parseInt(tParam, 10);
        if (isNaN(start)) start = 0;
      }

      url.searchParams.set('start', String(start));
    }

    for (const k of ['end', 'start', 'list']) {
      const param = searchParams.get(k);
      if (param) url.searchParams.set(k, param);
    }

    return {
      type: 'IFRAME',
      embed: url.href,
      embedAutoplay: `${url.href}&autoplay=1`,
      fixedRatio: true
    };
  },

  getVideoData: batch(async ids => {
    const {
      items
    } = await ajax({
      url: 'https://www.googleapis.com/youtube/v3/videos',
      query: {
        id: [...ids].sort().join(','),
        part: ['id', 'contentDetails', 'snippet', 'statistics'].join(','),
        fields: `items(${['id', 'contentDetails(duration)', 'snippet(title,publishedAt)', 'statistics(viewCount)'].join(',')})`,
        key: 'AIzaSyB8ufxFN0GapU1hSzIbuOLfnFC0XzJousw'
      },
      type: 'json',
      cacheFor: DAY
    });
    return ids.map(id => {
      const data = items.find(({
        id: _id
      }) => _id === id);

      try {
        const {
          contentDetails: {
            duration: rawDuration
          },
          snippet: {
            title,
            publishedAt
          },
          statistics: {
            viewCount
          }
        } = data;
        const duration = ['0'].concat(rawDuration.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i).slice(1)).map(time => `0${time || 0}`.slice(-2)).filter((time, i, {
          length
        }) => +time !== 0 || i >= length - 2).join(':');
        return {
          title,
          duration,
          publishedAt,
          viewCount
        };
      } catch (e) {}
    });
  }, {
    size: 50,
    delay: 0
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/znipe.js

/* harmony default export */ var znipe = (new Host('znipe', {
  name: 'ZnipeTV',
  domains: ['beta.znipe.tv', 'www.znipe.tv'],
  logo: 'https://assets.znipe.tv/icons/favicon.jpg',
  detect: ({
    searchParams
  }) => {
    const mParam = searchParams.get('m');
    if (mParam) return ['m', mParam];
    const vParam = searchParams.get('v');
    if (vParam) return ['v', vParam];
  },

  handleLink(href, [clipType, clipId]) {
    return {
      type: 'IFRAME',
      embed: `https://beta.znipe.tv/watch?${clipType}=${clipId}`
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=default!./lib/modules/hosts/default.js
/* generated by sibling-loader */






















































































/* harmony default export */ var modules_hosts_default = ({ "aarli.js": aarli, "adultswim.js": adultswim, "archilogic.js": archilogic, "archiveis.js": archiveis, "bime.js": bime, "clyp.js": clyp, "codepen.js": codepen, "coub.js": coub, "ctrlv.js": ctrlv, "dailymotion.js": dailymotion, "default.js": hosts_default, "defaultAudio.js": defaultAudio, "defaultVideo.js": defaultVideo, "derpibooru.js": derpibooru, "deviantart.js": deviantart, "dropbox.js": dropbox, "fiveHundredPx.js": fiveHundredPx, "flickr.js": flickr, "futurism.js": futurism, "gatherer.js": gatherer, "getyarn.js": getyarn, "gfycat.js": gfycat, "gifyoutube.js": gifyoutube, "giphy.js": giphy, "github.js": github, "googlemaps.js": googlemaps, "graphiq.js": graphiq, "gyazo.js": gyazo, "hastebin.js": hastebin, "iloopit.js": iloopit, "imgflip.js": imgflip, "imgur.js": imgur, "instagram.js": instagram, "ireddit.js": ireddit, "jsfiddle.js": jsfiddle, "liveleak.js": liveleak, "livememe.js": livememe, "makeameme.js": makeameme, "masterypoints.js": masterypoints, "memecrunch.js": memecrunch, "memedad.js": memedad, "memegen.js": memegen, "mixer.js": mixer, "onedrive.js": onedrive, "pastebin.js": pastebin, "peertube.js": peertube, "photobucket.js": photobucket, "picshd.js": picshd, "pixiv.js": pixiv, "poly.js": poly, "pornbot.js": pornbot, "pornhub.js": pornhub, "ppy.js": ppy, "qwipit.js": qwipit, "rawprogress.js": rawprogress, "redditbooru.js": redditbooru, "redditmedia.js": redditmedia, "reddituploads.js": reddituploads, "ridewithgps.js": ridewithgps, "simplecove.js": simplecove, "snag.js": snag, "soundcloud.js": soundcloud, "spotify.js": spotify, "steamcommunity.js": steamcommunity, "steampowered.js": steampowered, "strawpollcom.js": strawpollcom, "strawpollme.js": strawpollme, "streamable.js": streamable, "streamja.js": streamja, "supgif.js": supgif, "supload.js": supload, "tenor.js": tenor, "tumblr.js": tumblr, "twimg.js": twimg, "twitch.js": twitch, "twitchclips.js": twitchclips, "twitter.js": twitter, "vidble.js": vidble, "vimeo.js": vimeo, "vlipsy.js": vlipsy, "vlive.js": vlive, "wikipedia.js": wikipedia, "xboxdvr.js": xboxdvr, "xkcd.js": xkcd, "youtube.js": youtube, "znipe.js": znipe });
// CONCATENATED MODULE: ./lib/modules/showImages.js

























const siteModules = flow_default()(() => Object.values(modules_hosts_default), map_default()(host => downcast(host, Host)), keyBy_default()(host => host.moduleID))();

const genericHosts = [siteModules.default, siteModules.defaultVideo, siteModules.defaultAudio];
const showImages_module = new Module('showImages');
showImages_module.moduleName = 'showImagesName';
showImages_module.category = 'productivityCategory';
showImages_module.description = 'showImagesDesc';
showImages_module.bodyClass = true;
showImages_module.options = {
  mediaBrowse: {
    title: 'showImagesMediaBrowseTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaBrowseDesc'
  },
  browsePreloadCount: {
    title: 'showImagesBrowsePreloadCountTitle',
    type: 'text',
    value: '1',
    description: 'showImagesBrowsePreloadCountDesc',
    dependsOn: options => options.mediaBrowse.value
  },
  galleryPreloadCount: {
    title: 'showImagesGalleryPreloadCountTitle',
    type: 'text',
    value: '2',
    description: 'showImagesGalleryPreloadCountDesc'
  },
  conserveMemory: {
    title: 'showImagesConserveMemoryTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesConserveMemoryDesc'
  },
  maxWidth: {
    title: 'showImagesMaxWidthTitle',
    type: 'text',
    value: '100%',
    description: 'showImagesMaxWidthDesc',
    advanced: true
  },
  maxHeight: {
    title: 'showImagesMaxHeightTitle',
    type: 'text',
    value: '80%',
    description: 'showImagesMaxHeightDesc',
    advanced: true
  },
  displayOriginalResolution: {
    title: 'showImagesDisplayOriginalResolutionTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesDisplayOriginalResolutionDesc'
  },
  selfTextMaxHeight: {
    title: 'showImagesSelfTextMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesSelfTextMaxHeightDesc',
    advanced: true
  },
  commentMaxHeight: {
    title: 'showImagesCommentMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesCommentMaxHeightDesc',
    advanced: true
  },
  autoMaxHeight: {
    title: 'showImagesAutoMaxHeightTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesAutoMaxHeightDesc',
    dependsOn: options => !!parseInt(options.selfTextMaxHeight.value, 10) || !!parseInt(options.commentMaxHeight.value, 10),
    advanced: true
  },
  openInNewWindow: {
    title: 'showImagesOpenInNewWindowTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesOpenInNewWindowDesc'
  },
  hideNSFW: {
    title: 'showImagesHideNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHideNSFWDesc'
  },
  highlightNSFWButton: {
    title: 'showImagesHighlightNSFWButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightNSFWButtonDesc',
    bodyClass: true
  },
  highlightSpoilerButton: {
    title: 'showImagesHighlightSpoilerButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightSpoilerButtonDesc',
    bodyClass: true
  },
  imageZoom: {
    title: 'showImagesImageZoomTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageZoomDesc'
  },
  imageMove: {
    title: 'showImagesImageMoveTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageMoveDesc'
  },
  mediaControls: {
    title: 'showImagesMediaControlsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaControlsDesc'
  },
  mediaControlsPosition: {
    title: 'showImagesMediaControlsPositionTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'enum',
    value: 'top-left',
    values: [{
      name: 'Top left',
      value: 'top-left'
    }, {
      name: 'Top right',
      value: 'top-right'
    }, {
      name: 'Bottom left.',
      value: 'bottom-left'
    }, {
      name: 'Bottom right.',
      value: 'bottom-right'
    }],
    description: 'showImagesMediaControlsPositionDesc'
  },
  clippy: {
    title: 'showImagesClippyTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'boolean',
    value: true,
    description: 'showImagesClippyDesc'
  },
  crossposts: {
    title: 'showImagesCrosspostsTitle',
    description: 'showImagesCrosspostsDescription',
    type: 'enum',
    value: 'withMetadata',
    values: [{
      name: 'Do not replace Reddit crosspost expando',
      value: 'none'
    }, {
      name: 'Show with original post\'s metadata',
      value: 'withMetadata'
    }, {
      name: 'Show without metadata',
      value: 'plain'
    }]
  },
  displayImageCaptions: {
    title: 'showImagesDisplayImageCaptionsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesDisplayImageCaptionsDesc',
    advanced: true,
    bodyClass: true
  },
  captionsPosition: {
    title: 'showImagesCaptionsPositionTitle',
    dependsOn: options => options.displayImageCaptions.value,
    type: 'enum',
    value: 'titleAbove',
    values: [{
      name: 'Display all captions above image.',
      value: 'allAbove'
    }, {
      name: 'Display title and caption above image, credits below.',
      value: 'creditsBelow'
    }, {
      name: 'Display title above image, caption and credits below.',
      value: 'titleAbove'
    }, {
      name: 'Display all captions below image.',
      value: 'allBelow'
    }],
    description: 'showImagesCaptionsPositionDesc',
    advanced: true,
    bodyClass: true
  },
  markVisited: {
    title: 'showImagesMarkVisitedTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMarkVisitedDesc',
    advanced: true
  },
  markSelftextVisited: {
    title: 'showImagesMarkSelftextVisitedTitle',
    dependsOn: options => options.markVisited.value,
    type: 'boolean',
    value: false,
    description: 'showImagesMarkSelftextVisitedDesc',
    advanced: true
  },
  sfwHistory: {
    title: 'showImagesSfwHistoryTitle',
    dependsOn: options => options.markVisited.value,
    type: 'enum',
    value: 'add',
    values: [{
      name: 'Add links to history',
      value: 'add'
    }, {
      name: 'Color links, but do not add to history',
      value: 'color'
    }, {
      name: 'Do not add or color links.',
      value: 'none'
    }],
    description: 'showImagesSfwHistoryDesc'
  },
  galleryRememberWidth: {
    title: 'showImagesGalleryRememberWidthTitle',
    dependsOn: options => options.imageZoom.value,
    type: 'boolean',
    value: true,
    description: 'showImagesGalleryRememberWidthDesc'
  },
  galleryAsFilmstrip: {
    title: 'showImagesGalleryAsFilmstripTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesGalleryAsFilmstripDesc'
  },
  filmstripLoadIncrement: {
    title: 'showImagesFilmstripLoadIncrementTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '30',
    description: 'showImagesFilmstripLoadIncrementDesc'
  },
  useSlideshowWhenLargerThan: {
    title: 'showImagesUseSlideshowWhenLargerThanTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '0',
    description: 'showImagesUseSlideshowWhenLargerThanDesc'
  },
  convertGifstoGfycat: {
    title: 'showImagesConvertGifstoGfycatTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesConvertGifstoGfycatDesc'
  },
  showViewImagesTab: {
    title: 'showImagesShowViewImagesTabTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowViewImagesTabDesc'
  },
  autoExpandTypes: {
    title: 'showImagesAutoExpandTypesTitle',
    type: 'enum',
    value: 'any',
    values: [{
      name: 'Images (but occasionally also .gif)',
      value: 'image'
    }, {
      name: 'Images, text',
      value: 'image text'
    }, {
      name: 'Images, text, galleries, and muted videos',
      value: 'image text gallery video'
    }, {
      name: 'All muted expandos (includes iframes)',
      value: 'any'
    }],
    description: 'showImagesAutoExpandTypesDesc'
  },
  autoExpandSelfText: {
    title: 'showImagesAutoExpandSelfTextTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextDesc'
  },
  autoExpandSelfTextFirstVisibleNonMuted: {
    title: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedDesc'
  },
  autoExpandSelfTextNSFW: {
    title: 'showImagesAutoExpandSelfTextNSFWTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: false,
    description: 'showImagesAutoExpandSelfTextNSFWDesc'
  },
  showSiteAttribution: {
    title: 'showImagesShowSiteAttributionTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowSiteAttributionDesc'
  },
  expandoCommentRedirects: {
    title: 'showImagesExpandoCommentRedirectsTitle',
    type: 'enum',
    value: 'expando',
    values: [{
      name: 'Do nothing',
      value: 'nothing'
    }, {
      name: 'Create expandos',
      value: 'expando'
    }, {
      name: 'Create expandos, redirect the link back to the image',
      value: 'rewrite'
    }],
    description: 'showImagesExpandoCommentRedirectsDesc'
  },
  startVideosMuted: {
    title: 'showImagesStartVideosMutedTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesStartVideosMutedDesc'
  },
  onlyPlayMutedWhenVisible: {
    title: 'showImagesOnlyPlayMutedWhenVisibleTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesOnlyPlayMutedWhenVisibleDesc'
  },
  maxSimultaneousPlaying: {
    title: 'showImagesMaxSimultaneousPlayingTitle',
    type: 'text',
    value: '0',
    description: 'showImagesMaxSimultaneousPlayingDesc'
  },
  autoplayVideo: {
    title: 'showImagesAutoplayVideoTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoplayVideoDesc'
  },
  hidePinnedRedditVideos: {
    title: 'showImagesHidePinnedRedditVideosTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHidePinnedRedditVideosDesc',
    bodyClass: true
  },
  ...Object.values(siteModules).reduce((options, siteModule) => {
    if (genericHosts.includes(siteModule)) return options;
    options[siteModuleOptionKey(siteModule)] = {
      title: siteModule.name,
      description: 'showImagesHostToggleDesc',
      value: true,
      type: 'boolean'
    };
    Object.assign(options, siteModule.options);
    return options;
  }, {})
};
showImages_module.exclude = [/^\/ads\/[\-\w\._\?=]*/i, 'submit', /^\/subreddits/i];

showImages_module.beforeLoad = () => {
  const selfTextMaxHeight = parseInt(showImages_module.options.selfTextMaxHeight.value, 10);

  if (selfTextMaxHeight) {
    addCSS(`
			.selftext.expanded ~ * .md {
				max-height: ${selfTextMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  const commentMaxHeight = parseInt(showImages_module.options.commentMaxHeight.value, 10);

  if (commentMaxHeight) {
    addCSS(`
			.comment .md {
				max-height: ${commentMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  watchForElements(['selfText'], null, scanBody);
  watchForThings(['comment', 'message'], thing => scanBody(thing.getTextBody()), {
    id: showImages_module
  });
  watchForThings(['post'], thing => checkElementForMedia(thing.getPostLink()), {
    id: showImages_module
  });
  watchForRedditEvents('comment', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const comment = placeholder.closest('.Comment');
    scanBody(comment);
  });
  watchForRedditEvents('postAuthor', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const body = placeholder.closest('[data-test-id="post-content"]');
    if (body && body.querySelector('.media-element')) return;
    scanBody(body);
  });
};

showImages_module.contentStart = () => {
  createImageButtons();

  if (showImages_module.options.mediaBrowse.value) {
    selectedEntry_addListener(mediaBrowse, 'instantly');
  }
};

showImages_module.go = () => {
  if (isPageType('wiki')) scanBody(document.querySelector('.wiki-page-content'));
  const spotlight = document.querySelector('#siteTable_organic');

  if (spotlight) {
    const nextprev = spotlight.querySelector('.nextprev');

    if (nextprev) {
      nextprev.addEventListener('click', () => {
        const open = spotlight.querySelector('.expando-button.expanded');
        if (open) open.click();
      });
    }
  }
};

showImages_module.afterLoad = () => {
  if (showImages_module.options.conserveMemory.value) {
    enableConserveMemory();
  }
};

function siteModuleOptionKey(siteModule) {
  const id = siteModule.moduleID;
  return `display_${id}`;
}

function isSiteModuleEnabled(siteModule) {
  const key = siteModuleOptionKey(siteModule);
  return !showImages_module.options[key] || showImages_module.options[key].value;
}

const sitesMap = once_default()(() => Object.values(siteModules).filter(isSiteModuleEnabled).reduce((map, siteModule) => {
  for (const domain of siteModule.domains) {
    map.set(domain, (map.get(domain) || []).concat(siteModule));
  }

  return map;
}, new Map()));

function* modulesForHostname(hostname) {
  do {
    for (const m of sitesMap().get(hostname) || []) yield m;
  } while (hostname = hostname.replace(/^.+?(\.|$)/, ''));

  for (const m of genericHosts) yield m;
}

function enableConserveMemory() {
  const fullscreenActive = () => !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);

  const rootMargin = '50% 100000%';
  const boxMap = new WeakMap();
  const ioBox = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!isIntersecting && fullscreenActive()) return;
      const {
        media
      } = downcast(boxMap.get(target), expando_Expando);
      if (media) media.setLoaded(isIntersecting);else ioBox.unobserve(target);
    }
  }, {
    rootMargin
  });
  const buttonMap = new WeakMap();
  const ioButton = new IntersectionObserver(entries => {
    if (fullscreenActive()) return;

    for (const {
      isIntersecting,
      target
    } of entries) {
      const expando = downcast(buttonMap.get(target), expando_Expando);
      const {
        open
      } = expando;

      if (!isIntersecting && !open) {
        ioButton.unobserve(target);
        expando.empty();
      }
    }
  }, {
    rootMargin
  });
  window.addEventListener('scroll', idleThrottle(() => {
    for (const expando of primaryExpandos.values()) {
      if (expando.isAttached()) {
        const {
          box,
          media,
          button
        } = expando;
        if (!media) continue;

        if (media.supportsUnload()) {
          ioBox.observe(box);
          boxMap.set(box, expando);
        } else {
          ioButton.observe(button);
          buttonMap.set(button, expando);
        }
      } else {
        expando.destroy();
      }
    }
  }));
}

let viewImagesButton;
let autoExpandActive = false;
let mediaBrowseModeActive = false;
function toggleViewImages() {
  viewImagesButton.click();
}

function createImageButtons() {
  if (showImages_module.options.showViewImagesTab.value) {
    viewImagesButton = createElement_namespaceObject.tabMenuItem({
      text: 'show images',
      className: 'res-show-images'
    });
    viewImagesButton.addEventListener('change', e => {
      autoExpandActive = e.detail;

      flow_default()(Array.from, filter_default()(expando => expando.isAttached() && expando.button.offsetParent), fp_sortBy_default()(v => v.button.getBoundingClientRect().top), forEachChunked(expando => {
        const open = isExpandWanted(expando);
        if (open) expando.expand();else if (!autoExpandActive) expando.collapse();
      }))(primaryExpandos.values());
    });
  }
}

function toggleThingExpandos(thing, {
  scrollOnToggle
} = {}) {
  const expandos = expando_Expando.getAllExpandosFrom(thing);
  if (!expandos.length) return;
  const openExpandos = expandos.filter(v => v.open);

  if (openExpandos.length) {
    for (const expando of openExpandos) expando.collapse();

    if (scrollOnToggle) {
      scrollToElement(thing.entry, null, {
        scrollStyle: 'directional',
        restrictDirectionTo: 'up'
      });
    }
  } else {
    for (const expando of expandos) {
      if (!(expando instanceof expando_Expando) || isExpandWanted(expando, {
        thing,
        autoExpandFirstVisibleNonMutedInThing: true,
        autoExpand: true,
        autoExpandTypes: [],
        ignoreDuplicatesScope: thing.entry
      })) {
        expando.expand();
      }
    }

    if (scrollOnToggle) {
      scrollToElement(thing.entry, null, {
        scrollStyle: 'top',
        restrictDirectionTo: 'down'
      });
    }
  }
}
const preloadExpandos = idleThrottle((fromThing, direction, preloadCount = parseInt(showImages_module.options.browsePreloadCount.value, 10)) => {
  const pieces = [];
  let target = fromThing;

  do {
    const expando = expando_Expando.getEntryExpandoFrom(target);
    if (expando && expando instanceof expando_Expando) pieces.push(expando);
  } while ((target = target.getNext({
    direction
  })) && pieces.length <= preloadCount);

  preloadMedia(pieces);
});

function mediaBrowse(selected, unselected, options) {
  if (!selected || !options.allowMediaBrowse || autoExpandActive) return;
  const oldExpando = expando_Expando.getEntryExpandoFrom(unselected);
  const newExpando = expando_Expando.getEntryExpandoFrom(selected);

  if (oldExpando) {
    mediaBrowseModeActive = oldExpando.expandWanted || oldExpando.open;
    oldExpando.collapse();
  }

  if (mediaBrowseModeActive && newExpando) {
    newExpando.expand();
    options.scrollStyle = 'top';
    preloadExpandos(selected, options.direction);
  }
}

function hasEntryAnyExpandedNonMuted(thing) {
  return expando_Expando.getTextExpandosFrom(thing).some(expando => expando.types.includes('non-muted') && (expando.open || expando.expandWanted));
}

const showImages_types = ['selftext', 'video', 'image', 'iframe', 'gallery', 'native', 'muted', 'non-muted'];
function matchesTypes(wantedTypes, expandoTypes = showImages_types) {
  return !wantedTypes.length || !!intersection_default()(expandoTypes, wantedTypes).length;
}

function isExpandWanted(expando, {
  thing,
  autoExpand = autoExpandActive,
  autoExpandTypes = showImages_module.options.autoExpandTypes.value.replace('any', '').split(' ').filter(Boolean),
  ignoreDuplicates = true,
  ignoreDuplicatesScope,
  onlyExpandMuted = true,
  autoExpandFirstVisibleNonMutedInThing = false
} = {}) {
  if (ignoreDuplicates && !expando.isPrimary()) {
    if (!ignoreDuplicatesScope) return false;
    const primary = expando.getPrimary();
    if (primary && ignoreDuplicatesScope.contains(primary.button)) return false;
  }

  const expandoIsNonMuted = expando.types.includes('non-muted');
  const typeCriteriaOK = matchesTypes(autoExpandTypes, expando.types);
  const muteCriteriaOK = !(onlyExpandMuted && expandoIsNonMuted) || autoExpandFirstVisibleNonMutedInThing && elementInViewport(expando.button) && !hasEntryAnyExpandedNonMuted(thing);
  return autoExpand && muteCriteriaOK && typeCriteriaOK;
}

async function convertGifToVideo(options) {
  try {
    const info = await ajax({
      type: 'json',
      url: 'https://upload.gfycat.com/transcodeRelease',
      query: {
        fetchUrl: options.src
      },
      cacheFor: DAY
    });
    if (!info.gfyName) throw new Error('gfycat transcode did not contain "gfyName"');
    return {
      options: await siteModules.gfycat.handleLink('', [], info),
      siteModule: siteModules.gfycat
    };
  } catch (e) {
    throw new Error(`Could not convert gif to video ${options.src}: ${e}`);
  }
}

function resolveMediaUrl(element, thing) {
  if (showImages_module.options.expandoCommentRedirects.value !== 'nothing' && thing && element.classList.contains('title')) {
    const dataUrl = thing.element.getAttribute('data-url');
    const fullDataUrl = dataUrl && new URL(dataUrl, location.href);

    if (fullDataUrl && fullDataUrl.href !== thing.getCommentsLink().href) {
      return fullDataUrl;
    }
  }

  return new URL(element.href, location.href);
}

function promptSiteModulePermissions({
  name,
  permissions = []
}) {
  const urlStripRe = /((?:\w+\.)+\w+)(?=\/|$)/i;
  notifications_showNotification({
    header: 'Permission required',
    moduleID: 'permissions',
    closeDelay: 20000,
    message: `
			<p>In order to inline expand content from ${name}, RES needs permission to access these sites:</p>
			<p>${permissions.map(url => `<code>${urlStripRe.exec(url)[0]}</code>`).join(', ')}</p>
			<p>Be assured RES does not access/modify any of your information on these domains - it only accesses the public API.</p>
		`
  });
  return permissions_namespaceObject.request(permissions);
}

const generateSiteModuleLock = memoize_default()(async siteModule => {
  if (!siteModule.permissions || (await permissions_namespaceObject.has(siteModule.permissions))) return;
  let resolve;
  return {
    promise: new Promise(_resolve => {
      resolve = _resolve;
    }),
    open: () => promptSiteModulePermissions(siteModule).then(resolve)
  };
});

function getMediaInfo(mediaUrl, thing) {
  for (const siteModule of modulesForHostname(mediaUrl.hostname)) {
    const detectResult = siteModule.detect(mediaUrl, thing);

    if (detectResult) {
      return {
        detectResult,
        siteModule,
        href: mediaUrl.href
      };
    }
  }
}

function scanBody(element) {
  if (!element) return;

  for (const link of element.querySelectorAll('a')) {
    checkElementForMedia(downcast(link, HTMLAnchorElement));
  }
}

const linksMap = new WeakMap();
function getLinkExpando(link) {
  return linksMap.get(link);
}

const inText = element => !!element.closest('.md, .search-result-footer');

async function checkElementForMedia(element) {
  const thing = Thing_Thing.from(element);
  const entryExpando = !inText(element) && expando_Expando.getEntryExpandoFrom(thing);
  const nativeExpando = entryExpando instanceof expando_Expando ? null : entryExpando;

  if (showImages_module.options.hideNSFW.value && thing && thing.isNSFW()) {
    if (nativeExpando) nativeExpando.detach();
    return;
  }

  if (nativeExpando) {
    trackNativeExpando(nativeExpando, element, thing);

    if (nativeExpando.open) {
      console.log('Native expando has already been opened; skipping.', element.href);
      return;
    }
  }

  const mediaUrl = resolveMediaUrl(element, thing);
  const mediaInfo = getMediaInfo(mediaUrl, thing);
  if (!mediaInfo) return;

  if (thing && thing.isCrosspost() && showImages_module.options.crossposts.value === 'none') {
    return;
  }

  if (mediaUrl && showImages_module.options.expandoCommentRedirects.value === 'rewrite') {
    element.href = mediaUrl.href;
    element.removeAttribute('data-inbound-url');
  }

  const expando = new expando_Expando(mediaInfo.href);
  linksMap.set(element, expando);
  expando.button.setAttribute('data-host', mediaInfo.siteModule.moduleID);
  expando.box.setAttribute('data-host', mediaInfo.siteModule.moduleID);
  expando.onExpand(() => {
    trackMediaLoad(element, thing);
  });
  if (nativeExpando) nativeExpando.detach();
  placeExpando(expando, element, thing);
  const lock = await generateSiteModuleLock(mediaInfo.siteModule);

  if (lock) {
    expando.setLock(lock);
    await lock.promise;
  }

  try {
    await completeExpando(expando, thing, mediaInfo);
  } catch (e) {
    console.error(`showImages: could not create expando for ${mediaInfo.href}`);
    console.error(e);
    if (nativeExpando) nativeExpando.reattach();
    expando.destroy();
    linksMap.delete(element);
  }
}

function placeExpando(expando, element, thing) {
  if (!inText(element) && thing && thing.getTitleElement()) {
    if (element.parentElement) element.parentElement.after(expando.button);
    thing.entry.appendChild(expando.box);
  } else {
    $(element).add($(element).next('.keyNavAnnotation')).last().after(expando.box).after($('<span class="res-freetext-expando">').append(expando.button));
  }
}

async function completeExpando(expando, thing, mediaInfo) {
  expando.initialize((await retrieveExpandoOptions(thing, mediaInfo)));
  const hideButton = thing && thing.getHideElement();
  if (hideButton) hideButton.addEventListener('click', () => {
    expando.destroy();
  });

  if (thing && thing.isComment()) {
    expando.onExpand(once_default()(() => {
      let wasOpen;
      $([thing, ...thing.getParents()].map(e => e.entry)).find('.tagline > .expand, > .buttons .toggleChildren').click(() => {
        if (thing.isContentVisible()) {
          if (wasOpen && expando.media) expando.expand();
        } else {
          wasOpen = expando.open;
          if (expando.open) expando.collapse();
        }
      });
    }));
  }

  expando.onExpand(() => {
    const lightbox = expando.media.element.closest('#overlayScrollContainer');
    if (lightbox) lightbox.firstChild.style.overflowY = 'initial';
  });
  expando.button.addEventListener('mousedown', () => {
    preloadMedia([expando]);
  });

  if (showImages_module.options.autoMaxHeight.value && thing && inText(expando.button)) {
    thing.entry.addEventListener('mediaResize', updateParentHeight);
  }

  if (!expando.open) {
    let autoExpand;
    let autoExpandFirstVisibleNonMutedInThing;

    if (showImages_module.options.autoExpandSelfText.value && inText(expando.button) && thing && thing.isSelfPost() && !isPageType('comments')) {
      const dontAutoExpandNSFW = !showImages_module.options.autoExpandSelfTextNSFW.value && thing.isNSFW();
      autoExpand = !dontAutoExpandNSFW;
      autoExpandFirstVisibleNonMutedInThing = showImages_module.options.autoExpandSelfTextFirstVisibleNonMuted.value;
    }

    if (isExpandWanted(expando, {
      thing,
      autoExpand,
      autoExpandFirstVisibleNonMutedInThing
    })) {
      expando.expand();
    }
  }
}

const retrieveExpandoOptions = memoize_default()(async (thing, {
  siteModule,
  detectResult,
  href
}) => {
  let mediaOptions = await siteModule.handleLink(href, detectResult);

  if (showImages_module.options.convertGifstoGfycat.value && mediaOptions.type === 'IMAGE' && /^(http|https|ftp):\/\/.*\.gif($|\/?)/.test(mediaOptions.src)) {
    try {
      ({
        options: mediaOptions,
        siteModule
      } = await convertGifToVideo(mediaOptions));
    } catch (e) {
      console.log(e);
    }
  }

  if (mediaOptions.title && thing && string_namespaceObject.areSimilar(mediaOptions.title, thing.getTitle())) {
    mediaOptions.title = '';
  }

  const attribution = showImages_module.options.showSiteAttribution.value && thing && thing.isPost() && !thing.isSelfPost() && siteModule.domains.length && siteModule.attribution !== false;

  const isMuted = media => media.muted || ['IMAGE', 'TEXT'].includes(media.type);

  const muted = mediaOptions.type === 'GALLERY' ? mediaOptions.src.every(isMuted) : isMuted(mediaOptions);
  return {
    types: [mediaOptions.type, muted ? 'muted' : 'non-muted', ...(mediaOptions.expandoClass || '').split(' ')].filter(v => v).map(s => s.toLowerCase()),
    buttonInfo: getMediaButtonInfo(mediaOptions),

    generateMedia() {
      const media = generateMedia(mediaOptions, {
        href
      });

      if (showImages_module.options.crossposts.value === 'withMetadata' && thing && thing.isCrosspost()) {
        media.element.prepend(crosspostMetadataTemplate(thing.element.dataset));
      }

      if (attribution) addSiteAttribution(siteModule, media);
      return media;
    }

  };
}, (thing, {
  href
}) => href);

function updateParentHeight(e) {
  const thing = Thing_Thing.from(e.target);
  if (!thing) return;
  const basisHeight = thing.isSelfPost() && parseInt(showImages_module.options.selfTextMaxHeight.value, 10) || thing.isComment() && parseInt(showImages_module.options.commentMaxHeight.value, 10) || 0;

  if (basisHeight > 0) {
    const expandoHeight = Array.from(thing.entry.querySelectorAll('.res-expando-box, .expando-button.expanded')).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
    thing.element.querySelector('.md').style.maxHeight = `${basisHeight + expandoHeight}px`;
  }
}

function trackNativeExpando(expando, element, thing) {
  if (!showImages_module.options.markSelftextVisited.value && expando.button.classList.contains('selftext')) return;

  const trackLoad = once_default()(() => trackMediaLoad(element, thing));

  if (expando.open) trackLoad();else expando.button.addEventListener('click', trackLoad);
}

function getMediaButtonInfo(options) {
  let title = '';
  let type = options.type;

  if (options.type === 'GALLERY') {
    if (options.src.length === 1) {
      type = options.src[0].type;
    } else {
      title += `${options.src.length} items in gallery`;
    }
  }

  const defaultClass = {
    IMAGE: 'image',
    GALLERY: 'image gallery',
    TEXT: 'selftext',
    VIDEO: options.muted ? 'video-muted' : 'video',
    IFRAME: options.muted ? 'video-muted' : 'video',
    AUDIO: 'video',
    GENERIC_EXPANDO: 'selftext'
  }[type];
  return {
    title,
    mediaClass: options.expandoClass || defaultClass
  };
}

let lastPreloadIndex = 0;

function preloadMedia(pieces) {
  const index = ++lastPreloadIndex;
  return forEachSeq(pieces, piece => {
    if (!piece.generateMedia) return;
    if (lastPreloadIndex !== index) return;
    piece.media = piece.media || piece.generateMedia();
    return piece.media.ready;
  });
}

function generateMedia(options, context) {
  const $span = $('<span>');
  if (options.credits) options.credits = $span.safeHtml(options.credits).html();
  if (options.caption) options.caption = $span.safeHtml(options.caption).html();

  switch (options.type) {
    case 'GALLERY':
      return new showImages_Gallery(options, context);

    case 'IMAGE':
      return new showImages_Image(options, context);

    case 'TEXT':
      return new showImages_Text(options);

    case 'IFRAME':
      return new showImages_Iframe(options);

    case 'VIDEO':
      return new showImages_Video(options, context);

    case 'AUDIO':
      return new showImages_Audio(options);

    case 'GENERIC_EXPANDO':
      return new Generic(options);

    default:
      throw new Error(`Unreachable: invalid media type ${options.type}`);
  }
}

const stopEventPropagation = e => {
  e.stopImmediatePropagation();
};

class Media {
  constructor() {
    this.element = void 0;
    this.ready = void 0;
    this.onAttach = void 0;
    this._state = 'unloaded';
  }

  isAttached() {
    return document.body.contains(this.element);
  }

  expand() {
    this.setLoaded(true);
  }

  collapse() {
    this.setLoaded(false);
  }

  supportsUnload() {
    return false;
  }

  _unload() {}

  _restore() {}

  setLoaded(state) {
    if (state && this._state === 'unloaded') {
      this.element.removeEventListener('mediaResize', stopEventPropagation, true);

      this._restore();

      this._state = 'loaded';
    } else if (!state && this._state === 'loaded') {
      this.element.addEventListener('mediaResize', stopEventPropagation, true);

      this._unload();

      this._state = 'unloaded';
    }
  }

}

class showImages_Gallery extends Media {
  constructor(options, context) {
    super();
    this.filmstripLoadIncrement = parseInt(showImages_module.options.filmstripLoadIncrement.value, 10) || Infinity;
    this.preloadCount = parseInt(showImages_module.options.galleryPreloadCount.value, 10) || 0;
    this.individualCtrl = void 0;
    this.msgPosition = void 0;
    this.ctrlToFilmstrip = void 0;
    this.ctrlConcurrentIncrease = void 0;
    this.pieces = void 0;
    this.lastRevealedPiece = null;
    this.filmstripActive = void 0;
    this.rememberResizeWidth = void 0;
    this.lastResizedWidth = void 0;
    this.element = galleryTemplate({
      title: options.title,
      caption: options.caption,
      credits: options.credits,
      src: options.src
    });
    const piecesContainer = this.element.querySelector('.res-gallery-pieces');
    this.individualCtrl = this.element.querySelector('.res-gallery-individual-controls');
    const ctrlPrev = this.individualCtrl.querySelector('.res-gallery-previous');
    const ctrlNext = this.individualCtrl.querySelector('.res-gallery-next');
    this.msgPosition = this.individualCtrl.querySelector('.res-gallery-position');
    this.ctrlToFilmstrip = this.individualCtrl.querySelector('.res-gallery-to-filmstrip');
    this.ctrlConcurrentIncrease = this.element.querySelector('.res-gallery-increase-concurrent');
    this.pieces = options.src.map(src => ({
      generateMedia: () => generateMedia(src, context),
      media: null,
      wrapper: document.createElement('div')
    }));
    piecesContainer.append(...this.pieces.map(({
      wrapper
    }) => wrapper));
    const slideshowWhenLargerThan = parseInt(showImages_module.options.useSlideshowWhenLargerThan.value, 10) || Infinity;
    this.filmstripActive = showImages_module.options.galleryAsFilmstrip.value && this.pieces.length < slideshowWhenLargerThan;

    if (this.filmstripActive || this.pieces.length === 1) {
      this.ready = this.expandFilmstrip();
      this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
    } else {
      this.element.classList.add('res-gallery-slideshow');
      this.ready = this.changeSlideshowPiece(0);
      ctrlPrev.addEventListener('click', () => {
        this.changeSlideshowPiece(-1);
      });
      ctrlNext.addEventListener('click', () => {
        this.changeSlideshowPiece(1);
      });
      waitForEvent(this.ctrlToFilmstrip, 'click').then(() => {
        this.expandFilmstrip();
        this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
        this.element.classList.remove('res-gallery-slideshow');
      });
    }
  }

  shouldRememberResizeWidth() {
    return showImages_module.options.galleryRememberWidth.value && !this.filmstripActive;
  }

  rememberWidth(piece) {
    const resizedElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    const resizedWidth = resizedElement && parseInt(resizedElement.style.width, 10);
    if (resizedWidth) this.lastResizedWidth = resizedWidth;
  }

  restoreWidth(piece) {
    if (!this.lastResizedWidth) return;
    const resizeElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    if (resizeElement) resizeMedia(resizeElement, this.lastResizedWidth);
  }

  revealPiece(piece) {
    if (this.shouldRememberResizeWidth() && this.lastRevealedPiece) this.rememberWidth(this.lastRevealedPiece);
    this.lastRevealedPiece = piece;
    piece.media = piece.media || piece.generateMedia();
    const {
      media,
      wrapper
    } = piece;
    if (!media.isAttached()) wrapper.appendChild(media.element);
    wrapper.hidden = false;
    if (this.shouldRememberResizeWidth()) this.restoreWidth(piece);
    if (this.isAttached()) media.expand();
  }

  preloadAhead() {
    const preloadFrom = this.pieces.indexOf(this.lastRevealedPiece);
    const preloadTo = Math.min(preloadFrom + this.preloadCount + 1, this.pieces.length);
    return preloadMedia(this.pieces.slice(preloadFrom, preloadTo));
  }

  async expandFilmstrip() {
    const revealFrom = this.lastRevealedPiece ? this.pieces.indexOf(this.lastRevealedPiece) : 0;
    const revealTo = Math.min(revealFrom + this.filmstripLoadIncrement, this.pieces.length);
    this.ctrlConcurrentIncrease.hidden = true;
    await forEachSeq(this.pieces.slice(revealFrom, revealTo), piece => {
      this.revealPiece(piece);
      return piece.media && piece.media.ready;
    });

    if (revealTo < this.pieces.length) {
      this.ctrlConcurrentIncrease.innerText = `Show next ${Math.min(this.filmstripLoadIncrement, this.pieces.length - revealTo)} pieces`;
      this.ctrlConcurrentIncrease.hidden = false;
    }

    return this.preloadAhead();
  }

  changeSlideshowPiece(step) {
    const previous = this.lastRevealedPiece;
    const previousIndex = previous ? this.pieces.indexOf(previous) : 0;
    let newIndex = previousIndex + step;
    newIndex = positiveModulo(newIndex, this.pieces.length);
    this.individualCtrl.setAttribute('first-piece', String(newIndex === 0));
    this.individualCtrl.setAttribute('last-piece', String(newIndex === this.pieces.length - 1));
    this.msgPosition.innerText = String(newIndex + 1);
    this.revealPiece(this.pieces[newIndex]);

    if (previous) {
      const {
        media,
        wrapper
      } = previous;
      if (!media) throw new Error();
      media.collapse();
      wrapper.hidden = true;
    }

    return this.preloadAhead();
  }

  supportsUnload() {
    return this.pieces.every(({
      media
    }) => !media || media.supportsUnload()) || false;
  }

  setLoaded(state) {
    for (const {
      media
    } of this.pieces) {
      if (media) media.setLoaded(state);
    }
  }

}

class showImages_Image extends Media {
  constructor({
    title,
    caption,
    credits,
    src,
    href
  }, context) {
    super();
    this.image = void 0;
    this.src = void 0;
    this.src = src;
    this.element = imageTemplate({
      title,
      caption,
      credits,
      src,
      href: href || context.href,
      openInNewWindow: showImages_module.options.openInNewWindow.value
    });
    this.image = downcast(this.element.querySelector('img.res-image-media'), HTMLImageElement);
    const anchor = this.element.querySelector('a.res-expando-link');
    this.ready = waitForEvent(this.image, 'load', 'error');
    this.image.addEventListener('error', () => {
      this.element.classList.add('res-media-load-error');
    });

    if (showImages_module.options.displayOriginalResolution.value) {
      this.image.addEventListener('load', () => {
        this.image.title = `${this.image.naturalWidth} × ${this.image.naturalHeight} px`;
      });
    }

    setMediaMaxSize(this.image);
    makeMediaZoomable(this.element, this.image);
    const wrapper = setMediaControls(anchor, src, src);
    makeMediaMovable(this.element, wrapper);
    keepMediaVisible(wrapper);
    makeMediaIndependent(wrapper);
  }

  supportsUnload() {
    return true;
  }

  _unload() {
    this.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
  }

  _restore() {
    this.image.src = this.src;
  }

}

class showImages_Iframe extends Media {
  constructor({
    embed,
    embedAutoplay,
    width = '640px',
    height = '360px',
    fixedRatio = false,
    pause: pauseCommand,
    play: playCommand
  }) {
    super();
    this.loaded = false;
    this.iframe = void 0;
    this.pauseCommand = void 0;
    this.playCommand = void 0;
    this.pauseCommand = pauseCommand;
    this.playCommand = playCommand;
    this.element = iframeTemplate({
      url: showImages_module.options.autoplayVideo.value && embedAutoplay ? embedAutoplay : embed,
      width,
      height
    });
    this.iframe = downcast(this.element.querySelector('iframe'), HTMLIFrameElement);
    const iframeWrapper = downcast(this.element.firstElementChild, HTMLElement);
    const dragHandle = this.element.querySelector('.res-iframe-expando-drag-handle');
    makeMediaZoomable(this.element, this.iframe, dragHandle, !fixedRatio);
    makeMediaMovable(this.element, iframeWrapper, dragHandle);
    keepMediaVisible(iframeWrapper);
    makeMediaIndependent(iframeWrapper);
  }

  async expand() {
    if (showImages_module.options.autoplayVideo.value && this.playCommand) {
      if (!this.loaded) await waitForEvent(this.iframe, 'load');
      this.loaded = true;

      try {
        this.iframe.contentWindow.postMessage(this.playCommand, '*');
      } catch (e) {
        console.error('Could not post "play" command to iframe', this, e);
      }
    }
  }

  collapse() {
    if (this.pauseCommand) {
      try {
        this.iframe.contentWindow.postMessage(this.pauseCommand, '*');
        return;
      } catch (e) {
        console.error('Could not post "pause" command to iframe', this, e);
      }
    }

    this.element.remove();
  }

}

class showImages_Text extends Media {
  constructor({
    title,
    credits,
    src
  }) {
    super();
    this.element = textTemplate({
      title,
      credits,
      src: $('<span>').safeHtml(src).html()
    });
  }

}

class showImages_Audio extends Media {
  constructor({
    autoplay = false,
    loop,
    sources
  }) {
    super();
    this.autoplay = void 0;
    this.audio = void 0;
    this.autoplay = autoplay;
    this.element = audioTemplate({
      loop,
      sources
    });
    this.audio = downcast(this.element.querySelector('audio'), HTMLAudioElement);
  }

  collapse() {
    if (!this.isAttached()) return;
    this.autoplay = !this.audio.paused;
    if (!this.audio.paused) this.audio.pause();
  }

  expand() {
    if (this.autoplay) this.audio.play();
  }

}

class Generic extends Media {
  constructor(options) {
    super();
    this.onAttach = options.onAttach;
    this.element = document.createElement('div');
    this.element.appendChild(options.generate());
  }

  collapse() {
    this.element.remove();
  }

}

const trackVisitNative = batch(async things => {
  if (!document.body.classList.contains('gold')) return;
  if (isPrivateBrowsing()) return;
  await ajax({
    method: 'POST',
    url: '/api/store_visits',
    data: {
      links: things.map(t => t.getFullname()).join(',')
    }
  });
}, {
  delay: 10000,
  size: 50
});

function trackMediaLoad(link, thing) {
  if (showImages_module.options.markVisited.value) {
    if (thing) trackVisitNative(thing);
    const isNSFW = thing && thing.isNSFW();
    const sfwMode = showImages_module.options.sfwHistory.value;
    if ((!isNSFW || sfwMode !== 'none') && thing) thing.element.classList.add('visited');
    if (!isNSFW || sfwMode === 'add') addURLToHistory(link.href);
  }
}

function setMediaControls(media, lookupUrl, downloadUrl) {
  if (!showImages_module.options.mediaControls.value) return media;
  const [y, x] = showImages_module.options.mediaControlsPosition.value.split('-');
  const element = mediaControlsTemplate({
    clippy: showImages_module.options.clippy.value,
    lookupUrl,
    downloadUrl,
    x,
    y
  });
  const controls = element.querySelector('.res-media-controls');
  media.replaceWith(element);
  element.appendChild(media);
  media.classList.add('res-media-rotatable');
  let rotationState = 0;

  function refreshRotatedSize({
    width,
    height
  }) {
    const horizontal = rotationState % 2 === 0;
    element.style.height = `${horizontal ? height : width}px`;
    element.style.width = `${horizontal ? width : height}px`;
  }

  const hookInResizeObserver = once_default()(() => {
    new lib_default.a(refreshRotatedSize).observe(media);
  });

  function updateRotation() {
    hookInResizeObserver();
    media.setAttribute('rotation', String(positiveModulo(rotationState, 4)));
    refreshRotatedSize(media.getBoundingClientRect());
  }

  controls.addEventListener('click', e => {
    switch (e.target.dataset.action) {
      case 'rotateLeft':
        --rotationState;
        updateRotation();
        break;

      case 'rotateRight':
        ++rotationState;
        updateRotation();
        break;

      case 'download':
        permissions_namespaceObject.request(['downloads']).then(() => {
          const re = /(?:\.([^.]+))?$/;
          const ext = re.exec(downloadUrl);
          const thing = Thing_Thing.from(media);
          let title = thing && thing.getTitle();

          if (title && ext) {
            let extension = ext[1];
            if (extension.includes('?')) extension = extension.split('?')[0];
            title = title.replace(/[*|?:"<>\\\/]/gi, '');
            const filename = `${title}.${extension}`;
            download(downloadUrl, filename);
          } else download(downloadUrl);
        });
        break;

      case 'imageLookup':
        lookupUrl = new URL(downcast(lookupUrl, 'string'), location.href).href;
        openNewTab(string_namespaceObject.encode`https://images.google.com/searchbyimage?image_url=${lookupUrl}`);
        break;

      case 'showImageSettings':
        settingsNavigation_open(showImages_module.moduleID, 'mediaControls');
        break;

      case 'clippy':
        if (e.target.classList.contains('res-media-controls-clippy-expanded')) {
          options_set(showImages_module, 'clippy', false);
          e.target.remove();
        } else {
          e.target.classList.add('res-media-controls-clippy-expanded');
          e.target.title = 'Click to disable the info button';
          e.target.innerText = getClippyText();
        }

        break;

      default:
        break;
    }

    e.stopPropagation();
    e.preventDefault();
  });
  return element;
}

function addSiteAttribution(siteModule, media) {
  const $element = $(siteAttributionTemplate({
    name: siteModule.name,
    url: siteModule.landingPage || `https://${siteModule.domains[0]}`,
    logoUrl: siteModule.logo,
    settingsLink: makeUrlHash(showImages_module.moduleID, siteModuleOptionKey(siteModule))
  }));
  const $replace = $('.res-expando-siteAttribution', media.element);

  if ($replace.length) {
    $element.replaceAll($replace);
  } else {
    $element.addClass('res-expando-siteAttribution-generic').appendTo(media.element);
  }
}

function keepMediaVisible(media) {
  media.classList.add('res-media-keep-visible');

  const basisLeft = once_default()(() => downcast(media.parentElement, HTMLElement).getBoundingClientRect().left);

  let isAligned = false;
  media.addEventListener('mediaResize', ({
    detail: {
      width: mediaWidth
    }
  }) => {
    const {
      width: viewportWidth
    } = getViewportSize();
    if (!isAligned && basisLeft() + mediaWidth < viewportWidth) return;
    const {
      left: mediaLeft,
      right: mediaRight
    } = media.getBoundingClientRect();
    const deltaLeft = mediaLeft - basisLeft();

    if (mediaWidth > viewportWidth) {
      isAligned = true;
      moveMedia(media, -mediaLeft, 0);
    } else if (mediaRight - deltaLeft > viewportWidth) {
      isAligned = true;
      moveMedia(media, viewportWidth - mediaRight, 0);
    } else if (deltaLeft) {
      isAligned = false;
      moveMedia(media, -deltaLeft, 0);
    }
  });
}

function getClippyText() {
  const clippy = [];

  if (showImages_module.options.imageZoom.value) {
    clippy.push('drag to resize');
  }

  if (showImages_module.options.imageMove.value) {
    clippy.push('shift-drag to move');
  }

  return clippy.join(' or ');
}

function setMediaMaxSize(media) {
  let value = showImages_module.options.maxWidth.value;
  let isPercentage = value.endsWith('%');
  const maxWidth = (isPercentage ? getViewportSize().width / 100 : 1) * parseInt(value, 10);
  if (maxWidth) media.style.maxWidth = `${maxWidth}px`;
  value = showImages_module.options.maxHeight.value;
  isPercentage = value.endsWith('%');
  const maxHeight = (isPercentage ? getViewportSize().height / 100 : 1) * parseInt(value, 10);
  if (maxHeight) media.style.maxHeight = `${maxHeight}px`;
}

function addDragListener({
  media,
  element,
  atShiftKey,
  onStart,
  onMove
}) {
  let hasFrameExecution = false;

  const setFrameExecution = (() => {
    const throttle = frameThrottle(() => {
      hasFrameExecution = false;
    });
    return () => {
      throttle();
      hasFrameExecution = true;
    };
  })();

  let isActive, hasMoved, lastX, lastY;

  const handleMove = e => {
    const movementX = e.clientX - lastX;
    const movementY = e.clientY - lastY;

    if (!movementX && !movementY) {
      return;
    } else if (1 & ~e.buttons) {
      stop();
      return;
    } else if (atShiftKey !== e.shiftKey) {
      isActive = false;
      ({
        clientX: lastX,
        clientY: lastY
      } = e);
      return;
    }

    if (!isActive) {
      if (onStart) onStart(lastX, lastY);
      isActive = true;
      hasMoved = true;
      requestAnimationFrame(() => {
        media.classList.add('res-media-dragging');
      });
    }

    if (hasFrameExecution) return;
    setFrameExecution();
    onMove(e.clientX, e.clientY, movementX, movementY);
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
  };

  function handleClick(e) {
    if (hasMoved) e.preventDefault();
  }

  function stop() {
    requestAnimationFrame(() => {
      media.classList.remove('res-media-dragging');
    });
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', stop);
    setTimeout(() => document.removeEventListener('click', handleClick));
  }

  element.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
    hasMoved = false;
    isActive = false;
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', stop);
    document.addEventListener('click', handleClick);
    e.preventDefault();
  });
}

function makeMediaZoomable(media, element, dragInitiater = element, absoluteSizing = false) {
  if (!showImages_module.options.imageZoom.value) return;
  element.classList.add('res-media-zoomable');
  let initialWidth, initialDiagonal, left, top;

  function getDiagonal(x, y) {
    const w = Math.max(1, x - left);
    const h = Math.max(1, y - top);
    return Math.round(Math.hypot(w, h));
  }

  addDragListener({
    media,
    element: dragInitiater,
    atShiftKey: false,

    onStart(x, y) {
      ({
        left,
        top,
        width: initialWidth
      } = element.getBoundingClientRect());
      initialDiagonal = getDiagonal(x, y);
    },

    onMove(x, y, deltaX, deltaY) {
      if (absoluteSizing) {
        const {
          width,
          height
        } = element.getBoundingClientRect();
        resizeMedia(element, width + deltaX, height + deltaY);
      } else {
        const newWidth = getDiagonal(x, y) / initialDiagonal * initialWidth;
        resizeMedia(element, newWidth);
      }
    }

  });
}

function makeMediaMovable(media, element, dragInitiater = element) {
  if (!showImages_module.options.imageMove.value) return;
  element.classList.add('res-media-movable');

  const mediaManuallyMoved = once_default()(() => {
    element.dispatchEvent(new CustomEvent('mediaManuallyMoved', {
      bubbles: true
    }));
  });

  addDragListener({
    media,
    element: dragInitiater,
    atShiftKey: true,

    onMove(x, y, deltaX, deltaY) {
      moveMedia(element, deltaX, deltaY);
      mediaManuallyMoved();
    }

  });
}

function makeMediaIndependent(element) {
  const wrapper = document.createElement('div');
  const independent = document.createElement('div');
  element.replaceWith(wrapper);
  wrapper.appendChild(independent);
  independent.appendChild(element);
  independent.classList.add('res-media-independent');
  wrapper.style.willChange = 'height';
  wrapper.addEventListener('mediaResize', ({
    detail: {
      height
    }
  }) => {
    wrapper.style.height = `${height}px`;
  });
  const observer = new lib_default.a(contentRect => {
    element.dispatchEvent(new CustomEvent('mediaResize', {
      detail: contentRect,
      bubbles: true
    }));
  });
  observer.observe(element);
  waitForEvent(element, 'mediaManuallyMoved').then(() => {
    observer.disconnect();
  });
}

const mutedVideoManager = once_default()(() => {
  const maxSimultaneousPlaying = parseInt(showImages_module.options.maxSimultaneousPlaying.value, 10) || Infinity;
  const videos = [];
  const updatePlay = frameThrottle(() => {
    const all = videos.map(video => {
      const thing = Thing_Thing.from(video);
      return {
        video,
        visibility: getPercentageVisibleYAxis(video),
        top: video.getBoundingClientRect().top,
        selected: Number(thing && thing.isSelected())
      };
    });
    const notVisible = all.filter(({
      visibility
    }) => visibility === 0);

    for (const {
      video
    } of notVisible) if (!video.paused) video.pause();

    without_default()(all, ...notVisible).sort((a, b) => b.selected - a.selected || b.visibility - a.visibility || a.top - b.top).forEach(({
      video
    }, index) => {
      const play = index < maxSimultaneousPlaying;

      if (play === video.paused) {
        if (play) video.play();else video.pause();
      }
    });
  });
  let intervalId = null;
  return {
    observe(video) {
      videos.push(video);
      updatePlay();
      if (intervalId === null) intervalId = setInterval(updatePlay, 100);
    },

    unobserve(video) {
      pull_default()(videos, video);

      if (!videos.length && intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    }

  };
});

class showImages_Video extends Media {
  constructor({
    title,
    caption,
    credits,
    fallback,
    frameRate = 24,
    href,
    loop = false,
    muted = false,
    playbackRate = 1,
    poster,
    reversable = false,
    reversed = false,
    source,
    sources,
    time = 0
  }, context) {
    super();
    this.video = void 0;
    this.autoplay = void 0;
    this.time = void 0;
    this.frameRate = void 0;
    this.useVideoManager = void 0;
    this.useVideoManager = showImages_module.options.onlyPlayMutedWhenVisible.value && muted;
    this.autoplay = muted || showImages_module.options.autoplayVideo.value;
    this.time = time;
    this.frameRate = frameRate;
    this.element = videoTemplate({
      title,
      caption,
      credits,
      href: href || context.href,
      source,
      poster: !this.autoplay && poster || '',
      hasAudio: !muted,
      loop,
      reversable,
      openInNewWindow: showImages_module.options.openInNewWindow.value,
      formattedPlaybackRate: this.formatMultilineNumber(playbackRate, 'x')
    });
    this.video = downcast(this.element.querySelector('video'), HTMLVideoElement);
    const container = this.element.querySelector('.res-video-container');
    const msgError = this.element.querySelector('.res-video-error');

    const displayError = error => {
      if (msgError.hidden) {
        msgError.hidden = false;
        $('<span>').text(`Could not play video: ${error.message ? String(error.message) : 'Unknown error'}`).appendTo(msgError);
      }
    };

    const sourceElements = $(compact_default()(sources.map(v => {
      if (!this.video.canPlayType(v.type)) return null;
      const source = document.createElement('source');
      source.src = v.source;
      source.type = v.type;
      if (v.reverse) source.dataset.reverse = v.reverse;
      return source;
    }))).appendTo(this.video).get();

    if (!sourceElements.length) {
      if (fallback) {
        return new showImages_Image({
          type: 'IMAGE',
          title,
          caption,
          credits,
          src: fallback
        }, context);
      } else {
        displayError(new Error('No playable sources were found'));
      }
    }

    const lastSource = sourceElements[sourceElements.length - 1];
    lastSource.addEventListener('error', displayError);
    if (reversed) this.reverse();
    this.ready = Promise.race([waitForEvent(this.video, 'suspend'), waitForEvent(lastSource, 'error')]);

    const setPlayIcon = () => {
      if (!this.video.paused) this.element.setAttribute('playing', '');else this.element.removeAttribute('playing');
    };

    this.video.addEventListener('pause', () => {
      setPlayIcon();
      if (this.video.controls && this.useVideoManager) mutedVideoManager().unobserve(this.video);
    });
    this.video.addEventListener('play', setPlayIcon);
    this.video.addEventListener('loadedmetadata', () => {
      if (this.time !== this.video.currentTime) this.video.currentTime = this.time;
    });
    this.video.playbackRate = playbackRate;
    this.video.addEventListener('mousedown', e => {
      if (this.video.hasAttribute('controls')) {
        const {
          height,
          top
        } = this.video.getBoundingClientRect();

        if (height - 0 < e.clientY - top) {
          e.stopImmediatePropagation();
        }
      }
    });
    Promise.all([waitForEvent(this.element, 'mouseenter'), waitForEvent(this.video, 'loadedmetadata')]).then(() => this.addControls());
    new MutationObserver(() => this.element.classList.toggle('res-video-has-native-controls', this.video.hasAttribute('controls'))).observe(this.video, {
      attributes: true
    });

    if (!loop && this.autoplay) {
      waitForEvent(this.video, 'ended').then(() => this.stopAutoplay());
    }

    if (!muted) {
      if (showImages_module.options.startVideosMuted.value) this.video.muted = true;
      Promise.all([waitForEvent(this.video, 'canplay'), showImages_Video.volumeStorage.get()]).then(([, volume]) => {
        this.video.volume = volume;
      });
    }

    setMediaMaxSize(this.video);
    makeMediaZoomable(this.element, this.video);
    setMediaControls(this.video, undefined, sources[0].source);
    makeMediaMovable(this.element, container);
    keepMediaVisible(container);
    makeMediaIndependent(container);
  }

  reverse() {
    this.time = this.video.duration - this.video.currentTime;
    if (isNaN(this.time)) this.time = 0;

    for (const v of this.video.querySelectorAll('source')) {
      [v.src, v.dataset.reverse] = [v.dataset.reverse, v.src];
    }

    this.video.load();
    this.video.play();
    if (this.element.hasAttribute('reversed')) this.element.setAttribute('reversed');else this.element.removeAttribute('reversed');
  }

  formatMultilineNumber(value, suffix) {
    return `${value.toFixed(2).replace('.', '.\u200B')}${suffix}`;
  }

  addControls() {
    const ctrlContainer = this.element.querySelector('.res-video-controls');
    const ctrlReverse = ctrlContainer.querySelector('.res-video-reverse');
    const ctrlTogglePause = ctrlContainer.querySelector('.res-video-toggle-pause');
    const ctrlSpeedDecrease = ctrlContainer.querySelector('.res-video-speed-decrease');
    const ctrlSpeedIncrease = ctrlContainer.querySelector('.res-video-speed-increase');
    const ctrlTimeDecrease = ctrlContainer.querySelector('.res-video-time-decrease');
    const ctrlTimeIncrease = ctrlContainer.querySelector('.res-video-time-increase');
    const progress = this.element.querySelector('.res-video-progress');
    const indicatorPosition = progress.querySelector('.res-video-position');
    const ctrlPosition = progress.querySelector('.res-video-position-thumb');
    const msgSpeed = ctrlContainer.querySelector('.res-video-speed');
    const msgTime = ctrlContainer.querySelector('.res-video-time');
    ctrlTogglePause.addEventListener('click', () => {
      if (this.video.paused) this.video.play();else this.video.pause();
      if (this.video.paused) this.stopAutoplay();
    });
    if (ctrlReverse) ctrlReverse.addEventListener('click', () => this.reverse());
    ctrlSpeedDecrease.addEventListener('click', () => {
      this.video.playbackRate /= 1.1;
    });
    ctrlSpeedIncrease.addEventListener('click', () => {
      this.video.playbackRate *= 1.1;
    });
    ctrlTimeDecrease.addEventListener('click', () => {
      this.video.currentTime -= 1 / this.frameRate;
    });
    ctrlTimeIncrease.addEventListener('click', () => {
      this.video.currentTime += 1 / this.frameRate;
    });
    this.video.addEventListener('ratechange', () => {
      msgSpeed.textContent = this.formatMultilineNumber(this.video.playbackRate, 'x');
    });
    this.video.addEventListener('timeupdate', () => {
      indicatorPosition.style.left = `${this.video.currentTime / this.video.duration * 100}%`;
      msgTime.textContent = this.formatMultilineNumber(this.video.currentTime, 's');
    });
    progress.addEventListener('mousemove', e => {
      let left = e.offsetX;

      if (e.target === ctrlPosition) {
        left += e.target.offsetLeft;
      }

      ctrlPosition.style.left = `${left}px`;
      if (e.buttons === 1) ctrlPosition.click();
    });
    ctrlPosition.addEventListener('click', e => {
      const percentage = (e.target.offsetLeft + e.target.clientWidth / 2) / progress.clientWidth;
      this.video.currentTime = this.video.duration * percentage;
    });
    const ctrlVolume = ctrlContainer.querySelector('.res-video-volume');

    if (ctrlVolume) {
      const ctrlVolumeLevel = ctrlVolume.querySelector('.res-video-volume-level');
      const volumePercentage = ctrlVolume.querySelector('.res-video-volume-percentage');

      const updateVolume = e => {
        const base = ctrlVolumeLevel.clientHeight;
        const click = base - e.offsetY;
        const level = Math.min(click / base, 1);

        if (level > 0.05) {
          this.video.volume = level;
          this.video.muted = false;
          showImages_Video.volumeStorage.set(level);
        } else {
          this.video.muted = true;
        }
      };

      ctrlVolume.addEventListener('click', () => {
        this.video.muted = !this.video.muted;
      });
      ctrlVolumeLevel.addEventListener('mousemove', e => {
        if (e.buttons === 1) updateVolume(e);
      });
      ctrlVolumeLevel.addEventListener('click', e => {
        updateVolume(e);
        e.stopPropagation();
      });

      const refresh = () => {
        ctrlVolume.setAttribute('level', this.video.muted || !this.video.volume ? '0' : String(Math.ceil(this.video.volume * 3)));
        volumePercentage.style.height = `${this.video.volume * 100}%`;
      };

      this.video.addEventListener('volumechange', refresh);
      refresh();
    }
  }

  stopAutoplay() {
    this.autoplay = false;
    if (this.useVideoManager) mutedVideoManager().unobserve(this.video);
  }

  supportsUnload() {
    return this.video.paused;
  }

  _unload() {
    if (!this.isAttached()) return;
    if (!this.video.paused) this.video.pause();
    this.time = this.video.currentTime;
    this.video.setAttribute('src', '');
    this.video.load();
    if (this.useVideoManager) mutedVideoManager().unobserve(this.video);
  }

  _restore() {
    if (this.video.hasAttribute('src')) {
      this.video.removeAttribute('src');
      this.video.load();
    }

    if (this.autoplay) {
      if (this.useVideoManager) mutedVideoManager().observe(this.video);else this.video.play();
    }
  }

}

showImages_Video.volumeStorage = storage_namespaceObject.wrap('showImages.video.volume', 1);
function moveMedia(ele, deltaX, deltaY) {
  ele.style.marginLeft = `${((parseFloat(ele.style.marginLeft) || 0) + deltaX).toFixed(2)}px`;
  ele.style.marginTop = `${((parseFloat(ele.style.marginTop) || 0) + deltaY).toFixed(2)}px`;
}
function resizeMedia(ele, newWidth, newHeight) {
  if (newWidth < 20) return;

  if (typeof newHeight === 'number') {
    ele.style.height = `${newHeight}px`;
  } else if (ele.style.height) {
    const {
      width,
      height
    } = ele.getBoundingClientRect();
    ele.style.height = `${(height / width * newWidth).toFixed(2)}px`;
  }

  ele.style.width = `${newWidth}px`;
  ele.style.maxWidth = ele.style.maxHeight = 'none';
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Expando.js



class Expando_Expando extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = this.conditions.types.length ? `expando ${this.conditions.types.join('|')}` : 'expando';
  }

  static parseCriterion(input) {
    return {
      types: input.split(/[\s|]/).filter(Boolean)
    };
  }

  static thingToCriterion(thing) {
    const expando = thing.isPost() ? expando_Expando.getEntryExpandoFrom(thing) : expando_Expando.getTextExpandosFrom(thing)[0];
    return expando && expando.types.join(' & ') || '';
  }

  isValid() {
    return matchesTypes(this.value.types);
  }

  _matches(e) {
    if (!e) return false;
    if (!e.ready) return null;
    return matchesTypes(this.value.types, e.types);
  }

  _waitTillReady(thing) {
    const completeTask = thing.tasks.byId.get(showImages_module);

    if (completeTask) {
      const promise = completeTask();
      if (!(promise instanceof Promise)) return;
      return Promise.race([promise.catch(() => {}), new Promise(rej => setTimeout(rej, 1000))]).catch(() => {
        promise.finally(() => {
          this.refresh();
        });
      });
    }
  }

  async evaluate(thing) {
    await this._waitTillReady(thing);

    if (thing.isPost()) {
      const expando = expando_Expando.getEntryExpandoFrom(thing);
      return this._matches(expando);
    } else {
      const expandos = expando_Expando.getTextExpandosFrom(thing);
      const res = expandos.map(this._matches.bind(this));
      if (res.some(Boolean)) return true;
      if (res.some(v => v === null)) return null;
      return false;
    }
  }

  onObserve() {
    return true;
  }

}
Expando_Expando.text = 'Expando';
Expando_Expando.defaultConditions = {
  types: []
};
Expando_Expando.fields = ['post has expando, and (if specified) expando types intersects with ', {
  type: 'checkset',
  items: showImages_types,
  id: 'types'
}];
Expando_Expando.slow = 9;
Expando_Expando.pattern = `[(${showImages_types.join('|')})]`;
Expando_Expando.criterionOperators = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsLocked.js

class IsLocked_IsLocked extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'locked';
  }

  evaluate(thing) {
    return thing.isLocked();
  }

}
IsLocked_IsLocked.text = 'Locked';
IsLocked_IsLocked.fields = ['post is locked'];
IsLocked_IsLocked.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsNSFW.js

class IsNSFW_IsNSFW extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'nsfw';
  }

  evaluate(thing) {
    return thing.isNSFW();
  }

}
IsNSFW_IsNSFW.text = 'NSFW';
IsNSFW_IsNSFW.fields = ['post is marked NSFW'];
IsNSFW_IsNSFW.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsSpoiler.js

class IsSpoiler_IsSpoiler extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'spoiler';
  }

  evaluate(thing) {
    return thing.isSpoiler();
  }

}
IsSpoiler_IsSpoiler.text = 'Spoiler';
IsSpoiler_IsSpoiler.fields = ['post is marked spoiler'];
IsSpoiler_IsSpoiler.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsVisited.js


class IsVisited_IsVisited extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'visited';
  }

  evaluate(thing) {
    if (thing.element.classList.contains('visited')) return true;
    const link = thing.getPostLink();
    if (!link) return null;
    return isURLVisited(link.href);
  }

}
IsVisited_IsVisited.text = 'Visited';
IsVisited_IsVisited.fields = ['link has been visited'];
IsVisited_IsVisited.slow = 2;
IsVisited_IsVisited.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/LinkFlair.js

class LinkFlair_LinkFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `link flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getPostFlairText();
  }

  evaluate(thing) {
    const text = thing.getPostFlairText();
    return this.value.some(v => v.test(text));
  }

}
LinkFlair_LinkFlair.text = 'Link flair';
LinkFlair_LinkFlair.fields = ['post has link flair matching ', {
  type: 'text',
  id: 'patt'
}];
LinkFlair_LinkFlair.pattern = '[RegEx]';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAfter.js

class PostAfter_PostAfter extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `after ${this.conditions.patt}`;
    this.value = new Date(this.conditions.patt);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static thingToCriterion(thing) {
    return thing.getTimestamp().toISOString();
  }

  isValid() {
    return !isNaN(this.value);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return postTime >= this.value;
  }

}
PostAfter_PostAfter.text = 'Post after';
PostAfter_PostAfter.defaultConditions = {
  patt: new Date().toISOString()
};
PostAfter_PostAfter.fields = ['posted after date ', {
  type: 'text',
  id: 'patt'
}];
PostAfter_PostAfter.pattern = 'Date — string representing a RFC2822 or ISO 8601 date';
// EXTERNAL MODULE: ./node_modules/lodash/dropWhile.js
var dropWhile = __webpack_require__(132);
var dropWhile_default = /*#__PURE__*/__webpack_require__.n(dropWhile);

// EXTERNAL MODULE: ./node_modules/lodash/head.js
var lodash_head = __webpack_require__(79);
var head_default = /*#__PURE__*/__webpack_require__.n(lodash_head);

// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAge.js




const qualifiers = [['Y', 12], ['M', 30.44], ['d', 24], ['h', 60], ['m', 60], ['s', 1000]];
const PostAge_now = new Date();

function prettifyAge(remainder) {
  let remainderQualifier = '';

  for (const [qualifier, multiplier] of qualifiers.slice().reverse()) {
    if (remainder < multiplier) break;
    remainder /= multiplier;
    remainderQualifier = qualifier;
  }

  return remainder.toFixed(2) + remainderQualifier;
}

class PostAge_PostAge extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `age ${prettyOperator(this.conditions.op)} ${prettifyAge(this.conditions.age)}`;
    this.falseText = `age ${prettyOperator(inverseOperator(this.conditions.op))} ${prettifyAge(this.conditions.age)}`;
  }

  static parseCriterion(input) {
    let age = parseInt(input, 10);
    if (isNaN(age)) throw new Error('Invalid age');
    const ageQualifier = head_default()(input.match(/Y|M|d|h|m|s/)) || 's';
    age = dropWhile_default()(qualifiers, ([qualifier]) => qualifier !== ageQualifier).reduce((a, [, multiplier]) => a * multiplier, age);
    return {
      op: '<=',
      age
    };
  }

  static thingToCriterion(thing) {
    const remainder = PostAge_now - new Date(thing.getTimestamp());
    if (isNaN(remainder)) throw new Error('Could not determine Thing date');
    return prettifyAge(remainder);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return numericalCompare(this.value.op, PostAge_now - postTime, this.value.age);
  }

}
PostAge_PostAge.text = 'Post age';
PostAge_PostAge.defaultConditions = {
  op: '<=',
  age: 4 * 60 * 60 * 1000
};
PostAge_PostAge.fields = ['post is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'duration',
  id: 'age'
}, ' old'];
PostAge_PostAge.pattern = 'x[(Y|M|d|h|m)] — where x is the number of seconds or Y year, M month, h hour, m minute (case sensitive)';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostTitle.js

class PostTitle_PostTitle extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `title contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  evaluate(thing) {
    const title = thing.getTitle();
    return this.value.some(v => v.test(title));
  }

}
PostTitle_PostTitle.text = 'Post title';
PostTitle_PostTitle.fields = ['post\'s title contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostType.js

const PostType_options = [['link post', 'link'], ['self post', 'self']];
class PostType_PostType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `type ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return PostType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'link':
        return thing.isLinkPost();

      case 'self':
        return thing.isSelfPost();

      default:
        return null;
    }
  }

}
PostType_PostType.text = 'Post type';
PostType_PostType.defaultConditions = {
  kind: 'link'
};
PostType_PostType.fields = ['post is a ', {
  type: 'select',
  id: 'kind',
  options: PostType_options
}];
PostType_PostType.pattern = `(${PostType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Score.js


class Score_Score extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `score ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `score ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getScore());
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const score = thing.getScore();
    if (isNaN(score)) return null;
    return numericalCompare(this.value.op, score, this.value.val);
  }

}
Score_Score.text = 'Score';
Score_Score.defaultConditions = {
  op: '>',
  val: 0
};
Score_Score.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' points'];
Score_Score.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Selector.js


class Selector_Selector extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `$('${this.conditions.patt.replace(/\'/g, '\\\'')}')`;
    this.falseText = `$(':not(${this.conditions.patt.replace(/\'/g, '\\\'')}'))`;
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  isValid() {
    return this.value.patt && !!$(this.value.patt);
  }

  evaluate(thing) {
    return $(thing.element).is(this.value.patt) || $(thing.entry).is(this.value.patt) || !!$(thing.entry).has(this.value.patt).length;
  }

}
Selector_Selector.text = 'Selector';
Selector_Selector.defaultConditions = {
  patt: ''
};
Selector_Selector.fields = ['thing matches jQuery selector ', {
  type: 'text',
  id: 'patt'
}];
Selector_Selector.slow = 10;
Selector_Selector.pattern = 'string';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Subreddit.js

class Subreddit_Subreddit extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `in ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getSubreddit();
  }

  evaluate(thing) {
    const subreddit = thing.getSubreddit();
    if (!subreddit) return null;
    return this.value.some(v => v.test(subreddit));
  }

}
Subreddit_Subreddit.text = 'Subreddit';
Subreddit_Subreddit.fields = ['posted in /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserAttr.js


const UserAttr_options = [['a friend', 'friend'], ['a moderator', 'moderator'], ['an admin', 'admin'], ['me', 'me'], ['op', 'submitter']];
class UserAttr_UserAttr extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.attr}`;
  }

  static parseCriterion(input) {
    return {
      attr: input
    };
  }

  isValid() {
    return UserAttr_options.map(([, cls]) => cls).includes(this.value.attr);
  }

  evaluate(thing) {
    if (this.value.attr === 'me') {
      const myName = loggedInUser();
      const author = thing.getAuthor();
      if (!myName || !author) return null;
      return author.trim().toLowerCase() === myName.trim().toLowerCase();
    } else {
      const element = thing.getAuthorElement();
      if (!element) return null;
      return element.classList.contains(this.value.attr);
    }
  }

}
UserAttr_UserAttr.text = 'User attribute';
UserAttr_UserAttr.fields = ['user is ', {
  type: 'select',
  id: 'attr',
  options: UserAttr_options
}];
UserAttr_UserAttr.defaultConditions = {
  attr: 'friend'
};
UserAttr_UserAttr.pattern = `(${UserAttr_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserFlair.js

class UserFlair_UserFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `user flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getUserFlairText();
  }

  evaluate(thing) {
    const text = thing.getUserFlairText();
    return this.value.some(v => v.test(text));
  }

}
UserFlair_UserFlair.text = 'User flair';
UserFlair_UserFlair.fields = ['author of this post has flair matching ', {
  type: 'text',
  id: 'patt'
}];
UserFlair_UserFlair.pattern = '[RegEx]';
// EXTERNAL MODULE: ./node_modules/lodash/fp/slice.js
var slice = __webpack_require__(133);
var slice_default = /*#__PURE__*/__webpack_require__.n(slice);

// EXTERNAL MODULE: ./node_modules/lodash/fp/mapValues.js
var mapValues = __webpack_require__(134);
var mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);

// EXTERNAL MODULE: ./node_modules/lodash/zip.js
var lodash_zip = __webpack_require__(135);
var zip_default = /*#__PURE__*/__webpack_require__.n(lodash_zip);

// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(136);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// CONCATENATED MODULE: ./lib/modules/customToggles.js








const customToggles_module = new Module('customToggles');
customToggles_module.moduleName = 'customTogglesName';
customToggles_module.category = 'coreCategory';
customToggles_module.description = 'customTogglesDesc';
customToggles_module.options = {
  toggle: {
    description: 'customTogglesToggleDesc',
    title: 'customTogglesToggleTitle',
    type: 'table',
    fields: [{
      key: 'key',
      name: 'key',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'enabled',
      type: 'boolean',
      value: true
    }, {
      key: 'text',
      name: 'text',
      type: 'text'
    }],
    value: []
  }
};
const toggles = new Map();
const customToggles = [];

customToggles_module.beforeLoad = () => {
  for (const instance of customToggles_module.options.toggle.value) {
    const [key, initialEnabled, text] = instance;

    if (toggles.has(key)) {
      console.error(`A toggle with key ${key} already exists`, instance);
      continue;
    }

    const toggle = new customToggles_Toggle(key, text, initialEnabled);
    customToggles.push(toggle);
    toggle.onStateChange(() => {
      instance[1] = toggle.enabled;
      $(customToggles_module).trigger($.Event('toggle'));
    });
    toggle.onToggle(() => {
      options_set(customToggles_module, 'toggle', customToggles_module.options.toggle.value);
    });
    toggle.addMenuItem();
  }
};

customToggles_module.contentStart = () => {
  registerCommandLine();
};

class customToggles_Toggle {
  constructor(key, text, enabled) {
    this.text = void 0;
    this.enabled = void 0;
    this.stateChangeCallbacks = [];
    this.toggleCallbacks = [];
    this.multicast = void 0;
    this.text = text;
    this.enabled = enabled;
    this.multicast = multicast(frameThrottle(enabled => {
      this.toggle('multicast', enabled);
    }), {
      local: false,
      name: `toggle.${key}`
    });
    toggles.set(key, this);
  }

  toggle(type = 'manual', state = !this.enabled) {
    if (this.enabled === state) return;
    this.enabled = state;

    for (const callback of this.stateChangeCallbacks) callback();

    if (type !== 'multicast') {
      for (const callback of this.toggleCallbacks) callback(type);

      this.multicast(state);
    }
  }

  onStateChange(callback) {
    this.stateChangeCallbacks.push(callback);
  }

  onToggle(callback) {
    this.toggleCallbacks.push(callback);
  }

  addMenuItem(title = `Toggle ${this.text}`, order = 9, on, off) {
    addMenuItem(once_default()(() => {
      const item = string_namespaceObject.html`<div title="${title}">${this.text || '\u00A0'}</div>`;
      const toggle = createElement_namespaceObject.toggleButton(undefined, this.text, this.enabled, on, off);
      item.append(toggle);
      this.onStateChange(() => {
        toggle.classList.toggle('enabled', this.enabled);
      });
      return item;
    }), e => {
      this.toggle();
      e.stopPropagation();
    }, order);
  }

  addCLI(commandPredicate) {
    registerCommand(commandPredicate, `${commandPredicate} - toggle ${this.text}`, () => ` ${this.enabled ? 'Disable' : 'Enable'} ${this.text}`, () => {
      this.toggle();
    });
  }

  buildCheckbox() {
    const checkbox = document.createElement('input');
    checkbox.setAttribute('type', 'checkbox');
    checkbox.checked = this.enabled;
    checkbox.addEventListener('change', () => {
      this.toggle('manual', checkbox.checked);
    });
    this.onStateChange(() => {
      checkbox.checked = this.enabled;
    });
    return checkbox;
  }

}

function registerCommandLine() {
  const getToggles = val => Array.from(toggles.values()).filter(({
    text
  }) => text.startsWith(val)).sort(({
    text: a
  }, {
    text: b
  }) => a.localeCompare(b));

  registerCommand('toggle', 'toggle - toggle any custom toggle', (command, val) => getToggles(val).length ? `Toggle ${getToggles(val).map((toggle, i) => i === 0 ? `<b>${toggle.text}</b>` : toggle.text).join('|')}` : `No toggles matching <i>${val}</i>`, (command, val) => {
    const match = getToggles(val)[0];
    if (match) match.toggle();else return `${val} does not match a valid toggle`;
  });
}

function toggleActive(key) {
  const toggle = toggles.get(key);
  return !!toggle && toggle.enabled;
}
const customToggles_getToggles = () => (stage_namespaceObject.get(customToggles_module.moduleID) || customToggles_module.options).toggle.value.map(([key,, text]) => ({
  key,
  text
}));
// EXTERNAL MODULE: ./node_modules/lodash/union.js
var union = __webpack_require__(137);
var union_default = /*#__PURE__*/__webpack_require__.n(union);

// CONCATENATED MODULE: ./lib/modules/filteReddit/Filter.js



class Filter_Filter {
  constructor(id, BaseCase, name, conditions = null, state = true, effects = {}) {
    this.id = void 0;
    this.name = void 0;
    this.parent = void 0;
    this.updatePromise = void 0;
    this.BaseCase = void 0;
    this.case = void 0;
    this.state = void 0;
    this.active = false;
    this.element = void 0;
    this.effects = {};

    this.refresh = thing => {
      if (!this.parent) return;
      this.updatePromise = this.parent.refresh(this, thing ? [thing] : undefined);
    };

    this.matches = fastAsync(function* (thing) {
      try {
        const result = yield this.case.evaluate(thing);
        return result === null ? false : this.state === !result;
      } catch (e) {
        return false;
      }
    });
    this.id = id;
    this.BaseCase = BaseCase;
    this.name = name;
    this.state = state;
    Object.assign(this.effects, pickBy_default()(effects, Boolean));
    this.setCase(BaseCase.fromConditions(conditions));
  }

  isActive() {
    return !!this.getEffects().length && this.case.isEvaluatable();
  }

  createElement() {}

  setParent(parent) {
    this.parent = parent;
  }

  getStateText(state = this.state, cased = this.case) {
    return state !== false ? this.name || cased.trueText || (this.BaseCase.text || this.BaseCase.type).toLowerCase() : this.name && `¬ ${this.name}` || cased.falseText || `¬ ${this.getStateText(true, cased)}`;
  }

  getSaveValues() {
    const values = {
      type: this.BaseCase.type,
      state: this.state,
      effects: this.effects
    };

    if (this.BaseCase.variant === 'basic') {
      values.conditions = this.case.conditions;

      if (this.name && this.name !== this.case.trueText) {
        values.name = this.name;
      }
    }

    return values;
  }

  remove() {
    for (const effect of Object.keys(this.effects)) this.effects[effect] = false;

    if (this.parent) this.parent.removeFilter(this);
  }

  getEffects() {
    return Object.entries(this.effects).filter(([, enabled]) => enabled).map(([name]) => name);
  }

  setCase(newCase) {
    this.case = newCase;
    this.active = this.isActive();
    if (this.active) this.case.observe(this);
  }

  update(state = this.state, conditions, effects = {}, describeOnly = false) {
    const cased = conditions === undefined ? this.case : this.BaseCase.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');

    if (describeOnly) {
      return `Show only posts which matches "${this.getStateText(state, cased)}"`;
    }

    this.state = state;
    Object.assign(this.effects, effects);
    this.setCase(cased);
    this.refresh();
    if (this.parent) this.parent.save();
  }

  async updateByInputConstruction({
    criterion,
    disableFilter,
    reverseActive,
    fromSelected
  }, describeOnly = false) {
    if (disableFilter) {
      if (describeOnly) return 'Disable filter';
      return this.update(undefined, undefined, {
        hide: false
      });
    }

    let state, conditions;

    if (fromSelected) {
      ({
        state,
        conditions
      } = await this.BaseCase.getSelectedEntryValue());
    } else {
      if (criterion) conditions = this.BaseCase.criterionToConditions(criterion);
      state = this.state;
    }

    if (reverseActive) state = !state;
    return this.update(state, conditions, {
      hide: true
    }, describeOnly);
  }

  getMatchingEntry(thing) {
    return this.case.conditions;
  }

  removeEntry(entry, effect) {
    this.update(undefined, undefined, {
      [effect]: false
    });
  }

  async buildReasonElement(thing, effect) {
    const entry = await this.getMatchingEntry(thing);
    const element = string_namespaceObject.html`
			<div class="res-thing-filter-remove-matching-entry" title="${JSON.stringify(entry, null, '  ')}">
				${effect}: ${this.getStateText(!this.state)} — click to remove matching filter entry
			</div>
		`;
    element.addEventListener('click', () => {
      this.removeEntry(entry, effect);
    });
    return element;
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/ExternalFilter.js





class ExternalFilter_ExternalFilter extends Filter_Filter {
  constructor(...args) {
    super(...args);
    this.toggleEffects = ['hide'];
  }

  isActive() {
    return this.case.constructor.type !== 'false' && super.isActive();
  }

  createElement() {
    this.element = string_namespaceObject.html`
			<div class="res-filterline-external-filter" type="${this.BaseCase.type}">
				<div>${this.name || this.BaseCase.type}</div>
			</div>
		`;

    if (filteReddit_module.options.hasOwnProperty(this.BaseCase.type)) {
      this.element.prepend(string_namespaceObject.html`${string_namespaceObject.safe(makeUrlHashLink(filteReddit_module.moduleID, this.BaseCase.type, ' ', 'gearIcon'))}`);
    }

    const setActive = active => {
      const effects = this.toggleEffects.reduce((acc, val) => {
        acc[val] = active;
        return acc;
      }, {});
      this.update(undefined, undefined, effects);
    };

    if (isUseful(this.case.constructor.type)) {
      const t = createElement_namespaceObject.toggleButton(setActive, null, this.isActive(), '', '');
      this.element.appendChild(t);
    }
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/LineFilter.js









class LineFilter_LineFilter extends Filter_Filter {
  constructor(id, BaseCase, name, _conditions = null, state = true, effects = {}) {
    if (BaseCase.variant === 'ondemand') {
      const externOpts = BaseCase._customFilter && BaseCase._customFilter.opts;

      if (externOpts) {
        if (!name) ({
          name
        } = externOpts);

        if (!effects.hasOwnProperty('propagate')) {
          const {
            propagate
          } = externOpts;
          Object.assign(effects, {
            propagate
          });
        }
      }
    }

    super(id, BaseCase, name, _conditions, state, effects);
    this.initialConditions = void 0;
    this.getBuilder = memoize_default()((filterline, card) => {
      const builderCases = getByContext(filterline.thingType);
      let lastConditions = this.case.conditions;

      if (this.BaseCase.variant === 'ondemand') {
        Object.assign(builderCases, getByContext('browse'));
        lastConditions = this.BaseCase.getCustomFilter().body;
      }

      if (!this.initialConditions) this.initialConditions = lastConditions;
      const $builderBlock = caseBuilder_namespaceObject.drawBuilderBlock(lastConditions, builderCases, false);
      $builderBlock.on('change input', frameThrottle(() => {
        const conditions = caseBuilder_namespaceObject.readBuilderBlock($builderBlock, builderCases);

        if (!isEqual_default()(lastConditions, conditions)) {
          lastConditions = conditions;
          this.update(undefined, conditions);
          const lastFocus = $builderBlock.get(0).contains(document.activeElement) && document.activeElement;
          if (lastFocus) card.refresh().then(() => lastFocus.focus());
        }
      }));
      return {
        get builder() {
          return $builderBlock.get(0);
        },

        isCaseChanged: () => !isEqual_default()(this.initialConditions, lastConditions)
      };
    });
  }

  update(state = this.state, conditions, effects, describeOnly) {
    if (this.BaseCase.variant === 'ondemand' && conditions && !describeOnly) {
      updateCustomFilter(this.BaseCase.getCustomFilter(), {
        body: conditions
      });
      conditions = null;
    }

    const message = super.update(state, conditions, effects, describeOnly);
    if (this.element) this.refreshElement();
    return message;
  }

  setParent(parent) {
    super.setParent(parent);
    this.getBuilder.cache.clear();
  }

  createElement() {
    this.element = string_namespaceObject.html`<div class="res-filterline-filter" type="${this.BaseCase.type}"></div>`;
    this.refreshElement();
    this.element.addEventListener('click', () => {
      if (!this.effects.hide) this.update(undefined, undefined, {
        hide: true
      });else if (this.state) this.update(false, undefined, {
        hide: true
      });else this.update(true, undefined, {
        hide: false
      });
    });
    this.element.addEventListener('contextmenu', e => {
      if (this.effects.hide) this.update(undefined, undefined, {
        hide: false
      });else this.remove();
      e.preventDefault();
    });
    this.element.addEventListener('mouseenter', async () => {
      await new Promise(res => setTimeout(res, 150));
      if (this.element.matches(':hover')) this.showInfocard();
    });
    this.element.addEventListener('click', () => infocard('filterline-filter').resetShowTimer());
    this.element.addEventListener('contextmenu', () => infocard('filterline-filter').resetShowTimer());
  }

  showInfocard(immediately = false) {
    const card = infocard('filterline-filter');
    if (card.visible) immediately = true;
    card.target(this.element).options({
      width: 570,
      openDelay: immediately ? 0 : 550,
      pin: pin.bottom
    }).populateWith(this.populateHover.bind(this)).begin();
  }

  refreshElement() {
    this.element.setAttribute('text', this.getStateText());
    this.element.classList.toggle('res-filterline-filter-disabled', this.BaseCase.variant !== 'basic' && !this.case.isEvaluatable());
    this.element.classList.toggle('res-filterline-filter-hiding', this.case.isEvaluatable() && !!this.effects.hide);
  }

  populateHover(card) {
    const {
      parent: filterline
    } = this;
    if (!filterline) throw new Error('Filter not attached');

    const redraw = () => {
      this.getBuilder.cache.clear();
      card.refresh();
    };

    const head = string_namespaceObject.html`
			<div class="res-filterline-filter-hover-preamble">
				<span>Filter ${this.BaseCase.text}</span>
				<div class="res-filterline-filter-hover-group" group="case-actions">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
			</div>
		`;
    const body = string_namespaceObject.html`
			<div class="res-filterline-filter-hover">
				<span class="res-filterline-filter-hover-options"></span>
				<span>For posts (<span class="res-filterline-filter-hover-number-matches">…</span>) ${this.state ? 'not ' : ''}matching:</span>
				<div class="builderItem"></div>
				<div class="res-filterline-filter-hover-notice">${this.BaseCase.variant === 'ondemand' && 'By adding browse context conditions such as "Date", "Logged in user", and "Custom toggle", you control where and when this filter is available.'}</div>
				<div class="res-filterline-filter-hover-group" group="match-effects">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
				<div class="res-filterline-filter-hover-group" group="match-actions" hidden>
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
		`;
    const {
      builder,
      isCaseChanged
    } = this.getBuilder(filterline, card);
    body.querySelector('.builderItem').appendChild(builder);
    setTimeout(() => {
      if (!builder.contains(document.activeElement)) {
        const e = [...builder.querySelectorAll('input'), ...builder.querySelectorAll('select')].find(e => e.offsetParent);
        if (e) e.focus();
      }
    });

    if (filterline.thingType === 'comment') {
      const options = body.querySelector('.res-filterline-filter-hover-options');
      const propagate = string_namespaceObject.html`<label><input type="checkbox" ${this.effects.propagate && 'checked'}>Also hide children</label>`;
      options.append(propagate);
      waitForEvent(propagate, 'change').then(() => {
        this.effects.propagate = downcast(propagate.querySelector('input'), HTMLInputElement).checked;
        this.refresh();
      }).then(redraw);
    }

    function addButton(container, text, groupName, action) {
      const button = string_namespaceObject.html`<button class="res-filterline-filter-hover-button" action="${action}">${text}</button>`;
      const group = downcast(container.querySelector(`[group=${groupName}]`), HTMLElement);
      group.hidden = false;
      const buttons = downcast(group.querySelector('.res-filterline-filter-hover-buttons'), HTMLElement);
      buttons.appendChild(button);
      return waitForEvent(button, 'click');
    }

    if (this.BaseCase.variant === 'basic' && this.BaseCase === cases_Group) {
      addButton(head, 'To on-demand', 'case-actions', 'to-ondemand').then(() => {
        const conditions = getGroup('all', [cases_getConditions('currentLocation'), getGroup(this.state ? 'all' : 'none', [this.case.conditions])]);
        if (!this.name) this.name = window.prompt('Filter name:');
        this.BaseCase = addOndemandCase(addCustomFilter({
          body: resolveGroup(conditions, false, true),
          opts: {
            ondemand: true,
            name: this.name
          }
        }));
        this.update(true, null);
      }).then(redraw);
    }

    if (isCaseChanged()) {
      addButton(head, 'Reset change', 'case-actions', 'reset').then(() => {
        this.update(undefined, this.initialConditions);
      }).then(redraw);
    }

    if (this.BaseCase.variant === 'ondemand' || this.BaseCase === cases_Group) {
      addButton(head, 'Rename', 'case-actions', 'rename').then(() => {
        const name = window.prompt('New filter name:', this.case.trueText);
        if (!name) return;

        if (this.BaseCase.variant === 'ondemand') {
          const customFilter = this.BaseCase.getCustomFilter();
          updateCustomFilter(customFilter, {
            opts: {
              name
            }
          });
        }

        this.name = name;
        this.update();
      }).then(redraw);
    }

    addButton(head, 'Invert', 'case-actions', 'invert').then(() => {
      this.update(!this.state);
    }).then(redraw);
    addButton(head, 'Remove', 'case-actions', 'remove').then(() => {
      this.remove();
    }).then(card.close.bind(card));
    addButton(body, this.effects.hide ? 'Don\'t hide' : 'Hide', 'match-effects', `hide-${this.effects.hide ? 'false' : 'true'}`).then(() => {
      this.update(undefined, undefined, {
        hide: !this.effects.hide
      });
    }).then(redraw);
    addButton(body, this.effects.highlight ? 'Don\'t highlighting' : 'Highlight', 'match-effects', 'highlight').then(() => {
      this.update(undefined, undefined, {
        highlight: !this.effects.highlight
      });
    }).then(redraw);

    if (isRunning(commentNavigator_namespaceObject) && !this.effects.hide) {
      addButton(body, 'Navigate by', 'match-actions', 'navigate-by').then(() => {
        updateCustomConditions(getGroup(this.state ? 'none' : 'all', [this.case.conditions]));
        setCategory('custom');
        card.close();
      });
    }

    asyncFilter(Array.from(filterline.things), async thing => await this.matches(thing)).then(matches => {
      const numberSpan = body.querySelector('.res-filterline-filter-hover-number-matches');
      numberSpan.textContent = String(matches.length);

      if (filterline.thingType === 'post' && matches.length) {
        addButton(body, 'Permanently hide', 'match-actions', 'native-hide').then(() => {
          filterline.hidePermanently(matches);
        });
      }
    });
    return [head, body];
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/Filterline.js






















class Filterline_Filterline {
  constructor(storage, thingType) {
    this.things = new Set();
    this.thingType = void 0;
    this.storage = void 0;
    this.filters = [];
    this.sortedFilters = [];
    this.currentMatches = new Map();
    this.permanentlyHiddenThings = new Set();
    this.displayReasons = false;
    this.element = void 0;
    this.dropdown = void 0;
    this.preamble = void 0;
    this.filterContainer = void 0;
    this.poweredElement = void 0;
    this.permanentlyHideCheckbox = void 0;
    this.initialized = false;

    this.togglePowered = (powered = !this.isPowered()) => {
      bodyClasses_namespaceObject.toggle(!powered, 'res-filters-disabled');
      this.poweredElement.checked = powered;
    };

    this.deferredFilters = {};
    this.save = idleThrottle(async () => {
      const filters = this.filters.reduce((acc, v) => {
        acc[v.id] = v.getSaveValues();
        return acc;
      }, { ...this.deferredFilters
      });
      await this.storage.deletePath('filters');
      await this.storage.patch({
        filters,
        lastUsed: Date.now()
      });
    });
    this.availableEffects = {
      propagate: (thing, match) => {
        thing.element.classList.toggle('res-thing-hide-children', !!match);

        this._refreshAfterChange();
      },
      highlight: (thing, match) => {
        thing.entry.style.backgroundColor = match ? 'rgba(255, 155, 155, .16)' : '';
      },
      hide: (thing, match) => {
        thing.setHideFilter(match);

        this._refreshAfterChange();
      },
      placeholder: (thing, match) => {
        function removePlaceholders() {
          thing.element.classList.remove('res-thing-has-placeholder');

          for (const ele of thing.entry.querySelectorAll('.res-thing-placeholder-message')) ele.remove();
        }

        function replaceWithPlaceholder(ele) {
          if (!ele) return;
          const placeholder = string_namespaceObject.html`<span class="res-thing-placeholder-message">
					<span class="res-icon">&#xF093;</span> Content ignored. Click to show anyway.
				</span>`;
          ele.after(placeholder);
          thing.element.classList.add('res-thing-has-placeholder');
          waitForEvent(placeholder, 'click').then(removePlaceholders);
        }

        if (match) {
          replaceWithPlaceholder(thing.getTitleElement());
          replaceWithPlaceholder(thing.getTextBody());
        } else {
          removePlaceholders();
        }

        this._refreshAfterChange();
      },
      collapse: (thing, match) => {
        thing.setCommentCollapse(!!match, 'filterline', true);

        this._refreshAfterChange();
      }
    };
    this._refreshAfterChange = frameThrottle(() => {
      refreshSelect();
      this.checkEmptyState();
    });
    this.refreshThing = keyedMutex(fastAsync(function* (thing, invokedByFilter) {
      if (!this.currentMatches.has(thing)) this.currentMatches.set(thing, {});
      const currentMatches = this.currentMatches.get(thing);
      const effectsToRefresh = Object.keys(this.availableEffects);

      const filtersToTest = union_default()(...effectsToRefresh.map(effect => this.getFiltersToTest(currentMatches[effect], invokedByFilter))).sort((a, b) => this.sortedFilters.indexOf(a) - this.sortedFilters.indexOf(b));

      remove_default()(effectsToRefresh, effect => invokedByFilter && !invokedByFilter.effects.hasOwnProperty(effect) || currentMatches[effect] && !filtersToTest.includes(currentMatches[effect]));

      const updateEffect = (effect, filter) => {
        const old = currentMatches[effect];
        if (filter == old) return;
        currentMatches[effect] = filter;
        this.availableEffects[effect](thing, filter);
        if (this.displayReasons) this.refreshDisplayReasonsChunked([thing]);
      };

      for (const filter of filtersToTest.filter(v => this.getActiveFilters().includes(v))) {
        const effects = filter.getEffects().filter(v => effectsToRefresh.includes(v));

        if (effects.length && (yield filter.matches(thing))) {
          for (const effect of effects) updateEffect(effect, filter);

          pull_default()(effectsToRefresh, ...effects);
        }
      }

      for (const effect of effectsToRefresh) {
        updateEffect(effect, null);
      }
    }));

    this.checkEmptyState = (() => {
      const showNotification = debounce_default()(once_default()(() => {
        const info = $('<p>').text(i18n('filteRedditEmptyNotificationInfo'));
        const toggle = $('<button>').text(i18n('filteRedditEmptyNotificationToggleShowReason')).click(() => {
          this.toggleDisplayReasons();
        });
        notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'everyThingHidden',
          header: i18n('filteRedditEmptyNotificationHeader'),
          message: $('<div>').append(info).append(toggle).get(0),
          closeDelay: Infinity
        });
      }), 3000);

      return () => {
        if (Array.from(this.things).some(v => v.isVisible())) {
          showNotification.cancel();
        } else if (!this.displayReasons && Array.from(this.currentMatches.values()).some(v => v.hide)) {
            showNotification();
          }
      };
    })();

    this.refreshDisplayReasonsChunked = forEachChunked(this.refreshDisplayReasons.bind(this));
    this.storage = storage;
    this.thingType = thingType;
  }

  isInitialized() {
    if (this.initialized) return true;
    if (!this.things.size || !this.getActiveFilters().length) return false;
    this.initialized = true;
    this.sortedFilters = sortBy_default()(this.filters, ({
      case: {
        constructor: {
          slow
        }
      }
    }) => slow);

    if (this.thingType === 'post') {
      delete this.availableEffects.collapse;
      delete this.availableEffects.propagate;
    }

    return true;
  }

  isPowered() {
    return !document.documentElement.classList.contains('res-filters-disabled');
  }

  createElement() {
    const element = this.element = string_namespaceObject.html`
			<div class="res-filterline">
				<div class="res-filterline-preamble"></div>
				<div class="res-filterline-filters">
					<input type="checkbox" ${this.isPowered() && 'checked'} class="res-filterline-toggle-powered" title="Stop filtering temporarily"></input>
				</div>
			</div>
		`;
    this.preamble = element.querySelector('.res-filterline-preamble');
    this.filterContainer = element.querySelector('.res-filterline-filters');
    this.addFilterElements(this.filters);
    waitForEvent(this.preamble, 'mouseenter', 'click').then(() => this.createDropdown());
    this.poweredElement = downcast(element.querySelector('.res-filterline-toggle-powered'), HTMLInputElement);
    this.poweredElement.addEventListener('change', () => {
      this.togglePowered();
    });
  }

  addFilterElements(filters) {
    for (const filter of filters) {
      if (filter instanceof ExternalFilter_ExternalFilter) continue;
      filter.createElement();
      this.filterContainer.appendChild(filter.element);
    }
  }

  getFiltersOfCase(CaseClass) {
    return this.filters.filter(v => v.BaseCase === CaseClass);
  }

  getPickable() {
    return Object.values(getByContext(this.thingType, false)).filter(v => !v.disabled && v.variant !== 'external');
  }

  createDropdown() {
    const element = string_namespaceObject.html`
			<div class="res-filterline-dropdown">
				<div class="res-filterline-dropdown-other"></div>
				<div class="res-filterline-dropdown-toggles">
					<div class="res-filterline-display-match-reason">
						<label>
							<input type="checkbox" ${this.displayReasons && 'checked'}">
							<span>Show matching filters</span>
						</label>
					</div>
				</div>
				<div class="res-filterline-show-help">
					Usage information
				</div>
			</div>
		`;
    this.preamble.append(element);
    this.preamble.addEventListener('mouseenter', () => {
      infocard('filterline-filter').close();
    });

    function addDetails(summary, className, ...elements) {
      const e = string_namespaceObject.html`<details class="${className}"><summary>${summary}</summary></details>`;
      e.append(...elements);
      element.querySelector('.res-filterline-dropdown-other').append(e);
    }

    addDetails('Modify external filters', 'res-filterline-external', ...this.filters.filter(filter => filter instanceof ExternalFilter_ExternalFilter).map(filter => {
      filter.createElement();
      return filter.element;
    }));

    const dp = groupBy_default()(without_default()(this.getPickable(), cases_Group), v => v.variant);

    for (const [name, CaseClasses] of Object.entries(dp)) {
      addDetails(`New ${name} filter`, `res-filterline-new-${name}`, ...CaseClasses.sort((a, b) => a.type.localeCompare(b.type)).map(CaseClass => this.createNewFilterElement(CaseClass)));
    }

    const _getAsConditions = this.getAsConditions.bind(this);

    addDetails('New complex filter', 'res-filterline-new-group', this.createNewFilterElement(cases_Group, 'Copy active filters', {
      get conditions() {
        return _getAsConditions();
      }

    }), ...cases_Group.fields[0].options.map(op => this.createNewFilterElement(cases_Group, `Matches ${op}`, {
      conditions: {
        op,
        of: []
      }
    })));
    addDetails('Use as default', 'res-filterline-set-default', ...defaultFilters.map(({
      type,
      text
    }) => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">${text}</div>`;
      e.addEventListener('click', () => saveFilterlineStateAsDefault(type));
      return e;
    }), (() => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">Reset this Filterline</div>`;
      e.addEventListener('click', () => {
        this.storage.delete();
        if (confirm('Reload page to restore default')) location.reload();
      });
      return e;
    })());
    const displayReasonsCheckbox = downcast(element.querySelector('.res-filterline-display-match-reason input'), HTMLInputElement);
    displayReasonsCheckbox.addEventListener('change', () => {
      this.toggleDisplayReasons(displayReasonsCheckbox.checked);
    });

    if (this.thingType === 'post' && loggedInUser()) {
      const permanentlyHide = string_namespaceObject.html`
				<div class="res-filterline-permanently-hide">
					<label>
						<input type="checkbox">
						<span>Permanently hide</span>
					</label>
				</div>
			`;
      const checkbox = this.permanentlyHideCheckbox = downcast(permanentlyHide.querySelector('input'), HTMLInputElement);
      this.updatePermanentlyHideCheckbox();
      permanentlyHide.addEventListener('click', async () => {
        checkbox.disabled = true;
        await (this.permanentlyHiddenThings.size ? this.unhidePermanently() : this.hidePermanently());
        checkbox.disabled = false;
      });
      element.querySelector('.res-filterline-dropdown-toggles').append(permanentlyHide);
    }

    downcast(element.querySelector('.res-filterline-show-help'), HTMLElement).addEventListener('click', () => {
      showFeatureTip('filterlineVisible');
    });
  }

  updatePermanentlyHideCheckbox() {
    if (!this.permanentlyHideCheckbox) return;
    this.permanentlyHideCheckbox.checked = this.permanentlyHideCheckbox.indeterminate = false;
    if (!this.permanentlyHiddenThings.size) return;
    if (this.getThings('hide').length === this.permanentlyHiddenThings.size) this.permanentlyHideCheckbox.checked = true;else this.permanentlyHideCheckbox.indeterminate = true;
  }

  createNewFilterElement(CaseClass, text = CaseClass.text, newOpts) {
    let fromSelected = false;
    const element = string_namespaceObject.html`<div class="res-filterline-dropdown-action res-filterline-filter-new" type="${CaseClass.type}">${text}</div>`;
    element.addEventListener('click', () => {
      const existing = CaseClass.unique && this.getFiltersOfCase(CaseClass)[0];
      let filter;

      if (existing) {
        if (!(existing instanceof LineFilter_LineFilter)) throw new Error();
        filter = existing;
      } else {
        filter = downcast(this.createFilter({
          type: CaseClass.type,
          add: true,
          ...newOpts
        }), LineFilter_LineFilter);
      }

      if (fromSelected) filter.updateByInputConstruction({
        fromSelected
      });else filter.showInfocard(true);
    });

    if (CaseClass.thingToCriterion || !CaseClass.defaultConditions) {
      const c = string_namespaceObject.html`<div class="res-filterline-filter-new-from-selected" title="From selected entry"></div>`;
      c.addEventListener('click', () => {
        fromSelected = true;
        setTimeout(() => {
          fromSelected = false;
        });
      });
      element.append(c);
    }

    return element;
  }

  async hidePermanently(things = this.getThings('hide')) {
    await Promise.all(difference_default()(things, Array.from(this.permanentlyHiddenThings)).map(thing => thingHide_hide(thing)));

    for (const v of things) this.permanentlyHiddenThings.add(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'hideThings',
      message: string_namespaceObject.html`<div><p>Reddit has now hidden ${things.length} things. Undo by unchecking the checkbox in the menu.</p><p><a href="/user/me/hidden/">See all hidden posts</a></p>`
    });
  }

  async unhidePermanently(things = [...this.permanentlyHiddenThings]) {
    await Promise.all(intersection_default()(things, Array.from(this.permanentlyHiddenThings)).map(thing => unhide(thing)));

    for (const v of things) this.permanentlyHiddenThings.delete(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'unhideThings',
      message: `${things.length} things are no longer hidden.`
    });
  }

  getAsConditions(hasEffect = 'hide') {
    const extracted = filterMap(this.filters, v => v.effects[hasEffect] && v instanceof LineFilter_LineFilter && [v] || undefined);
    return resolveGroup(getGroup('all', extracted.map(v => v.state ? v.case.conditions : getGroup('none', [v.case.conditions]))), false, true);
  }

  resumeDeferredTypes(types) {
    Object.entries(this.deferredFilters).filter(([, {
      type
    }]) => types.includes(type)).forEach(([id]) => this.createFilterFromStateValues(id));
  }

  restoreState(filters) {
    for (const [id, opts] of Object.entries(filters)) {
      try {
        if (opts.type === 'inert') throw new Error('Requested inert filter. This state is likely due to a bug. Ignoring.');
        const filter = this.getFilter(id);
        if (filter) throw new Error(`Filter with id ${id} already exists`);

        if (cases_has(opts.type) && !(cases_get(opts.type).variant === 'external')) {
          this.createFilterFromStateValues(id, opts);
        } else {
          this.deferredFilters[id] = opts;
        }
      } catch (e) {
        console.error('Could not create filter', id, opts);
        this.storage.deletePath('filters', id);
      }
    }
  }

  createFilterFromStateValues(id, opts) {
    const deferredOpts = this.deferredFilters[id];
    delete this.deferredFilters[id];
    return this.createFilter({
      id,
      ...opts,
      ...deferredOpts,
      add: true,
      save: false
    });
  }

  getCLI() {
    const deconstruct = val => {
      const [, modifiers, key, criterion] = val.match(/^([^\w]*)(\w*)(.*)/);
      return {
        key,
        criterion: criterion.trim(),
        disableFilter: !!modifiers.match('/'),
        reverseActive: !!modifiers.match('!'),
        asNewFilter: !!modifiers.match('\\+'),
        fromSelected: !!modifiers.match('=')
      };
    };

    const findMatchingCases = val => this.getPickable().sort((a, b) => a.variant.localeCompare(b.variant) || a.type.localeCompare(b.type)).map(CaseClass => ({
      name: CaseClass.variant === 'ondemand' ? CaseClass.text : CaseClass.type,
      cls: CaseClass
    })).filter(({
      name
    }) => name.toLowerCase().match(val.toLowerCase()));

    let filter;

    async function getTip(val) {
      const deconstructed = deconstruct(val);
      const {
        key,
        asNewFilter
      } = deconstructed;

      const bestMatch = key && sortBy_default()(findMatchingCases(key), ({
        name
      }) => name.toLowerCase().indexOf(key.toLowerCase()))[0];

      const {
        cls: MatchedCase
      } = bestMatch || {};
      let message;

      if (bestMatch) {
        try {
          const lastFilter = last_default()(this.getFiltersOfCase(MatchedCase));

          filter = lastFilter && !asNewFilter ? lastFilter : this.createFilter({
            type: MatchedCase.type
          });
          const actionDescription = await filter.updateByInputConstruction(deconstructed, true);
          message = `${filter.parent ? `Modify "${filter.getStateText(filter.state)}"` : 'New filter'}: ${actionDescription}`;
        } catch (e) {
          message = `Error: ${e.message}`;
        }
      } else {
        filter = null;
        message = 'No filter selected.';
      }

      return ['<pre>', 'Syntax: [modifiers] filterName [criterion]', '', message, '', 'Filters:', ...findMatchingCases('').map(v => ` ${MatchedCase === v.cls ? `<b>${v.name}</b>` : v.name} ${v.cls.pattern}`), '', 'Modifiers:', ' / — disable the filter', ' ! — reverse the active state', ' + — create as new filter', ' = — use the currently selected post\'s data as criterion', '', 'Examples:', ' =postAfter   → filter posts older than selected', ' +=!postAfter → new filter, filter posts younger than selected', '</pre>'].join('\n');
    }

    function executeCommand(val) {
      if (!filter) return;
      if (!filter.parent) this.addFilter(filter);
      filter.updateByInputConstruction(deconstruct(val));
      filter = null;
    }

    return {
      getTip: getTip.bind(this),
      executeCommand: executeCommand.bind(this)
    };
  }

  createFilter(opts) {
    const {
      Filter = LineFilter_LineFilter,
      id = `~${performance.timing.navigationStart + performance.now()}`,
      add = false,
      save = true,
      type,
      criterion,
      effects,
      name,
      state
    } = opts;
    let {
      conditions
    } = opts;
    if (this.deferredFilters.hasOwnProperty(id)) return this.createFilterFromStateValues(id, opts);
    const CaseClass = cases_get(type);
    if (CaseClass.unique && this.getFiltersOfCase(CaseClass).length) throw new Error('Cannot create new instances of unique filters');

    if (!conditions && criterion) {
      conditions = CaseClass.criterionToConditions(criterion);
    }

    const filter = new Filter(id, CaseClass, name, conditions, state, effects);

    if (add) {
      this.addFilter(filter);
      if (save) this.save();
    }

    return filter;
  }

  addFilter(filter) {
    filter.setParent(this);
    this.filters.push(filter);

    if (this.isInitialized()) {
      this.sortedFilters.push(filter);
      this.refresh(filter);
    }

    if (this.filterContainer) this.addFilterElements([filter]);
  }

  async removeFilter(filter) {
    if (filter.element) filter.element.remove();
    if (this.isInitialized()) await this.refresh(filter);

    pull_default()(this.filters, filter);

    pull_default()(this.sortedFilters, filter);

    this.save();
  }

  getFilter(id) {
    return this.filters.find(filter => filter.id === id);
  }

  getActiveFilters() {
    return this.filters.filter(v => v.active);
  }

  getFiltersToTest(currentFilter, invokedByFilter) {
    if (!invokedByFilter) return this.sortedFilters;
    const invokedByFilterIndex = this.sortedFilters.indexOf(invokedByFilter);
    const currentFilterIndex = this.sortedFilters.indexOf(currentFilter);

    if (!currentFilter) {
      return [invokedByFilter];
    } else if (currentFilter === invokedByFilter) {
      return this.sortedFilters.slice(invokedByFilterIndex);
    } else if (currentFilterIndex > invokedByFilterIndex) {
      return [invokedByFilter, currentFilter];
    } else {
      return [];
    }
  }

  refresh(invokedByFilter, things = Array.from(this.things)) {
    return Promise.all(things.map(thing => this.refreshThing(thing, invokedByFilter)));
  }

  addThing(thing) {
    this.things.add(thing);
    if (this.isInitialized()) return this.refreshThing(thing);
  }

  getThings(withEffect) {
    return Array.from(this.currentMatches.entries()).filter(([, effects]) => effects[withEffect]).map(([thing]) => thing);
  }

  toggleDisplayReasons(newState = !this.displayReasons) {
    this.displayReasons = newState;
    this.refreshDisplayReasonsChunked(this.things);
    bodyClasses_namespaceObject.toggle(this.displayReasons, 'res-display-match-reason');
  }

  async refreshDisplayReasons(thing) {
    const reasons = this.displayReasons ? await Promise.all(Object.entries(this.currentMatches.get(thing) || {}).map(([effect, filter]) => filter && filter.buildReasonElement(thing, effect)).filter(Boolean)) : [];
    thing.setFilterReasons(reasons);
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit.js




























const filteReddit_module = new Module('filteReddit');
filteReddit_module.moduleName = 'filteRedditName';
filteReddit_module.category = 'subredditsCategory';
filteReddit_module.description = 'filteRedditDesc';
filteReddit_module.keywords = ['filterreddit'];
filteReddit_module.options = {
  hideUntilProcessed: {
    type: 'boolean',
    value: true,
    description: 'filteRedditHideUntilProcessedDesc',
    title: 'filteRedditHideUntilProcessedTitle',
    advanced: true
  },
  NSFWfilter: {
    type: 'boolean',
    value: false,
    description: 'filteRedditNSFWfilterDesc',
    title: 'filteRedditNSFWfilterTitle'
  },
  allowNSFW: {
    type: 'table',
    addRowText: 'filteRedditAddSubreddits',
    description: 'filteRedditAllowNSFWDesc',
    title: 'filteRedditAllowNSFWTitle',
    fields: [{
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'where',
      name: 'filteRedditAllowNSFWWhere',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditAllowNSFWWhenBrowsingSubreddit',
        value: 'visit'
      }],
      value: 'everywhere'
    }],
    value: []
  },
  NSFWQuickToggle: {
    type: 'boolean',
    value: true,
    description: 'filteRedditNSFWQuickToggleDesc',
    title: 'filteRedditNSFWQuickToggleTitle',
    advanced: true
  },
  showFilterline: {
    type: 'boolean',
    value: false,
    description: 'filteRedditShowFilterlineDesc',
    title: 'filteRedditShowFilterlineTitle'
  },
  excludeOwnPosts: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeOwnPostsDesc',
    title: 'filteRedditExcludeOwnPostsTitle'
  },
  excludeModqueue: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeModqueueDesc',
    title: 'filteRedditExcludeModqueueTitle'
  },
  excludeUserPages: {
    type: 'boolean',
    value: false,
    description: 'filteRedditExcludeUserPagesDesc',
    title: 'filteRedditExcludeUserPagesTitle'
  },
  keywords: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'subreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'unlessKeyword',
      name: 'unlessKeyword',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditKeywordsDesc',
    title: 'filteRedditKeywordsTitle'
  },
  subreddits: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'subreddit',
      name: 'filteRedditSubredditsSubreddits',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditSubredditsDesc',
    title: 'filteRedditSubredditsTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  filterSubredditsFrom: {
    type: 'enum',
    value: 'everywhere-except-subreddit',
    values: [{
      name: 'filteRedditFilterSubredditsEverywhereButSubreddit',
      value: 'everywhere-except-subreddit'
    }, {
      name: 'filteRedditEverywhere',
      value: 'everywhere'
    }, {
      name: 'filteRedditFilterSubredditsAllPopularAndDomain',
      value: 'legacy'
    }],
    description: 'filteRedditFilterSubredditsFromDesc',
    title: 'filteRedditFilterSubredditsFromTitle'
  },
  useRedditFilters: {
    type: 'boolean',
    value: false,
    description: 'filteRedditUseRedditFiltersDesc',
    title: 'filteRedditUseRedditFiltersTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  forceSyncFilters: {
    type: 'button',
    text: 'filteRedditForceSyncFiltersLabel',
    description: 'filteRedditForceSyncFiltersDesc',
    title: 'filteRedditForceSyncFiltersTitle',

    callback() {
      return reconcileNativeFilters({
        warnNotLoggedIn: true
      });
    }

  },
  users: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'username',
      name: 'filteRedditUsername',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditUsersDesc',
    title: 'filteRedditUsersTitle'
  },
  usersMatchAction: {
    type: 'enum',
    value: 'hide',
    values: [{
      name: 'Hidden',
      value: 'hide'
    }, {
      name: 'Replaced with placeholder',
      value: 'placeholder'
    }],
    description: 'filteRedditUsersMatchActionDesc',
    title: 'filteRedditUsersMatchActionTitle'
  },
  usersMatchRepliesAction: {
    type: 'enum',
    value: 'collapse',
    values: [{
      name: 'Kept visible',
      value: ''
    }, {
      name: 'Collapsed',
      value: 'collapse'
    }, {
      name: 'Hidden',
      value: 'propagate'
    }],
    description: 'filteRedditUsersMatchRepliesActionDesc',
    title: 'filteRedditUsersMatchRepliesActionTitle'
  },
  domains: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditDomainsDesc',
    title: 'filteRedditDomainsTitle'
  },
  flair: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditFlairDesc',
    title: 'filteRedditFlairTitle'
  },
  customFiltersP: {
    type: 'builder',
    advanced: true,
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersPTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: ''
        }
      };
    },

    customOptionsFields: [[{
      type: 'check',
      id: 'ondemand',
      label: 'Only filter when added to Filterline (on-demand)'
    }], ['Filterline name: ', {
      type: 'text',
      id: 'name'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('post'),
        ...getByContext('browse')
      };
    }

  },
  customFiltersC: {
    type: 'builder',
    advanced: true,
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersCTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: '',
          propagate: false
        }
      };
    },

    customOptionsFields: [[{
      type: 'check',
      id: 'ondemand',
      label: 'Only filter when added to Filterline (on-demand)'
    }], ['Filterline name: ', {
      type: 'text',
      id: 'name'
    }], [{
      type: 'check',
      id: 'propagate',
      label: 'Hide child commments'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('comment'),
        ...getByContext('browse')
      };
    }

  }
};
filteReddit_module.include = ['linklist', 'modqueue', 'profile', 'comments', 'commentsLinklist', 'search'];
const featureTips = {
  filterline: {
    message: `
RES allows you to easily apply complex filters to post listings and comments. To toggle Filterline, click on the tab.
	`,
    title: 'Filterline',
    position: 6,
    quiet: true
  },
  filterlineVisible: {
    message: () => snudown_es_markdown(`
* Click once on a filter to enable it (e.g. clicking \`expando\` will only show posts with embedded media).
* Click again to only show posts which do not not match.
* A third click makes the filter inactive.
* To clear a filter, right-click on it.
* **Hover** on it to modify conditions, highlight or permanently hide all matches.

To find more filters and options, hover on icon to the left.

You can use the currently selected post as a basis for a new filter. To do this, click on **=** to the right of the filter name.

**Complex filter** creates filters which matches when \`none\`, \`one\`, \`any\`, or \`all\` of the subfilters matches. Click \`To on-demand\` to make these filters available on other pages.

**Use as default** lets you store the current filters to be used on other pages.

To see why a post is hidden, open dropdown and check **Show filter-reason**. This also gives you the opportunity to remove an external filter so that you don't have to look for it in the settings console.

You can use the command line to manipulate Filterline. Enter it by pressing the key \`f\`.
		`),
    title: 'Filterline — how to use it',
    position: 7,
    options: [{
      moduleID: 'filteReddit',
      key: 'showFilterline'
    }]
  }
};
const pageID = fullLocation();
const filterlineStorage = storage_namespaceObject.wrap(`filterline.${pageID}`, {});
const filteReddit_thingType = isPageType('comments', 'commentsLinklist') ? 'comment' : 'post';
const customFilterVariant = filteReddit_thingType === 'post' ? 'customFiltersP' : 'customFiltersC';

const createStateFromTypes = types => types.reduce((acc, v, i) => {
  if (v) acc[`!${i}`] = {
    type: v
  };
  return acc;
}, {});

const defaultFilters = [];

if (filteReddit_thingType === 'comment') {
  if (currentSubreddit()) {
    defaultFilters.push({
      type: 'subreddit',
      text: 'This subreddit',
      storage: storage_namespaceObject.wrap(`RESmodules.filteReddit.commentDefault-${String(currentSubreddit())}`, null)
    });
  }

  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.commentDefault', createStateFromTypes(['hasExpando', 'score', 'isRead']))
  });
} else if (filteReddit_thingType === 'post') {
  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.postDefault', createStateFromTypes(['isNSFW', 'isSpoiler', 'isVisited', 'commentsOpened', 'hasExpando', 'score']))
  });
}

async function getDefaultFilters() {
  for (const {
    storage
  } of defaultFilters) {
    const filters = await storage.get();
    if (filters) return filters;
  }
}

let nsfwToggle;
let filteReddit_filterline;
let filteReddit_visible;

const filteReddit_initial = (async () => {
  let {
    filters,
    visible,
    lastUsed
  } = await filterlineStorage.get();
  if (!filters || !Object.values(filters).length) filters = await getDefaultFilters();
  return {
    filters,
    visible,
    lastUsed
  };
})();

filteReddit_module.beforeLoad = async () => {
  updateNsfwBodyClass(filteReddit_module.options.NSFWfilter.value);
  nsfwToggle = new customToggles_Toggle('nsfwMode', i18n('nsfwSwitchToggleText'), filteReddit_module.options.NSFWfilter.value);
  nsfwToggle.onToggle(() => {
    options_set(filteReddit_module, 'NSFWfilter', nsfwToggle.enabled);
  });
  nsfwToggle.onStateChange(() => {
    updateNsfwBodyClass(nsfwToggle.enabled);
  });
  nsfwToggle.addCLI('nsfw');
  watchForThings(['post'], updateNsfwThingClass, {
    immediate: true
  });
  populatePrimitives(['browse', filteReddit_thingType]);
  filteReddit_filterline = new Filterline_Filterline(filterlineStorage, filteReddit_thingType);
  let filters, lastUsed;
  ({
    filters,
    visible: filteReddit_visible,
    lastUsed
  } = await filteReddit_initial);
  filteReddit_filterline.restoreState(filters);
  populateFromOptions();
  const hideUntilProcessed = filteReddit_module.options.hideUntilProcessed.value && filteReddit_filterline.getActiveFilters().length;
  watchForThings([filteReddit_thingType], async thing => {
    if (!shouldFilter(thing)) return;
    if (hideUntilProcessed) thing.element.classList.add('res-thing-filter-unprocessed');

    try {
      await filteReddit_filterline.addThing(thing);
    } catch (e) {
      console.error(e);
    }

    if (hideUntilProcessed) thing.element.classList.remove('res-thing-filter-unprocessed');
  }, {
    immediate: true,
    id: 'filter'
  });
  if (filteReddit_module.options.excludeModqueue.value && isPageType('modqueue') || filteReddit_module.options.excludeUserPages.value && isPageType('profile')) filteReddit_filterline.togglePowered(false);

  if (typeof filteReddit_visible !== 'boolean') {
    filteReddit_visible = filteReddit_module.options.showFilterline.value || filteReddit_filterline.getActiveFilters().some(v => !(v instanceof ExternalFilter_ExternalFilter));
  }

  if (lastUsed) requestIdleCallback(() => {
    filterlineStorage.patch({
      lastUsed: Date.now()
    });
  });
};

filteReddit_module.contentStart = () => {
  makeFilterlineInteractable();

  if (filteReddit_module.options.NSFWQuickToggle.value) {
    nsfwToggle.addMenuItem(i18n('nsfwSwitchToggleTitle'), 8);
  }

  registerSubredditFilterCommand();
};

const shouldFilter = thing => !(filteReddit_module.options.excludeOwnPosts.value && context_data.username && currentUserProfile() !== context_data.username && context_data.username === thing.getAuthor());

function makeFilterlineInteractable() {
  const insertFilterline = once_default()(() => {
    filteReddit_filterline.createElement();

    if (isPageType('comments')) {
      document.querySelector('.comments-page .nestedlisting').before(filteReddit_filterline.element);
    } else {
      document.querySelector('#siteTable, .search-result-listing').before(filteReddit_filterline.element);
    }

    addFeatureTip('filterlineVisible', { ...featureTips.filterlineVisible,
      attachTo: filteReddit_filterline.element
    });
  });

  const filterlineTab = createElement_namespaceObject.tabMenuItem({
    text: '',
    title: 'Toggle Filterline visibility',
    className: 'res-toggle-filterline-visibility',
    checked: filteReddit_visible
  });
  filterlineTab.addEventListener('change', ({
    detail: newVisibilityState
  }) => {
    filteReddit_visible = newVisibilityState;

    if (filteReddit_visible) {
      insertFilterline();
      scrollToElement(filteReddit_filterline.element, null, {
        scrollStyle: 'legacy'
      });
    }

    if (filteReddit_filterline.element) filteReddit_filterline.element.hidden = !filteReddit_visible;
    filterlineStorage.patch({
      visible: filteReddit_visible
    });
  });

  const ensureVisible = () => {
    if (!filteReddit_visible) filterlineTab.click();
  };

  const {
    getTip,
    executeCommand
  } = filteReddit_filterline.getCLI();
  registerCommand(/(fl|filterline)/, 'fl - modify Filterline', (cmd, val) => getTip(val), (cmd, val) => {
    ensureVisible();
    executeCommand(val);
  });
  registerCommand(/fp/, 'fp - toggle filtering', () => 'Toggle filtering', () => {
    ensureVisible();
    filteReddit_filterline.poweredElement.click();
  });
  addFeatureTip('filterline', { ...featureTips.filterline,
    attachTo: filterlineTab,
    continuation: () => {
      ensureVisible();
      return 'filterlineVisible';
    }
  });
  if (filteReddit_visible) insertFilterline();
}

class filteReddit_ListFilter {
  get list() {
    return filteReddit_module.options[this.externalKey].value;
  }

  constructor(externalKey) {
    this.externalKey = void 0;
    this.filter = void 0;
    this.externalKey = externalKey;
  }

  initialize(caseType, additionalCriteria, useEffects = ['hide']) {
    const _listFilter = this;

    const sources = new Map();
    this.filter = addExternalFilter(this.externalKey, i18n(filteReddit_module.options[this.externalKey].title), () => {
      sources.clear();
      return resolveGroup(getGroup('any', this.list.map(v => {
        const c = getStringMatchConditions(v, caseType, additionalCriteria);
        sources.set(c, v);
        return c;
      })));
    }, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects = {}) {
        const _effects = useEffects.reduce((acc, val) => {
          acc[val] = typeof effects[val] === 'boolean' ? effects[val] : true;
          return acc;
        }, {});

        super(id, BaseCase, name, conditions, state, _effects);
        this.toggleEffects = useEffects;
      }

      async getMatchingEntry(thing) {
        const matching = Array.from(sources.keys()).map(v => Case_Case.fromConditions(v).evaluate(thing) && sources.get(v));
        return (await Promise.all(matching)).filter(Boolean);
      }

      removeEntry(entries) {
        _listFilter.toggleEntry(false, ...entries);
      }

    });
  }

  findEntry(matchString) {
    return this.list.find(([str]) => str.toLowerCase() === matchString.toLowerCase());
  }

  toggleEntry(newState, ...entries) {
    if (newState) {
      this.list.push(...entries);
    } else {
      pull_default()(this.list, ...entries);
    }

    options_set(filteReddit_module, this.externalKey, this.list);
    if (this.filter) return this.filter.update(undefined, null);
  }

  includesString(matchString) {
    return !!this.findEntry(matchString);
  }

  async toggleString(matchString, newState = !this.includesString(matchString)) {
    if (Thing_Thing.selected) Thing_Thing.selected.anchor();
    await this.toggleEntry(newState, this.findEntry(matchString) || [matchString]);
  }

}

const listFilters = {
  users: new filteReddit_ListFilter('users'),
  subreddits: new filteReddit_ListFilter('subreddits'),
  keywords: new filteReddit_ListFilter('keywords'),
  domains: new filteReddit_ListFilter('domains'),
  flair: new filteReddit_ListFilter('flair')
};
function addExternalFilter(id, name, getConditions, Filter = ExternalFilter_ExternalFilter) {
  const cased = createAdHoc(id, getConditions, 'external', filteReddit_thingType);
  return filteReddit_filterline.createFilter({
    Filter,
    id,
    name,
    type: cased.type,
    state: false,
    add: true,
    save: false
  });
}

function populateFromOptions() {
  const customFilters = groupBy_default()(filteReddit_module.options[customFilterVariant].value, ({
    opts: {
      ondemand
    } = {}
  }) => ondemand ? 'ondemand' : 'always');

  if (customFilters.ondemand) {
    const cases = customFilters.ondemand.map(v => addOndemandCase(v, true));
    filteReddit_filterline.resumeDeferredTypes(cases.map(({
      type
    }) => type));
  }

  addExternalFilter(customFilterVariant, i18n(filteReddit_module.options[customFilterVariant].title), () => ({
    type: 'false'
  }));

  for (const customFilter of customFilters.always || []) {
    const conditions = resolveGroup(customFilter.body);
    if (!isUseful(conditions.type)) continue;
    addExternalFilter(customFilter.id, (customFilter.opts || {}).name, () => conditions, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects) {
        const propagate = !!(customFilter.opts && customFilter.opts.propagate);
        super(id, BaseCase, name, conditions, state, {
          hide: true,
          propagate,
          ...effects
        });
      }

    });
  }

  if (!isPageType('profile')) {
    const effects = [filteReddit_module.options.usersMatchAction.value, filteReddit_module.options.usersMatchRepliesAction.value].filter(Boolean);
    listFilters.users.initialize('username', undefined, effects);
  }

  if (filteReddit_thingType === 'post') {
    listFilters.keywords.initialize('postTitle');
    listFilters.domains.initialize('domain', {
      fullMatch: false
    });

    if (filteReddit_module.options.filterSubredditsFrom.value === 'everywhere' || filteReddit_module.options.filterSubredditsFrom.value === 'everywhere-except-subreddit' && !currentSubreddit() || isCurrentSubreddit('all') || isCurrentSubreddit('popular') || currentDomain() || isCurrentMultireddit('me/f/all')) {
      listFilters.subreddits.initialize('subreddit');
    }

    listFilters.flair.initialize('linkFlair');
  }
}

function addOndemandCase(customFilter, onlyUseful = false) {
  const getConditions = () => resolveGroup(customFilter.body);

  if (!onlyUseful || isUseful(getConditions().type)) {
    return createAdHoc(customFilter.id, getConditions, 'ondemand', filteReddit_thingType, customFilter);
  } else {
    return cases_Inert;
  }
}
function addCustomFilter({
  body,
  opts
}) {
  const customFilter = {
    note: `From ${fullLocation()}`,
    ver: 3,
    id: `customFilter-${Date.now()}`,
    body,
    opts
  };
  options_set(filteReddit_module, customFilterVariant, [customFilter, ...filteReddit_module.options[customFilterVariant].value]);
  return customFilter;
}
function updateCustomFilter(customFilter, val) {
  extendDeep(customFilter, val);
  options_set(filteReddit_module, customFilterVariant, filteReddit_module.options[customFilterVariant].value);
}
async function saveFilterlineStateAsDefault(type) {
  const {
    storage
  } = defaultFilters.find(v => v.type === type) || {};
  if (!storage) throw new Error(`Could not find storage for type ${type}`);
  const v = await filterlineStorage.get();
  let {
    filters
  } = cloneDeep_default()(v) || {};
  if (isEmpty_default()(filters)) filters = null;
  await storage.set(filters);
  notifications_showNotification('Saved.', 1000);
}

function getStringMatchConditions(source, caseType, additionalCriteria) {
  const [matchString = '', applyTo = 'everywhere', applyList = '', except = ''] = source;
  const mainFilter = {
    type: caseType,
    patt: matchString,
    ...additionalCriteria
  };
  if (source.length === 1) return mainFilter;
  let applyToConditions;

  if (applyTo !== 'everywhere') {
    const subreddits = applyList.split(',');

    if (subreddits.findIndex(v => !v) !== -1) {
      console.error('Filter must have subreddits specified', source);
      return {
        type: 'false'
      };
    }

    applyToConditions = getGroup(applyTo === 'exclude' ? 'none' : 'any', [subreddits.includes('all') ? {
      type: 'currentSub',
      patt: 'all'
    } : null, subreddits.includes('popular') ? {
      type: 'currentSub',
      patt: 'popular'
    } : null, ...subreddits.map(sr => ({
      type: 'subreddit',
      patt: sr
    }))].filter(Boolean));
  }

  return getGroup('all', [applyToConditions || null, mainFilter, except && except.length && getGroup('none', [{
    type: caseType,
    patt: except,
    ...additionalCriteria
  }]) || null].filter(Boolean));
}

const reconcileNativeFilters = (() => {
  const getTopScore = batch(async requests => {
    const resp = await ajax({
      url: `/r/${requests.map(r => r.sub).join('+')}/top.json`,
      query: {
        t: 'day',
        limit: 100
      },
      type: 'json'
    });

    if (!resp.data.children.length) {
      return requests.map(() => 0);
    }

    const topScoreBySub = flow_default()(() => resp.data.children.reverse(), keyBy_default()(post => post.data.subreddit.toLowerCase()), mapValues_default()(post => post.data.score))();

    return requests.map(({
      sub,
      depth = 0
    }) => {
      const score = topScoreBySub[sub.toLowerCase()];

      if (score !== undefined) {
        return score;
      } else if (depth > 5) {
        return 0;
      } else {
        return getTopScore({
          sub,
          depth: depth + 1
        });
      }
    });
  }, {
    size: 100,
    delay: 2000
  });

  async function sortByPopularity(subreddits) {
    const scores = await Promise.all(subreddits.map(sub => getTopScore({
      sub
    })));
    return sortBy_default()(zip_default()(subreddits, scores), ([, score]) => score).map(([sub]) => sub).filter(Boolean).reverse();
  }

  return mutex(async ({
    warnNotLoggedIn = false
  } = {}) => {
    const user = context_data.username;

    if (!user) {
      if (warnNotLoggedIn) {
        notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'filterSyncNotLoggedIn',
          header: 'Filters not synced',
          message: 'You must log in to sync filters.'
        });
      }

      console.warn('Not syncing filters, not logged in...');
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'filterSyncStarted',
      message: 'Filter sync started...'
    });
    const {
      data: {
        subreddits
      }
    } = await ajax({
      url: `/api/filter/user/${user}/f/all`,
      type: 'json'
    });
    const existing = subreddits.map(({
      name
    }) => name.toLowerCase());
    const desired = await asyncFlow(map_default()(([sr]) => sr), filter_default()(sr => !string_namespaceObject.regexRegex.test(sr)), map_default()(name => name.toLowerCase()), sortByPopularity, slice_default()(0, 100))(filteReddit_module.options.subreddits.value);

    const toRemove = difference_default()(existing, desired).length;

    const toAdd = difference_default()(desired, existing).length;

    if (!toRemove && !toAdd) {
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncNoneAddedOrRemoved',
        closeDelay: 5000,
        header: 'No filters synced',
        message: `
					Either no subreddit filters were changed, or you have more than 100 subreddits filtered.
					Reddit's native /r/all filtering is limited to 100 subreddits.
				`
      });
      return;
    }

    try {
      await ajax({
        method: 'PUT',
        url: `/api/filter/user/${user}/f/all`,
        data: {
          model: JSON.stringify({
            subreddits: desired.map(name => ({
              name
            }))
          })
        }
      });
    } catch (e) {
      console.error(e);
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncError',
        header: 'Error syncing filters',
        message: `Filters could not be synced: ${e}`
      });
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      optionKey: 'useRedditFilters',
      notificationID: 'filterSyncSuccess',
      header: 'Successfully synced filters',
      message: `Removed ${toRemove} and added ${toAdd} filters.`
    });
  });
})();

const subredditAllowNsfwOption = once_default()(() => indexOptionTable(filteReddit_module.options.allowNSFW, 0, key => key.toLowerCase()));

const allowAllNsfw = memoize_default()(subreddit => {
  const currOptionValue = subredditAllowNsfwOption()[subreddit.toLowerCase()];
  return currOptionValue && currOptionValue[0][1] === 'visit';
});

function allowNSFW(postSubreddit, currSubreddit = currentSubreddit()) {
  if (!filteReddit_module.options.allowNSFW.value || !filteReddit_module.options.allowNSFW.value.length) return false;

  if (currSubreddit && allowAllNsfw(currSubreddit)) {
    return true;
  }

  if (!postSubreddit) postSubreddit = currSubreddit;
  if (!postSubreddit) return false;
  const postOptionValue = subredditAllowNsfwOption()[postSubreddit.toLowerCase()];

  if (postOptionValue) {
    if (postOptionValue[0][1] === 'everywhere') {
      return true;
    } else {
      return (currSubreddit || '').split('+').includes(postSubreddit);
    }
  }

  return false;
}

function updateNsfwThingClass(thing) {
  if (thing.isNSFW()) {
    if (allowNSFW(thing.getSubreddit(), currentSubreddit())) {
      thing.element.classList.add('allowOver18');
    }

    thing.element.classList.add('over18');
  }
}

function updateNsfwBodyClass(filterOn) {
  bodyClasses_namespaceObject.toggle(filterOn, 'hideOver18');
}

function registerSubredditFilterCommand() {
  const getSubreddit = val => val || Thing_Thing.selected && Thing_Thing.selected.getSubreddit() || currentSubreddit() || '';

  registerCommand(/^f(?:ilter)?/, 'f[ilter] [subreddit] - toggle subreddit filter', (cmd, val) => {
    const subreddit = getSubreddit(val);
    return `toggle subreddit filter for: ${subreddit}`;
  }, (cmd, val) => {
    const subreddit = getSubreddit(val);
    if (!subreddit) return 'no subreddit specified or post selected';
    listFilters.subreddits.toggleString(subreddit);
  });
}
// EXTERNAL MODULE: ./node_modules/suncalc/suncalc.js
var suncalc = __webpack_require__(138);

// CONCATENATED MODULE: ./lib/modules/subredditStyleToggle.js








const subredditStyleToggle_module = new Module('subredditStyleToggle');
subredditStyleToggle_module.moduleName = 'subredditStyleToggleName';
subredditStyleToggle_module.category = 'appearanceCategory';
subredditStyleToggle_module.description = 'subredditStyleToggleDesc';
subredditStyleToggle_module.alwaysEnabled = true;
subredditStyleToggle_module.options = {
  browserToolbarButton: {
    title: 'subredditStyleToggleBrowserToolbarButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleBrowserToolbarButtonDesc',
    keywords: ['css'],
    noconfig: true
  },
  checkbox: {
    title: 'subredditStyleToggleCheckboxTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleCheckboxDesc',
    keywords: ['css']
  }
};
const ignoredStorage = storage_namespaceObject.wrap('RESmodules.subredditStyleToggle.ignored', []);
let subredditStyleToggle_toggle;
let refresh;

subredditStyleToggle_module.onInit = () => {
  pageAction_namespaceObject.hide();
  const ready = Promise.all([shouldDisable(), hasToggleableElements()]).then(([disable, has]) => {
    if (has) {
      bodyClasses_namespaceObject.add('res-srstyle-enabled');
      createToggle(!disable);
    }
  });

  refresh = nightmodeCompatible => ready.then(async () => {
    if (subredditStyleToggle_toggle) subredditStyleToggle_toggle.toggle('auto', !(await shouldDisable(nightmodeCompatible)));
  });
};

function createToggle(initialState) {
  const subreddit = (currentSubreddit() || '').toLowerCase();
  if (subredditStyleToggle_toggle || !subreddit) return;
  subredditStyleToggle_toggle = new customToggles_Toggle(`${subredditStyleToggle_module.moduleID}.${subreddit}`, 'Custom subreddit style', true);
  subredditStyleToggle_toggle.onToggle(async type => {
    if (type !== 'manual') return;
    await toggledSubredditStyle(subredditStyleToggle_toggle.enabled);
    const ignoredSubreddits = new Set((await ignoredStorage.get()));

    if (subredditStyleToggle_toggle.enabled) {
      ignoredSubreddits.delete(subreddit);
    } else if (await isNightmodeCompatible()) {
      ignoredSubreddits.add(subreddit);
    }

    ignoredStorage.set(Array.from(ignoredSubreddits));
  });
  subredditStyleToggle_toggle.onStateChange(() => {
    toggleElements(subredditStyleToggle_toggle.enabled);
    bodyClasses_namespaceObject.toggle(subredditStyleToggle_toggle.enabled, 'res-srstyle-enabled');
    bodyClasses_namespaceObject.toggle(!subredditStyleToggle_toggle.enabled, 'res-srstyle-disabled');
  });
  subredditStyleToggle_toggle.toggle('auto', initialState);
  makeInteractable();
}

function makeInteractable() {
  if (subredditStyleToggle_module.options.checkbox.value) {
    sitetableStarted.then(() => {
      const place = document.body.querySelector('.titlebox h1.redditname');
      if (place) insertCheckbox(place);
    });
  }

  if (subredditStyleToggle_module.options.browserToolbarButton.value) {
    pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    subredditStyleToggle_toggle.onStateChange(() => {
      pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    });
    pageAction_namespaceObject.onClick(() => {
      subredditStyleToggle_toggle.toggle('manual');
    });
  }

  subredditStyleToggle_toggle.addCLI('srstyle');

  if ($('#show_stylesheets').length) {
    $('label[for=show_stylesheets]').after(string_namespaceObject.escape` <span class="little gray">(${i18n('subredditStyleToggleRedditPrefsMessage')} <a href="/r/Enhancement/wiki/srstyle">${i18n('subredditStyleToggleClickToLearnMore')}</a>)</span>`);
  }
}

function insertCheckbox(place) {
  const container = string_namespaceObject.html`
		<form class="toggle res-sr-style-toggle">
			<label for="res-style-checkbox">${i18n('subredditStyleToggleUse')}</label>
		</form>
	`;
  const checkbox = subredditStyleToggle_toggle.buildCheckbox();
  checkbox.setAttribute('id', 'res-style-checkbox');
  checkbox.setAttribute('name', 'res-style-checkbox');
  container.prepend(checkbox);
  place.after(container);
}

const shouldDisable = (nightmodeCompatible = isNightmodeCompatible(true)) => asyncSome([async () => (await ignoredStorage.get()).includes((currentSubreddit() || '').toLowerCase()), async () => !(await nightmodeCompatible)], f => f());

const hasToggleableElements = () => asyncSome([getStylesheet, async () => !!(await getHeaderImg()).headerImg], f => f());

const getStylesheet = once_default()(async () => {
  const query = () => (document.head || document.documentElement).querySelector('link[title=applied_subreddit_stylesheet]');

  return query() || (await bodyStart.then(query)) || null;
});

const getHeaderImg = once_default()(async () => {
  const query = () => document.getElementById('header-img-a');

  const imgWrapper = (await bodyStart.then(query)) || (await waitForChild(document.body, '#header').then(query)) || (await init_contentStart.then(query));
  return {
    imgWrapper,
    headerImg: imgWrapper && (() => document.getElementById('header-img'))()
  };
});

const toggleElements = (() => {
  const toggleStylesheet = mutex(async shouldRestore => {
    const subredditStylesheet = await getStylesheet();
    if (!subredditStylesheet) return;

    if (shouldRestore) {
      if (!subredditStylesheet.parentNode) {
        document.head.appendChild(subredditStylesheet);
      }
    } else {
      if (subredditStylesheet.parentNode) {
        subredditStylesheet.remove();
      }
    }
  });
  const toggleHeaderImg = mutex(async shouldRestore => {
    const {
      imgWrapper,
      headerImg
    } = await getHeaderImg();
    if (!imgWrapper || !headerImg) return;

    if (shouldRestore) {
      if (!headerImg.parentNode) {
        imgWrapper.id = 'header-img-a';
        imgWrapper.classList.remove('default-header');
        imgWrapper.appendChild(headerImg);
      }
    } else {
      if (headerImg.parentNode) {
        headerImg.remove();
        imgWrapper.id = 'header-img';
        imgWrapper.classList.add('default-header');
      }
    }
  });
  return shouldRestore => Promise.all([toggleStylesheet(shouldRestore), toggleHeaderImg(shouldRestore)]);
})();
// CONCATENATED MODULE: ./lib/modules/nightMode.js











const nightMode_module = new Module('nightMode');
nightMode_module.moduleName = 'nightModeName';
nightMode_module.category = 'appearanceCategory';
nightMode_module.description = 'nightModeDesc';
nightMode_module.options = {
  nightModeOn: {
    type: 'boolean',
    value: false,
    description: 'nightModeNightModeOnDesc',
    title: 'nightModeNightModeOnTitle'
  },
  nightSwitch: {
    type: 'boolean',
    value: true,
    description: 'nightModeNightSwitchDesc',
    title: 'nightModeNightSwitchTitle',
    advanced: true
  },
  automaticNightMode: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'nightModeAutomaticNightModeNone',
      value: 'none'
    }, {
      name: 'nightModeAutomaticNightModeAutomatic',
      value: 'automatic'
    }, {
      name: 'nightModeAutomaticNightModeUser',
      value: 'user'
    }],
    description: 'nightModeAutomaticNightModeDesc',
    title: 'nightModeAutomaticNightModeTitle'
  },
  nightModeStart: {
    type: 'text',
    value: '20:00',
    description: 'nightModeNightModeStartDesc',
    title: 'nightModeNightModeStartTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeEnd: {
    type: 'text',
    value: '6:00',
    description: 'nightModeNightModeEndDesc',
    title: 'nightModeNightModeEndTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeOverrideHours: {
    type: 'text',
    value: '8',
    description: 'nightModeNightModeOverrideHoursDesc',
    title: 'nightModeNightModeOverrideHoursTitle',
    dependsOn: options => options.automaticNightMode.value !== 'none'
  },
  useSubredditStyles: {
    type: 'boolean',
    value: false,
    description: 'nightModeUseSubredditStylesDesc',
    title: 'nightModeUseSubredditStylesTitle',
    advanced: true
  },
  subredditStylesWhitelist: {
    type: 'list',
    value: '',
    listType: 'subreddits',
    description: 'nightModeSubredditStylesWhitelistDesc',
    title: 'nightModeSubredditStylesWhitelistTitle'
  },
  coloredLinks: {
    type: 'boolean',
    bodyClass: true,
    value: false,
    description: 'nightModeColoredLinksDesc',
    title: 'nightModeColoredLinksTitle'
  }
};
const localStorageKey = 'RES_nightMode';

const nightModeActive = () => typeof localStorage === 'object' && !!localStorage.getItem(localStorageKey);

const nightmodeOverrideStorage = storage_namespaceObject.wrap('RESmodules.nightMode.nightModeOverrideStart', null);
let nightMode_toggle;

nightMode_module.onToggle = enabled => {
  if (nightMode_toggle && nightMode_toggle.enabled && !enabled) nightMode_toggle.toggle();
};

nightMode_module.onInit = () => {
  if (nightModeActive()) addNightMode();
};

nightMode_module.beforeLoad = () => {
  if (isNightModeOn()) {
    addNightMode();
  } else {
    removeNightMode();
  }

  nightMode_toggle = new customToggles_Toggle('nightMode', i18n('nightModeToggleText'), nightMode_module.options.nightModeOn.value);
  nightMode_toggle.onToggle(type => {
    if (type === 'manual') overrideNightMode();
    options_set(nightMode_module, 'nightModeOn', nightMode_toggle.enabled);
  });
  nightMode_toggle.onStateChange(() => {
    if (nightMode_toggle.enabled) addNightMode();else removeNightMode();
    isNightmodeCompatible();
  });
  nightMode_toggle.addCLI('ns');
  if (nightMode_module.options.nightSwitch.value) nightMode_toggle.addMenuItem(i18n('nightModeToggleTitle'), 7, '☽', '☀');
  handleAutomaticNightMode();
};

nightMode_module.always = () => {
  if (!isRunning(nightMode_module)) {
    removeNightMode();
  }
};

function isNightModeOn() {
  if (!isRunning(nightMode_module)) return false;
  return nightMode_toggle ? nightMode_toggle.enabled : nightMode_module.options.nightModeOn.value;
}
async function isNightmodeCompatible(useCache = false) {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    return true;
  }

  if (['all', 'popular', 'friends', 'mod'].includes(subreddit)) {
    return true;
  }

  const isAllowedByOptions = async () => {
    await init_loadOptions;

    if (!isNightModeOn()) {
      return true;
    }

    if (nightMode_module.options.useSubredditStyles.value) {
      return true;
    }

    const isWhitelisted = nightMode_module.options.subredditStylesWhitelist.value.split(',').includes(subreddit.toLowerCase());

    if (isWhitelisted) {
      return true;
    }
  };

  const isSubredditCompatible = async () => {
    const query = () => !!document.querySelector('.side a[href$="#/RES_SR_Config/NightModeCompatible"]');

    return query() || (await bodyStart.then(query)) || (await waitForChild(document.body, '.side').then(query)) || init_contentStart.then(query);
  };

  const id = `isNightmodeCompatible.${subreddit.toLowerCase()}`;

  const updatePromise = async function () {
    const compatible = (await isAllowedByOptions()) || (await isSubredditCompatible());
    await session_namespaceObject.set(id, compatible);
    if (cached !== compatible && refresh) refresh(compatible);
    return compatible;
  }();

  const stored = await session_namespaceObject.get(id);
  const cached = typeof stored === 'boolean' ? stored : !nightModeActive();
  return useCache ? cached : updatePromise;
}
async function toggledSubredditStyle(toggledOn) {
  const currSub = currentSubreddit();

  if (!isNightModeOn() || !currSub) {
    return;
  }

  const subreddit = currSub.toLowerCase();
  const whitelist = nightMode_module.options.subredditStylesWhitelist.value.split(',');

  if (toggledOn && !(await isNightmodeCompatible())) {
    if (!whitelist.includes(subreddit)) {
      whitelist.push(subreddit);
    }
  } else if (!toggledOn) {
    pull_default()(whitelist, subreddit);
  }

  await options_set(nightMode_module, 'subredditStylesWhitelist', whitelist.join(','));
}

const handleAutomaticNightMode = once_default()(async function check() {
  if (nightMode_module.options.automaticNightMode.value === 'none') {
    return;
  }

  const nightModeOverrideStart = await nightmodeOverrideStorage.get();
  const nightModeOverrideLength = HOUR * parseFloat(nightMode_module.options.nightModeOverrideHours.value);
  const nightModeOverrideEnd = (parseInt(nightModeOverrideStart, 10) || 0) + nightModeOverrideLength;
  const isOverrideActive = Date.now() <= nightModeOverrideEnd;
  const needsNightModeToggle = !isOverrideActive && isNightModeOn() !== (await isTimeForNightMode());

  if (needsNightModeToggle) {
    nightMode_toggle.toggle('auto');
  }

  setTimeout(() => requestAnimationFrame(check), 5 * MINUTE);
});

function overrideNightMode() {
  if (nightMode_module.options.automaticNightMode.value === 'none') {
    return;
  }

  nightmodeOverrideStorage.set(Date.now());
}

function getGeolocation() {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(position => resolve(position.coords), reject);
  });
}

async function getNightModeTimes() {
  switch (nightMode_module.options.automaticNightMode.value) {
    case 'automatic':
      try {
        const {
          latitude,
          longitude
        } = await getGeolocation();
        const {
          sunrise,
          sunset
        } = Object(suncalc["getTimes"])(new Date(), latitude, longitude);
        return {
          startingTime: sunset,
          endingTime: sunrise
        };
      } catch (err) {
        console.warn('Failed to init automatic night mode:', err);

        switch (err.code) {
          case err.PERMISSION_DENIED:
            return alert_namespaceObject.open(i18n('nightModeAutomaticNightModeDenied', 'confirm'), {
              cancelable: true
            }).then(() => {
              options_set(nightMode_module, 'automaticNightMode', 'none');
              return {
                startingTime: new Date(0),
                endingTime: new Date(0)
              };
            });

          case err.POSITION_UNAVAILABLE:
          case err.TIMEOUT:
          case err.UNKNOWN_ERROR:
          default:
            throw err;
        }
      }

    case 'user':
      return {
        startingTime: timeStringToDate(nightMode_module.options.nightModeStart.value),
        endingTime: timeStringToDate(nightMode_module.options.nightModeEnd.value)
      };

    default:
      throw new Error(`Invalid automaticNightMode value: ${nightMode_module.options.automaticNightMode.value}`);
  }
}

async function isTimeForNightMode() {
  const currentTime = new Date();
  const {
    startingTime,
    endingTime
  } = await getNightModeTimes();

  if (startingTime <= endingTime) {
    return startingTime <= currentTime && currentTime < endingTime;
  } else {
    return startingTime <= currentTime || currentTime < endingTime;
  }
}

function timeStringToDate(timeString) {
  const [hour, minute] = timeString.split(':').map(s => parseInt(s, 10));
  const date = new Date();
  date.setHours(hour, minute, 0, 0);
  return date;
}

const nightMode_className = () => {
  switch (appType()) {
    case 'r2':
    case 'options':
      return 'res-nightmode';

    case 'd2x':
      return 'res-d2x-nightmode';

    default:
      throw new Error(`Impossible appType: ${appType()}`);
  }
};

const addNightMode = () => {
  bodyClasses_namespaceObject.add(nightMode_className());
  localStorage.setItem(localStorageKey, 'true');
};

const removeNightMode = () => {
  bodyClasses_namespaceObject.remove(nightMode_className());
  localStorage.removeItem(localStorageKey);
};
// CONCATENATED MODULE: ./lib/modules/userTagger.js













const userTagger_module = new Module('userTagger');
const bgToTextColorMap = {
  none: 'inherit',
  aqua: 'black',
  black: 'white',
  blue: 'white',
  cornflowerblue: 'white',
  fuchsia: 'white',
  gray: 'white',
  green: 'white',
  lime: 'black',
  maroon: 'white',
  navy: 'white',
  olive: 'white',
  orange: 'white',
  orangered: 'white',
  pink: 'black',
  purple: 'white',
  red: 'white',
  silver: 'black',
  teal: 'white',
  white: 'black',
  yellow: 'black'
};
userTagger_module.moduleName = 'userTaggerName';
userTagger_module.category = 'usersCategory';
userTagger_module.description = 'userTaggerDesc';
userTagger_module.options = {
  showTaggingIcon: {
    title: 'userTaggerShowTaggingIconTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerShowTaggingIconDesc'
  },
  storeSourceLink: {
    title: 'userTaggerStoreSourceLinkTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerStoreSourceLinkDesc',
    advanced: true
  },
  useCommentsLinkAsSource: {
    title: 'userTaggerUseCommentsLinkAsSourceTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerUseCommentsLinkAsSourceDesc',
    advanced: true
  },
  trackVoteWeight: {
    title: 'userTaggerTrackVoteWeightTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTrackVoteWeightDesc',
    advanced: true
  },
  vwNumber: {
    title: 'userTaggerVwNumberTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerVWNumberDesc',
    advanced: true,
    dependsOn: options => options.trackVoteWeight.value
  },
  truncateTag: {
    title: 'userTaggerTruncateTagTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTruncateTagDesc',
    advanced: true
  },
  presetTags: {
    title: 'userTaggerPresetTagsTitle',
    type: 'table',
    addRowText: '+add preset',
    fields: [{
      key: 'text',
      name: 'text',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'select',
      value: 'none',
      values: Object.entries(bgToTextColorMap).map(([k, v]) => ({
        name: k,
        value: k,
        style: `color: ${v}; background-color: ${k};`
      }))
    }],
    value: [],
    description: 'userTaggerPresetTagsDesc',
    advanced: true
  }
};
const tagStorage = storage_namespaceObject.wrapPrefix('tag.', () => null, user => user.toLowerCase(), true);

userTagger_module.beforeLoad = () => {
  watchForThings(null, thing => {
    const user = thing.getAuthor();
    if (user) userTagger_Tag.get(user);
  }, {
    immediate: true
  });
  watchForElements(['page', 'selfText'], usernameSelector, applyFromElement);
  watchForRedditEvents('postAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;

    for (const tag of element.getElementsByClassName('RESUserTag')) tag.remove();

    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('commentAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('userHovercard', (element, {
    user: {
      username
    },
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username,
      renderTaggingIcon: false
    });
  });
};

userTagger_module.contentStart = () => {
  if (userTagger_module.options.trackVoteWeight.value && loggedInUser()) {
    attachVoteHandler();
  }

  userTagger_registerCommandLine();
};

userTagger_module.go = () => {
  if (isCurrentSubreddit('dashboard')) {
    userTagger_addDashboardFunctionality();
  }
};

function applyFromElement(element) {
  const username = getUsernameFromLink(element);
  if (username) return applyToUser(element, {
    username
  });
}

function applyToUser(element, {
  username,
  renderTaggingIcon = userTagger_module.options.showTaggingIcon.value && username !== loggedInUser(),
  renderVoteWeight = userTagger_module.options.trackVoteWeight.value && username !== loggedInUser()
} = {}) {
  const tag = userTagger_Tag.getUnfilled(username);
  tag.add(element, {
    renderVoteWeight,
    renderTaggingIcon
  });
  tag.fill();
}
const userTagger_tags = new Map();
class userTagger_Tag {
  static buildTagElement({
    text,
    color
  } = {}) {
    return string_namespaceObject.html`
			<span class="RESUserTag">
				<a
					class="userTagLink ${text || color ? 'hasTag' : 'RESUserTagImage'} ${userTagger_module.options.truncateTag.value ? 'truncateTag' : ''}"
					${(text || color) && string_namespaceObject._html`style="background-color: ${color || 'none'}; color: ${bgToTextColorMap[color || 'none']} !important;"`}
					title="${text || 'set a tag'}"
					href="javascript:void 0"
				>${text || '\u00A0'}</a>
			</span>
		`;
  }

  static async getStored() {
    return Object.entries((await tagStorage.getAll())).map(([k, v]) => {
      const tag = userTagger_Tag.getUnfilled(k);
      tag.load(v);
      return tag;
    });
  }

  static getUnfilled(id) {
    let tag = userTagger_tags.get(id);

    if (!tag) {
      tag = new userTagger_Tag(id);
      userTagger_tags.set(id, tag);
    }

    return tag;
  }

  static async get(id) {
    const tag = userTagger_Tag.getUnfilled(id);
    await tag.fill();
    return tag;
  }

  get ignored() {
    return listFilters.users.includesString(this.id);
  }

  constructor(id = '~dummy') {
    this.id = void 0;
    this.text = null;
    this.link = null;
    this.color = null;
    this.votesUp = 0;
    this.votesDown = 0;
    this.instances = [];
    this.fill = once_default()(async () => {
      const data = await tagStorage.get(this.id);

      if (data) {
        if (Object.keys(this.getBaseDifference(data)).length) {
          this.load(data);
        } else {
          this.delete();
        }
      }
    });
    this.id = id;
  }

  load(data) {
    if (data.color !== undefined) this.color = data.color;else if (data.color === 'none') this.color = null;
    if (data.link !== undefined) this.link = data.link;
    if (data.text !== undefined) this.text = data.text;
    if (data.votesDown !== undefined) this.votesDown = data.votesDown;
    if (data.votesUp !== undefined) this.votesUp = data.votesUp;

    for (const instance of this.instances) this.render(instance);
  }

  extract() {
    return {
      color: this.color,
      link: this.link,
      text: this.text,
      votesDown: this.votesDown,
      votesUp: this.votesUp
    };
  }

  save() {
    tagStorage.set(this.id, this.getBaseDifference());
  }

  getBaseDifference(data = this.extract()) {
    const base = new userTagger_Tag().extract();
    return pickBy_default()(data, (v, k) => base[k] !== v);
  }

  delete() {
    tagStorage.delete(this.id);
  }

  add(element, {
    renderTaggingIcon,
    renderVoteWeight
  } = {}) {
    const instance = this.instances.find(v => v.element === element) || {
      element
    };
    if (!this.instances.includes(instance)) this.instances.push(instance);
    if (renderTaggingIcon) instance.renderTaggingIcon = true;
    if (renderVoteWeight) instance.renderVoteWeight = true;
    this.render(instance);
  }

  get votes() {
    return this.votesUp - this.votesDown;
  }

  ignore({
    showNotice = true
  } = {}) {
    if (showNotice) {
      notifications_showNotification({
        moduleID: userTagger_module.moduleID,
        notificationID: 'addedToIgnoreList',
        message: `
					<p>Now ignoring content posted by ${this.id}.</p>
					${isPageType('inbox') ? `
						<p>If you wish to block ${this.id} from sending you messages, go to <a href="/message/messages/">your messages</a> and click 'block user' underneath their last message.</p>
						<p><a href="https://www.reddit.com/r/changelog/comments/ijfps/reddit_change_users_may_block_other_users_that/">About blocking users</a>.</p>
					` : ''}
				`,
        closeDelay: 5000
      });
    }

    listFilters.users.toggleString(this.id, true);
    if (!this.text) this.load({
      text: 'ignored'
    });
    this.save();
  }

  unignore() {
    listFilters.users.toggleString(this.id, false);
    if (this.text === 'ignored') this.load({
      text: null
    });
    this.save();
  }

  openPrompt(instance) {
    if (this.link === null && userTagger_module.options.storeSourceLink.value) {
      this.link = getLinkBasedOnTagLocation(instance.element);
    }

    infocard('userTagger').target(instance.tagger || instance.element).options({
      openDelay: 0,
      width: 350,
      closeOnMouseOut: false
    }).populateWith(card => populateDialog(this, card)).begin();
  }

  render(instance) {
    if (instance.vw) instance.vw.remove();

    if (instance.renderVoteWeight && (this.votesUp || this.votesDown)) {
      instance.vw = preventCloning(string_namespaceObject.html`
				<a
					class="voteWeight"
					href="javascript:void 0"
					title="${i18n('userTaggerYourVotesFor', this.id, `+${this.votesUp} -${this.votesDown}`)}"
					style="${getVoteWeightStyle(this)}"
				>${userTagger_module.options.vwNumber.value ? `[${this.votes > 0 ? '+' : ''}${this.votes}]` : '[vw]'}</a>
			`);
      instance.vw.addEventListener('click', () => this.openPrompt(instance));

      if (isAppType('d2x')) {
        (instance.tagger || instance.element).appendChild(instance.vw);
      } else {
        (instance.tagger || instance.element).after(instance.vw);
      }
    }

    if (instance.tagger) instance.tagger.remove();

    if (this.text || this.color || instance.renderTaggingIcon) {
      instance.tagger = preventCloning(this.text || this.color ? userTagger_Tag.buildTagElement(this) : userTagger_Tag.defaultTagElement());
      instance.tagger.addEventListener('click', () => this.openPrompt(instance));

      if (isAppType('d2x')) {
        instance.element.appendChild(instance.tagger);
      } else {
        instance.element.after(instance.tagger);
      }
    }
  }

}

userTagger_Tag.defaultTagElement = (e => () => e().cloneNode(true))(once_default()(() => userTagger_Tag.buildTagElement()));

function populateDialog(tag, card) {
  const head = string_namespaceObject.html`<div class="userTagger-dialog-head">
		<span class="res-icon">&#xF0AC;</span>
		<span>${tag.id}</span>
		<span class="res-usertag-ignore"></span>
		</div>
	</div>`;
  const colors = Object.entries(bgToTextColorMap).map(([color, textColor]) => ({
    textColor,
    color
  }));
  const presetTags = userTagger_module.options.presetTags.value;
  const body = string_namespaceObject.html`
		<form id="userTaggerToolTip">
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerText">Text</label>
				<input class="fieldPair-text" type="text" id="userTaggerText" value="${tag.text}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerColor">Color</label>
				<select id="userTaggerColor">
					${colors.map(({
    textColor,
    color
  }) => string_namespaceObject._html`
						<option style="color: ${textColor}; background-color: ${color}" value="${color}" ${tag.color === color && string_namespaceObject._html`selected`}>${color}</option>
					`)}
				</select>
			</div>
			<div class="fieldPair" style="flex-wrap: wrap">
				<label class="fieldPair-label" for="userTaggerPreview">Preview</label>
				<span id="userTaggerPreview"></span>
				<a id="userTaggerPresetSaveAs" title="save as preset" href="javascript:void 0">save as preset</a>
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerLink">
					<span class="userTaggerOpenLink">
						<a title="open link" href="javascript:void 0">Source URL</a>
					</span>
				</label>
				<input class="fieldPair-text" type="text" id="userTaggerLink" value="${tag.link}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesUp" title="Upvotes you have given this redditor">Upvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesUp" value="${tag.votesUp}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesDown" title="Downvotes you have given this redditor">Downvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesDown" value="${tag.votesDown}">
			</div>
			<div class="fieldPair" ${!presetTags.length && 'hidden'}>
				<label class="fieldPair-label" for="userTaggerPresetTags">Presets</label>
				<span id="userTaggerPresetTags"></span>
			</div>
			<div class="res-usertagger-footer">
				<a href="/r/dashboard#userTaggerContents" target="_blank" rel="noopener noreferer">View tagged users</a>
				<input type="submit" id="userTaggerSave" value="✓ save tag">
			</div>
		</form>
	`;
  const elements = {
    color: downcast(body.querySelector('#userTaggerColor'), HTMLSelectElement),
    presetSaveAs: downcast(body.querySelector('#userTaggerPresetSaveAs'), HTMLAnchorElement),
    presetTag: downcast(body.querySelector('#userTaggerPresetTags'), HTMLElement),
    presetFieldPair: downcast(body.querySelector('#userTaggerPresetTags').parentElement, HTMLElement),
    link: downcast(body.querySelector('#userTaggerLink'), HTMLInputElement),
    openLink: downcast(body.querySelector('.userTaggerOpenLink a'), HTMLAnchorElement),
    preview: downcast(body.querySelector('#userTaggerPreview'), HTMLElement),
    save: downcast(body.querySelector('#userTaggerSave'), HTMLElement),
    text: downcast(body.querySelector('#userTaggerText'), HTMLInputElement),
    votesDown: downcast(body.querySelector('#userTaggerVotesDown'), HTMLInputElement),
    votesUp: downcast(body.querySelector('#userTaggerVotesUp'), HTMLInputElement)
  };
  head.querySelector('.res-usertag-ignore').append(createElement_namespaceObject.toggleButton(ignore => {
    const textShouldBeUpdated = extract().text === tag.text;
    if (ignore) tag.ignore();else tag.unignore();
    if (textShouldBeUpdated) elements.text.value = tag.text || '';
    updateTagPreview();
  }, 'userTaggerIgnore', tag.ignored, '\uF038', '\uF03B', false, true));

  function extract() {
    return {
      color: elements.color.value !== 'none' ? elements.color.value : null,
      link: elements.link.value || null,
      text: elements.text.value || null,
      votesDown: parseInt(elements.votesDown.value, 10) || 0,
      votesUp: parseInt(elements.votesUp.value, 10) || 0
    };
  }

  function updateTagPreview() {
    empty(elements.preview);
    elements.preview.appendChild(userTagger_Tag.buildTagElement(extract()));
  }

  function buildPresetTagElement(text, color) {
    const element = userTagger_Tag.buildTagElement({
      text,
      color
    });
    element.addEventListener('click', () => {
      tag.load({
        text,
        color
      });
      tag.save();
      card.close();
    });
    return element;
  }

  function saveAsPreset() {
    const {
      text,
      color
    } = extract();

    if (text || color) {
      elements.presetFieldPair.hidden = false;
      elements.presetTag.append(buildPresetTagElement(text, color));
      options_set(userTagger_module.moduleID, 'presetTags', [...presetTags, [text, color]]);
    } else {
      window.alert('Tag text must be specified in order to save as preset.');
    }
  }

  elements.openLink.addEventListener('click', () => openNewTabs('none', ...elements.link.value.split(/\s/)));
  elements.presetTag.append(...presetTags.map(([text, color]) => buildPresetTagElement(text, color)));
  elements.presetSaveAs.addEventListener('click', () => saveAsPreset());
  $(body).on('change input click', updateTagPreview);
  body.addEventListener('submit', e => {
    e.preventDefault();
    tag.load(extract());
    tag.save();
    card.close();
  });
  updateTagPreview();
  setTimeout(() => {
    elements.text.setSelectionRange(elements.text.value.length, elements.text.value.length);
    elements.text.focus();
  });
  return [head, body];
}

function userTagger_registerCommandLine() {
  let tag;
  registerCommand('tag', `tag [text] - ${i18n('userTaggerCommandLineDescription')}`, async (command, val) => {
    const username = Thing_Thing.selected && Thing_Thing.selected.getAuthor();
    tag = username && (await userTagger_Tag.get(username));
    return tag ? i18n(val ? 'userTaggerTagUserAs' : 'userTaggerTagUser', tag.id, val) : i18n('userTaggerTagCanNotSetTag');
  }, (command, val) => {
    if (tag) {
      tag.load({
        text: val
      });
      tag.save();
    } else {
      return i18n('userTaggerTagCanNotSetTag');
    }
  });
}

function attachVoteHandler() {
  document.body.addEventListener('click', e => {
    if (e.button !== 0) return;

    if (e.target.classList.contains('arrow')) {
      handleVoteClick(e.target);
    }
  }, true);
}

async function handleVoteClick(arrow) {
  const $this = $(arrow);
  const $otherArrow = $this.siblings('.arrow');

  if ($this.hasClass('archived')) {
    return;
  }

  let up = 0;
  let down = 0;

  if ($this.hasClass('up')) {
    up = 1;

    if ($otherArrow.hasClass('downmod')) {
      down = -1;
    }
  } else if ($this.hasClass('upmod')) {
    up = -1;
  } else if ($this.hasClass('down')) {
    down = 1;

    if ($otherArrow.hasClass('upmod')) {
      up = -1;
    }
  } else if ($this.hasClass('downmod')) {
    down = -1;
  }

  const thing = Thing_Thing.checkedFrom(arrow);
  const username = thing.getAuthor();
  if (username === loggedInUser()) return;
  const tag = username && (await userTagger_Tag.get(username));
  if (!tag) throw new Error('No tag');
  tag.load({
    votesUp: tag.votesUp + up,
    votesDown: tag.votesDown + down
  });
  tag.save();
}

function getLinkBasedOnTagLocation(obj) {
  const closestEntry = $(obj).closest('.entry');
  let linkTitle = '';

  if (!userTagger_module.options.useCommentsLinkAsSource.value) {
    linkTitle = $(closestEntry).find('a.title');
  }

  if (!linkTitle.length) {
    linkTitle = $(closestEntry).find('a.bylink');
  }

  if (linkTitle.length) {
    return $(linkTitle).attr('href');
  } else {
    const permaLink = $(closestEntry).find('.flat-list.buttons li.first a');

    if (permaLink.length) {
      return $(permaLink).attr('href');
    }
  }
}

function getVoteWeightStyle({
  votes,
  votesUp,
  votesDown
}) {
  let red = 255;
  let green = 255;
  let blue = 255;
  let alpha = 1;

  if (votesUp > votesDown) {
    red = Math.max(0, 255 - 8 * votes);
    green = 255;
    blue = Math.max(0, 255 - 8 * votes);
    alpha = Math.abs(votes) / (votesUp + votesDown);
  } else if (votesUp < votesDown) {
    red = 255;
    green = Math.max(0, 255 - Math.abs(8 * votes));
    blue = Math.max(0, 255 - Math.abs(8 * votes));
    alpha = Math.abs(votes) / (votesUp + votesDown);
  }

  const color = `rgba(${red}, ${green}, ${blue}, ${0.2 + alpha * 0.8})`;
  return isNightModeOn() ? `color: ${color};` : `background-color: ${color};`;
}

const userTagger_filters = [{
  get name() {
    return i18n('userTaggerAllUsers');
  },

  filter: v => v
}, {
  get name() {
    return i18n('userTaggerTaggedUsers');
  },

  filter: v => v.text
}];

async function userTagger_addDashboardFunctionality() {
  const $tabPage = addTab('userTaggerContents', i18n('userTaggerMyUserTags'), userTagger_module.moduleID);
  const $showDiv = $(string_namespaceObject.html`<div class="show">${i18n('userTaggerShow')} </div>`).appendTo($tabPage);
  const tags = await userTagger_Tag.getStored();
  $(string_namespaceObject.html`
		<select id="tagFilter">
			${userTagger_filters.map(({
    name,
    filter
  }, i) => string_namespaceObject._html`<option value="${i}" ${tags.some(filter) && 'selected'}>${name}</option>`)}
		</select>
	`).change(() => drawUserTagTable()).appendTo($showDiv);
  const tagsPerPage = parseInt(dashboard_module.options.tagsPerPage.value, 10);

  if (tagsPerPage) {
    const controlWrapper = document.createElement('div');
    controlWrapper.id = 'tagPageControls';
    $(controlWrapper).data({
      page: 1,
      pageCount: 1
    });
    const leftButton = document.createElement('a');
    leftButton.className = 'res-step noKeyNav';
    leftButton.addEventListener('click', () => {
      const {
        page,
        pageCount
      } = $(controlWrapper).data();

      if (page === 1) {
        $(controlWrapper).data('page', pageCount);
      } else {
        $(controlWrapper).data('page', page - 1);
      }

      drawUserTagTable();
    });
    $(controlWrapper).append(string_namespaceObject.escape`${i18n('userTaggerPage')} `);
    controlWrapper.appendChild(leftButton);
    const posLabel = document.createElement('span');
    posLabel.className = 'res-step-progress';
    posLabel.textContent = '1 of 2';
    controlWrapper.appendChild(posLabel);
    const rightButton = document.createElement('a');
    rightButton.className = 'res-step res-step-reverse noKeyNav';
    rightButton.addEventListener('click', () => {
      const {
        page,
        pageCount
      } = $(controlWrapper).data();

      if (page === pageCount) {
        $(controlWrapper).data('page', 1);
      } else {
        $(controlWrapper).data('page', page + 1);
      }

      drawUserTagTable();
    });
    controlWrapper.appendChild(rightButton);
    $tabPage.append(controlWrapper);
  }

  const $thisTable = $(string_namespaceObject.html`
		<table id="userTaggerTable">
			<thead>
				<tr>
					<th sort="username" class="active">${i18n('userTaggerUsername')}<span class="sortAsc"></span></th>
					<th sort="tag">${i18n('userTaggerTag')}</th>
					<th sort="color">${i18n('userTaggerColor')}</th>
					<th sort="votesDown">${i18n('userTaggerVotesDown')}</th>
					<th sort="votesUp">${i18n('userTaggerVotesUp')}</th>
				</tr>
			</thead>
			<tbody></tbody>
		</table>
	`);
  $tabPage.append($thisTable);
  $('#userTaggerTable thead th').click(function (e) {
    e.preventDefault();
    const $this = $(this);

    if ($this.hasClass('delete')) {
      return false;
    }

    if ($this.hasClass('active')) {
      $this.toggleClass('descending');
    }

    $this.addClass('active');
    $this.siblings().removeClass('active').find('SPAN').remove();
    $this.find('.sortAsc, .sortDesc').remove();
    $this.append($(e.target).hasClass('descending') ? '<span class="sortDesc" />' : '<span class="sortAsc" />');
    drawUserTagTable($(e.target).attr('sort'), $(e.target).hasClass('descending'));
  });
  drawUserTagTable();
}

let userTagger_currentSortMethod, userTagger_isDescending;

async function drawUserTagTable(sortMethod, descending) {
  userTagger_currentSortMethod = sortMethod || userTagger_currentSortMethod;
  userTagger_isDescending = descending === undefined || descending === null ? userTagger_isDescending : descending;
  const tags = (await userTagger_Tag.getStored()).filter(userTagger_filters[$('#tagFilter').val()].filter);

  switch (userTagger_currentSortMethod) {
    case 'tag':
      tags.sort((a, b) => (a.text || '').localeCompare(b.text || ''));
      break;

    case 'color':
      tags.sort((a, b) => (a.color || '').localeCompare(b.color || ''));
      break;

    case 'votesDown':
      tags.sort((a, b) => a.votesDown - b.votesDown);
      break;

    case 'votesUp':
      tags.sort((a, b) => a.votesUp - b.votesUp);
      break;

    case 'username':
    default:
      tags.sort((a, b) => a.id.localeCompare(b.id));
      break;
  }

  if (userTagger_isDescending) {
    tags.reverse();
  }

  $('#userTaggerTable tbody').html('');
  const tagsPerPage = parseInt(dashboard_module.options.tagsPerPage.value, 10);
  const count = tags.length;
  let start = 0;
  let end = count;

  if (tagsPerPage) {
    const $tagControls = $('#tagPageControls');
    let page = $tagControls.data('page');
    const pages = Math.ceil(count / tagsPerPage);
    page = Math.min(page, pages);
    page = Math.max(page, 1);
    $tagControls.data('page', page).data('pageCount', pages);
    $tagControls.find('.res-step-progress').text(i18n('userTaggerPageXOfY', page, pages));
    start = tagsPerPage * (page - 1);
    end = Math.min(count, tagsPerPage * page);
  }

  tags.slice(start, end).forEach(tag => {
    const d = $(`
				<tr>
					<td>
						<span class="res-icon res-right deleteIcon" data-icon="&#xf056;" user="${tag.id}"></span>
						<a href="/user/${tag.id}">${tag.id}</a>
					</td>
					<td><a class="author" hidden></a></td>
					<td><span style="color: ${tag.color || 'initial'}">${tag.color ? tag.color : ''}</span></td>
					<td>${tag.votesDown}</td>
					<td>${tag.votesUp}</td>
				</tr>
			`).get(0);
    tag.add(downcast(d.querySelector('.author'), HTMLAnchorElement), {
      renderTaggingIcon: true
    });
    $('#userTaggerTable tbody').append(d);
  });
  $('#userTaggerTable tbody .deleteIcon').click(async function () {
    const tag = await userTagger_Tag.get(this.getAttribute('user'));
    alert_namespaceObject.open(i18n('userTaggerAreYouSureYouWantToDeleteTag', tag.id), {
      cancelable: true
    }).then(() => {
      tag.delete();
      this.closest('tr').remove();
    });
  });
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserVoteWeight.js




class UserVoteWeight_UserVoteWeight extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `vote weight ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `vote weight ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    const username = thing.getAuthor();
    if (!username) throw new Error('No username');
    return String((await userTagger_Tag.get(username)).votes || 0);
  }

  static get disabled() {
    return !modules_isEnabled(userTagger_namespaceObject) || !userTagger_module.options.trackVoteWeight.value;
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  async evaluate(thing) {
    const username = thing.getAuthor();
    if (!username) return null;
    return numericalCompare(this.value.op, (await userTagger_Tag.get(username)).votes, this.value.val);
  }

}
UserVoteWeight_UserVoteWeight.text = 'User vote weight';
UserVoteWeight_UserVoteWeight.defaultConditions = {
  op: '>',
  val: 0
};
UserVoteWeight_UserVoteWeight.fields = ['user\'s vote weight is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' votes'];
UserVoteWeight_UserVoteWeight.slow = 1;
UserVoteWeight_UserVoteWeight.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Username.js

class Username_Username extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getAuthor();
  }

  evaluate(thing) {
    const user = thing.getAuthor();
    if (!user) return null;
    return this.value.some(v => v.test(user));
  }

}
Username_Username.text = 'Username';
Username_Username.fields = ['posted by /u/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/VoteType.js

const VoteType_options = [['upvoted', 'upvote'], ['downvoted', 'downvote'], ['not voted', 'unvoted']];
class VoteType_VoteType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = (VoteType_options.find(([, cls]) => cls === this.conditions.kind) || [])[0];
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return VoteType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'upvote':
        return thing.isUpvoted();

      case 'downvote':
        return thing.isDownvoted();

      case 'unvoted':
        return thing.isUnvoted();

      default:
        throw new Error('Invalid option');
    }
  }

}
VoteType_VoteType.text = 'Vote type';
VoteType_VoteType.defaultConditions = {
  kind: 'unvoted'
};
VoteType_VoteType.fields = ['post is ', {
  type: 'select',
  id: 'kind',
  options: VoteType_options
}, ' by me'];
VoteType_VoteType.pattern = `(${VoteType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/index.js






















// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentContent.js

class CommentContent_CommentContent extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `comment contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  evaluate(thing) {
    const body = thing.getTextBody();
    if (!body) return null;
    return this.value.some(v => v.test(body.textContent));
  }

}
CommentContent_CommentContent.text = 'Comment content';
CommentContent_CommentContent.fields = ['comment contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentLength.js


const CommentLength_options = ['characters', 'words'];
class CommentLength_CommentLength extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `length ${prettyOperator(this.conditions.op)} ${this.conditions.val} ${this.conditions.kind}`;
    this.falseText = `length ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val} ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      kind: 'words',
      val: parseInt(input, 10)
    };
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const md = thing.entry.querySelector('.md');
    if (!md) return null;

    switch (this.value.kind) {
      case 'characters':
        return numericalCompare(this.value.op, md.textContent.length, this.value.val);

      case 'words':
        return numericalCompare(this.value.op, md.textContent.split(' ').length, this.value.val);

      default:
        throw new Error('Invalid option');
    }
  }

}
CommentLength_CommentLength.text = 'Comment length';
CommentLength_CommentLength.fields = ['comment length is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' ', {
  type: 'select',
  id: 'kind',
  options: CommentLength_options
}];
CommentLength_CommentLength.defaultConditions = {
  op: '>',
  kind: 'words',
  val: 0
};
CommentLength_CommentLength.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/Depth.js


class Depth_Depth extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `depth ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `depth ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '==',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getParents().length);
  }

  isValid() {
    return this.value.val >= 0;
  }

  evaluate(thing) {
    const depth = thing.getParents().length;
    return numericalCompare(this.value.op, depth, this.value.val);
  }

}
Depth_Depth.text = 'Comment depth';
Depth_Depth.defaultConditions = {
  op: '>',
  val: 0
};
Depth_Depth.fields = ['comment\'s depth ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}];
Depth_Depth.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsDeleted.js

class IsDeleted_IsDeleted extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'deleted';
  }

  evaluate(thing) {
    return thing.isDeleted();
  }

}
IsDeleted_IsDeleted.text = 'Deleted';
IsDeleted_IsDeleted.fields = ['comment is deleted'];
IsDeleted_IsDeleted.unique = true;
// CONCATENATED MODULE: ./lib/modules/readComments.js




const readComments_module = new Module('readComments');
readComments_module.moduleName = 'readCommentsName';
readComments_module.category = 'commentsCategory';
readComments_module.description = 'readCommentsDesc';
readComments_module.options = {
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'readCommentsCleanCommentsDesc',
    title: 'readCommentsCleanCommentsTitle',
    advanced: true
  },
  monitorWhenIncognito: {
    type: 'boolean',
    value: false,
    description: 'readCommentsMonitorWhenIncognitoDesc',
    title: 'readCommentsMonitorWhenIncognitoTitle',
    advanced: true
  }
};
readComments_module.include = ['comments', 'commentsLinklist'];
const currentId = (execRegexes.comments(location.pathname) || [])[2] || location.pathname;
const readComments_entryStorage = storage_namespaceObject.wrapPrefix('readComments.', () => ({
  updateTime: Date.now(),
  ids: {}
}));
const readComments_initial = readComments_entryStorage.get(currentId);
let readComments_ids;

readComments_module.beforeLoad = async () => {
  readComments_ids = await readComments_initial.then(({
    ids
  }) => new Set(Object.keys(ids)));
  if (!readComments_module.options.monitorWhenIncognito.value && isPrivateBrowsing()) return;
  selectedEntry_addListener(selected => {
    if (selected.isComment() && selected.isContentVisible()) {
      const id = selected.getFullname();
      readComments_ids.add(id);
      readComments_entryStorage.patch(currentId, {
        ids: {
          [id]: true
        },
        updateTime: Date.now()
      });
    }
  }, 'beforePaint');
  maybePruneOldEntries('readComments', readComments_entryStorage, parseInt(readComments_module.options.cleanComments.value, 10));
};

const isRead = thing => {
  if (!readComments_ids) throw new Error();
  return readComments_ids.has(thing.getFullname());
};
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsRead.js



class IsRead_IsRead extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'read';
  }

  static get disabled() {
    return !modules_isEnabled(readComments_namespaceObject);
  }

  evaluate(thing) {
    return isRead(thing);
  }

}
IsRead_IsRead.text = 'Read';
IsRead_IsRead.fields = ['comment is read'];
IsRead_IsRead.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/index.js















// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/BrowsingFrontPage.js


class BrowsingFrontPage_BrowsingFrontPage extends Case_Case {
  evaluate() {
    return isPageType('linklist') && !currentSubreddit() && !currentMultireddit() && !currentUserProfile();
  }

}
BrowsingFrontPage_BrowsingFrontPage.text = 'Browsing the front page';
BrowsingFrontPage_BrowsingFrontPage.fields = ['when browsing the front page'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentLocation.js


class CurrentLocation_CurrentLocation extends Case_Case {
  evaluate() {
    return fullLocation() === this.value.patt;
  }

}
CurrentLocation_CurrentLocation.text = 'When browsing in location';
CurrentLocation_CurrentLocation.defaultConditions = {
  patt: fullLocation()
};
CurrentLocation_CurrentLocation.fields = ['when browsing ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentMulti.js


class CurrentMulti_CurrentMulti extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      name: Case_Case.buildRegex(this.conditions.name),
      user: Case_Case.buildRegex(this.conditions.user)
    };
  }

  evaluate() {
    const rawMulti = currentMultireddit();
    if (!rawMulti) return false;
    const parts = /^(?:user\/)?([a-z0-9_-]+)\/m\/([a-z0-9_-]+)$/i.exec(rawMulti);
    if (!parts) return false;
    const [, user, multi] = parts;

    if (user === 'me' && this.conditions.name === 'me') {
      return this.value.name.test(multi);
    } else {
      return this.value.user.test(user) && this.value.name.test(multi);
    }
  }

}
CurrentMulti_CurrentMulti.text = 'When browsing a multireddit';
CurrentMulti_CurrentMulti.defaultConditions = {
  user: '',
  name: ''
};
CurrentMulti_CurrentMulti.fields = ['when browsing /u/', {
  type: 'text',
  id: 'user'
}, '/m/', {
  type: 'text',
  id: 'name'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentUserProfile.js


class CurrentUserProfile_CurrentUserProfile extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const user = currentUserProfile();
    return !!user && this.value.test(user);
  }

}
CurrentUserProfile_CurrentUserProfile.text = 'When browsing a user profile';
CurrentUserProfile_CurrentUserProfile.defaultConditions = {
  patt: ''
};
CurrentUserProfile_CurrentUserProfile.fields = ['when browsing /u/', {
  type: 'text',
  id: 'patt'
}, '\'s posts'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentSub.js


class CurrentSub_CurrentSub extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const sub = currentSubreddit();
    return !!sub && this.value.test(sub);
  }

}
CurrentSub_CurrentSub.text = 'When browsing a subreddit';
CurrentSub_CurrentSub.defaultConditions = {
  patt: ''
};
CurrentSub_CurrentSub.fields = ['when browsing /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Date.js


const Date_options = [['before', '<'], ['on or after', '>=']];
class Date_Date extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      op: this.conditions.op,
      date: localization_dayjs(this.conditions.date)
    };
  }

  isValid() {
    return this.value.date.isValid();
  }

  evaluate() {
    return this.value.op === '<' === localization_dayjs().isBefore(this.value.date);
  }

}
Date_Date.text = 'Date';
Date_Date.defaultConditions = {
  op: '<',
  date: '2020-12-30'
};
Date_Date.fields = ['today is ', {
  type: 'select',
  options: Date_options,
  id: 'op'
}, ' ', {
  type: 'text',
  id: 'date'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Dow.js

const Dow_days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
class Dow_Dow extends Case_Case {
  evaluate() {
    const currentDOW = Dow_days[new Date().getDay()];
    return this.value.days.includes(currentDOW);
  }

}
Dow_Dow.text = 'Day of week';
Dow_Dow.defaultConditions = {
  days: []
};
Dow_Dow.fields = ['current day of the week is ', {
  type: 'checkset',
  items: Dow_days,
  id: 'days'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/LoggedInAs.js



class LoggedInAs_LoggedInAs extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.loggedInAs);
  }

  async evaluate() {
    await sitetableStarted;
    const myName = loggedInUser();
    return !!myName && this.value.test(myName);
  }

}
LoggedInAs_LoggedInAs.text = 'Logged in user';
LoggedInAs_LoggedInAs.defaultConditions = {
  loggedInAs: ''
};
LoggedInAs_LoggedInAs.fields = ['logged in as /u/', {
  type: 'text',
  id: 'loggedInAs'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Toggle.js



const getOptions = () => customToggles_getToggles().map(({
  key,
  text
}) => [text, key]);

class Toggle_Toggle extends Case_Case {
  evaluate() {
    const key = this.value.toggleName;
    return toggleActive(key);
  }

}
Toggle_Toggle.text = 'Custom toggle';
Toggle_Toggle.defaultConditions = {
  toggleName: getOptions()[0] || ''
};
Toggle_Toggle.fields = ['custom toggle ', {
  type: 'select',
  id: 'toggleName',

  get options() {
    return getOptions();
  }

}, ' is enabled'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/index.js









// CONCATENATED MODULE: ./lib/modules/filteReddit/cases.js






class cases_Inert extends Case_Case {
  isValid() {
    return false;
  }

  evaluate() {
    console.error('Evaluating inert case');
    return false;
  }

}

class cases_True extends Case_Case {
  evaluate() {
    return true;
  }

}

cases_True.text = 'True';
cases_True.fields = ['always true'];

class cases_False extends Case_Case {
  evaluate() {
    return false;
  }

}

cases_False.text = 'False';
cases_False.fields = ['always false'];
class cases_Group extends Case_Case {
  constructor(...args) {
    super(...args);
    this._cases = this.conditions.of.map(v => Case_Case.fromConditions(v));
    this.trueText = this._cases.length && this.toCriterion(this.conditions.op, this._cases) || 'empty group';

    this.value = (() => {
      const op = this.conditions.op;
      const [NONE, ANY, ONE, ALL] = [op === 'none', op === 'any', op === 'one', op === 'all'];

      const evaluators = this._cases.sort((a, b) => a.constructor.slow - b.constructor.slow).map(cased => cased.evaluate.bind(cased));

      return fastAsync(function* (thing) {
        let seenTrue = false;

        for (const evaluator of evaluators) {
          if (yield evaluator(thing)) {
            if (NONE) return false;else if (ANY) return true;else if (ONE && seenTrue) return false;
            seenTrue = true;
          } else {
            if (ALL) return false;
          }
        }

        if (NONE) return true;else if (ANY) return false;else if (ONE) return seenTrue;else return true;
      });
    })();
  }

  toCriterion(op, cases) {
    let str = cases.map(v => v.trueText).join(` ${(op === 'any' || op === 'none') && '∨' || op === 'one' && '⊕' || '∧'} `);
    if (cases.length > 1) str = `(${str})`;
    return op === 'none' ? `¬ ${str}` : str;
  }

  isValid() {
    return this._cases.every(v => v.isValid());
  }

  hasType(type) {
    return super.hasType(type) || this._cases.some(v => v.hasType(type));
  }

  evaluate(thing) {
    return this.value(thing);
  }

  onObserve() {
    return this._cases.map(v => v.observe(this)).some(v => v);
  }

}
cases_Group.text = 'Group of conditions';
cases_Group.fields = [{
  type: 'select',
  options: ['none', 'any', 'one', 'all'],
  id: 'op'
}, ' of these are true:', {
  type: 'multi',
  include: 'all',
  id: 'of'
}];
cases_Group.defaultConditions = {
  op: 'all',
  of: []
};
cases_Group.slow = 1;
const falseConditions = {
  type: 'false'
};
const trueConditions = {
  type: 'true'
};
const inertConditions = {
  type: 'inert'
};
function resolveGroup(initial, precompute = true, keepGroup = false) {
  let seenTrue = false;
  let of = [];
  let op = initial.op;

  for (let v of initial.of) {
    if (!cases_has(v.type)) {
      console.error(`Type ${v.type} is not available`);
      return inertConditions;
    }

    if (v.type === 'group') v = resolveGroup(v, precompute);

    if (!keepGroup && precompute && !available[v.type].prototype.evaluate.length) {
      const match = Case_Case.fromConditions(v).evaluate();

      if (typeof match === 'boolean') {
        if (match) {
          if (op === 'none') return falseConditions;
          if (op === 'any') return trueConditions;
          if (op === 'one' && seenTrue) return falseConditions;
          seenTrue = true;
        } else {
          if (op === 'all') return falseConditions;
        }

        continue;
      }
    }

    of.push(v);
  }

  if (op === 'one' && seenTrue) {
    op = 'none';
  }

  if (!keepGroup) {
    if (of.length === 1) {
      const p = of[0];

      if (op !== 'none') {
        return p;
      } else if (p.type === 'group') {
        if (p.op === 'none') {
          p.op = 'any';
          return p;
        } else if (p.op === 'any' || p.op === 'all') {
          p.op = 'none';
          return p;
        }
      }
    }

    if (!of.length) {
      if (op === 'none') return trueConditions;
      if (op === 'any') return falseConditions;
      if (op === 'one') return falseConditions;
      if (op === 'all') return trueConditions;
    }
  }

  if (precompute && (op === 'any' || op === 'none')) {
    const l = of.length;
    const typeSorted = of.sort((a, b) => a.type === b.type ? 0 : a.type > b.type ? 1 : -1);
    of = [];

    for (let i = 0; i < l; i++) {
      const a = typeSorted[i];
      const cls = available[a.type];
      const reconcile = cls.reconcile;

      if (reconcile) {
        const values = [a];
        let b;

        while ((b = typeSorted[i + 1]) && a.type === b.type) {
          i++;
          values.push(b);
        }

        of.push(reconcile(values));
      } else {
        of.push(a);
      }
    }
  }

  return {
    type: 'group',
    op,
    of
  };
}
function cases_getConditions(type, conditions) {
  return {
    type,
    ...(available[type] && available[type].defaultConditions),
    ...conditions
  };
}
function getGroup(op, of) {
  return cases_getConditions('group', {
    op,
    of
  });
}
function createAdHoc(type, getConditions, variant, context, customFilter) {
  const {
    opts: {
      name = type
    } = {}
  } = customFilter || {};

  class AdHoc extends Case_Case {
    static get defaultConditions() {
      return getConditions();
    }

  }

  AdHoc.text = name;
  AdHoc.unique = true;
  AdHoc.variant = variant;
  AdHoc._customFilter = customFilter;
  cases_add(type, AdHoc, context);
  return AdHoc;
}
const available = {};

function getUniqueTypeName(name) {
  if (typeof name !== 'string') name = '';

  while (!name || cases_has(name)) {
    name += randomHash();
  }

  return name;
}

function cases_add(type, c, ...contexts) {
  if (!type || available.hasOwnProperty(type) && c !== available[type]) {
    type = getUniqueTypeName(type);
  }

  c.type = type;
  if (!c.contexts) c.contexts = [];
  c.contexts.push(...contexts);
  available[type] = c;
}
const primitives = new Set();
function populatePrimitives(types = ['post', 'comment', 'browse']) {
  function fill(cases, ...contexts) {
    for (const [k, v] of Object.entries(cases)) {
      cases_add(k, v, ...contexts);
      primitives.add(v);
    }
  }

  fill({
    inert: cases_Inert,
    false: cases_False,
    true: cases_True
  });
  fill({
    group: cases_Group
  }, 'post', 'comment', 'browse');
  if (types.includes('post')) fill(postCases_namespaceObject, 'post');
  if (types.includes('comment')) fill(commentCases_namespaceObject, 'comment');
  if (types.includes('browse')) fill(browseCases_namespaceObject, 'browse');
}
function filterThings(things, conditions) {
  if (!conditions) return things;
  const cased = Case_Case.fromConditions(conditions);
  return asyncFilter(things, thing => cased.evaluate(thing));
}
const cases_remove = type => {
  delete available[type];
};
const cases_has = type => available.hasOwnProperty(type);
const cases_get = type => cases_has(type) ? available[type] : cases_Inert;
const getByContext = (context, primitivesOnly = true) => pickBy_default()(available, v => v.contexts.includes(context) && (!primitivesOnly || primitives.has(v)));
const isUseful = type => typeof type === 'string' && cases_has(type) && ![cases_Inert.type, cases_False.type, cases_True.type].includes(type);
// CONCATENATED MODULE: ./lib/modules/accountSwitcher.js








const accountSwitcher_module = new Module('accountSwitcher');
accountSwitcher_module.moduleName = 'accountSwitcherName';
accountSwitcher_module.category = 'myAccountCategory';
accountSwitcher_module.description = 'accountSwitcherDesc';
accountSwitcher_module.options = {
  keepLoggedIn: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherKeepLoggedInDesc',
    title: 'accountSwitcherKeepLoggedInTitle',
    keywords: ['remember']
  },
  accounts: {
    type: 'table',
    addRowText: 'accountSwitcherAddAccount',
    fields: [{
      key: 'username',
      name: 'accountSwitcherUsername',
      type: 'text'
    }, {
      key: 'password',
      name: 'accountSwitcherPassword',
      type: 'password'
    }, {
      key: '2fa',
      name: 'accountSwitcherRequiresOtp',
      type: 'boolean',
      value: false
    }],
    value: [],
    description: 'accountSwitcherAccountsDesc',
    title: 'accountSwitcherAccountsTitle'
  },
  updateOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherUpdateOtherTabsDesc',
    title: 'accountSwitcherUpdateOtherTabsTitle',
    value: true,
    advanced: true
  },
  reloadOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherReloadOtherTabsDesc',
    title: 'accountSwitcherReloadOtherTabsTitle',
    value: false,
    advanced: true
  },
  showCurrentUserName: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherShowCurrentUserNameDesc',
    title: 'accountSwitcherShowCurrentUserNameTitle',
    advanced: true
  },
  dropDownStyle: {
    type: 'enum',
    values: [{
      name: 'accountSwitcherSnoo',
      value: 'alien'
    }, {
      name: 'accountSwitcherSimpleArrow',
      value: 'arrow'
    }],
    value: 'alien',
    description: 'accountSwitcherDropDownStyleDesc',
    title: 'accountSwitcherDropDownStyleTitle',
    advanced: true,
    bodyClass: true
  },
  showUserDetails: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowUserDetailsDesc',
    title: 'accountSwitcherShowUserDetailsTitle',
    advanced: true
  },
  showKarma: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowKarmaDesc',
    title: 'accountSwitcherShowKarmaTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  },
  showGold: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowGoldDesc',
    title: 'accountSwitcherShowGoldTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  }
};
let hover;

accountSwitcher_module.contentStart = () => {
  const downArrow = accountSwitcher_module.options.dropDownStyle.value === 'alien' ? string_namespaceObject.html`<span id="RESAccountSwitcherIcon"></span>` : string_namespaceObject.html`<span id="RESAccountSwitcherIcon"><span class="downArrow"></span></span>`;
  downArrow.addEventListener('click', () => hover.begin());
  downArrow.addEventListener('dblclick', manageAccounts);
  const userLink = document.querySelector('#header-bottom-right > span.user > a');

  if (userLink) {
    userLink.style.marginRight = '2px';
    userLink.after(downArrow);
  } else {
    addElement(downArrow, {
      order: 3
    });
  }

  hover = dropdownList(accountSwitcher_module.moduleID).options({
    className: 'RESAccountSwitcherDropdown',
    openDelay: 0,
    offsetHeight: 5
  }).populateWith(createAccountMenu).target(downArrow);
  registerCommand(/^sw$/, `sw [username] - ${i18n('accountSwitcherCliHelp')}`, (command, val) => {
    const found = findMatchingAccount(val, true);

    if (val && found) {
      return i18n('accountSwitcherCliSwitchToUsernamePrompt', found[0]);
    } else {
      return i18n('accountSwitcherCliSwitchToUsernamePrompt', '...');
    }
  }, (command, val) => {
    if (!val.length) {
      return i18n('accountSwitcherCliNoUsername');
    }

    const found = findMatchingAccount(val, true);

    if (found) {
      switchTo(found[0]);
    } else {
      manageAccounts();
    }
  });

  if (accountSwitcher_module.options.updateOtherTabs.value) {
    window.addEventListener('focus', _onFocus);
  }
};

async function createAccountMenu() {
  const accountMenu = document.createDocumentFragment();
  const users = await Promise.all(accountSwitcher_module.options.accounts.value.map(async ([username]) => ({
    username,
    active: username.localeCompare(loggedInUser() || '') === 0,
    data: accountSwitcher_module.options.showUserDetails.value && (await getUserInfo(username).catch(e => {
      console.error('Error loading userinfo for', username, e);
      return {};
    })).data || {}
  })));

  for (const {
    username,
    active,
    data
  } of users) {
    if (!accountSwitcher_module.options.showCurrentUserName.value && active) continue;
    const goldExpDate = data.gold_expiration && new Date(data.gold_expiration * 1000);
    const element = string_namespaceObject.html`
			<li class="accountName ${active && 'active'}">
				<span style="margin-right: auto;">${username}</span>
				${accountSwitcher_module.options.showKarma.value && data.link_karma && string_namespaceObject._html`
					<span style="margin-left: 4px">(${data.link_karma} &middot; ${data.comment_karma})</span>
				`}
				${accountSwitcher_module.options.showGold.value && data.is_gold && string_namespaceObject._html`
					<span style="all: initial; margin-left: 4px; line-height: 0;" class="gilded-icon" title="${goldExpDate && i18n('accountSwitcherGoldUntil', formatDate(goldExpDate), formatDateDiff(new Date(), goldExpDate))}"></span>
				`}
				<a style="margin-left: 4px" onclick="event.stopPropagation()" href="/user/${username}" class="res-icon linkIcon"></a>
			</li>
		`;
    element.addEventListener('click', () => switchTo(username));
    accountMenu.append(element);
  }

  {
    const element = string_namespaceObject.html`<li class="addAccount">+ add account</li>`;
    element.addEventListener('click', manageAccounts);
    accountMenu.append(element);
  }
  return [accountMenu];
}

function findMatchingAccount(username, partialMatch) {
  const accounts = accountSwitcher_module.options.accounts.value;
  const matched = accounts.find(([user]) => user.toUpperCase() === username.toUpperCase());

  if (matched || !partialMatch) {
    return matched;
  }

  return accounts.find(([user]) => user.toUpperCase().startsWith(username.toUpperCase()));
}

const switchTo = mutex(async user => {
  const account = findMatchingAccount(user);
  if (!account) return;
  const [username, storedPassword, requiresOtp] = account;
  const logoutPromise = isLoggedIn() && ajax({
    method: 'POST',
    url: '/logout'
  });
  const password = storedPassword ? storedPassword : window.prompt(i18n('accountSwitcherPasswordPrompt', username));
  let otp;

  if (requiresOtp) {
    otp = {
      otp: window.prompt(i18n('accountSwitcherOptPrompt', username))
    };
  }

  await logoutPromise;
  const {
    success,
    jquery
  } = await ajax({
    method: 'POST',
    url: '/api/login',
    data: {
      user: username,
      passwd: password,
      ...otp,
      rem: accountSwitcher_module.options.keepLoggedIn.value ? 'on' : 'off'
    },
    type: 'json'
  }).catch(e => {
    notifications_showNotification({
      type: 'error',
      moduleID: 'accountSwitcher',
      message: i18n('accountSwitcherAccountSwitchError')
    });
    throw e;
  });

  if (success) {
    switchedAccount(username);
  } else {
    switchedAccount(false);
    const jqueryRpc = JSON.stringify(jquery);
    const message = jqueryRpc.includes('PASSWORD') && i18n('accountSwitcherLoginError', username) || jqueryRpc.includes('RATELIMIT') && i18n('accountSwitcherRateLimitError') || i18n('accountSwitcherUnknownError', username, jqueryRpc);
    alert_namespaceObject.open(message, {
      cancelable: true
    }).then(manageAccounts);
  }
});

function switchedAccount(username) {
  if (accountSwitcher_module.options.updateOtherTabs.value) {
    switchedAccountElsewhere(username);
  }

  if (username) {
    reloadPage();
  }
}

let _usernameElsewhere;

let _notifiedSwitchedAccount = false;

let _switchedAccountMessage;

const switchedAccountElsewhere = multicast(username => {
  _usernameElsewhere = username;

  if (_switchedAccountMessage) {
    _switchedAccountMessage.close();
  }

  _switchedAccountMessage = undefined;
}, {
  name: 'switchedAccountElsewhere',
  local: false,
  crossContext: false
});

async function _onFocus() {
  if (_usernameElsewhere === undefined) return;
  const currentUsername = (loggedInUser() || '').toLowerCase();

  if (currentUsername === (_usernameElsewhere || '').toLowerCase()) {
    _notifiedSwitchedAccount = false;
    return;
  }

  if (_notifiedSwitchedAccount) return;
  _notifiedSwitchedAccount = true;

  if (_switchedAccountMessage) {
    _switchedAccountMessage.close();
  }

  _switchedAccountMessage = await _notifySwitchedAccountElsewhere();
}

function _notifySwitchedAccountElsewhere() {
  const username = _usernameElsewhere;
  const hasDraft = Array.from(document.getElementsByTagName('textarea')).some(textarea => textarea.value);

  if (!hasDraft && accountSwitcher_module.options.reloadOtherTabs.value) {
    reloadPage();
    return;
  }

  let message = username ? i18n('accountSwitcherUserSwitched', username) : i18n('accountSwitcherLoggedOut');

  if (hasDraft) {
    message += ` ${i18n('accountSwitcherDraft', loggedInUser() || '')}`;
  }

  message += ` <p><a class="RESNotificationButtonBlue" href="${location.pathname}">${i18n('accountSwitcherReload')}</a></p>`;
  return notifications_showNotification({
    moduleID: 'accountSwitcher',
    optionKey: 'updateOtherTabs',
    message
  });
}

function manageAccounts() {
  hover.close();
  settingsNavigation_open(accountSwitcher_module.moduleID, 'accounts');
}

function reloadPage() {
  location.href = location.href;
}
// CONCATENATED MODULE: ./lib/modules/submitIssue.js








const submitIssue_module = new Module('submitIssue');
submitIssue_module.moduleName = 'submitIssueName';
submitIssue_module.category = 'aboutCategory';
submitIssue_module.alwaysEnabled = true;
submitIssue_module.sort = -7;
submitIssue_module.description = 'submitIssueDesc';
submitIssue_module.include = ['submit'];
const submitIssue_subreddits = ['enhancement', 'resissues'];
const subredditsForDiagnostics = ['beta', 'help', 'resbetatesting'];

submitIssue_module.go = () => {
  checkIfSubmitting();
};

const submitWizardTemplate = ({
  foolin,
  settings,
  bugs,
  requests
}) => string_namespaceObject.html`
	<div>
		${foolin && string_namespaceObject._html`
			<h2>Enjoy April Fool's</h2>
			<p>RES can't turn off any of Reddit's shenanigans. However, <a href="/r/Enhancement/wiki/faq/srstyle" target="_blank" rel="noopener noreferer">you can turn off subreddit styles</a>.</p>
		`}

		<h2>Something is broken in RES. How do I fix it?</h2>

		<p>Take a minute to read through other posts. Someone might have already posted a solution.</p>

		<ol id="RESKnownBugs">
			${bugs.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>

		<p><a href="/r/RESissues/submit/" class="blueButton">Ask how to fix RES</a></p>

		<p>Please write some text about:</p>
		<dl>

			<dt>What makes this happen?</dt>
			<dd>
				clicking a button, opening an image preview, ...
			</dd>


			<dt>Where does this happen?</dt>
			<dd>
				in a particular subreddit, on comments pages, on frontpage (reddit.com), on /r/all, ...
			</dd>

			<dt>Screenshot/video of problem</dt>
			<dd>
				<a href="https://www.take-a-screenshot.org/" target="_blank" rel="noreferer noopener">Take a screenshot</a>, <a href="https://imgur.com/upload">upload it</a>, and copy-paste the link here.
			</dd>
		</dl>


		<h2>How do I customize or use RES features?</h2>
		<p>If you want to disable certain features of RES, try searching in <a href="${settings}">RES settings</a>, your account's <a href="/prefs">reddit preferences</a>, or <a href="/r/Enhancement/search?q=restrict_sr=on">posts in r/Enhancement</a>.</p>

		<p><a href="/r/Enhancement/submit/" class="blueButton">Get guidance on using RES</a></p>


		<h2>I have a suggestion.</h2>

		<p>Look for similar ideas before posting:</p>
		<ol id="RESKnownFeatureRequests">
			${requests.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>
		<p><a href="/r/Enhancement/submit/" class="blueButton">Post a request</a></p>


		<h2>I found a security issue.</h2>
		<p>Please report security issues privately using modmail.</p>
		<p><a href="/message/compose/?to=/r/Enhancement" class="blueButton">Report a security issue</a></p>
	</div>
`;

const submitIssueDefaultBody = `
*What's up?*
???


*Where does it happen?*
???


*Screenshots or mock-ups*
???


*What browser extensions are installed?*
???
`.trim();
const diagnostics = once_default()(() => `

- Night mode: ${String(isNightModeOn())}
- RES Version: ${metadata_version}
- Browser: ${browserDetect_namespaceObject.browser}
- Browser Version: ${browserDetect_namespaceObject.version}
- Cookies Enabled: ${String(navigator.cookieEnabled)}
- Reddit beta: ${String($('.beta-hint').length > 0)}

`);

function checkIfSubmitting() {
  const subredditInput = document.getElementById('sr-autocomplete');
  const selfText = document.querySelector('.usertext-edit textarea');

  if (subredditInput) {
    function check() {
      const subreddit = subredditInput.value;

      if (submitIssue_subreddits.includes(subreddit.toLowerCase())) {
        showWizard();
        injectTemplate(selfText);
      } else {
        hideWizard();
      }
    }

    check();
    subredditInput.addEventListener('change', e => {
      if (e.res) return;
      check();
    });
    $('#suggested-reddits .sr-suggestion').on('click', () => setTimeout(check, 500));
  }

  if (selfText && subredditInput) {
    $(selfText).add(subredditInput).on('blur', () => {
      const subreddit = subredditInput.value;

      if ([...submitIssue_subreddits, ...subredditsForDiagnostics].includes(subreddit.toLowerCase())) {
        const diagnosticsStripped = diagnostics().replace(/\s/g, '');
        const selfTextStripped = selfText.value.replace(/\s/g, '');

        if (!selfTextStripped.includes(diagnosticsStripped)) {
          selfText.value += diagnostics();
          $(selfText).trigger('input');
        }
      } else {
        selfText.value = selfText.value.replace(diagnostics(), '');
        $(selfText).trigger('input');
      }
    });
  }
}

function updateSubreddit(subreddit) {
  const input = document.querySelector('#sr-autocomplete');
  input.value = subreddit;
  const e = new Event('change');
  e.res = true;
  input.dispatchEvent(e);
}

function injectTemplate(selfText) {
  if (selfText && !selfText.value) {
    selfText.value = submitIssueDefaultBody;
  }
}

async function wizard() {
  const [bugs, requests] = await Promise.all([fetchLinks('/r/Enhancement/wiki/knownbugs.json'), fetchLinks('/r/Enhancement/wiki/knownrequests.json')]);
  return submitWizardTemplate({
    foolin: submitIssue_foolin(),
    bugs,
    requests,
    settings: makeUrlHash()
  });
}

const guiderId = 'RESSubmitWizard';

async function showWizard() {
  const guider = jqueryPlugins_guiders.get(guiderId);

  if (guider) {
    jqueryPlugins_guiders.show(guider.id);
    return;
  }

  const description = await wizard();
  jqueryPlugins_guiders.createGuider({
    attachTo: '.submit .usertext',
    description,
    buttonCustomHTML: `
		<footer>
			<small>
				<a href="/r/RESissues/wiki/knownissues">known issues</a>
				|  <a href="/r/RESissues/wiki/postanissue">troubleshooting</a>
			</small>
		</footer>
	`,
    id: guiderId,
    position: 3,
    title: 'What are you posting about?'
  }).show();
  $(document.body).on('click', '#RESSubmitWizard a[href$="/submit/"]', e => {
    const match = e.target.pathname.match(regexes.submit);
    if (!match) return;
    updateSubreddit(match[1]);
    e.preventDefault();
  });
}

function hideWizard() {
  if (jqueryPlugins_guiders.get(guiderId)) {
    jqueryPlugins_guiders.hideAll();
  }
}

async function fetchLinks(url) {
  try {
    const {
      data
    } = await ajax({
      url,
      type: 'json'
    });
    return parseObjectList(data && data.content_md);
  } catch (e) {
    return [];
  }
}

function parseObjectList(text) {
  if (!text) {
    return [];
  }

  const items = text.split(/\s*-{3,}\s*/).filter(x => x.match(/[^\s\n]/));
  return items.map(dictText => {
    const item = {};
    const dictMapping = dictText.replace(/\r/g, '').split('\n');

    for (const rawLine of dictMapping) {
      const line = $.trim(rawLine).split(':');

      if (line.length > 0) {
        const key = line.shift();

        if (key) {
          item[key] = line.join(':');
        }
      }
    }

    return item;
  });
}

function submitIssue_foolin() {
  const now = new Date();
  return now.getMonth() === 2 && now.getDate() > 30 || now.getMonth() === 3 && now.getDate() <= 2;
}
// CONCATENATED MODULE: ./lib/modules/commentTools.js













const commentTools_module = new Module('commentTools');
commentTools_module.moduleName = 'commentToolsName';
commentTools_module.category = 'commentsCategory';
commentTools_module.description = 'commentToolsDesc';
commentTools_module.options = {
  userAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsUserAutoCompleteDesc',
    title: 'commentToolsUserAutoCompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  subredditAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsSubredditAutocompleteDesc',
    title: 'commentToolsSubredditAutocompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  wikiAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsWikiAutocompleteDesc',
    title: 'commentToolsWikiAutocompleteTitle',
    advanced: true
  },
  formattingToolButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsFormattingToolButtonsDesc',
    title: 'commentToolsFormattingToolButtonsTitle'
  },
  keyboardShortcuts: {
    dependsOn: options => options.formattingToolButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsKeyboardShortcutsDesc',
    title: 'commentToolsKeyboardShortcutsTitle'
  },
  boldKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [66, false, true, false, false],
    description: 'commentToolsBoldKeyDesc',
    title: 'commentToolsBoldKeyTitle'
  },
  italicKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [73, false, true, false, false],
    description: 'commentToolsItalicKeyDesc',
    title: 'commentToolsItalicKeyTitle'
  },
  strikeKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [83, false, true, false, false],
    description: 'commentToolsStrikeKeyDesc',
    title: 'commentToolsStrikeKeyTitle'
  },
  superKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [187, false, true, true, false],
    description: 'commentToolsSuperKeyDesc',
    title: 'commentToolsSuperKeyTitle'
  },
  linkKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [75, false, true, false, false],
    description: 'commentToolsLinkKeyDesc',
    title: 'commentToolsLinkKeyTitle'
  },
  quoteKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [190, false, true, true, false],
    description: 'commentToolsQuoteKeyDesc',
    title: 'commentToolsQuoteKeyTitle'
  },
  ctrlEnterSubmitsComments: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSubmitsCommentsDesc',
    title: 'commentToolsCtrlEnterSubmitsCommentsTitle'
  },
  ctrlEnterSavesLiveThreads: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSavesLiveThreadsDesc',
    title: 'commentToolsCtrlEnterSavesLiveThreadsTitle'
  },
  ctrlEnterSubmitsPosts: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrolEnterSubmitsPostsDesc',
    title: 'commentToolsCtrolEnterSubmitsPostsTitle'
  },
  commentingAs: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCommentingAsDesc',
    title: 'commentToolsCommentingAsTitle'
  },
  highlightIfAltAccount: {
    dependsOn: options => options.commentingAs.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsHighlightIfAltAccountDesc',
    title: 'commentToolsHighlightIfAltAccountTitle'
  },
  showInputLength: {
    type: 'boolean',
    value: true,
    description: 'commentToolsShowInputLengthDesc',
    title: 'commentToolsShowInputLengthTitle',
    advanced: true,
    bodyClass: true
  },
  macroButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroButtonsDesc',
    title: 'commentToolsMacroButtonsTitle',
    bodyClass: true
  },
  macros: {
    dependsOn: options => options.macroButtons.value,
    type: 'table',
    addRowText: 'commentToolsAddShortcut',
    fields: [{
      key: 'label',
      name: 'commentToolsLabel',
      type: 'text'
    }, {
      key: 'text',
      name: 'commentToolsText',
      type: 'textarea'
    }, {
      key: 'category',
      name: 'commentToolsCategory',
      type: 'text'
    }, {
      key: 'key',
      name: 'commentToolsKey',
      type: 'keycode'
    }],
    value: [['reddiquette', '[reddiquette](/wiki/reddiquette) ', undefined, undefined], ['Promote RES', '[Reddit Enhancement Suite](https://redditenhancementsuite.com "also /r/Enhancement") ', undefined, undefined], ['Current timestamp', '{{now}} ', undefined, undefined]],
    description: 'commentToolsMacrosDesc',
    title: 'commentToolsMacrosTitle'
  },
  keepMacroListOpen: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: false,
    description: 'commentToolsKeepMacroListOpenDesc',
    title: 'commentToolsKeepMacroListOpenTitle',
    advanced: true
  },
  macroPlaceholders: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroPlaceholdersDesc',
    title: 'commentToolsMacroPlaceholdersTitle'
  },
  enabledOnBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentToolsEnableOnBanMessagesDesc',
    title: 'commentToolsEnableOnBanMessagesTitle',
    advanced: true
  }
};
commentTools_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'liveThread', /^\/r\/[\-\w\.]+\/wiki\/(?:create|edit)(\/\w+)?/i];
const SUBMIT_LIMITS = {
  STYLESHEET: 128 * 1024,
  SIDEBAR: 10240,
  DESCRIPTION: 500,
  WIKI: 512 * 1024,
  COMMENT: 10000,
  LIVE_COMMENT: 4096,
  POST: 40000,
  POST_TITLE: 300,
  BAN_MESSAGE: 1000
};
const macroCallbackTable = [];
const macroKeyTable = [];

commentTools_module.contentStart = () => {
  $(document.body).on('focus', commentTextareaSelector, attachEditorToUsertext);
  initializeCtrlEnterToSubmit();
  initializeLengthCounters();
  initializeAutocomplete();
};

function initializeCtrlEnterToSubmit() {
  if (commentTools_module.options.ctrlEnterSubmitsComments.value) {
    onCtrlEnter('.usertext-edit textarea, #BigEditor textarea, #wiki_page_content', e => {
      const currentForm = $(e.target).closest('form');
      const saveButton = currentForm.find('.save')[0] || currentForm.find('#wiki_save_button')[0] || $('.BEFoot button')[0];
      if (saveButton) click(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSavesLiveThreads.value) {
    onCtrlEnter('.usertext-edit textarea', () => {
      const saveButton = $('#new-update-form .save-button button')[0];
      if (saveButton) click(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSubmitsPosts.value) {
    onCtrlEnter('#title-field textarea, #text-field textarea, #url, #sr-autocomplete, input.captcha', () => {
      const $captcha = $('input.captcha:not(.cap-text)');

      if ($captcha.length && $captcha.val() === '') {
        $captcha.focus();
      } else {
        click($('.spacer .btn')[0]);
      }
    });
  }
}

function initializeLengthCounters() {
  if (commentTools_module.options.showInputLength.value) {
    $(document.body).on('input', '.usertext-edit textarea, #title-field textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function () {
      updateCounter(this);
    });
    $('.submit-page #title-field span.title').prepend('<span class="RESCharCounter" title="character limit: 0/300">0/300</span>');
  }
}

const initializeEditorTools = once_default()(() => {
  $(document.body).on('click', 'div.markdownEditor-wrapper a:not(.userTagLink)', function (e) {
    e.preventDefault();
    const index = parseInt($(this).attr('data-macro-index'), 10);
    const box = findTextareaForElement(this);

    if (!box) {
      console.error('Failed to locate textarea.');
      return;
    }

    const handler = macroCallbackTable[index];

    if (!handler) {
      throw new Error(`No macro callback at index: ${index}.`);
    }

    handler(box);
    box.focus();
    box.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  }).on('click', '.RESMacroDropdownTitle', function (e) {
    const thisCat = e.target;

    if (thisCat.classList.contains('openMacro')) {
      thisCat.classList.remove('openMacro');
    } else {
      $('.RESMacroWrappingSpan span').removeClass('openMacro');
      thisCat.classList.add('openMacro');
    }

    $(this).next().css({
      top: `${thisCat.offsetTop + thisCat.offsetHeight}px`,
      left: `${thisCat.offsetLeft + thisCat.offsetWidth - thisCat.nextSibling.offsetWidth}px`
    });
  });

  if (commentTools_module.options.keyboardShortcuts.value) {
    $(document.body).on('keydown', '.usertext-edit textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function (e) {
      if (e.key === NAMED_KEYS.Escape) {
        this.blur();
        e.preventDefault();
        return;
      }

      for (const [testedKeyArray, macroIndex] of macroKeyTable) {
        if (checkKeysForEvent(e, testedKeyArray)) {
          const handler = macroCallbackTable[macroIndex];
          handler(this);
          this.dispatchEvent(new Event('input', {
            bubbles: true,
            cancelable: true
          }));
          e.preventDefault();
          return;
        }
      }
    });
  }
});

const commentTextareaSelector = ['textarea[name=text]', 'textarea[name=description]', 'textarea[name=public_description]', 'textarea[name=body]', 'textarea[name=ban_message]', 'textarea[name=content]', 'textarea[name=title]'].join(':not([readonly]),');

function getFieldLimit(elem) {
  switch (elem.name) {
    case 'title':
      return SUBMIT_LIMITS.POST_TITLE;

    case 'text':
      if (isPageType('submit') || $(elem).closest('.thing').hasClass('self')) {
        return SUBMIT_LIMITS.POST;
      }

      return SUBMIT_LIMITS.COMMENT;

    case 'description':
      return SUBMIT_LIMITS.SIDEBAR;

    case 'body':
      return SUBMIT_LIMITS.LIVE_COMMENT;

    case 'public_description':
      return SUBMIT_LIMITS.DESCRIPTION;

    case 'content':
      return SUBMIT_LIMITS.WIKI;

    case 'ban_message':
      return SUBMIT_LIMITS.BAN_MESSAGE;

    default:
      return 1337;
  }
}

function attachEditorToUsertext() {
  if (this.hasAttribute('commentTools-initialized')) return;
  this.setAttribute('commentTools-initialized', true);

  if (this.hasAttribute('data-max-length')) {
    return;
  }

  const limit = getFieldLimit(this);
  this.setAttribute('data-limit', limit);

  if (this.name === 'title') {
    return;
  }

  if (this.id === 'ban_message' && !commentTools_module.options.enabledOnBanMessages.value) {
    return;
  }

  if (this.id === 'ban_message') {
    this.style.width = '500px';
    this.style.height = '100px';
  }

  const bar = makeEditBar();

  if (this.id === 'wiki_page_content' || this.id === 'ban_message') {
    $(this).parent().prepend(bar);
  } else {
    $(this).parent().before(bar);
  }

  updateCounter(this);
}

function updateCounter(textarea) {
  const length = $(textarea).val().length;
  const limit = textarea.getAttribute('data-limit');
  const counter = $(textarea).parent().parent().find('.RESCharCounter');
  counter.attr('title', `character limit: ${length}/${limit}`);
  counter.text(`${length}/${limit}`);

  if (length > limit) {
    counter.addClass('tooLong');
  } else {
    counter.removeClass('tooLong');
  }
}
let cachedEditBar;
function makeEditBar() {
  initializeEditorTools();

  if (cachedEditBar) {
    return $(cachedEditBar).clone();
  }

  const $editBar = $('<div class="markdownEditor">');
  const wrappedEditBar = $('<div class="markdownEditor-wrapper">').append($editBar);

  if (commentTools_module.options.commentingAs.value) {
    const commentingAsMessage = location.href.match(/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned\/?/i) ? 'Moderating as' : 'Speaking as';
    const commentingAs = $('<div class="commentingAs">').html(`${commentingAsMessage}: `).append($('#header-bottom-right .user a:first').clone().wrap('<span class="commentingAsUser"></span>').parent());
    const loggedIn = loggedInUser();

    if (loggedIn && isRunning(userTagger_namespaceObject)) {
      applyToUser(commentingAs.find('a')[0], {
        username: loggedIn,
        renderVoteWeight: false
      });
    }

    if (commentTools_module.options.highlightIfAltAccount.value && accountSwitcher_module.options.accounts.value.length && loggedIn && loggedIn.toLowerCase() !== accountSwitcher_module.options.accounts.value[0][0].toLowerCase()) {
      commentingAs.addClass('highlightedAltAccount');
    }

    wrappedEditBar.append(commentingAs);
  }

  if (commentTools_module.options.formattingToolButtons.value) {
    const shortcuts = commentTools_module.options.keyboardShortcuts.value;
    $editBar.append(makeEditButton('<b>Bold</b>', `bold${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.boldKey.value)})` : ''}`, commentTools_module.options.boldKey.value, 'btn-bold', box => {
      wrapSelection(box, '**', '**');
    }));
    $editBar.append(makeEditButton('<i>Italic</i>', `italic${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.italicKey.value)})` : ''}`, commentTools_module.options.italicKey.value, 'btn-italic', box => {
      wrapSelection(box, '*', '*');
    }));
    $editBar.append(makeEditButton('<del>strike</del>', `strike${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.strikeKey.value)})` : ''}`, commentTools_module.options.strikeKey.value, 'btn-strike', box => {
      wrapSelection(box, '~~', '~~');
    }));
    $editBar.append(makeEditButton('<sup>sup</sup>', `super${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.superKey.value)})` : ''}`, commentTools_module.options.superKey.value, 'btn-superscript', box => {
      wrapSelectedWords(box, '^');
    }));
    $editBar.append(makeEditButton('Link', `link${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.linkKey.value)})` : ''}`, commentTools_module.options.linkKey.value, 'btn-link', box => {
      linkSelection(box);
    }));
    $editBar.append(makeEditButton('>Quote', `quote${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.quoteKey.value)})` : ''}`, commentTools_module.options.quoteKey.value, 'btn-quote', box => {
      wrapSelectedLines(box, '> ', '');
    }));
    $editBar.append(makeEditButton('<span style="font-family: monospace">Code</span>', 'code', null, 'btn-code', box => {
      wrapSelectedLines(box, '    ', '');
    }));
    $editBar.append(makeEditButton('&bull;Bullets', 'bullet list', null, 'btn-list-unordered', box => {
      wrapSelectedLines(box, '* ', '');
    }));
    $editBar.append(makeEditButton('1.Numbers', 'number list', null, 'btn-list-ordered', box => {
      wrapSelectedLines(box, '1. ', '');
    }));
    $editBar.append(makeEditButton('<span style="border: 1px black solid;">Table</span>', 'table', null, 'btn-table', box => {
      const selectedText = box.value.substring(box.selectionStart, box.selectionEnd).replace(/^[\s]+/, '').replace(/[\s]+$/, '').split('\n');
      let isTable;

      if (selectedText.length >= 2) {
        if (selectedText[0].includes('|')) {
          selectedText[0] = selectedText[0].replace(/^\|/, '').replace(/\|\s+$/, '');
          const numSeparator = selectedText[0].split('|').length;
          isTable = true;
          selectedText[1] = selectedText[1].replace(/\|[^|\-]+$/, '');
          selectedText[1] = selectedText[1].replace(/-/g, '--');

          if (!selectedText[1].includes('-|') && !selectedText[1].includes('|-')) {
            isTable = false;
          }

          selectedText[1] = selectedText[1].replace(/^\]+/, '').replace(/[\s|]+$/, '');

          if (selectedText[1].split('-|-').length < numSeparator) {
            isTable = false;
          }

          if (/[^|\-]/.test(selectedText[1])) {
            isTable = false;
          }

          if (isTable) {
            for (const i of range(2, selectedText.length)) {
              if (!selectedText[i].includes('|')) {
                isTable = false;
                break;
              }

              selectedText[i] = selectedText[i].replace(/^\|/, '').replace(/[\s|]+$/, '');

              if (selectedText[i].split('|').length !== numSeparator) {
                isTable = false;
                break;
              }
            }
          }
        }
      }

      let startTable;

      if (isTable) {
        startTable = selectedText.reduce((prevTable, currText, i) => {
          if (i === 1) {
            return prevTable;
          }

          return `${prevTable}<tr><td>${escapeHTML(currText).replace(/\|/g, '</td><td>')}</td></tr>`;
        }, '');
      } else {
        startTable = '<tr><td>Foo</td><td>Bar</td></tr><tr><td>Foo</td><td>Bar</td></tr>';
      }

      alert_namespaceObject.open(`<div class="buttonContainer"></div><table class="commentPreview" contenteditable="true">${startTable}</table>`, {
        cancelable: true
      }).then(() => {
        let generatedTable = '\n\n';
        let generatedTableSeparation = '';
        $('#alert_message tr:first td').each(function () {
          const text = $(this).text().replace(/[\n|]/g, '');
          generatedTable += `${text} | `;
          generatedTableSeparation += '-'.repeat(text.length);
          generatedTableSeparation += '|';
        });
        generatedTableSeparation = generatedTableSeparation.substr(0, generatedTableSeparation.length - 1);
        generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n${generatedTableSeparation}\n`;
        $('#alert_message tr:gt(0)').each(function () {
          $(this).find('td').each(function () {
            generatedTable += `${$(this).text().replace(/[\n|]/g, '')} | `;
          });
          generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n`;
        });

        if (isTable) {
          replaceSelection(box, generatedTable);
        } else {
          wrapSelection(box, generatedTable, '');
        }

        $(box).trigger('input');
      });
      const addRow = alert_namespaceObject.makeButton('+ Row');
      const remRow = alert_namespaceObject.makeButton('- Row');
      const addCol = alert_namespaceObject.makeButton('+ Col');
      const remCol = alert_namespaceObject.makeButton('- Col');
      addRow.addEventListener('click', () => {
        const nbCol = $('#alert_message tr:first td').length;
        const newRow = '<td>text</td>'.repeat(nbCol);
        $('#alert_message table').append(`<tr>${newRow}</tr>`);
      });
      remRow.addEventListener('click', () => {
        if ($('#alert_message tr').length > 1) {
          $('#alert_message table tr:last').remove();
        }
      });
      addCol.addEventListener('click', () => {
        $('#alert_message table tr').append('<td>text</td>');
      });
      remCol.addEventListener('click', () => {
        if ($('#alert_message tr:first td').length > 1) {
          $('#alert_message table tr td:last-of-type').remove();
        }
      });
      const $buttonContainer = $('#alert_message .buttonContainer');
      $buttonContainer.append(addRow);
      $buttonContainer.append(remRow);
      $buttonContainer.append(addCol);
      $buttonContainer.append(remCol);
    }));
  }

  if (commentTools_module.options.showInputLength.value) {
    const $counter = $('<span class="RESCharCounter" title="character limit: 0/?????">0/?????</span>');
    $editBar.prepend($counter);
  }

  if (commentTools_module.options.macroButtons.value) {
    buildMacroDropdowns(wrappedEditBar);
    const addMacroButton = makeEditButton(i18n(commentTools_module.options.macros.addRowText), null, null, 'btn-macro btn-macro-add', () => {
      settingsNavigation_open(commentTools_module.moduleID, 'macros');
      $('.RESMacroWrappingSpan span').removeClass('openMacro');
    });
    addButtonToMacroGroup('', addMacroButton);
  }

  cachedEditBar = wrappedEditBar;
  return cachedEditBar;
}
const macroDropDownTable = new Map();

function getMacroGroup(groupName) {
  groupName = (groupName || '').toString().trim() || 'macros';
  let macroGroup = macroDropDownTable.get(groupName);

  if (macroGroup === undefined) {
    macroGroup = {};
    macroGroup.titleButton = $(`<span class="RESMacroDropdownTitle">${groupName}</span>`);
    macroGroup.container = $('<span class="RESMacroDropdown"></span>');
    macroGroup.dropdown = $('<ul class="RESMacroDropdownList"></ul>');
    macroGroup.container.append(macroGroup.dropdown);
    macroDropDownTable.set(groupName, macroGroup);
  }

  return macroGroup;
}

function addButtonToMacroGroup(groupName, button) {
  const group = getMacroGroup(groupName);
  group.dropdown.append($('<li>').append(button));
}

function getDebugMacros() {
  if (!isCurrentSubreddit('Enhancement', 'RESissues')) return [];
  return [['RES modified settings', '\n\n{{resmodifiedsettings}}\n', null, null], ['RES diagnostics', '{{resdiagnostics}}', null, null]];
}

function buildMacroDropdowns(editBar) {
  const macros = [...commentTools_module.options.macros.value, ...getDebugMacros()];

  for (const [title, text, category, key] of macros) {
    const button = makeEditButton(title, null, key, 'btn-macro', box => {
      macroSelection(box, text);
    });
    addButtonToMacroGroup(category, button);
  }

  const $macroWrapper = $('<span class="RESMacroWrappingSpan">');
  const defaultGroup = getMacroGroup('');
  $macroWrapper.append(defaultGroup.titleButton);
  $macroWrapper.append(defaultGroup.container);

  for (const [category, macroGroup] of macroDropDownTable) {
    if (category === 'macros') {
      continue;
    }

    $macroWrapper.append(macroGroup.titleButton);
    $macroWrapper.append(macroGroup.container);
  }

  editBar.append($macroWrapper);
}

function makeEditButton(label, title, key, cls, handler) {
  if (label === null) {
    label = 'unlabeled';
  }

  if (title === null) {
    title = '';
  }

  const macroButtonIndex = macroCallbackTable.length;
  const button = $('<a>').safeHtml(label).attr({
    class: `edit-btn ${cls}`,
    title,
    href: '#',
    tabindex: 1,
    'data-macro-index': macroButtonIndex
  });

  if (key && key[0] !== null) {
    macroKeyTable.push([key, macroButtonIndex]);
  }

  macroCallbackTable[macroButtonIndex] = handler;
  return button;
}

function linkSelection(box) {
  let url = prompt('Enter the URL:', '');

  if (url) {
    url = url.replace(/[\(\)]/g, '\\$&');
    wrapSelection(box, '[', `](${url})`, text => text.replace(/[\[\]\(\)]/g, '\\$&'));
  }
}

function macroSelection(box, macroText) {
  if (!commentTools_module.options.keepMacroListOpen.value) {
    $('.RESMacroWrappingSpan span').removeClass('openMacro');
  }

  if (commentTools_module.options.macroPlaceholders.value) {
    wrapSelection(box, '', '', selectedText => fillPlaceholders(box, macroText, selectedText));
  } else {
    wrapSelection(box, macroText, '');
  }
}

function fillPlaceholders(box, macroText, selectedText) {
  const placeholders = macroText.match(/\{\{\w+\}\}/g);

  if (placeholders) {
    const completedPlaceholders = new Set();

    for (const placeholder of placeholders) {
      if (completedPlaceholders.has(placeholder)) {
        continue;
      }

      completedPlaceholders.add(placeholder);
      const placeholderInnerText = placeholder.substring(2, placeholder.length - 2).toLowerCase();
      let value;

      try {
        value = getMagicPlaceholderValue(placeholderInnerText, macroText, selectedText, box);
      } catch (e) {
        console.error('Error getting magic placeholder value', placeholderInnerText);
        console.error(e);
      }

      if (value === undefined) {
        value = promptForPlaceholderValue(placeholder, macroText);
      }

      if (value === null) {
        break;
      }

      macroText = macroText.replace(new RegExp(placeholder, 'g'), value);
    }
  }

  return macroText;
}

function getMagicPlaceholderValue(placeholder, macroText, selectedText, box) {
  const handler = magicPlaceholders.find(current => current.matches.includes(placeholder));

  if (handler) {
    return handler.handle(macroText, selectedText, box);
  }
}

const magicPlaceholders = [{
  matches: ['subreddit'],

  handle(macroText, selectedText, box) {
    const thing = Thing_Thing.from(box);
    const subreddit = thing && thing.getSubreddit();

    if (subreddit) {
      return `/r/${subreddit}`;
    }
  }

}, {
  matches: ['me', 'my_username'],

  handle() {
    const username = loggedInUser();

    if (username) {
      return `/u/${username}`;
    }
  }

}, {
  matches: ['op', 'op_username'],

  handle(macroText, selectedText, box) {
    let profile;

    if (isPageType('comments')) {
      profile = document.querySelector('.sitetable .author');
    } else {
      let $next = $(box);
      let furthest = $next;

      do {
        if ($next && $next.length) furthest = $next;
        $next = $next.parent().closest('.sitetable');
      } while ($next.length);

      profile = furthest.find('.author')[0];
    }

    if (profile) {
      const match = profile.pathname.match(regexes.profile);
      if (!match) throw new Error(`Invalid profile link: ${profile.href}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['url'],

  handle() {
    return location.href;
  }

}, {
  matches: ['reply_to', 'reply_to_username'],

  handle(macroText, selectedText, box) {
    let $base = $(box);
    const isEditing = $base.closest('.thing, .entry').hasClass('entry');

    if (isEditing) {
      $base = $base.closest('.thing').parent();
    }

    const profile = $base.closest('.thing').find('.entry .author')[0];

    if (!profile) {
      return getMagicPlaceholderValue('op', macroText, selectedText, box);
    } else {
      const match = profile.pathname.match(regexes.profile);
      if (!match) throw new Error(`Invalid profile link: ${String(profile)}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['selected', 'selection'],

  handle(macroText, selectedText) {
    return selectedText;
  }

}, {
  matches: ['now'],

  handle() {
    const date = new Date();
    return date.toTimeString();
  }

}, {
  matches: ['today'],

  handle() {
    const date = new Date();
    return date.toDateString();
  }

}, {
  matches: ['linkflair'],

  handle() {
    if (isPageType('comments')) {
      return document.querySelector('.linkflairlabel').textContent;
    }
  }

}, {
  matches: ['escaped'],

  handle(macroText, selectedText) {
    return selectedText.replace(/[\[\]()\\\*\^~\-_.]/g, '\\$&').replace(/^([ ]{0,3})>/gm, '$1\\>');
  }

}, {
  matches: ['resmodifiedsettings'],

  handle() {
    return getModifiedText();
  }

}, {
  matches: ['resdiagnostics'],

  handle() {
    return diagnostics();
  }

}];

function promptForPlaceholderValue(placeholder, macroText) {
  return prompt(`${macroText}\n\n\nEnter replacement for ${placeholder}:`, placeholder);
}

function wrapSelection(box, prefix, suffix, escapeFunction) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  let selectedText = text.substring(selectionStart, selectionEnd);
  const afterSelection = text.substring(selectionEnd);
  let trailingSpace = '';
  let cursor = selectedText.length - 1;

  while (cursor > 0 && selectedText[cursor] === ' ') {
    trailingSpace += ' ';
    cursor--;
  }

  selectedText = selectedText.substring(0, cursor + 1);

  if (typeof escapeFunction === 'function') {
    selectedText = escapeFunction(selectedText);
  }

  box.value = beforeSelection + prefix + selectedText + suffix + trailingSpace + afterSelection;
  box.selectionEnd = beforeSelection.length + prefix.length + selectedText.length;

  if (selectionStart === selectionEnd) {
    box.selectionStart = box.selectionEnd;
  } else {
    box.selectionStart = beforeSelection.length + prefix.length;
  }

  box.scrollTop = scrollTop;
}

function replaceSelection(box, replacement) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const afterSelection = text.substring(selectionEnd);
  box.value = beforeSelection + replacement + afterSelection;
  box.selectionEnd = beforeSelection.length + replacement.length;
  box.scrollTop = scrollTop;
}

function wrapSelectedLines(box, prefix, suffix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  let selectionEnd = box.selectionEnd;
  const text = box.value;
  let startPosition = 0;
  const lines = text.split('\n');

  for (const i of range(0, lines.length)) {
    let lineStart = startPosition;
    let lineEnd = lineStart + lines[i].length;

    if (selectionStart <= lineStart && lineStart <= selectionEnd || selectionStart <= lineEnd && lineEnd <= selectionEnd || lineStart <= selectionStart && selectionStart <= lineEnd || lineStart <= selectionEnd && selectionEnd <= lineEnd) {
      lines[i] = prefix + lines[i] + suffix;
      let startMovement = 0;
      let endMovement = 0;

      if (lineStart < selectionStart) {
        startMovement += prefix.length;
      }

      if (lineEnd < selectionStart) {
        startMovement += suffix.length;
      }

      if (lineStart < selectionEnd) {
        endMovement += prefix.length;
      }

      if (lineEnd < selectionEnd) {
        endMovement += suffix.length;
      }

      selectionStart += startMovement;
      selectionEnd += endMovement;
      lineStart += prefix.length;
      lineEnd += prefix.length + suffix.length;
    }

    startPosition = lineEnd + 1;
  }

  box.value = lines.join('\n');
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd;
  box.scrollTop = scrollTop;
}

function wrapSelectedWords(box, prefix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const selectedWords = text.substring(selectionStart, selectionEnd).split(' ');
  const afterSelection = text.substring(selectionEnd);
  let selectionModify = 0;

  for (const i of range(0, selectedWords.length)) {
    if (selectedWords[i] !== '') {
      if (selectedWords[i].includes('\n')) {
        const newLinePosition = selectedWords[i].lastIndexOf('\n') + 1;
        selectedWords[i] = selectedWords[i].substring(0, newLinePosition) + prefix + selectedWords[i].substring(newLinePosition);
        selectionModify += prefix.length;
      }

      if (selectedWords[i].charAt(0) !== '\n') {
        selectedWords[i] = prefix + selectedWords[i];
      }

      selectionModify += prefix.length;
    } else if (selectedWords[i] === '' && selectedWords.length === 1) {
      selectedWords[i] = prefix + selectedWords[i];
      selectionModify += prefix.length;
      selectionStart += prefix.length;
    }
  }

  box.value = beforeSelection + selectedWords.join(' ') + afterSelection;
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd + selectionModify;
  box.scrollTop = scrollTop;
}

const autoCompleteMatchRegExp = /(^|\W)\/?(?:r\/([\w]+)\/)?(wiki|w|r|u)\/([\w]+)$/;

function initializeAutocomplete() {
  if (!commentTools_module.options.subredditAutocomplete.value && !commentTools_module.options.userAutocomplete.value && !commentTools_module.options.wikiAutocomplete.value) return;
  $(document.body).on('input', '.usertext .usertext-edit textarea, #BigText, #wiki_page_content', debounce_default()(async e => {
    const textarea = e.target;
    const prefixText = textarea.value.slice(0, textarea.selectionStart);
    const [,, subreddit, [type] = [], query] = autoCompleteMatchRegExp.exec(prefixText) || [];
    const completions = query && (type === 'u' && commentTools_module.options.userAutocomplete.value && (await getUserCompletions(query)) || type === 'r' && commentTools_module.options.subredditAutocomplete.value && (await getSubredditCompletions(query)) || type === 'w' && commentTools_module.options.wikiAutocomplete.value && (await getWikiCompletions(query, subreddit || currentSubreddit() || ''))) || [];
    autoComplete(textarea)(completions);
  }, 100));
}

const autoComplete = memoize_default()(textarea => {
  const element = string_namespaceObject.html`<div id="autocomplete_dropdown" class="drop-choices srdrop"></div>`;
  let entries = [];
  let index = 0;
  element.addEventListener('click', e => {
    const text = e.target.textContent;
    const caretPos = textarea.selectionStart;
    let left = textarea.value.substr(0, caretPos);
    const right = textarea.value.substr(caretPos);
    left = left.replace(autoCompleteMatchRegExp, `$1${text} `);
    textarea.value = left + right;
    textarea.selectionStart = textarea.selectionEnd = left.length;
    textarea.focus();
    textarea.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  });

  const updateSelection = () => {
    for (const entry of entries) entry.classList.remove('selectedItem');

    entries[index % entries.length].classList.add('selectedItem');
  };

  const remove = () => {
    element.remove();
    textarea.removeEventListener('keydown', navigate);
    textarea.removeEventListener('blur', remove);
  };

  const navigate = e => {
    if (e.metaKey || e.shiftKey || e.ctrlKey || e.altKey) return;
    if (!document.contains(element)) return;

    switch (e.key) {
      case NAMED_KEYS.Down:
      case NAMED_KEYS.Right:
        e.preventDefault();
        index++;
        updateSelection();
        return;

      case NAMED_KEYS.Up:
      case NAMED_KEYS.Left:
        e.preventDefault();
        index--;
        updateSelection();
        return;

      case NAMED_KEYS.Tab:
      case NAMED_KEYS.Enter:
        e.preventDefault();
        entries[index % entries.length].click();
        return;

      case NAMED_KEYS.Escape:
        e.preventDefault();
        e.stopImmediatePropagation();
        remove();
        break;

      default:
        break;
    }
  };

  return matches => {
    if (!matches.length || document.activeElement !== textarea) {
      remove();
      return;
    }

    empty(element);
    entries = matches.slice(0, 20).map(text => string_namespaceObject.html`<a class="choice">${text}</a>`);
    element.append(...entries);
    index = 0;
    updateSelection();

    if (!document.contains(element)) {
      const textareaOffset = $(textarea).offset();
      textareaOffset.left += $(textarea).width();
      $(element).css(textareaOffset);
      document.body.append(element);
      textarea.addEventListener('keydown', navigate);
      textarea.addEventListener('blur', () => {
        setTimeout(() => {
          if (document.activeElement !== textarea) remove();
        }, 200);
      });
    }
  };
});

async function getSubredditCompletions(query) {
  const {
    names
  } = await ajax({
    method: 'POST',
    url: '/api/search_reddit_names.json',
    query: {
      query
    },
    data: {
      query
    },
    type: 'json',
    cacheFor: DAY
  });
  return names.map(name => `/r/${name}`);
}

const loadAllTags = once_default()(() => userTagger_Tag.getStored());

async function getUserCompletions(query) {
  await loadAllTags();
  return Array.from(userTagger_tags.values()).filter(({
    id
  }) => id.toLowerCase().startsWith(query.toLowerCase())).filter(({
    text,
    votesUp,
    instances
  }) => text || votesUp || instances.length).sort((a, b) => Number(b.instances.length > a.instances.length) || a.id.localeCompare(b.id)).map(({
    id
  }) => `/u/${id}`);
}

async function getWikiCompletions(query, subreddit) {
  const {
    data: wikiPages
  } = await ajax({
    method: 'GET',
    url: `/r/${subreddit}/wiki/pages.json`,
    type: 'json',
    cacheFor: DAY
  });
  return wikiPages.filter(wikiPage => wikiPage.toLowerCase().startsWith(query.toLowerCase())).map(wikiPage => `/r/${subreddit}/wiki/${wikiPage}`);
}

function findTextareaForElement(elem) {
  const textarea = $(elem).closest('.usertext-edit, #BigEditor, .wiki-page-content, #banned').find('textarea').filter('#BigText, [name=text], [name=description], [name=public_description], [name=body], #wiki_page_content, #ban_message').get(0);
  return textarea;
}

function onCtrlEnter(selector, callback) {
  $(document.body).on('keydown', selector, e => {
    if (e.key === NAMED_KEYS.Enter && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      callback(e);
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/usernameHider.js





const usernameHider_module = new Module('usernameHider');
usernameHider_module.moduleName = 'usernameHiderName';
usernameHider_module.category = 'myAccountCategory';
usernameHider_module.disabledByDefault = true;
usernameHider_module.description = 'usernameHiderDesc';
usernameHider_module.options = {
  displayText: {
    title: 'usernameHiderDisplayTextTitle',
    type: 'text',
    value: '~anonymous~',
    description: 'usernameHiderDisplayTextDesc'
  },
  perAccountDisplayText: {
    title: 'usernameHiderPerAccountDisplayTextTitle',
    type: 'table',
    addRowText: '+add account',
    fields: [{
      key: 'username',
      name: 'username',
      type: 'text'
    }, {
      key: 'displayText',
      name: 'displayText',
      type: 'text'
    }],
    value: [],
    description: 'usernameHiderPerAccountDisplayTextDesc'
  },
  hideAllUsernames: {
    title: 'usernameHiderHideAllUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAllUsernamesDesc'
  },
  hideAccountSwitcherUsernames: {
    title: 'usernameHiderHideAccountSwitcherUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAccountSwitcherUsernamesDesc'
  },
  showUsernameOnHover: {
    title: 'usernameHiderShowUsernameOnHoverTitle',
    type: 'boolean',
    value: false,
    description: 'usernameHiderShowUsernameOnHoverDesc'
  }
};

usernameHider_module.contentStart = () => {
  hideUsernames();
};

function getDisplayText(username) {
  const accounts = usernameHider_module.options.perAccountDisplayText.value;
  let displayText;

  if (username && accounts) {
    username = username.toLowerCase();
    [, displayText] = accounts.find(([user]) => user.toLowerCase() === username) || [];
  }

  if (!displayText) {
    displayText = usernameHider_module.options.displayText.value;
  }

  return displayText;
}

function hideUsernames() {
  hideUsername();

  if (usernameHider_module.options.hideAllUsernames.value) {
    hideAllUsernames();
  }

  if (usernameHider_module.options.hideAccountSwitcherUsernames.value) {
    hideAccountSwitcherUsernames();
  }
}

function hideAllUsernames() {
  for (const [username] of usernameHider_module.options.perAccountDisplayText.value) {
    hideUsername(username);
  }
}

function hideAccountSwitcherUsernames() {
  const accounts = accountSwitcher_module.options.accounts.value;

  if (accounts) {
    for (const [username] of accounts) {
      hideUsername(username);
    }
  }
}

const hideUsername = memoize_default()((user = loggedInUser()) => {
  if (!user) return;
  const curatedBy = document.querySelector('.multi-details > h2 a');
  const displayText = getDisplayText(user);
  const userHref = `[href*="/user/${user}"]`;
  addCSS(`
		p.tagline > a${userHref},
		#header .user > a${userHref},
		.titlebox .tagline a.author${userHref},
		.commentingAsUser a${userHref},
		a.author${userHref},
		.bottom a${userHref} {
			line-height: 0;
			font-size: 0;
		}

		p.tagline > a${userHref}::after,
		#header .user > a${userHref}::after,
		.titlebox .tagline a.author${userHref}::after,
		.commentingAsUser a${userHref}::after,
		a.author${userHref}::after,
		.bottom a${userHref}::after {
			content: "${displayText}";
			letter-spacing: normal;
			font-size: 10px;
			background-color: inherit;
			border-radius: inherit;
			padding: inherit;
		}

		a.author${userHref}::after {
			margin-right: 0.5em;
		}

		.commentingAsUser a${userHref}::after {
			font-size: small;
		}
	`);

  if (usernameHider_module.options.showUsernameOnHover.value) {
    addCSS(`
			p.tagline > a${userHref}:hover,
			#header .user > a${userHref}:hover,
			.titlebox .tagline a.author${userHref}:hover,
			.commentingAsUser a${userHref}:hover,
			a.author${userHref}:hover,
			.bottom a${userHref}:hover {
				line-height: inherit;
				font-size: inherit;
			}

			p.tagline > a${userHref}:hover::after,
			#header .user > a${userHref}:hover::after,
			.titlebox .tagline a.author${userHref}:hover::after,
			.commentingAsUser a${userHref}:hover::after,
			a.author${userHref}:hover::after,
			.bottom a${userHref}:hover::after {
				content: none;
			}
		`);
  }

  if (curatedBy) {
    const curatedByUsername = curatedBy.pathname.match(regexes.profile);

    if (curatedByUsername && curatedByUsername[1].toLowerCase() === user.toLowerCase()) {
      curatedBy.textContent = curatedBy.textContent.replace(user, displayText);

      if (usernameHider_module.options.showUsernameOnHover.value) {
        $(curatedBy).on('mouseenter', function () {
          this.textContent = this.textContent.replace(displayText, user);
        }).on('mouseleave', function () {
          this.textContent = this.textContent.replace(user, displayText);
        });
      }
    }
  }
}, (user = loggedInUser()) => user && user.toLowerCase());
// CONCATENATED MODULE: ./lib/modules/quickMessage.js











const quickMessage_module = new Module('quickMessage');
quickMessage_module.moduleName = 'quickMessageName';
quickMessage_module.category = 'usersCategory';
quickMessage_module.description = 'quickMessageDesc';
quickMessage_module.options = {
  openQuickMessage: {
    title: 'quickMessageOpenQuickMessageTitle',
    type: 'keycode',
    value: [77, false, true, false, false],
    description: 'quickMessageOpenQuickMessageDesc'
  },
  defaultSubject: {
    title: 'quickMessageDefaultSubjectTitle',
    type: 'text',
    value: '',
    description: 'quickMessageDefaultSubjectDesc'
  },
  sendAs: {
    title: 'quickMessageSendAsTitle',
    type: 'enum',
    values: [{
      name: 'Current user',
      value: 'user'
    }, {
      name: 'Current subreddit',
      value: 'sub'
    }, {
      name: 'Last selected',
      value: 'last'
    }, {
      name: 'Last selected (this page load)',
      value: 'temporary'
    }],
    value: 'user',
    description: 'quickMessageSendAsDesc'
  },
  handleContentLinks: {
    title: 'quickMessageHandleContentLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleContentLinksDesc'
  },
  handleSideLinks: {
    title: 'quickMessageHandleSideLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleSideLinksDesc'
  },
  linkToCurrentPage: {
    title: 'quickMessageLinkToCurrentPageTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageLinkToCurrentPageDesc'
  }
};
const lastSentAsStorage = storage_namespaceObject.wrapPrefix('RESmodules.quickMessage.lastSentAs.', () => null);

quickMessage_module.contentStart = () => {
  registerCommand((cmd, val) => cmd === 'qm' && /^(?:([^\s]+)(?:\s(.*))?)?$/.exec(val), 'qm [recipient [message]] - open quick message dialog', (command, val, [, to, body]) => {
    if (body) {
      return `quick message to ${to}: ${body}`;
    } else if (to) {
      return `quick message to ${to}`;
    }

    return 'quick message';
  }, (command, val, [, to, body]) => {
    openQuickMessageDialog({
      to,
      body
    });
  });
  window.addEventListener('keydown', e => {
    if (checkKeysForEvent(e, quickMessage_module.options.openQuickMessage.value)) {
      e.preventDefault();
      openQuickMessageDialog();
    }
  }, true);

  if (quickMessage_module.options.handleContentLinks.value) {
    $('div.content[role="main"]').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }

  if (quickMessage_module.options.handleSideLinks.value) {
    $('div.side').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }
};

const quickMessageDialog = once_default()(() => {
  const $dialog = $(string_namespaceObject.html`
		<div id="quickMessage">
			<div id="quickMessageDialog" class="RESDialogSmall">
				<h3>Send Message<a class="gearIcon" href="${makeUrlHash(quickMessage_module.moduleID)}"></a></h3>
				<div id="quickMessageDialogClose" class="RESCloseButton">×</div>
				<div id="quickMessageDialogContents" class="RESDialogContents clear">
					<form name="quickMessageDialogForm" action="">
						<label for="quickMessageDialogFrom">From</label>
						<select id="quickMessageDialogFrom"></select>
						<label for="quickMessageDialogTo">To</label>
						<input type="text" id="quickMessageDialogTo" value=""/>
						<label for="quickMessageDialogSubject">Subject</label>
						<input type="text" id="quickMessageDialogSubject" value=""/>
						<label for="quickMessageDialogBody">Body</label>
						<textarea id="quickMessageDialogBody"></textarea>
						<div class="clear"></div>
						<input type="button" id="quickMessageDialogSend" value="✓ send message"/>
						<a href="/message/compose" class="fullMessageForm blueButton">open full message form</a>
					</form>
				</div>
			</div>
		</div>
	`);
  const from = downcast($dialog.find('#quickMessageDialogFrom').get(0), HTMLSelectElement);
  const to = downcast($dialog.find('#quickMessageDialogTo').get(0), HTMLInputElement);
  const subject = downcast($dialog.find('#quickMessageDialogSubject').get(0), HTMLInputElement);
  const body = downcast($dialog.find('#quickMessageDialogBody').get(0), HTMLTextAreaElement);
  $dialog.find('#quickMessageDialogClose').on('click', e => {
    e.preventDefault();
    closeQuickMessageDialog();
  });
  $dialog.get(0).addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      e.preventDefault();
      closeQuickMessageDialog();
    }
  }, true);
  $dialog.find('#quickMessageDialogSend').get(0).addEventListener('click', e => {
    e.preventDefault();
    quickMessage_sendMessage();
  }, true);
  onCtrlEnter('#quickMessageDialog', quickMessage_sendMessage);
  $dialog.find('a.fullMessageForm').on('mousedown focus', e => {
    $(e.target).attr('href', getFullMessageFormUrl());
  }).on('click', closeQuickMessageDialog);
  $dialog.find('a').on('keypress', e => {
    if (e.key === NAMED_KEYS.Enter) {
      $(e.target).trigger('click');
    }
  });
  from.addEventListener('change', ({
    target
  }) => {
    const val = $(target).val();
    updateModeratorIcon(val.startsWith('/r/'));
    const loggedIn = loggedInUser();
    if (loggedIn) lastSentAsStorage.set(loggedIn, val);
  });
  $dialog.appendTo(document.body);
  return {
    $dialog,
    from,
    to,
    subject,
    body
  };
});

function updateModeratorIcon(state) {
  quickMessageDialog().$dialog.find('label[for=quickMessageDialogFrom]').toggleClass('moderator', state);
}

function messageLinkEventHandler(e) {
  const {
    searchParams,
    pathname
  } = new URL(downcast(e.target, HTMLAnchorElement).href, location.href);
  const hasModifier = e.ctrlKey || e.altKey || e.metaKey || e.shiftKey;

  if (e.button === 0 && !hasModifier && regexes.composeMessage.test(pathname)) {
    e.preventDefault();
    const srMatch = regexes.subreddit.exec(pathname);
    openQuickMessageDialog({
      from: srMatch ? `/r/${srMatch[1]}` : undefined,
      to: searchParams.get('to') || '',
      subject: searchParams.get('subject') || '',
      body: searchParams.get('message') || ''
    });
    return true;
  }
}

function onClickMessageLink(event) {
  if (!isRunning(quickMessage_module)) {
    return false;
  }

  return messageLinkEventHandler(event);
}

async function getValidSendFrom() {
  const username = loggedInUser();

  if (!username) {
    return [];
  }

  const users = [{
    name: `/u/${username}`,
    displayText: `/u/${modules_isEnabled(usernameHider_namespaceObject) ? getDisplayText(username) : username}`
  }];

  if (isModeratorAnywhere()) {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine/moderator.json',
      query: {
        limit: 1000,
        show: 'all',
        user: loggedInUser() || ''
      },
      type: 'json',
      cacheFor: HOUR
    });
    const modSubs = data.children.map(({
      data
    }) => {
      const name = data.url.slice(0, -1);
      return {
        name,
        displayText: name
      };
    });
    users.push(...modSubs);
  }

  return users;
}

const setUpSendFromDropdown = once_default()(async () => {
  const senders = await getValidSendFrom();

  for (const {
    name,
    displayText
  } of senders) {
    const currentOption = document.createElement('option');
    currentOption.value = name;
    currentOption.text = displayText;
    quickMessageDialog().from.add(currentOption);
  }

  quickMessageDialog().from.disabled = senders.length < 2;
});

function focusFirstEmpty() {
  Array.from(quickMessageDialog().$dialog.find('input, textarea')).find((ele, i, {
    length
  }) => !ele.value || i === length - 1).focus();
}

async function updateSelectedSender(desiredUser, loggedIn) {
  const sendAsOptions = Array.from(quickMessageDialog().from.options).map(ele => $(ele).text().toLowerCase());
  let indexToSelect = sendAsOptions.indexOf(desiredUser.toLowerCase());

  if (indexToSelect === -1) {
    switch (quickMessage_module.options.sendAs.value) {
      case 'sub':
        const sub = currentSubreddit();
        if (sub) indexToSelect = sendAsOptions.indexOf(`/r/${sub.toLowerCase()}`);
        break;

      case 'last':
        const lastSelected = await lastSentAsStorage.get(loggedIn);

        if (lastSelected) {
          indexToSelect = sendAsOptions.indexOf(lastSelected.toLowerCase());
        }

        break;

      case 'temporary':
        indexToSelect = quickMessageDialog().from.selectedIndex;
        break;

      default:
        indexToSelect = 0;
        break;
    }
  }

  quickMessageDialog().from.selectedIndex = indexToSelect !== -1 ? indexToSelect : 0;
  updateModeratorIcon(quickMessageDialog().from.value.startsWith('/r/'));
}

async function openQuickMessageDialog({
  from = '',
  to = '',
  subject = quickMessage_module.options.defaultSubject.value,
  body = quickMessage_module.options.linkToCurrentPage.value ? location.href : ''
} = {}) {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'quickMessageNoUser',
      header: 'Not Logged In.',
      closeDelay: 3000,
      message: 'You must log in to use the quick message dialog.'
    });
    return;
  }

  await setUpSendFromDropdown();
  await updateSelectedSender(from, loggedIn);
  quickMessageDialog().to.value = to;
  quickMessageDialog().subject.value = subject;
  quickMessageDialog().body.value = body;
  quickMessageDialog().$dialog.fadeIn(300);
  focusFirstEmpty();
}

function closeQuickMessageDialog() {
  quickMessageDialog().$dialog.fadeOut(300);

  for (const ele of quickMessageDialog().$dialog.find('input, textarea, button')) {
    ele.blur();
  }
}

function getFullMessageFormUrl() {
  const subreddit = quickMessageDialog().from.value.startsWith('/r/') ? quickMessageDialog().from.value : '';
  return subreddit + string_namespaceObject.encode`/message/compose?to=${quickMessageDialog().to.value}&subject=${quickMessageDialog().subject.value}&message=${quickMessageDialog().body.value}`;
}

const presetSendErrors = {
  NO_USER: 'No recipient specified.',
  NO_SUBJECT: 'No subject specified.',
  NO_TEXT: 'Message body is empty.',
  BAD_CAPTCHA: '<p>Sorry, reddit requires you to enter a captcha to send messages. This is usually because your account is brand new or has low karma.</p><b>Click on "open full message form" and try again (your message will be preserved).</b>',
  TOO_LONG: 'Either your subject (max 100 characters) or body (max 10,000 characters) is too long.'
};

async function quickMessage_sendMessage() {
  const from = quickMessageDialog().from.value;

  try {
    const {
      json: {
        errors
      }
    } = await ajax({
      method: 'POST',
      url: '/api/compose',
      data: {
        api_type: 'json',
        from_sr: from.includes('/r/') ? from.slice(3) : '',
        subject: quickMessageDialog().subject.value,
        text: quickMessageDialog().body.value,
        to: quickMessageDialog().to.value
      },
      type: 'json'
    });

    if (errors[0]) {
      notifications_showNotification({
        moduleID: 'quickMessage',
        notificationID: 'quickMessageSendError',
        header: 'Message not sent.',
        closeDelay: 15000,
        message: presetSendErrors[errors[0][0]] || `${errors[0][0]} : ${errors[0][1]}`
      });
    } else {
      closeQuickMessageDialog();
    }
  } catch (e) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'failedToSendQuickMessage',
      header: 'Sending Failed!',
      closeDelay: 15000,
      message: 'Reddit is likely under heavy load. Either wait a minute or click on "open full message form" and try again (your message will be preserved).'
    });
    throw e;
  }
}
// CONCATENATED MODULE: ./lib/modules/userHighlight.js





const userHighlight_module = new Module('userHighlight');
userHighlight_module.moduleName = 'userHighlightName';
userHighlight_module.category = 'usersCategory';
userHighlight_module.description = 'userHighlightDesc';
userHighlight_module.bodyClass = true;
userHighlight_module.options = {
  highlightSelf: {
    title: 'userHighlightHighlightSelfTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightSelfDesc'
  },
  selfColor: {
    title: 'userHighlightSelfColorTitle',
    type: 'color',
    value: '#B8860B',
    description: 'userHighlightSelfColorDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  selfColorHover: {
    title: 'userHighlightSelfColorHoverTitle',
    type: 'color',
    value: '#8A6508',
    description: 'userHighlightSelfColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  highlightOP: {
    title: 'userHighlightHighlightOPTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightOPDesc'
  },
  OPColor: {
    title: 'userHighlightOPColorTitle',
    type: 'color',
    value: '#0055DF',
    description: 'userHighlightOPColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  OPColorHover: {
    title: 'userHighlightOPColorHoverTitle',
    type: 'color',
    value: '#4E7EAB',
    description: 'userHighlightOPColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  highlightAdmin: {
    title: 'userHighlightHighlightAdminTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAdminDesc'
  },
  adminColor: {
    title: 'userHighlightAdminColorTitle',
    type: 'color',
    value: '#FF0011',
    description: 'userHighlightAdminColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  adminColorHover: {
    title: 'userHighlightAdminColorHoverTitle',
    type: 'color',
    value: '#B3000C',
    description: 'userHighlightAdminColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  highlightAlum: {
    title: 'userHighlightHighlightAlumTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAlumDesc'
  },
  alumColor: {
    title: 'userHighlightAlumColorTitle',
    type: 'color',
    value: '#BE1337',
    description: 'userHighlightAlumColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  alumColorHover: {
    title: 'userHighlightAlumColorHoverTitle',
    type: 'color',
    value: '#8F0E29',
    description: 'userHighlightAlumColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  highlightFriend: {
    title: 'userHighlightHighlightFriendTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightFriendDesc'
  },
  friendColor: {
    title: 'userHighlightFriendColorTitle',
    type: 'color',
    value: '#FF4500',
    description: 'userHighlightFriendColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  friendColorHover: {
    title: 'userHighlightFriendColorHoverTitle',
    type: 'color',
    value: '#B33000',
    description: 'userHighlightFriendColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  highlightMod: {
    title: 'userHighlightHighlightModTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightModDesc'
  },
  modColor: {
    title: 'userHighlightModColorTitle',
    type: 'color',
    value: '#228822',
    description: 'userHighlightModColorDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  modColorHover: {
    title: 'userHighlightModColorHoverTitle',
    type: 'color',
    value: '#134913',
    description: 'userHighlightModColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  highlightOpMentions: {
    title: 'userHighlightOpMentionsTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightOpMentionsDesc'
  },
  opMentionsColor: {
    title: 'userHighlightOpMentionsColorTitle',
    type: 'color',
    value: '#6D4731',
    description: 'userHighlightOpMentionsColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  opMentionsHover: {
    title: 'userHighlightOpMentionsHoverTitle',
    type: 'color',
    value: '#C4946E',
    description: 'userHighlightOpMentionsHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  highlightFirstCommenter: {
    title: 'userHighlightHighlightFirstCommenterTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightFirstCommenterDesc'
  },
  dontHighlightFirstComment: {
    title: 'userHighlightDontHighlightFirstCommentTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightDontHighlightFirstCommentDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColor: {
    title: 'userHighlightFirstCommentColorTitle',
    type: 'color',
    value: '#46B6CC',
    description: 'userHighlightFirstCommentColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColorHover: {
    title: 'userHighlightFirstCommentColorHoverTitle',
    type: 'color',
    value: '#72D2E5',
    description: 'userHighlightFirstCommentColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  fontColor: {
    title: 'userHighlightFontColorTitle',
    type: 'color',
    value: '#FFFFFF',
    description: 'userHighlightFontColorDesc',
    advanced: true
  },
  autoColorUsernames: {
    title: 'userHighlightAutoColorUsernamesTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightAutoColorUsernamesDesc'
  },
  autoColorUsing: {
    title: 'userHighlightAutoColorUsingTitle',
    description: 'userHighlightAutoColorUsingDesc',
    type: 'enum',
    value: 'hash-userid-notbright',
    values: [{
      name: 'Random color, not too bright, consistent for each user; night mode-friendly',
      value: 'hash-userid-notbright'
    }, {
      name: 'Simple random color, consistent for each user. (original)',
      value: 'hash-userid'
    }, {
      name: 'All black or, in night mode, all light gray.',
      value: 'monochrome'
    }],
    advanced: true,
    dependsOn: options => options.autoColorUsernames.value
  },
  generateHoverColors: {
    title: 'userHighlightGenerateHoverColorsTitle',
    type: 'button',
    text: 'Generate',
    callback: generateHoverColors,
    description: 'userHighlightGenerateHoverColorsDesc',
    advanced: true
  }
};

userHighlight_module.beforeLoad = () => {
  if (userHighlight_module.options.autoColorUsernames.value) {
    watchForThings(['post', 'comment', 'message'], updateNewUsernames, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFirstCommenter.value) {
    watchForThings(['comment'], updateFirstComments, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFriend.value) {
    highlight('friend', userHighlight_module.options.friendColor.value, userHighlight_module.options.friendColorHover.value);
  }

  if (userHighlight_module.options.highlightOP.value) {
    highlight('submitter', userHighlight_module.options.OPColor.value, userHighlight_module.options.OPColorHover.value);
  }

  if (userHighlight_module.options.highlightMod.value) {
    highlight('moderator', userHighlight_module.options.modColor.value, userHighlight_module.options.modColorHover.value);
  }

  if (userHighlight_module.options.highlightAdmin.value) {
    highlight('admin', userHighlight_module.options.adminColor.value, userHighlight_module.options.adminColorHover.value);
  }

  if (userHighlight_module.options.highlightAlum.value) {
    highlight('alum', userHighlight_module.options.alumColor.value, userHighlight_module.options.alumColorHover.value);
  }

  if (userHighlight_module.options.highlightOpMentions.value && isPageType('comments')) {
    watchForElements(['selfText'], null, selftext => {
      const thing = Thing_Thing.from(selftext);
      const author = thing && thing.getAuthor();
      highlightMentionedUsers(selftext, userHighlight_module.options.opMentionsColor.value, userHighlight_module.options.opMentionsHover.value, author);
    }, {
      immediate: true
    });
  }
};

userHighlight_module.contentStart = () => {
  const username = loggedInUser();

  if (userHighlight_module.options.highlightSelf.value && username) {
    highlight(`author[href$="/${username}"]`, userHighlight_module.options.selfColor.value, userHighlight_module.options.selfColorHover.value);
  }
};

function highlightMentionedUsers(element, color, hoverColor, ...exclude) {
  Array.from(element.querySelectorAll('a')).map(getUsernameFromLink).filter(Boolean).filter(user => !exclude.includes(user)).forEach(user => highlight(`author[href$="/${user}" i]`, color, hoverColor));
}

function updateFirstComments(thing) {
  if (!thing.isTopLevelComment()) return;
  const idClass = Array.from(thing.element.classList).find(cls => cls.startsWith('id-t1_'));
  if (!idClass) return;
  const author = thing.getAuthorElement();
  if (!author) return;
  const authorClass = Array.from(author.classList).find(cls => cls.startsWith('id-t2_'));

  if (authorClass) {
    const container = `.${idClass}${userHighlight_module.options.dontHighlightFirstComment.value ? ' .child' : ''}`;
    highlight(authorClass, userHighlight_module.options.firstCommentColor.value, userHighlight_module.options.firstCommentColorHover.value, container);
  }
}

function updateNewUsernames(thing) {
  const element = thing.getAuthorElement();
  if (!element) return;
  const idClass = Array.from(element.classList).find(cls => cls.startsWith('id-t2_'));
  if (!idClass) return;
  const colorGetter = autoColorUsing[userHighlight_module.options.autoColorUsing.value];
  const color = colorGetter(idClass);
  doTextColor(idClass, color);
}

const autoColorUsing = {
  'hash-userid-notbright'(idClass) {
    const hash = hashCode(idClass);
    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const lum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    const minLum = 0x66;
    const maxLum = 0xAA;
    let color = [r, g, b];
    let nightmodeColor = [r, g, b];

    if (lum < minLum) {
      const scale = minLum / lum;
      nightmodeColor = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    } else if (lum > maxLum) {
      const scale = maxLum / lum;
      color = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    }

    color = `rgb(${color.join(',')})`;
    nightmodeColor = `rgb(${nightmodeColor.join(',')})`;
    return {
      color,
      nightmodeColor
    };
  },

  'hash-userid'(idClass) {
    let hash = 5381;

    for (const char of idClass) {
      hash = (hash << 5) + hash + char.charCodeAt(0);
    }

    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const color = `rgb(${[r, g, b].join(',')})`;
    return {
      color
    };
  },

  monochrome() {
    return {
      color: 'black',
      nightmodeColor: '#ccc'
    };
  }

};
function highlightUser(userid) {
  return highlight(`author.id-t2_${userid}`, userInfo_module.options.highlightColor.value, userInfo_module.options.highlightColorHover.value);
}
const css = [];
const throttled = async_throttle(() => {
  addCSS(css.splice(0, css.length).join('\n'));
});

const userHighlight_batch = v => {
  css.push(v);
  throttled();
};

function highlight(selector, color, hoverColor, container = '') {
  userHighlight_batch(`
${container} .tagline .author.${selector},
${container} .crosspost-preview-tagline .author.${selector} {
	color: ${userHighlight_module.options.fontColor.value} !important;
	font-weight: bold;
	padding: 0 2px 0 2px;
	border-radius: 3px;
	background-color: ${color} !important;
}
${container} .collapsed .tagline .author.${selector},
${container} .collapsed .crosspost-preview-tagline .author.${selector} {
	color: white !important;
	background-color: #AAA !important;
}
${container} .tagline .author.${selector}:hover,
${container} .crosspost-preview-tagline .author.${selector}:hover {
	background-color: ${hoverColor} !important;
	text-decoration: none !important;
}
	`);
}

function doTextColor(selector, colorData) {
  const color = colorData.color;
  const nightmodeColor = colorData.nightmodeColor || colorData.color;
  userHighlight_batch(`
.tagline .author.${selector} {
	color: ${color} !important;
}
.res-nightmode .tagline .author.${selector} {
	color: ${nightmodeColor} !important;
}
	`);
}

function generateHoverColor(color) {
  if (!/^#[0-9A-F]{6}$/i.test(color)) throw new Error('Input color must be a six digit hex value');
  let R = parseInt(color.substr(1, 2), 16);
  let G = parseInt(color.substr(3, 2), 16);
  let B = parseInt(color.substr(5, 2), 16);
  R = Math.round(0.75 * R) + 256;
  G = Math.round(0.75 * G) + 256;
  B = Math.round(0.75 * B) + 256;
  return `#${R.toString(16).substr(1)}${G.toString(16).substr(1)}${B.toString(16).substr(1)}`;
}

function generateHoverColors() {
  try {
    for (const option of ['selfColor', 'OPColor', 'adminColor', 'friendColor', 'modColor', 'firstCommentColor', 'alumColor']) {
      const current = (stage_namespaceObject.get(userHighlight_module.moduleID) || userHighlight_module.options)[option].value;
      options_set(userHighlight_module.moduleID, option, generateHoverColor(current));
    }

    alert_namespaceObject.open('Saved, but not yet updated in settings console. Reload page without saving to see new values.');
  } catch (e) {
    alert_namespaceObject.open(i18n('userHighlightColorCouldNotBeGenerated'));
  }
}
// CONCATENATED MODULE: ./lib/modules/userInfo.js










const userInfo_module = new Module('userInfo');
userInfo_module.moduleName = 'userInfoName';
userInfo_module.category = 'usersCategory';
userInfo_module.description = 'userInfoDesc';
userInfo_module.options = {
  hoverInfo: {
    title: 'userInfoHoverInfoTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHoverInfoDesc'
  },
  useQuickMessage: {
    title: 'userInfoUseQuickMessageTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoUseQuickMessageDesc',
    dependsOn: options => options.hoverInfo.value
  },
  hoverDelay: {
    title: 'userInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'userInfoHoverDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeDelay: {
    title: 'userInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'userInfoFadeDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeSpeed: {
    title: 'userInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'userInfoFadeSpeedDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  gildComments: {
    title: 'userInfoGildCommentsTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoGildCommentsDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightButton: {
    title: 'userInfoHighlightButtonTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHighlightButtonDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightColor: {
    title: 'userInfoHighlightColorTitle',
    type: 'color',
    value: '#5544CC',
    description: 'userInfoHighlightColorDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  },
  highlightColorHover: {
    title: 'userInfoHighlightColorHoverTitle',
    type: 'color',
    value: '#6677AA',
    description: 'userInfoHighlightColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  }
};
const highlightedUsers = {};

userInfo_module.contentStart = () => {
  if (userInfo_module.options.hoverInfo.value) {
    $(document.body).on('mouseenter', usernameSelector, handleMouseEnter);
  }
};

function handleMouseEnter(e) {
  const username = getUsernameFromLink(e.target);

  if (!username) {
    console.error(i18n('userInfoInvalidUsernameLink'));
    return;
  }

  const thing = Thing_Thing.from(e.target);
  infocard(userInfo_module.moduleID).target(e.target).options({
    width: 475,
    openDelay: parseFloat(userInfo_module.options.hoverDelay.value),
    fadeDelay: parseFloat(userInfo_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(userInfo_module.options.fadeSpeed.value)
  }).populateWith(card => showUserInfo(card, username, thing)).begin();
}

async function showUserInfo(card, username, thing) {
  card.populate([username]);
  let data;

  try {
    ({
      data
    } = await getUserInfo(username));
  } catch (e) {
    return [null, i18n('userInfoUserNotFound')];
  }

  if (data.is_suspended) {
    return [null, i18n('userInfoUserSuspended')];
  }

  const d = new Date(data.created_utc * 1000);
  const header = string_namespaceObject.html`
		<div>
			<a href="/user/${data.name}">/u/${data.name}</a>
		 	(<a href="/user/${data.name}/submitted/">${i18n('userInfoLinks')}</a>)
		 	(<a href="/user/${data.name}/comments/">${i18n('userInfoComments')}</a>)
		</div>
	`;

  if (loggedInUser()) {
    const friendButton = string_namespaceObject.html`
			<span class="fancy-toggle-button toggle" style="display: inline-block; margin-left: 12px;">
				<a class="option active ${data.is_friend ? 'remove' : 'add'}" href="#" tabindex="100">${i18n('userInfoAddRemoveFriends', data.is_friend ? '-' : '+')}</a>
			</span>
		`;
    friendButton.addEventListener('click', async e => {
      if (e.target.tagName !== 'A') return;
      e.preventDefault();
      const $link = $(e.target);
      const isRemove = $link.hasClass('remove');
      await ajax({
        method: 'POST',
        url: `/api/${isRemove ? 'unfriend' : 'friend'}`,
        data: {
          type: 'friend',
          name: data.name,
          container: `t2_${(await getUserInfo()).data.id}`
        }
      });
      $link.toggleClass('remove', !isRemove).toggleClass('add', isRemove).text(`${isRemove ? '+' : '-'} friends`);
      ajax.invalidate({
        url: `/user/${data.name}/about.json`
      });
    });
    header.appendChild(friendButton);
  }

  card.populate([header]);
  const $body = $('<div id="authorInfoToolTip" />');
  let userHTML = string_namespaceObject.escape`
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoRedditorSince')}</div> <div class="fieldPair-text">${formatDate(d)} (${formatDateDiff(d)})</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoPostKarma')}</div> <div class="fieldPair-text">${formatNumber(data.link_karma)}</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoCommentKarma')}</div> <div class="fieldPair-text">${formatNumber(data.comment_karma)}</div></div>
	`;
  const userTaggerEnabled = isRunning(userTagger_namespaceObject);
  const userTag = userTaggerEnabled && (await userTagger_Tag.get(data.name));

  if (userTaggerEnabled) {
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoUserTag')}</div> <div class="fieldPair-text" style="display:flex"><a class="author" style="display: none;" href="/u/${data.name}"/></div></div>`;
  }

  if (userTag && userTag.link) {
    const links = userTag.link.split(/\s/).reduce((acc, url) => acc + string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" href="${url}">${url.replace(/^https?:\/\/(www\.)?/, '')}</a>`, '');
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoLink')}</div> <div class="fieldPair-text">${links}</div></div>`;
  }

  userHTML += string_namespaceObject.escape`
		<div class="clear"></div>
		<div class="bottomButtons">
			<a target="_blank" rel="noopener noreferer" class="blueButton composeButton" href="/message/compose/?to=${data.name}"><img src="https://redditstatic.s3.amazonaws.com/mailgray.png"> ${i18n('userInfoSendMessage')}</a>
	`;

  if (data.is_gold) {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" class="blueButton" href="/gold/about">${i18n('userInfoUserHasRedditGold')}</a>`;
  } else {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" id="gildUser" class="blueButton" href="/gold?goldtype=gift&recipient=${data.name}">${i18n('userInfoGiftRedditGold')}</a>`;
  }

  if (userInfo_module.options.highlightButton.value) {
    const isHighlight = !highlightedUsers[data.id];
    userHTML += string_namespaceObject.escape`<div class="${isHighlight ? 'blueButton' : 'redButton'}" id="highlightUser" data-userid="${data.id}">${isHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight')}</div>`;
  }

  if (userTag) {
    const getButton = () => string_namespaceObject.html`<div class="${userTag.ignored ? 'redButton' : 'blueButton'}" id="ignoreUser">&empty; ${userTag.ignored ? i18n('userInfoUnignore') : i18n('userInfoIgnore')}</div>`;

    $body.on('click', '#ignoreUser', e => {
      if (e.target.classList.contains('blueButton')) userTag.ignore();else userTag.unignore();
      e.target.replaceWith(getButton());
    });
    userHTML += getButton().outerHTML;
  }

  userHTML += '<div class="clear"></div></div>';
  $body.append(userHTML);

  if (userTag) {
    userTag.add(downcast($body.find('.author').get(0), HTMLAnchorElement), {
      renderTaggingIcon: true
    });
  }

  if (userInfo_module.options.highlightButton.value) {
    $body.find('#highlightUser').on('click', ({
      target
    }) => {
      const userid = target.getAttribute('data-userid');
      toggleUserHighlight(target, userid, thing);
    });
  }

  if (userInfo_module.options.gildComments.value && thing && thing.isComment()) {
    $body.find('#gildUser').on('click', e => {
      if (!thing || e.ctrlKey || e.metaKey || e.shiftKey) return;
      hideAuthorInfo();
      const giveGold = thing.entry.querySelector('.give-gold');
      click(giveGold);
      e.preventDefault();
    });
  }

  if (userInfo_module.options.useQuickMessage.value && isRunning(quickMessage_namespaceObject)) {
    $body.find('a.composeButton').on('click', e => {
      if (e.which === 1) {
        e.preventDefault();
        let entryUrl;

        if (quickMessage_module.options.linkToCurrentPage.value && thing) {
          const permalink = thing.getCommentPermalink();

          if (permalink) {
            entryUrl = permalink.href;
            if (!entryUrl.includes('?context=')) entryUrl += '?context=10';
          }
        }

        openQuickMessageDialog({
          to: data.name,
          body: entryUrl
        });
        hideAuthorInfo();
      }
    });
  }

  return [null, $body];
}

function hideAuthorInfo() {
  infocard(userInfo_module.moduleID).close();
}

function toggleUserHighlight(authorInfoToolTipHighlight, userid, thing) {
  if (highlightedUsers[userid]) {
    highlightedUsers[userid].remove();
    delete highlightedUsers[userid];
    toggleUserHighlightButton(authorInfoToolTipHighlight, true);
  } else {
    highlightedUsers[userid] = highlightUser(userid);
    toggleUserHighlightButton(authorInfoToolTipHighlight, false);
  }

  if (isRunning(commentNavigator_namespaceObject) && commentNavigator_module.options.openOnHighlightUser.value) {
    setCategory('highlighted', true);
    if (thing) updateFromSelected(thing);
    commentNavigator_toggle(false, true);
  }
}

function toggleUserHighlightButton(authorInfoToolTipHighlight, canHighlight) {
  $(authorInfoToolTipHighlight).toggleClass('blueButton', canHighlight).toggleClass('redButton', !canHighlight).text(canHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight'));
}
// CONCATENATED MODULE: ./lib/modules/wheelBrowse.js






const wheelBrowse_module = new Module('wheelBrowse');
wheelBrowse_module.moduleName = 'wheelBrowseName';
wheelBrowse_module.category = 'browsingCategory';
wheelBrowse_module.description = 'wheelBrowseDesc';
let behavior;

wheelBrowse_module.contentStart = () => {
  if (!behavior && isPageType('linklist')) useLinklistBehavior();
  if (!behavior) return;
  const wheelBrowseWidget = string_namespaceObject.html`<div hidden class="res-wheel-browse"></div>`;
  const onWheel = behavior(wheelBrowseWidget);
  selectedEntry_addListener(selected => {
    wheelBrowseWidget.hidden = !selected;
  }, 'instantly');
  wheelBrowseWidget.addEventListener('wheel', e => {
    e.stopImmediatePropagation();
    e.preventDefault();
    onWheel(e.deltaY > 0 ? 'down' : 'up', e);
  });
  addElement(wheelBrowseWidget, {
    order: -1
  });
};

function setCallback(v) {
  behavior = v;
}

function useLinklistBehavior() {
  const galleryPart = string_namespaceObject.html`<div hidden class="res-wheel-browse-gallery"></div>`;
  let media;

  function updateGalleryPart(direction) {
    const expando = expando_Expando.getEntryExpandoFrom(Thing_Thing.selected);
    media = expando && expando.media;
    galleryPart.hidden = !(media && media.element.classList.contains('res-gallery-slideshow') && !(direction === 'down' && media.element.querySelector('[last-piece=true]')) && !(direction === 'up' && media.element.querySelector('[first-piece=true]')));
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => settingsNavigation_open(wheelBrowse_module.moduleID));
    wheelBrowseWidget.addEventListener('mouseenter', () => {
      updateGalleryPart();
    });
    wheelBrowseWidget.append(galleryPart);
    return (direction, {
      target
    }) => {
      if (target === wheelBrowseWidget) {
        move(direction, {
          allowMediaBrowse: true,
          scrollStyle: 'top'
        });
      } else if (target === galleryPart) {
        const clicker = media && media.element.querySelector(direction === 'down' ? '.res-gallery-next' : '.res-gallery-previous');
        if (clicker) clicker.click();
        updateGalleryPart(direction);
      }
    };
  });
}
// CONCATENATED MODULE: ./lib/modules/commentNavigator.js













const commentNavigator_module = new Module('commentNavigator');
commentNavigator_module.moduleName = 'commentNavName';
commentNavigator_module.category = 'commentsCategory';
commentNavigator_module.description = 'commentNavDesc';
commentNavigator_module.options = {
  showByDefault: {
    type: 'boolean',
    value: false,
    description: 'commentNavigatorShowByDefaultDesc',
    title: 'commentNavigatorShowByDefaultTitle'
  },
  openOnHighlightUser: {
    type: 'boolean',
    value: true,
    description: 'commentNavigatorOpenOnHighlightUserDesc',
    title: 'commentNavigatorOpenOnHighlightUserTitle',
    advanced: true
  }
};
commentNavigator_module.include = ['comments'];

commentNavigator_module.contentStart = () => {
  installEntryElement();

  if (commentNavigator_module.options.showByDefault.value) {
    commentNav();
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => {
      commentNavigator_toggle();
    });
    return direction => {
      if (direction === 'up') commentNavigator_move('up');else commentNavigator_move('down');
    };
  });

  const getMatchingCategory = async val => val && (await getCategories()).find(({
    category
  }) => category.startsWith(val));

  registerCommand('nav', 'nav [sortType] - open the comment navigator', async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    return `navigate comments by [(${(await getCategories()).map(({
      category
    }) => matchingCategory === category ? `<b>${category}</b>` : category).join('|')})]`;
  }, async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    if (matchingCategory) setCategory(matchingCategory);
    commentNavigator_toggle(false, true);
  });
};

const commentNavigator_initialize = once_default()(() => {
  watchForThings(['comment'], () => {
    _memoized.cache.clear();
  });
  selectedEntry_addListener(updateFromSelected, 'instantly');
  if (Thing_Thing.selected) updateFromSelected(Thing_Thing.selected);
});

const commentNavigator_sortTypes = {
  custom: {
    title: 'Navigate custom category',
    conditions: {
      type: 'false'
    }
  },
  comment: {
    title: 'Navigate comments',
    conditions: {
      type: 'true'
    }
  },
  submitter: {
    title: 'Navigate comments made by the post submitter',
    conditions: {
      type: 'userAttr',
      attr: 'submitter'
    }
  },
  moderator: {
    title: 'Navigate comments made by moderators',
    conditions: {
      type: 'userAttr',
      attr: 'moderator'
    }
  },
  friend: {
    title: 'Navigate comments made by users on your friends list',
    conditions: {
      type: 'userAttr',
      attr: 'friend'
    }
  },
  me: {
    title: 'Navigate comments made by you',
    conditions: {
      type: 'userAttr',
      attr: 'me'
    }
  },
  admin: {
    title: 'Navigate comments made by reddit admins',
    conditions: {
      type: 'userAttr',
      attr: 'admin'
    }
  },
  highlighted: {
    title: 'Navigate comments made by highlighted user',

    getElements() {
      const highlightedUserSelector = Object.keys(highlightedUsers).map(key => `.author.id-t2_${key}`).join(', ');
      return highlightedUserSelector ? document.querySelectorAll(highlightedUserSelector) : [];
    }

  },
  tagged: {
    title: 'Navigate comments made by tagged users',
    getElements: () => document.querySelectorAll('.tagline .userTagLink.hasTag')
  },
  gilded: {
    title: 'Navigate through gilded comments',
    getElements: () => document.querySelectorAll('.gilded-icon')
  },
  IAmA: {
    title: 'Navigate through questions that have been answered by the submitter (most useful in /r/IAmA)',
    getThings: async () => filterMap((await getPosts('submitter')), thing => thing.parent ? [thing.parent] : undefined)
  },
  images: {
    title: 'Navigate through comments with images',
    conditions: {
      type: 'hasExpando',
      types: ['image']
    }
  },
  videos: {
    title: 'Navigate through comments with videos',
    conditions: {
      type: 'hasExpando',
      types: ['video']
    }
  },
  popular: {
    title: 'Navigate through comments in order of highest vote total',

    async getThings() {
      return flow_default()(filterMap(thing => {
        const score = thing.getScore();

        if (typeof score === 'number') {
          return [[score, thing]];
        }
      }), arr => arr.sort((a, b) => b[0] - a[0]), map_default()(([, thing]) => thing))((await getPosts('comment')));
    },

    nonlinear: true
  },
  new: {
    title: 'Navigate through new comments (Reddit Gold users only)',
    getElements: () => document.querySelectorAll('.new-comment'),
    disabled: () => !document.body.querySelector('.gold-accent.comment-visits-box')
  },
  upvoted: {
    title: 'Navigate through comments you upvoted',
    conditions: {
      type: 'voteType',
      kind: 'upvote'
    }
  }
};
function updateCustomConditions(conditions) {
  commentNavigator_sortTypes.custom.conditions = conditions;
}

function getCategories() {
  return Promise.all(Object.entries(commentNavigator_sortTypes).filter(([, {
    disabled
  }]) => !disabled || !disabled()).map(async ([category, {
    title
  }]) => ({
    category,
    selected: category === currentCategory,
    size: (await getVisiblePosts(category)).length,
    title
  }))).then(v => v.filter(({
    size,
    selected
  }) => selected || size));
}

const _memoized = memoize_default()(async category => {
  const {
    getElements,
    getThings,
    conditions
  } = commentNavigator_sortTypes[category];
  let things;

  if (getThings) {
    things = uniq_default()((await getThings()));
  } else if (getElements) {
    things = uniq_default()(Array.from(getElements()).map(e => Thing_Thing.from(e)).filter(Boolean));
  } else {
    things = Thing_Thing.things().filter(thing => thing.isComment());
  }

  return filterThings(things, conditions);
});

const getPosts = (category = currentCategory) => _memoized(category);

const getVisiblePosts = category => getPosts(category).then(v => v.filter(thing => thing.isContentVisible()));

let lastNavigatedTo = null;
let currentCategory = isCurrentSubreddit('IAmA', 'casualiama') ? 'IAmA' : 'popular';
let isOpen = false;

const commentNav = once_default()(() => {
  const box = string_namespaceObject.html`
		<div id="REScommentNavBox">
			<select id="commentNavBy">
				<option selected value="${currentCategory}">${currentCategory}</option>
			</select>
			<hr style="margin-bottom: 0">
			<div id="commentNavButtons">
				<button id="commentNavUp">&#x25B2;</button>
				<div id="commentNavPostCount"></div>
				<button id="commentNavDown">&#x25BC;</button>
			</div>
		</div>
	`;
  const select = downcast(box.querySelector('#commentNavBy'), HTMLSelectElement);
  select.addEventListener('focus', async () => {
    empty(select);
    const categories = await getCategories();
    select.append(...categories.map(({
      category,
      selected,
      size
    }) => string_namespaceObject.html`
				<option ${selected && 'selected'} value="${category}">${category}<span> (${size})</span></option>
			`));
  }, true);
  select.addEventListener('keyup', ({
    which
  }) => {
    if (which === 27) select.blur();
  });
  select.addEventListener('change', () => {
    const selectedItem = select.options.item(select.selectedIndex);

    if (selectedItem !== null) {
      setCategory(selectedItem.value);
    }
  });
  const postCount = box.querySelector('#commentNavPostCount');
  postCount.addEventListener('click', () => moveTo(lastNavigatedTo));
  const up = downcast(box.querySelector('#commentNavUp'), HTMLButtonElement);
  up.addEventListener('click', () => commentNavigator_move('up'));
  const down = downcast(box.querySelector('#commentNavDown'), HTMLButtonElement);
  down.addEventListener('click', () => commentNavigator_move('down'));
  addElement(box, {
    separate: true
  });
  commentNavigator_initialize();
  isOpen = true;
  return {
    select,
    refresh: function (index, length, lastNavigatedToIndex) {
      up.disabled = lastNavigatedToIndex <= 0;
      down.disabled = lastNavigatedToIndex >= length - 1;
      postCount.textContent = length ? `${lastNavigatedToIndex === index ? '' : '~'}${lastNavigatedToIndex + 1}/${length}` : 'none';
    },
    open: function () {
      isOpen = true;
      box.hidden = false;
    },
    close: function () {
      isOpen = false;
      box.hidden = true;
    }
  };
});

function installEntryElement() {
  const location = document.body.querySelector('.commentarea .panestack-title');
  if (!location) return;
  const commentNavToggle = string_namespaceObject.html`<div class="res-commentNavToggle">navigate by</div>`;
  const choices = string_namespaceObject.html`<div class="res-commentNavToggle-choices"><div>`;
  commentNavToggle.append(choices);
  location.append(commentNavToggle);
  commentNavToggle.addEventListener('mouseenter', async () => {
    empty(choices);
    const categories = await getCategories();
    choices.append(...categories.map(({
      category,
      title,
      size
    }) => {
      const element = string_namespaceObject.html`
				<div class="res-commentNavToggle-type noCtrlF" title="${title}" category="${category}">${category} (${size})</div>
			`;
      element.addEventListener('click', () => {
        setCategory(category);
      });
      return element;
    }));
  });
}

async function updateFromSelected(selected) {
  const posts = await getVisiblePosts();

  if (posts.includes(selected) && (!commentNavigator_sortTypes[currentCategory].nonlinear || Math.abs(posts.indexOf(lastNavigatedTo) - posts.indexOf(selected)) <= 1)) {
    lastNavigatedTo = selected;
  }

  commentNav().refresh(posts.indexOf(selected), posts.length, posts.indexOf(lastNavigatedTo));
}
function setCategory(category, keepSelected = false) {
  currentCategory = category;
  lastNavigatedTo = null;
  commentNav().select.value = category;

  _memoized.cache.delete(currentCategory);

  if (!keepSelected) commentNavigator_move('top');
}
function commentNavigator_toggle(focus = false, open = !isOpen) {
  if (!open) {
    commentNav().close();
  } else {
    commentNav().open();
    if (focus) commentNav().select.focus();
  }
}
async function commentNavigator_move(change) {
  commentNavigator_initialize();

  if (!commentNavigator_sortTypes[currentCategory].nonlinear) {
    const all = Thing_Thing.things();
    const lastNavigatedToIndex = all.indexOf(lastNavigatedTo);
    const selectedIndex = all.indexOf(Thing_Thing.selected);

    if (change === 'down' && selectedIndex < lastNavigatedToIndex || change === 'up' && selectedIndex > lastNavigatedToIndex) {
      moveTo(lastNavigatedTo);
      return;
    }
  }

  const visible = await getVisiblePosts();

  if (change === 'top') {
    moveTo(visible[0]);
  } else {
    const all = [...(await getPosts())];
    if (change === 'up') all.reverse();
    const comment = all.slice(all.indexOf(lastNavigatedTo) + 1).find(v => visible.includes(v));
    moveTo(comment);
  }
}

function moveTo(thing) {
  if (!thing) return;
  lastNavigatedTo = thing;
  selectedEntry_select(thing, {
    scrollStyle: 'top'
  }, true);
}
// CONCATENATED MODULE: ./lib/modules/easterEgg.js



const easterEgg_module = new Module('easterEgg');
easterEgg_module.moduleName = 'easterEggName';
easterEgg_module.category = 'coreCategory';
easterEgg_module.description = 'easterEggDesc';
easterEgg_module.hidden = true;
let konami;

easterEgg_module.contentStart = () => {
  konami = createKonami(() => {
    const $baconBit = $('<div>', {
      id: 'baconBit'
    }).appendTo(document.body);
    notifications_showNotification({
      header: 'RES Easter Eggies!',
      message: 'Mmm, bacon!',
      moduleID: easterEgg_module.moduleID,
      notificationID: 'konami'
    });
    setTimeout(() => $baconBit.addClass('makeitrain'), 500);
  });
};

function konamiActive() {
  return !!konami && konami.almostThere;
}

function createKonami(callback) {
  const konami = {
    input: '',
    pattern: '38384040373937396665',
    almostThere: false,
    prepattern: '383840403739373966',
    load: () => {
      document.addEventListener('keydown', event => {
        konami.input += event.keyCode;

        if (konami.input.length > konami.pattern.length) {
          konami.input = konami.input.substr(konami.input.length - konami.pattern.length);
        }

        if (konami.input === konami.pattern) {
          konami.code();
          konami.input = '';
          event.preventDefault();
        } else if (konami.input === konami.prepattern || konami.input.substr(2, konami.input.length) === konami.prepattern) {
          konami.almostThere = true;
          setTimeout(() => {
            konami.almostThere = false;
            konami.input = '';
          }, 2000);
        }
      }, false);
    },
    code: () => {}
  };

  if (typeof callback === 'function') {
    konami.code = callback;
    konami.load();
  }

  return konami;
}
// CONCATENATED MODULE: ./lib/modules/hideChildComments.js




const hideChildComments_module = new Module('hideChildComments');
hideChildComments_module.moduleName = 'hideChildCommentsName';
hideChildComments_module.category = 'commentsCategory';
hideChildComments_module.description = 'hideChildCommentsDesc';
hideChildComments_module.options = {
  automatic: {
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsAutomaticDesc',
    title: 'hideChildCommentsAutomaticTitle'
  },
  nested: {
    type: 'boolean',
    value: true,
    description: 'hideChildCommentsNestedDesc',
    title: 'hideChildCommentsNestedTitle'
  },
  hideNested: {
    dependsOn: options => options.nested.value,
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsHideNestedDesc',
    title: 'hideChildCommentsHideNestedTitle'
  }
};
hideChildComments_module.include = ['comments'];
let initialHide, toggleAllButton;

hideChildComments_module.beforeLoad = () => {
  initialHide = hideChildComments_module.options.automatic.value && !/\/comments\/(?:\w+)\/(?:\w+)\/(\w+)/.test(location.pathname);
  watchForThings(['comment'], addToggleChildrenButton);
  watchForThings(['post'], addToggleAllButton);
};

const addToggleAllButton = once_default()(thing => {
  const menu = thing.element.querySelector('ul.buttons');
  if (!menu) return;

  function toggle(action) {
    const includeChildren = hideChildComments_module.options.nested.value && hideChildComments_module.options.hideNested.value;
    const selector = includeChildren ? '.thing.comment' : '.nestedlisting > .thing.comment';
    forEachChunked(document.querySelectorAll(`${selector} > .entry .toggleChildren[action=${action}]`), toggle => {
      toggle.click();
    });

    if (action === 'hide') {
      initialHide = true;
      a.setAttribute('action', 'show');
      a.setAttribute('title', 'Show all comments.');
      a.setAttribute('data-text', i18n('hideChildCommentsShowAllLinkLabel'));
    } else {
      initialHide = false;
      a.setAttribute('action', 'hide');
      a.setAttribute('title', 'Show only replies to original poster.');
      a.setAttribute('data-text', i18n('hideChildCommentsHideAllLinkLabel'));
    }
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'noCtrlF res-toggleAllChildren');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  toggleAllButton = a;
  toggle(initialHide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
});

function addToggleChildrenButton(comment) {
  if (!hideChildComments_module.options.nested.value && !comment.isTopLevelComment()) return;
  if (!comment.getNumberOfChildren()) return;
  const children = comment.element.querySelector('div.child > .sitetable');
  const menu = comment.element.querySelector('ul.buttons');
  if (!children || !menu) return;

  function toggle(action) {
    if (action === 'hide') {
      children.style.display = 'none';
      a.setAttribute('data-text', i18n('hideChildCommentsShowLinkLabel', comment.getNumberOfChildren()));
      a.setAttribute('action', 'show');
    } else {
      children.style.display = '';
      a.setAttribute('data-text', i18n('hideChildCommentsHideLinkLabel'));
      a.setAttribute('action', 'hide');
    }

    comment.element.classList.toggle('res-children-hidden', action === 'hide');
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'toggleChildren noCtrlF');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  const hide = initialHide && (hideChildComments_module.options.hideNested.value || comment.isTopLevelComment());
  toggle(hide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
}

function toggleAll() {
  const button = toggleAllButton;
  if (!button) throw new Error('Toggle all button not found');
  button.click();
}
function hideChildComments_toggle(thing) {
  const button = thing.entry.querySelector('a.toggleChildren');
  if (!button) throw new Error('Toggle button not found');
  button.click();
}
// CONCATENATED MODULE: ./lib/modules/neverEndingReddit.js












const neverEndingReddit_module = new Module('neverEndingReddit');
neverEndingReddit_module.moduleName = 'nerName';
neverEndingReddit_module.category = 'browsingCategory';
neverEndingReddit_module.description = 'nerDesc';
neverEndingReddit_module.options = {
  returnToPrevPage: {
    type: 'boolean',
    value: true,
    description: 'nerReturnToPrevPageDesc',
    title: 'nerReturnToPrevPageTitle'
  },
  autoLoad: {
    type: 'boolean',
    value: true,
    description: 'nerAutoLoadDesc',
    title: 'nerAutoLoadTitle'
  },
  pauseAfterEvery: {
    dependsOn: options => options.autoLoad.value,
    type: 'text',
    value: '0',
    description: 'nerPauseAfterEveryDesc',
    title: 'nerPauseAfterEveryTitle'
  },
  showPauseButton: {
    dependsOn: options => options.autoLoad.value,
    type: 'boolean',
    value: true,
    description: 'nerShowPauseButtonDesc',
    title: 'nerShowPauseButtonTitle'
  },
  reversePauseIcon: {
    dependsOn: options => options.autoLoad.value && options.showPauseButton.value,
    type: 'boolean',
    value: false,
    description: 'nerReversePauseIconDesc',
    title: 'nerReversePauseIconTitle',
    advanced: true
  },
  hideDupes: {
    type: 'enum',
    value: 'hide',
    values: [{
      name: 'nerHideDupesHide',
      value: 'hide'
    }, {
      name: 'nerHideDupesFade',
      value: 'fade'
    }, {
      name: 'nerHideDupesDontHide',
      value: 'none'
    }],
    description: 'nerHideDupesDesc',
    title: 'nerHideDupesTitle',
    advanced: true
  },
  showServerInfo: {
    type: 'boolean',
    value: false,
    description: 'nerShowServerInfoDesc',
    title: 'nerShowServerInfoTitle',
    advanced: true,
    bodyClass: true
  }
};
neverEndingReddit_module.exclude = ['wiki', 'comments', 'd2x'];

neverEndingReddit_module.shouldRun = () => !isCurrentSubreddit('dashboard');

const dupeSet = new Set();
const pauseReasonStorage = storage_namespaceObject.wrap('RESmodules.neverEndingReddit.pauseReason', undefined);
let neverEndingReddit_pauseReason;

neverEndingReddit_module.beforeLoad = () => {
  if (neverEndingReddit_module.options.hideDupes.value !== 'none') {
    watchForThings(['post'], thing => {
      if (document.contains(thing.element) && !thing.element.closest('#siteTable')) return;
      handleDupes(thing);
    }, {
      immediate: true
    });
  }
};

neverEndingReddit_module.go = async () => {
  neverEndingReddit_pages[0] = {
    url: location.pathname,
    container: neverEndingReddit_container(),
    nextPageUrl: retrieveNextPageUrl(neverEndingReddit_container())
  };
  const loadReturnToPrevPage = initiateReturnToPrevPage();
  if (loadReturnToPrevPage) await loadReturnToPrevPage();

  if (neverEndingReddit_module.options.autoLoad.value) {
    setPause((await pauseReasonStorage.get()));
    selectedEntry_addListener(selected => {
      if (neverEndingReddit_pauseReason) return;
      const things = Thing_Thing.visibleThingElements();
      const distanceFromBottom = things.length - (things.indexOf(selected.element) + 1);
      if (distanceFromBottom === 1) prefetchNextPage();else if (distanceFromBottom < 1) loadNextPage();
    });
  }

  prepareNextPageLoad(false);
};

const neverEndingReddit_container = once_default()(() => getLastSiteTable() || document.createElement('div'));

const neverEndingReddit_pages = [];

const getNextPageUrl = (page = neverEndingReddit_pages.slice(-1)[0]) => page.nextPageUrl;

let loadNextPage = () => {};
let refreshAutoLoad;

function prepareNextPageLoad(displayEndBanner = true) {
  const nextPageUrl = getNextPageUrl();

  if (!nextPageUrl) {
    if (displayEndBanner) endNER('No more pages');
    return;
  }

  const pauseAfterPages = parseInt(neverEndingReddit_module.options.pauseAfterEvery.value, 10);

  if (neverEndingReddit_module.options.autoLoad.value && pauseAfterPages) {
    if (neverEndingReddit_pages.length % pauseAfterPages === 0) setPause('pauseAfterEvery');else if (neverEndingReddit_pauseReason === 'pauseAfterEvery') setPause(null);
  }

  const startPromise = new Promise(res => {
    loadNextPage = res;
  });
  const donePromise = startPromise.then(() => loadPage(nextPageUrl, neverEndingReddit_pages.length)).then(prepareNextPageLoad).catch(e => {
    endNER(`Could not load the next page: ${e.message}`);
    console.error(e);
  });
  waitForTaskCompletion().then(() => {
    createLoaderWidget(startPromise, donePromise);
    if (refreshAutoLoad) refreshAutoLoad(false);
  });
}

function waitForTaskCompletion() {
  const lastThings = Thing_Thing.things(neverEndingReddit_pages.slice(-1)[0].container);

  const taskPromises = flatten_default()(lastThings.map(thing => thing.tasks.immediate.map(fn => fn())));

  return Promise.race([Promise.all(taskPromises), new Promise((res, rej) => setTimeout(() => rej(new Error('Timed out waiting for a task')), 1500))]).catch(console.error);
}

const pauseButton = once_default()(() => {
  const element = $('<span>', {
    id: 'NREPause',
    title: 'Pause / Restart Never Ending Reddit',
    click: () => setPause(neverEndingReddit_pauseReason ? null : 'manual')
  }).get(0);
  addElement(element);
  return element;
});

function setPause(source) {
  if (neverEndingReddit_module.options.showPauseButton.value) {
    pauseButton().classList.toggle('paused', neverEndingReddit_module.options.reversePauseIcon.value === !source);
  }

  neverEndingReddit_pauseReason = source;
  if (neverEndingReddit_pauseReason) pauseReasonStorage.set(source);else pauseReasonStorage.delete();
  if (refreshAutoLoad) refreshAutoLoad();
}

const isNerUrl = () => location.hash.startsWith(RES_NER_PAGE_HASH);

function setReturnToPage(selected) {
  let number = 0;
  const $earlierMarkers = $(selected.element).parent().prevAll('.NERPageMarker');
  const marker = $earlierMarkers.get(0);
  if (marker) number = parseInt(marker.dataset.number, 10);
  const {
    ner: saved
  } = history.state || {};
  if (saved && saved.number === number) return;
  if ($earlierMarkers.length > 1) history.scrollRestoration = 'manual';
  const page = neverEndingReddit_pages[number];
  history.replaceState({ ...history.state,
    ner: {
      number,
      url: page.url,
      nextPageUrl: page.nextPageUrl
    }
  }, `${document.title}${number ? `- page ${number + 1}` : ''}`, number ? `${RES_NER_PAGE_HASH}=${number + 1}` : `${location.pathname}${location.search}${isNerUrl() ? '' : location.hash}`);
}

const initiateReturnToPrevPage = once_default()(() => {
  if (!neverEndingReddit_module.options.returnToPrevPage.value) return;
  const {
    ner: {
      number,
      url
    } = {}
  } = history.state || {};
  let append;

  if (number && url && isNerUrl()) {
    const loadPromise = loadPage(url, number, new Promise(res => {
      append = () => {
        res();
        return loadPromise;
      };
    }));
  }

  return async () => {
    if (append) await append();
    selectedEntry_addListener(setReturnToPage, 'instantly');
  };
});

function handleDupes(thing) {
  const id = thing.getFullname();

  if (dupeSet.has(id)) {
    if (neverEndingReddit_module.options.hideDupes.value === 'fade') {
      thing.element.classList.add('NERdupe');
    } else if (neverEndingReddit_module.options.hideDupes.value === 'hide') {
      thing.element.remove();
    }
  } else {
    dupeSet.add(id);
  }
}

function getLastSiteTable(body = document.body) {
  const selector = '.sitetable, .search-result-group';
  const elements = Array.from(body.querySelectorAll(selector)).reverse();

  for (const element of elements) {
    if (!element.parentElement || !element.parentElement.closest(selector)) return element;
  }
}

function getNextPrevLinks(ele = document.body) {
  const buttons = ele.matches('.modactionlisting') ? ele.nextElementSibling : ele.querySelector('.nav-buttons');
  return {
    buttons,
    next: buttons && buttons.querySelector('a[rel~=next]'),
    prev: buttons && buttons.querySelector('a[rel~=prev]')
  };
}

function retrieveNextPageUrl(body) {
  const {
    buttons,
    next
  } = getNextPrevLinks(body);
  if (!buttons) return;
  buttons.hidden = true;
  return next ? next.getAttribute('href') : null;
}

function setLoaderWidgetActionText(widget) {
  empty(widget);
  widget.append(...string_namespaceObject.html`<span>
		<h2>
			Never Ending Reddit
			${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
		</h2>
		<p>
			Click to load the next page;
			${neverEndingReddit_pauseReason ? string_namespaceObject.safe(`or click ${pauseButton().outerHTML} in the top right corner;`) : null}
		</p>
		<p>
			<a id="NERStaticLink" href="${getNextPageUrl() || ''}">or open next page</a> (and clear Never-Ending stream)
		</p>
	</span>`.children);
}

function createLoaderWidget(startPromise, donePromise) {
  const widget = document.createElement('div');
  widget.id = 'progressIndicator';
  widget.className = 'neverEndingReddit';
  widget.addEventListener('click', e => {
    if (e.target.tagName === 'A') return;
    loadNextPage();
  });
  startPromise.then(({
    scrollToLoadWidget = false
  } = {}) => {
    empty(widget);
    widget.append(string_namespaceObject.html`<span class="RESLoadingSpinner"></span>`);
    if (scrollToLoadWidget) scrollToElement(widget, null, {
      scrollStyle: 'middle',
      direction: 'down'
    });
  });
  donePromise.finally(() => widget.remove());
  neverEndingReddit_container().append(widget);
  const prefetchIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    prefetchNextPage();
  }, {
    rootMargin: '100%'
  });
  prefetchIo.observe(widget);

  const displayPauseReason = once_default()(pauseReason => notifications_showNotification({
    moduleID: neverEndingReddit_module.moduleID,
    notificationID: pauseReason,
    message: pauseReason === 'pauseAfterEvery' ? `
				<p>Time for a break!</p>
				<p>Never-Ending Reddit has been paused because you've passed ${neverEndingReddit_module.options.pauseAfterEvery.value} pages.</p>
			` : 'Never-Ending Reddit has been paused. Click the play/pause button to unpause it.'
  }));

  const pauseReasonIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (isIntersecting && neverEndingReddit_pauseReason) displayPauseReason(neverEndingReddit_pauseReason);
  }, {
    threshold: [1]
  });
  const loadNextPageIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    loadNextPage();
  }, {
    threshold: [1]
  });

  refreshAutoLoad = (updateWidget = true) => {
    const enabled = neverEndingReddit_module.options.autoLoad.value && !neverEndingReddit_pauseReason;
    if (enabled) loadNextPageIo.observe(widget);else loadNextPageIo.disconnect();
    if (updateWidget) setLoaderWidgetActionText(widget);
    pauseReasonIo.observe(widget);
  };

  setLoaderWidgetActionText(widget);
  startPromise.then(() => {
    prefetchIo.disconnect();
    loadNextPageIo.disconnect();
    pauseReasonIo.disconnect();
    refreshAutoLoad = null;
  });
}

const fetchPage = memoize_default()(url => ajax({
  url,
  cacheFor: HOUR
}));

const prefetchNextPage = () => {
  const url = getNextPageUrl();
  if (url) fetchPage(url);
};

async function loadPage(url, number, attachPromise) {
  const html = (await fetchPage(url)).replace(/<style(.|\s)*?>|<link(.|\s)*?>|<script(.|\s)*?\/script>/g, '');
  const tempDiv = $('<div>').html(html).get(0);

  if (context_data.username && context_data.username !== documentLoggedInUser(tempDiv)) {
    throw new Error('Page loaded was not for current user');
  }

  const newSiteTable = getLastSiteTable(tempDiv);
  if (!newSiteTable) throw Error('Could not find any siteTable');
  const noresults = newSiteTable.querySelector('#noresults');
  if (noresults) throw new Error(noresults.textContent);

  for (const {
    name
  } of newSiteTable.attributes) newSiteTable.removeAttribute(name);

  neverEndingReddit_pages[number] = {
    url,
    container: newSiteTable,
    nextPageUrl: retrieveNextPageUrl(newSiteTable)
  };
  registerPage(newSiteTable);
  const pageMarker = string_namespaceObject.html`<div class="NERPageMarker" data-number="${number}">
		<a href="${neverEndingReddit_pages[number].url}">Page ${number + 1}</a>
		${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
	</div>`;
  await attachPromise;
  const firstLen = $(neverEndingReddit_container()).find('.link:last .rank').text().length;
  const lastLen = $(newSiteTable).find('.link:last .rank').text().length;

  if (lastLen > firstLen) {
    addCSS(`body.res > .content .link .rank { width: ${(lastLen * 1.1).toFixed(1)}ex; }`);
  }

  neverEndingReddit_container().append(pageMarker, newSiteTable);
  window.dispatchEvent(new Event('neverEndingLoad', {
    bubbles: true,
    cancelable: true
  }));
}

function endNER(text) {
  $('<div>', {
    class: 'NERPageMarker NERPageMarkerLast',
    text
  }).append(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon')).append(`
			<p class="nextprev">
				<a href="${location.href.split('#')[0]}">start over</a>
				<a href="${getNextPageUrl() || ''}">try again</a>
				<a target="_blank" rel="noopener noreferer" href="/r/Enhancement/wiki/faq/never_ending_reddit">learn more</a>
				<a href="/r/random">random subreddit</a>
			</p>
		`).appendTo(neverEndingReddit_container());
}
// CONCATENATED MODULE: ./lib/modules/noParticipation.js






const noParticipation_module = new Module('noParticipation');
const noParticipation_urls = {
  moreinfo: 'https://www.reddit.com/r/NoParticipation/wiki/intro'
};
noParticipation_module.moduleName = 'noPartName';
noParticipation_module.description = 'noPartDesc';
noParticipation_module.category = 'subredditsCategory';
noParticipation_module.options = {
  disableVoteButtons: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableVoteButtonsDesc',
    title: 'noPartDisableVoteButtonsTitle',
    bodyClass: true
  },
  disableCommentTextarea: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableCommentTextareaDesc',
    title: 'noPartDisableCommentTextareaTitle',
    bodyClass: true
  },
  evenIfSubscriber: {
    type: 'boolean',
    value: false,
    description: 'noPartEvenIfSubscriberDesc',
    title: 'noPartEvenIfSubscriberTitle'
  },
  escapeNP: {
    type: 'boolean',
    value: true,
    description: 'noPartEscapeNPDesc',
    title: 'noPartEscapeNPTitle'
  }
};

noParticipation_module.shouldRun = () => isNpHostname(location.hostname);

const boilerplateNotificationText = `
	<p>
		<div class="RES-spoiler">
			<label class="RES-spoiler-title">Hover here for more details</label>
			<div class="RES-spoiler-contents">
				You came to this page by following a <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">NP</a> link, so you may be interfering with normal conversation.
				Please respect reddit's <a href="https://reddit.com/rules" target="_blank" rel="noopener noreferer">rules</a> by not commenting or voting. Violating these rules may get you banned.
				<a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a>
			</div>
		</div>
	</p>
`;
let noParticipationActive;

noParticipation_module.contentStart = () => {
  if (noParticipation_module.options.escapeNP.value) {
    $(document.body).on('mousedown', 'a', removeNpFromLink);
  }

  if (isNPIrrelevant()) {
    notifyNpIrrelevant();
  } else if (loggedInUser()) {
    if (isPageType('comments', 'linklist') && !(document.body.classList.contains('front-page') || document.body.classList.contains('profile-page'))) {
      applyNoParticipationMode();
    } else {
      notifyNpIrrelevant();
    }
  }
};

function isNpHostname(hostname) {
  return /^(?:\w+-)?np(?:-\w+)?\./i.test(hostname);
}

function removeNpFromLink(e) {
  const target = e.target;
  if (!target.getAttribute('href').startsWith('/') && target.matches('.md a')) return;

  if (target.hostname.endsWith('np.reddit.com')) {
    target.hostname = 'www.reddit.com';
  }
}

function isNPIrrelevant() {
  return !isPageType('comments') || isSubscriber() && !noParticipation_module.options.evenIfSubscriber.value;
}

function isVotingBlocked() {
  return noParticipationActive && noParticipation_module.options.disableVoteButtons.value;
}

function isSubscriber() {
  return document.body.classList.contains('subscriber');
}

function nonNpLocation(href = location.href) {
  const nonNpUrl = new URL(href, location.href);
  if (isNpHostname(nonNpUrl.hostname)) nonNpUrl.hostname = 'www.reddit.com';
  return nonNpUrl.href;
}

function notifyNpIrrelevant() {
  const message = isSubscriber() ? `You're browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but you're a subscriber here.` : `You're still browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but it's no longer necessary.`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'ok-participation',
    closeDelay: 3000,
    header: 'Okay to Participate',
    message: `${message} <p><a href="${nonNpLocation()}">Click here to return to normal reddit</a></p>`
  });
}

function notifyNpActive() {
  const message = isSubscriber() ? `
			<span class="res-icon">&#xF15A;</span>
			Please think before you comment or vote, and remember the subreddit's rules.
			Although you subscribe to this subreddit, you can still derail a particular thread.
			<p><a href="${nonNpLocation()}">Click here to return to normal reddit.</a></p>
		` : `
			<strong>
				<span class="res-icon">&#xF15A;</span>
				Do not vote or comment.
			</strong>
		`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'no-participation',
    closeDelay: 10000,
    header: 'No Participation',
    message: `${message}${boilerplateNotificationText}`
  });
}

const votedOnButtons = [];
async function notifyNoVote(voteButton) {
  const canUndoVote = voteButton && !voteButton.matches('.upmod, .downmod');
  if (voteButton) votedOnButtons.push(voteButton);
  const notification = await notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    cooldown: 5000,
    header: 'No Participation',
    message: `
			<strong><span class="res-icon">&#xF15A;</span> Do not vote.</strong>
			${boilerplateNotificationText}
			${canUndoVote ? '<p><button type="button" class="redButton" data-action="revertvote">Undo vote</button></p>' : ''}
		`
  });

  if (notification) {
    $(notification.element).find('[data-action=revertvote]').on('click', () => {
      revertVote(votedOnButtons);
      notification.close();
    });
  }
}

const notifyNoComment = once_default()(() => {
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableCommentTextarea',
    header: 'No Participation',
    message: `<strong><span class="res-icon">&#xF15A;</span> Do not comment.</strong>${boilerplateNotificationText}`
  });
});

function applyNoParticipationMode() {
  noParticipationActive = true;
  notifyNpActive();
  bodyClasses_namespaceObject.add('res-noParticipation');
  watchForVote();
  $(document.body).on('keydown', commentTextareaSelector, e => {
    notifyNoComment();

    if (noParticipation_module.options.disableCommentTextarea.value) {
      downcast(e.target, HTMLTextAreaElement).disabled = true;
    }
  });
}

function watchForVote() {
  $(document.body).on('click', '.arrow', e => {
    if (e.target.classList.contains('up') || e.target.classList.contains('down')) {
      notifyNoVote(e.target);
    }
  });
}

function revertVote(voteButtons) {
  voteButtons.forEach((voteButton, index) => {
    setTimeout(() => {
      if (voteButton.classList.contains('upmod') || voteButton.classList.contains('downmod')) {
        click(voteButton);
      }
    }, index * 2000);
  });
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    header: 'No Participation',
    message: `
			${voteButtons.length > 1 ? 'Your votes are being reverted.' : 'Your vote has been reverted.'}
			Please remember not to vote!
			<p><a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a></p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/saveComments.js









const saveComments_module = new Module('saveComments');
saveComments_module.moduleName = 'saveCommentsName';
saveComments_module.description = 'saveCommentsDesc';
saveComments_module.category = 'commentsCategory';
saveComments_module.exclude = ['submit'];
const savedRe = /\/user\/([\-\w]+)\/saved\/?/i;
const savedCommentStorage = storage_namespaceObject.wrapBlob('RESmodules.saveComments.savedComments', () => {
  throw new Error('Saved comment not found');
});
let savedCommentIDs;

saveComments_module.beforeLoad = async () => {
  savedCommentIDs = new Set(Object.keys((await savedCommentStorage.getAll())));
  watchForThings(['comment'], addSaveLinkToComment);
};

saveComments_module.contentStart = () => {
  if (savedRe.test(location.pathname)) {
    switchTab(location.hash);
  } else if (isPageType('profile')) {
    addTabs({
      onSavedPage: false
    });
  }
};

function saveComments_getId(thing) {
  return thing.getFullname().split('_').slice(-1)[0];
}

const unsaveElement = (e => () => e().cloneNode(true))(once_default()(() => string_namespaceObject.html`
	<li class="unsaveComments">
		<a class="RES-saved noCtrlF" href="/user/me/saved#comments" data-text="saved-RES"></a>
	</li>
`));

const saveElement = (e => () => preventCloning(e().cloneNode(true)))(once_default()(() => {
  $(document.body).on('click', 'li.saveComments', ({
    currentTarget
  }) => {
    const thing = Thing_Thing.checkedFrom(currentTarget);
    saveComment(thing);
    currentTarget.remove();
    addSaveLinkToComment(thing);
  });
  return string_namespaceObject.html`
		<li class="saveComments">
			<a class="RES-save noCtrlF" href="javascript:void 0" title="Save using RES - which is local only, but preserves the full text in case someone edits/deletes it" data-text="save-RES"></a>
		</li>
	`;
}));

function addSaveLinkToComment(thing) {
  const sibling = thing.element.querySelector('ul.buttons .comment-save-button');
  if (!sibling) return;
  sibling.after(savedCommentIDs.has(saveComments_getId(thing)) ? unsaveElement() : saveElement());
}

function getCommentContent(thing) {
  const content = $(thing.entry.querySelector('div.usertext-body > div.md')).clone();
  content.find('.keyNavAnnotation, .expando-button, .res-expando-box, script').remove();
  return content.html();
}

function saveComment(thing) {
  const id = saveComments_getId(thing);
  if (savedCommentIDs.has(id)) throw new Error('comment already saved!');
  const permaLink = thing.getCommentPermalink();
  if (!permaLink) throw new Error('Comment lacks permalink');
  savedCommentStorage.set(id, {
    href: permaLink.href,
    username: thing.getAuthor() || '[deleted]',
    comment: getCommentContent(thing),
    timeSaved: new Date().toString()
  });
  savedCommentIDs.add(id);
}

const addTabs = once_default()(({
  onSavedPage = true
} = {}) => {
  const $reddit = $('#header-bottom-left .tabmenu li').filter((i, e) => {
    const a = e.querySelector('a');
    return a && savedRe.test(a.href);
  });
  $reddit.find('a').attr('href', onSavedPage ? '#links' : '/saved/#links').text('saved - reddit');
  const $res = $('<li>').append($('<a>', {
    href: onSavedPage ? '#comments' : '/saved/#comments',
    text: 'saved - RES'
  }));
  $res.insertAfter($reddit);

  if (onSavedPage) {
    $reddit.add($res).find('a').click(e => {
      switchTab(e.target.hash);
    });
  }

  return {
    $reddit,
    $res
  };
});

async function switchTab(tabHash) {
  const $redditSaved = $('#siteTable');
  const $resSaved = $('#res-saveComments');

  switch (tabHash) {
    case '#comments':
      (await drawSavedComments()).insertBefore($redditSaved).show();
      $redditSaved.hide();
      addTabs().$reddit.removeClass('selected');
      addTabs().$res.addClass('selected');
      break;

    case '#links':
    default:
      $resSaved.hide();
      addTabs().$res.removeClass('selected');
      $redditSaved.show();
      addTabs().$reddit.addClass('selected');
      break;
  }
}

const savedCommentsTemplate = ({
  comments,
  keyNavTip,
  moduleDescription
}) => string_namespaceObject.html`
	<div id="res-saveComments" class="sitetable linklisting">
		${!comments.length && string_namespaceObject._html`
			<div class="res-module-description md">
				<h1>Saving comments with RES</h1>
				${string_namespaceObject.safe(moduleDescription)}
			</div>
		`}
		${keyNavTip && keyNavTip.map(({
  keyNavHash,
  savePostKey,
  saveCommentKey,
  saveRESKey
}) => string_namespaceObject._html`
			<div class="res-module-tip infobar">
				<p><i>Keyboard Shortcuts</i> <a class="gearIcon" href="${keyNavHash}" title="RES settings"></a></p>
				<ul>
					<li><b>${savePostKey}</b>: save a submission.</li>
					<li><b>${saveCommentKey}</b>: save a comment (to your reddit account).</li>
					<li><b>${saveRESKey}</b>: save a comment with RES.</li>
				</ul>
			</div>
		`)}
		<div class="res-saveComments-list">
			${comments.map(({
  id,
  link,
  username,
  dateTime,
  date,
  timeAgo,
  body
}) => string_namespaceObject._html`
				<div class="entry res-savedComment">
					<div class="savedCommentHeader">
						<a href="${link}">
							<b>${username}</b>
							- saved <date title="${dateTime}" datetime="${date}">${timeAgo}</date> ago
						</a>
					</div>
					<div class="savedCommentBody md">${string_namespaceObject.safe(body)}</div>
					<div class="savedCommentFooter">
						<ul class="flat-list buttons">
							<li><a href="${link}">permalink</a></li>
							<li><a class="unsaveComment" href="#" data-unsaveID="${id}">unsave-RES</a></li>
						</ul>
					</div>
				</div>
			`)}
		</div>
	</div>
`;

const drawSavedComments = once_default()(async () => {
  const savedComments = await savedCommentStorage.getAll();
  const comments = Object.entries(savedComments).map(([id, {
    comment,
    href,
    username,
    timeSaved
  }]) => {
    const date = new Date(timeSaved);
    return {
      id,
      link: href,
      username,
      date: formatDate(date),
      dateTime: formatDateTime(date),
      timeAgo: formatDateDiff(date),
      body: comment.replace(/<(script|iframe|video)(.|\s)*?\/(script|iframe|video)>/g, '')
    };
  });
  return $(savedCommentsTemplate({
    moduleDescription: i18n(saveComments_module.description),
    keyNavTip: modules_isEnabled(keyboardNav_namespaceObject) && [{
      keyNavHash: makeUrlHash(keyboardNav_module.moduleID, 'savePost'),
      savePostKey: keycode_niceKeyCode(keyboardNav_module.options.savePost.value),
      saveCommentKey: keycode_niceKeyCode(keyboardNav_module.options.saveComment.value),
      saveRESKey: keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)
    }],
    comments
  })).on('click', '.unsaveComment', e => {
    e.preventDefault();
    unsaveComment($(e.target).attr('data-unsaveID'));
    $(e.target).text('removed');
  });
});

function unsaveComment(id) {
  savedCommentStorage.delete(id);
  savedCommentIDs.delete(id);
}

function showEducationalNotification() {
  notifications_showNotification({
    moduleID: saveComments_module.moduleID,
    optionKey: 'savePost',
    notificationID: 'saveRES-educational',
    closeDelay: 10000,
    cooldown: 3 * WEEK,
    header: 'Saving Posts and Comments',
    message: `
			<p>
				The keyboard shortcuts <b>"${keycode_niceKeyCode(keyboardNav_module.options.savePost.value)}"</b> (posts) and <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveComment.value)}"</b> (comments) will save a post/comment to your reddit account (same as the "save" button).
				It will be accessible from anywhere that you're logged in, but the original text will not be preserved if it is edited or deleted.
			</p>
			<p>
				The keyboard shortcut <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)}"</b> will save a comment to RES (same as the "save-RES" button).
				It will only be available locally, but the original text will be preserved if the comment is edited or deleted.
			</p>
			<p>These shortcuts can be changed in the ${makeUrlHashLink(keyboardNav_module.moduleID, 'savePost', 'settings console')}.<p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/showParent.js






const showParent_module = new Module('showParent');
showParent_module.moduleName = 'showParentName';
showParent_module.category = 'myAccountCategory';
showParent_module.description = 'showParentDesc';
showParent_module.options = {
  hoverDelay: {
    title: 'showParentHoverDelayTitle',
    type: 'text',
    value: '500',
    description: 'showParentHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'showParentFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'showParentFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'showParentFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'showParentFadeSpeedDesc',
    advanced: true
  },
  direction: {
    title: 'showParentDirectionTitle',
    type: 'enum',
    value: 'down',
    values: [{
      name: 'Above',
      value: 'up'
    }, {
      name: 'Below',
      value: 'down'
    }],
    description: 'showParentDirectionDesc',
    bodyClass: true
  }
};
showParent_module.include = ['comments'];

showParent_module.contentStart = () => {
  $(document.body).on('mouseenter', '.comment .buttons :not(:first-child) .bylink', function () {
    startHover(this, {
      openDelay: parseFloat(showParent_module.options.hoverDelay.value),
      fadeDelay: parseFloat(showParent_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(showParent_module.options.fadeSpeed.value)
    });
  });
};

const closeOnSelect = once_default()(() => {
  selectedEntry_addListener(() => infocard(showParent_module.moduleID).close(false), 'instantly');
});

function startHover(button, options = {}) {
  closeOnSelect();
  infocard(showParent_module.moduleID).target(button).options(options).populateWith(() => showCommentHover(Thing_Thing.checkedFrom(button))).begin();
}

function showParent_handleVoteClick() {
  const $this = $(this);
  const voteClasses = {
    up: 'likes',
    none: 'unvoted',
    down: 'dislikes'
  };
  const id = $this.parent().parent().attr('data-fullname');
  let direction = /(up|down)(?:mod)?/.exec(this.className);
  if (!direction) return;
  direction = direction[1];
  const $targetButton = $(`.content .thing.id-${id}`).children('.midcol').find(`.arrow.${direction}, .arrow.${direction}mod`);

  if ($targetButton.length !== 1) {
    console.error('When attempting to find %s arrow for comment %s %d elements were returned', direction, id, $targetButton.length);
    return;
  }

  function removeClickHandlers(event) {
    event.stopPropagation();
  }

  $targetButton.on('click', removeClickHandlers);
  $targetButton.click();
  $targetButton.off('click', removeClickHandlers);
  const $midcol = $this.parent();
  let startDir = 'none';

  for (const [key, value] of Object.entries(voteClasses)) {
    if ($midcol.hasClass(value)) {
      startDir = key;
      break;
    }
  }

  const newDir = direction === startDir ? 'none' : direction;
  $midcol.parent().children(`.${voteClasses[startDir]}`).removeClass(voteClasses[startDir]).addClass(voteClasses[newDir]);
  $midcol.find('.up, .upmod').toggleClass('upmod', newDir === 'up').toggleClass('up', newDir !== 'up');
  $midcol.find('.down, .downmod').toggleClass('downmod', newDir === 'down').toggleClass('down', newDir !== 'down');
}

function showCommentHover(thing) {
  const direction = showParent_module.options.direction.value;
  let $parents = $(thing.element).parents('.thing').clone();
  let topParentURL = '';

  if ($parents.length === 0) {
    topParentURL = $(thing.element).find('[data-event-action="parent"]').first().attr('data-href-url');
  } else {
    const topParentId = $parents.last().attr('data-fullname');
    topParentURL = $(`[data-fullname="${topParentId}"] > .entry [data-event-action="parent"]`).first().attr('data-href-url');
  }

  if (direction === 'up') {
    $parents = $($parents.get().reverse());
  }

  $parents.addClass('comment parentComment').removeClass('thing even odd');
  $parents.children('.child').remove();
  $parents.each(function () {
    const $this = $(this);
    $this.off('click');
    let id = $this.attr('data-fullname');

    if (id) {
      id = id.slice(3);
      $this.find('> .entry .tagline').append(`<a class="bylink parentlink" href="#${id}">goto comment</a>`);
    }
  });
  $parents.find('.parent').remove();
  $parents.find('.usertext-body').show();
  $parents.find('.flat-list.buttons').remove();
  $parents.find('.usertext-edit').remove();
  $parents.find('.RESUserTag').remove();
  $parents.find('.voteWeight').remove();
  $parents.find('.collapsed').remove();
  $parents.find('.expand').remove();
  $parents.find('form').attr('id', '');
  $parents.find('.arrow').on('click', showParent_handleVoteClick);
  $parents.find('.res-expando-box, .expando-button').remove();
  $parents.find('.keyNavAnnotation').remove();
  const $container = $('<div class="parentCommentWrapper">');
  $container.append($parents);

  if (topParentURL) {
    $container.append(`<a class="bylink" href="${topParentURL}">View parent comment</a>`);
  }

  $parents.slice(0, -1).after('<div class="parentArrow">reply to</div>');
  return ['Parents', $container];
}
// CONCATENATED MODULE: ./lib/modules/singleClick.js




const singleClick_module = new Module('singleClick');
singleClick_module.moduleName = 'singleClickName';
singleClick_module.category = 'browsingCategory';
singleClick_module.description = 'singleClickDesc';
singleClick_module.options = {
  openOrder: {
    title: 'singleClickOpenOrderTitle',
    type: 'enum',
    values: [{
      name: 'open comments then link',
      value: 'commentsfirst'
    }, {
      name: 'open link then comments',
      value: 'linkfirst'
    }],
    value: 'commentsfirst',
    description: 'singleClickOpenOrderDesc'
  },
  hideLEC: {
    title: 'singleClickHideLECTitle',
    type: 'boolean',
    value: true,
    description: 'singleClickHideLECDesc',
    advanced: true,
    bodyClass: true
  },
  openFrontpage: {
    title: 'singleClickOpenFrontpageTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenFrontpageDesc',
    dependsOn: options => !options.hideLEC.value
  },
  openBackground: {
    title: 'singleClickOpenBackgroundTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenBackgroundDesc'
  }
};
singleClick_module.exclude = ['comments', /^\/subreddits(?:\/|$)/i];

singleClick_module.beforeLoad = () => {
  watchForThings(['post'], applyLinks);
};

singleClick_module.contentStart = () => {
  $(document.body).on('mousedown', '.redditSingleClick', e => {
    if (e.button !== 2) {
      e.preventDefault();
      const thing = Thing_Thing.checkedFrom(e.target);
      const focused = !e.button && !e.ctrlKey && !singleClick_module.options.openBackground.value;
      openTabs(thing, focused);
    }
  });
};

function openTabs(thing, focused) {
  const link = thing.getPostUrl();
  const urls = [link];

  if (thing.isLinkPost()) {
    const comments = thing.getCommentsLink().href;

    if (comments !== link) {
      urls.push(comments);
    }
  } else if (singleClick_module.options.openFrontpage.value) {
    const frontpageLink = thing.getSubredditLink();

    if (frontpageLink && frontpageLink.href !== link) {
      urls.push(frontpageLink.href);
    }
  }

  if (singleClick_module.options.openOrder.value === 'commentsfirst') urls.reverse();
  openNewTabs(focused, ...urls);
}

function applyLinks(thing) {
  for (const ele of thing.element.querySelectorAll('ul.flat-list')) {
    ele.appendChild(string_namespaceObject.html`<li><span class="redditSingleClick"></span></li>`);
  }
}
// CONCATENATED MODULE: ./lib/modules/keyboardNav.js
























const keyboardNav_module = new Module('keyboardNav');
keyboardNav_module.moduleName = 'keyboardNavName';
keyboardNav_module.category = 'browsingCategory';
keyboardNav_module.description = 'keyboardNavDesc';
keyboardNav_module.options = {
  linearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'directional',
    description: 'keyboardNavLinearScrollStyleDesc',
    title: 'keyboardNavLinearScrollStyleTitle',
    advanced: true
  },
  nonLinearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'legacy',
    description: 'keyboardNavNonLinearScrollStyleDesc',
    title: 'keyboardNavNonLinearScrollStyleTitle',
    advanced: true
  },
  linkNumbers: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNumbersDesc',
    title: 'keyboardNavLinkNumbersTitle'
  },
  linkNumberPosition: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'Place on right',
      value: 'right'
    }, {
      name: 'Place on left',
      value: 'left'
    }],
    value: 'right',
    description: 'keyboardNavLinkNumberPositionDesc',
    title: 'keyboardNavLinkNumberPositionTitle',
    advanced: true
  },
  linkToggleExpando: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkToggleExpandoDesc',
    title: 'keyboardNavLinkToggleExpandoTitle'
  },
  linkNumberAltModeModifier: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'Shift',
      value: 'shift'
    }, {
      name: 'Alt',
      value: 'alt'
    }],
    value: 'alt',
    description: 'keyboardNavLinkNumberAltModeModifierDesc',
    title: 'keyboardNavLinkNumberAltModeModifierTitle',
    advanced: true
  },
  linkNewTab: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNewTabDesc',
    title: 'keyboardNavLinkNewTabTitle',
    advanced: true
  },
  onHideMoveDown: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavOnHideMoveDownDesc',
    title: 'keyboardNavOnHideMoveDownTitle',
    advanced: true
  },
  onVoteMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteMoveDownDesc',
    title: 'keyboardNavOnVoteMoveDownTitle',
    advanced: true
  },
  onVoteCommentMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteCommentMoveDownDesc',
    title: 'keyboardNavOnVoteCommentMoveDownTitle',
    advanced: true
  },
  followLinkNewTabFocus: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavFollowLinkNewTabFocusDesc',
    title: 'keyboardNavFollowLinkNewTabFocusTitle'
  },
  toggleHelp: {
    type: 'keycode',
    value: [191, false, false, true, false],
    description: 'keyboardNavToggleHelpDesc',
    title: 'keyboardNavToggleHelpTitle',

    callback() {
      toggleKeyNavHelp();
    }

  },
  toggleCmdLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject],
    value: [190, false, false, false, false],
    description: 'keyboardNavToggleCmdLineDesc',
    title: 'keyboardNavToggleCmdLineTitle',

    callback() {
      commandLine_toggle();
    }

  },
  enterFilterCommandLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject, filteReddit_namespaceObject],
    value: [70, false, false, false, false],
    description: 'keyboardNavEnterFilterCommandLineDesc',
    title: 'keyboardNavEnterFilterCommandLineTitle',

    callback() {
      commandLine_open('fl ');
    }

  },
  hide: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile'],
    value: [72, false, false, false, false],
    description: 'keyboardNavHideDesc',
    title: 'keyboardNavHideTitle',
    callback: hideLink
  },
  moveUp: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpDesc',
    title: 'keyboardNavMoveUpTitle',

    callback() {
      move('up', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDown: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownDesc',
    title: 'keyboardNavMoveDownTitle',

    callback() {
      move('down', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      }, moveDownFallback);
    }

  },
  moveUpComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpCommentDesc',
    title: 'keyboardNavMoveUpCommentTitle',

    callback() {
      move('up', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDownComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownCommentDesc',
    title: 'keyboardNavMoveDownCommentTitle',

    callback() {
      move('down', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveTop: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveTopDesc',
    title: 'keyboardNavMoveTopTitle',

    callback() {
      move('top', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveBottom: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveBottomDesc',
    title: 'keyboardNavMoveBottomTitle',

    callback() {
      move('bottom', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveUpSiblingDesc',
    title: 'keyboardNavMoveUpSiblingTitle',

    callback() {
      move('upSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveDownSiblingDesc',
    title: 'keyboardNavMoveDownSiblingTitle',

    callback() {
      move('downSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownParentSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, false, false],
    description: 'keyboardNavMoveDownParentSiblingDesc',
    title: 'keyboardNavMoveDownParentSiblingTitle',

    callback() {
      move('downParentSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpThread: {
    type: 'keycode',
    include: ['comments'],
    value: [75, true, false, true, false],
    description: 'keyboardNavMoveUpThreadDesc',
    title: 'keyboardNavMoveUpThreadTitle',

    callback() {
      move('upThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownThread: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, true, false],
    description: 'keyboardNavMoveDownThreadDesc',
    title: 'keyboardNavMoveDownThreadTitle',

    callback() {
      move('downThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToTopComment: {
    type: 'keycode',
    include: ['comments'],
    value: [84, false, false, false, false],
    description: 'keyboardNavMoveToTopCommentDesc',
    title: 'keyboardNavMoveToTopCommentTitle',

    callback() {
      move('toTopComment', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToParent: {
    type: 'keycode',
    include: ['comments'],
    value: [80, false, false, false, false],
    description: 'keyboardNavMoveToParentDesc',
    title: 'keyboardNavMoveToParentTitle',

    callback() {
      move('toParent', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  undoMove: {
    type: 'keycode',
    value: [90, false, true, false, false],
    description: 'keyboardNavUndoMoveDesc',
    title: 'keyboardNavUndoMoveTitle',

    callback() {
      move('previous', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  showParents: {
    type: 'keycode',
    requiresModules: [showParent_namespaceObject],
    value: [80, false, false, true, false],
    description: 'keyboardNavShowParentsDesc',
    title: 'keyboardNavShowParentsTitle',

    callback(selected = getSelected()) {
      startHover(assertElement(selected.element.querySelector('.buttons .bylink[href^="#"]')));
    }

  },
  followLink: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, false, false],
    description: 'keyboardNavFollowLinkDesc',
    title: 'keyboardNavFollowLinkTitle',

    callback() {
      followLink();
    }

  },
  followLinkNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, true, false],
    description: 'keyboardNavFollowLinkNewTabDesc',
    title: 'keyboardNavFollowLinkNewTabTitle',

    callback() {
      followLink(true);
    }

  },
  toggleExpando: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, false, false],
    description: 'keyboardNavToggleExpandoDesc',
    title: 'keyboardNavToggleExpandoTitle',

    callback(selected = getSelected()) {
      toggleThingExpandos(selected, {
        scrollOnToggle: keyboardNav_module.options.scrollOnExpando.value
      });
    }

  },
  scrollOnExpando: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnExpandoDesc',
    title: 'keyboardNavScrollOnExpandoTitle',
    advanced: true
  },
  imageSizeUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, false, false],
    description: 'keyboardNavImageSizeUpDesc',
    title: 'keyboardNavImageSizeUpTitle',

    callback() {
      imageResize({
        factor: 1.3
      });
    }

  },
  imageSizeDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, false, false],
    description: 'keyboardNavImageSizeDownDesc',
    title: 'keyboardNavImageSizeDownTitle',

    callback() {
      imageResize({
        factor: 1 / 1.3
      });
    }

  },
  imageSizeUpFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, true, false],
    description: 'keyboardNavImageSizeUpFineDesc',
    title: 'keyboardNavImageSizeUpFineTitle',

    callback() {
      imageResize({
        factor: 1.1
      });
    }

  },
  imageSizeDownFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, true, false],
    description: 'keyboardNavImageSizeDownFineDesc',
    title: 'keyboardNavImageSizeDownFineTitle',

    callback() {
      imageResize({
        factor: 1 / 1.1
      });
    }

  },
  imageSizeAnyHeight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, false, true, false],
    description: 'keyboardNavImageSizeAnyHeightDesc',
    title: 'keyboardNavImageSizeAnyHeightTitle',

    callback() {
      imageResize({
        removeHeightRestriction: true
      });
    }

  },
  imageMoveUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [38, false, true, false, false],
    description: 'keyboardNavImageMoveUpDesc',
    title: 'keyboardNavImageMoveUpTitle',

    callback() {
      imageMove(0, -50);
    }

  },
  imageMoveDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [40, false, true, false, false],
    description: 'keyboardNavImageMoveDownDesc',
    title: 'keyboardNavImageMoveDownTitle',

    callback() {
      imageMove(0, 50);
    }

  },
  imageMoveLeft: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [37, false, true, false, false],
    description: 'keyboardNavImageMoveLeftDesc',
    title: 'keyboardNavImageMoveLeftTitle',

    callback() {
      imageMove(-50, 0);
    }

  },
  imageMoveRight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, true, false, false],
    description: 'keyboardNavImageMoveRightDesc',
    title: 'keyboardNavImageMoveRightTitle',

    callback() {
      imageMove(50, 0);
    }

  },
  previousGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [219, false, false, false, false],
    description: 'keyboardNavPreviousGalleryImageDesc',
    title: 'keyboardNavPreviousGalleryImageTitle',

    callback() {
      navigateGallery('previous');
    }

  },
  nextGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [221, false, false, false, false],
    description: 'keyboardNavNextGalleryImageDesc',
    title: 'keyboardNavNextGalleryImageTitle',

    callback() {
      navigateGallery('next');
    }

  },
  scrollOnGalleryNavigate: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnGalleryNavigateDesc',
    title: 'keyboardNavScrollOnGalleryNavigateTitle',
    advanced: true
  },
  toggleViewImages: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, true, false],
    description: 'keyboardNavToggleViewImagesDesc',
    title: 'keyboardNavToggleViewImagesTitle',
    callback: toggleViewImages
  },
  toggleChildren: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [13, false, false, false, false],
    description: 'keyboardNavToggleChildrenDesc',
    title: 'keyboardNavToggleChildrenTitle',
    callback: toggleChildren
  },
  followComments: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, false, false],
    description: 'keyboardNavFollowCommentsDesc',
    title: 'keyboardNavFollowCommentsTitle',

    callback() {
      followComments();
    }

  },
  followCommentsNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, true, false],
    description: 'keyboardNavFollowCommentsNewTabDesc',
    title: 'keyboardNavFollowCommentsNewTabTitle',

    callback() {
      followComments(true);
    }

  },
  followLinkAndCommentsNewTab: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, false, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabTitle',

    callback() {
      followLinkAndComments();
    }

  },
  followLinkAndCommentsNewTabBG: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, true, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabBGDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabBGTitle',

    callback() {
      followLinkAndComments(true);
    }

  },
  upVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, false, false],
    description: 'keyboardNavUpVoteDesc',
    title: 'keyboardNavUpVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod');
    }

  },
  downVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, false, false],
    description: 'keyboardNavDownVoteDesc',
    title: 'keyboardNavDownVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod');
    }

  },
  upVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, true, false],
    description: 'keyboardNavUpVoteWithoutTogglingDesc',
    title: 'keyboardNavUpVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod', true);
    }

  },
  downVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, true, false],
    description: 'keyboardNavDownVoteWithoutTogglingDesc',
    title: 'keyboardNavDownVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod', true);
    }

  },
  savePost: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments'],
    value: [83, false, false, false, false],
    description: 'keyboardNavSavePostDesc',
    title: 'keyboardNavSavePostTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.link-save-button a, .link-unsave-button a', ASSERT));
    }

  },
  saveComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist'],
    value: [83, false, false, true, false],
    description: 'keyboardNavSaveCommentDesc',
    title: 'keyboardNavSaveCommentTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.comment-save-button > a', ASSERT));
    }

  },
  saveRES: {
    type: 'keycode',
    requiresModules: [saveComments_namespaceObject],
    value: [83, false, false, false, false],
    description: 'keyboardNavSaveRESDesc',
    title: 'keyboardNavSaveRESTitle',

    callback() {
      click(getFirstElementInThingByQuery('.saveComments, .unsaveComments', ASSERT));
      showEducationalNotification();
    }

  },
  reply: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [82, false, false, false, false],
    description: 'keyboardNavReplyDesc',
    title: 'keyboardNavReplyTitle',
    mustBeLoggedIn: true,
    callback: reply
  },
  edit: {
    type: 'keycode',
    include: ['comments', 'profile'],
    value: [69, false, false, false, false],
    description: 'keyboardNavEditDesc',
    title: 'keyboardNavEditTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.entry .edit-usertext', ASSERT, getSelected()));
    }

  },
  showChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, false, false],
    description: 'keyboardNavShowChildCommentsDesc',
    title: 'keyboardNavShowChildCommentsTitle',

    callback(selected = getSelected()) {
      hideChildComments_toggle(selected);
    }

  },
  showAllChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, true, false],
    description: 'keyboardNavShowAllChildCommentsDesc',
    title: 'keyboardNavShowAllChildCommentsTitle',

    callback() {
      toggleAll();
    }

  },
  followPermalink: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, false, false],
    description: 'keyboardNavFollowPermalinkDesc',
    title: 'keyboardNavFollowPermalinkTitle',

    callback() {
      followPermalink();
    }

  },
  followPermalinkNewTab: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, true, false],
    description: 'keyboardNavFollowPermalinkNewTabDesc',
    title: 'keyboardNavFollowPermalinkNewTabTitle',

    callback() {
      followPermalink(true);
    }

  },
  followSubreddit: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, false, false],
    description: 'keyboardNavFollowSubredditDesc',
    title: 'keyboardNavFollowSubredditTitle',

    callback() {
      followSubreddit();
    }

  },
  followSubredditNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, true, false],
    description: 'keyboardNavFollowSubredditNewTabDesc',
    title: 'keyboardNavFollowSubredditNewTabTitle',

    callback() {
      followSubreddit(true);
    }

  },
  followProfile: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, false, false],
    description: 'keyboardNavFollowProfileDesc',
    title: 'keyboardNavFollowProfileTitle',

    callback() {
      followProfile();
    }

  },
  followProfileNewTab: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, true, false],
    description: 'keyboardNavFollowProfileNewTabDesc',
    title: 'keyboardNavFollowProfileNewTabTitle',

    callback() {
      followProfile(true);
    }

  },
  toggleCommentNavigator: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [78, false, false, false, false],
    description: 'keyboardNavToggleCommentNavigatorDesc',
    title: 'keyboardNavToggleCommentNavigatorTitle',

    callback() {
      commentNavigator_toggle(true);
    }

  },
  commentNavigatorMoveUp: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [38, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveUpDesc',
    title: 'keyboardNavCommentNavigatorMoveUpTitle',

    callback() {
      commentNavigator_move('up');
    }

  },
  commentNavigatorMoveDown: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [40, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveDownDesc',
    title: 'keyboardNavCommentNavigatorMoveDownTitle',

    callback() {
      commentNavigator_move('down');
    }

  },
  focusOnSearchBox: {
    type: 'keycode',
    value: [191, true, false, false, false],
    description: 'keyboardNavFocusOnSearchBoxDesc',
    title: 'keyboardNavFocusOnSearchBoxTitle',

    callback() {
      document.querySelector('#search input[name="q"]').focus();
    }

  },
  useGoMode: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavUseGoModeDesc',
    title: 'keyboardNavUseGoModeTitle'
  },
  goMode: {
    type: 'keycode',
    value: [71, false, false, false, false],
    description: 'keyboardNavGoModeDesc',
    title: 'keyboardNavGoModeTitle',
    dependsOn: options => options.useGoMode.value,

    callback() {
      if (keyboardNav_module.options.useGoMode.value) toggleGoMode();
    }

  },
  inbox: {
    type: 'keycode',
    value: [73, false, false, false, false],
    description: 'keyboardNavInboxDesc',
    title: 'keyboardNavInboxTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  inboxNewTab: {
    type: 'keycode',
    value: [73, false, false, true, false],
    description: 'keyboardNavInboxNewTabDesc',
    title: 'keyboardNavInboxNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  modmail: {
    type: 'keycode',
    value: [77, false, false, false, false],
    description: 'keyboardNavModmailDesc',
    title: 'keyboardNavModmailTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  modmailNewTab: {
    type: 'keycode',
    value: [77, false, false, true, false],
    description: 'keyboardNavModmailNewTabDesc',
    title: 'keyboardNavModmailNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  profile: {
    type: 'keycode',
    value: [85, false, false, false, false],
    description: 'keyboardNavProfileDesc',
    title: 'keyboardNavProfileTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileNewTab: {
    type: 'keycode',
    value: [85, false, false, true, false],
    description: 'keyboardNavProfileNewTabDesc',
    title: 'keyboardNavProfileNewTabTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  frontPage: {
    type: 'keycode',
    value: [70, false, false, false, false],
    description: 'keyboardNavFrontPageDesc',
    title: 'keyboardNavFrontPageTitle',

    callback() {
      keyboardNav_navigateTo('/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  slashAll: {
    type: 'keycode',
    value: [65, true, false, false, false],
    description: 'keyboardNavSlashAllDesc',
    title: 'keyboardNavSlashAllTitle',

    callback() {
      keyboardNav_navigateTo('/r/all', {
        leaveNP: true
      });
    },

    goMode: true
  },
  subredditFrontPage: {
    type: 'keycode',
    value: [70, false, false, true, false],
    description: 'keyboardNavsSubredditFrontPageDesc',
    title: 'keyboardNavsSubredditFrontPageTitle',

    callback() {
      const sub = currentSubreddit();
      if (sub) keyboardNav_navigateTo(`/r/${sub}`, {
        leaveNP: false
      });
    },

    goMode: true
  },
  random: {
    type: 'keycode',
    value: [89, true, false, false, false],
    description: 'keyboardNavRandomDesc',
    title: 'keyboardNavRandomTitle',

    callback() {
      keyboardNav_navigateTo('/r/random', {
        leaveNP: true
      });
    },

    goMode: true
  },
  nextPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [78, false, false, false, false],
    description: 'keyboardNavNextPageDesc',
    title: 'keyboardNavNextPageTitle',
    callback: nextPage,
    goMode: true
  },
  prevPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [80, false, false, false, false],
    description: 'keyboardNavPrevPageDesc',
    title: 'keyboardNavPrevPageTitle',
    callback: prevPage,
    goMode: true
  },
  overviewLegacy: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [79, false, false, true, false],
    description: 'keyboardNavOverviewLegacyDesc',
    title: 'keyboardNavOverviewLegacyTitle',

    callback() {
      const currentUser = currentUserProfile();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}/overview`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileView: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [80, false, false, true, false],
    description: 'keyboardNavProfileViewDesc',
    title: 'keyboardNavProfileViewTitle',

    callback() {
      const currentUser = currentUserProfile();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}`, {
        leaveNP: true
      });
    },

    goMode: true
  }
};

keyboardNav_module.beforeLoad = () => {
  keyboardNav_registerCommandLine();

  if (keyboardNav_module.options.linkNumbers.value) {
    selectedEntry_addListener(updateLinkAnnotations, 'instantly');
    watchForElements(['selfText'], null, element => {
      const thing = Thing_Thing.from(element);
      if (Thing_Thing.selected === thing) updateLinkAnnotations(thing);
    });
  }
};

keyboardNav_module.contentStart = () => {
  window.addEventListener('keydown', handleKeyPress, true);
};

function keyboardNav_registerCommandLine() {
  registerCommand(/\d+/, '[number] - navigates to the link with that number (if annotation exists) or rank (link pages)', () => {}, command => {
    const number = parseInt(command, 10);
    const annotation = linkAnnotations[number - 1];

    if (annotation) {
      if (!document.contains(annotation.link)) {
        console.log('Annotation refers to removed link; ignoring');
        return;
      }

      openLink(number - 1);
    } else {
      followLinkByRank(number);
    }
  });
}

let linkAnnotations = [];

function updateLinkAnnotations(selected) {
  for (const {
    annotation
  } of linkAnnotations) annotation.remove();

  linkAnnotations = Array.from(selected && selected.entry.querySelectorAll('div.md a:not(.noKeyNav)') || []).filter(link => !isCommentCode(link) && !isEmptyLink(link)).map((link, i) => {
    const number = i + 1;
    const title = number < 10 ? `press ${number} to open link` : number === 10 ? 'press 0 to open link' : `press ${keycode_niceKeyCode(keyboardNav_module.options.toggleCmdLine.value)} then ${number} and Enter to open link`;
    const annotation = string_namespaceObject.html`<span class="noCtrlF keyNavAnnotation" data-text="[${number}]" title="${title}"></span>`;
    if (keyboardNav_module.options.linkNumberPosition.value === 'right') link.after(annotation);else link.before(annotation);
    return {
      annotation,
      link
    };
  });
}

function toggleKeyNavHelp() {
  const slideSpeed = 400;

  if (!drawHelp().attr('shown')) {
    drawHelp().attr('shown', 'false');
    drawHelp().css({
      right: '-350px'
    });
    drawHelp().show();
  }

  if (drawHelp().attr('shown') === 'true') {
    drawHelp().animate({
      right: '-350px'
    }, slideSpeed);
    drawHelp().attr('shown', 'false');
  } else {
    drawHelp().animate({
      right: '20px'
    }, slideSpeed);
    drawHelp().attr('shown', 'true');
  }
}

const drawHelp = once_default()(() => {
  const keys = filterMap(getActiveCommandOptions(), opt => {
    let keyCode = keycode_niceKeyCode(opt.value);

    if (opt.goMode && keyboardNav_module.options.useGoMode.value) {
      keyCode = `${keycode_niceKeyCode(keyboardNav_module.options.goMode.value)} → ${keyCode}`;
    }

    return [{
      keyCode,
      description: i18n(opt.description)
    }];
  });
  return $(string_namespaceObject.html`
		<div id="keyHelp">
			<table>
				<thead>
					<tr><th>Key</th><th>Function</th></tr>
				</thead>
				<tbody>
					${keys.map(({
    keyCode,
    description
  }) => string_namespaceObject._html`
						<tr><td>${keyCode}</td><td>${description}</td></tr>
					`)}
				</tbody>
			</table>
		</div>
	`).appendTo(document.body);
});

function getLinkKeys() {
  const altModeModifier = keyboardNav_module.options.linkNumberAltModeModifier.value;
  const keys = [];

  function addKey(key, index) {
    keys.push({
      value: [key, false, false, false, false],

      callback() {
        openLink(index);
      }

    });

    if (altModeModifier !== 'none') {
      keys.push({
        value: [key, altModeModifier === 'alt', false, altModeModifier === 'shift', false],

        callback() {
          openLink(index, true);
        }

      });
    }
  }

  if (keyboardNav_module.options.linkNumbers.value) {
    [49, 50, 51, 52, 53, 54, 55, 56, 57, 48].forEach(addKey);
    [97, 98, 99, 100, 101, 102, 103, 104, 105, 96].forEach(addKey);
  }

  return keys;
}

const getActiveCommandOptions = once_default()(() => filterMap(Object.values(keyboardNav_module.options), option => {
  if (option.type === 'keycode' && option.callback && (!option.dependsOn || option.dependsOn(keyboardNav_module.options)) && (!option.include || matchesPageLocation(option.include)) && (!option.mustBeLoggedIn || loggedInUser()) && (!option.requiresModules || option.requiresModules.every(isRunning))) {
    return [option];
  }
}));

const _commandLookup = once_default()(() => {
  const lookup = {};

  for (const option of [...getActiveCommandOptions(), ...getLinkKeys()]) {
    const hash = hashKeyArray(option.value);

    if (!lookup[hash]) {
      lookup[hash] = [];
    }

    lookup[hash].push(option);
  }

  return lookup;
});

function handleKeyPress(e) {
  if (konamiActive()) return;

  if (document.activeElement && ['A', 'BUTTON'].includes(document.activeElement.tagName)) {
    const hasDefaultBehavior = [NAMED_KEYS.Tab, NAMED_KEYS.Enter, NAMED_KEYS.Space].includes(e.key);
    if (hasDefaultBehavior) return;
  } else if (document.activeElement && document.activeElement.tagName !== 'BODY') {
    return;
  }

  const hash = hashKeyEvent(e);
  const options = (_commandLookup()[hash] || []).filter(v => {
    if (v.goMode) return keyboardNav_module.options.useGoMode.value === goModeActive;else return !goModeActive;
  });

  if (options.length) {
    handleCallbacks(options);
    e.preventDefault();
    e.target.blur();
  }
}

async function handleCallbacks(options) {
  if (options.some(v => v.goMode)) {
    if (goModeActive) toggleGoMode();

    if (options.length > 1) {
      const shortcut = keycode_niceKeyCode(options[0].value);
      options = await promptUniqueShortcut(shortcut, options);
    }
  }

  for (const option of options) {
    try {
      option.callback();
    } catch (e) {
      console.error('Could not execute callback', i18n(option.title), e);
    }
  }
}

const promptUniqueShortcut = memoize_default()(async (shortcut, options) => {
  const question = i18n('keyboardNavAmbiguousShortcutPrompt', i18n(keyboardNav_module.moduleName), `<i>${shortcut}</i>`, '<br><br>', `<i>${shortcut}</i>`);
  const optionButtons = options.map(option => [option, $(`<button style="width: 100%; margin-top: 2px;">${i18n(option.description)}</button>`).get(0)]);
  const followUp = i18n('keyboardNavAmbiguousShortcutPromptFollowUp', makeUrlHashLink(keyboardNav_module.moduleID, undefined, i18n(keyboardNav_module.moduleName)));
  const message = $(`<div>${question}</div>`).append(optionButtons.map(([, button]) => button)).append(`<br><br><small>(${followUp})</small>`).get(0);
  const notification = await notifications_showNotification({
    moduleID: keyboardNav_module.moduleID,
    header: 'Ambiguous shortcut',
    message,
    noDisable: true,
    closeDelay: Infinity
  });
  const preservedOption = await Promise.race(optionButtons.map(([option, button]) => waitForEvent(button, 'click').then(() => option)));
  Object.entries(keyboardNav_module.options).filter(([, value]) => value !== preservedOption && options.includes(value)).forEach(([name]) => {
    options_set(keyboardNav_module, name, [-1, false, false, false, false]);
  });
  notification.close();
  return [preservedOption];
});

function getSelected() {
  const selected = Thing_Thing.selected;
  if (!selected) throw new Error('A entry must be selected');
  if (!selected.isVisible()) throw new Error('Entry must be visible');
  return selected;
}

const ASSERT = true;
const NOASSERT = false;

function assertElement(element) {
  if (!element) throw new Error('Element not available');
  return element;
}

function getFirstElementInThingByQuery(query, assertExistance, thing = getSelected()) {
  const element = thing.entry.querySelector(query);
  return assertExistance ? assertElement(element) : element;
}

function getElementsInThingByQuery(query, assertLength, thing = getSelected()) {
  const elements = Array.from(thing.entry.querySelectorAll(query));
  if (assertLength) assertElement(elements[0]);
  return elements;
}

function getMostVisibleElementInThingByQuery(query, assertLength, thing) {
  return maxBy_default()(getElementsInThingByQuery(query, assertLength, thing), getPercentageVisibleYAxis);
}

function hideLink(selected = getSelected()) {
  const hide = assertElement(selected.getHideElement());

  if (keyboardNav_module.options.onHideMoveDown.value) {
    move('down', {
      allowMediaBrowse: true,
      scrollStyle: 'none'
    }, moveDownFallback);
  }

  click(hide);
}

function followSubreddit(newWindow = false, selected = getSelected()) {
  const a = downcast(assertElement(selected.getSubredditLink()), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow,
    leaveNP: true
  });
}

function followProfile(newWindow = false, selected = getSelected()) {
  keyboardNav_navigateTo(selected.getAuthorUrl(), {
    newWindow,
    leaveNP: true
  });
}

function toggleChildren(selected = getSelected()) {
  if (selected.element.classList.contains('link')) return;
  click(assertElement(getFirstElementInThingByQuery('span.deepthread > a', NOASSERT, selected) || getFirstElementInThingByQuery('span.morecomments > a', NOASSERT, selected) || getFirstElementInThingByQuery('a.expand', NOASSERT, selected)));
}

function imageResize({
  factor = 1,
  removeHeightRestriction = false
}) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-zoomable', ASSERT);
  if (removeHeightRestriction) mostVisible.style.maxHeight = 'none';
  resizeMedia(mostVisible, mostVisible.clientWidth * factor);
}

function imageMove(deltaX, deltaY) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-movable', ASSERT);
  moveMedia(mostVisible, deltaX, deltaY);
}

function navigateGallery(direction) {
  const gallery = getMostVisibleElementInThingByQuery('.res-gallery', ASSERT);
  assertElement(gallery.querySelector(`.res-gallery-${direction}`)).click();

  if (keyboardNav_module.options.scrollOnGalleryNavigate.value) {
    scrollToElement(assertElement(gallery.querySelector('.res-gallery-pieces')), null, {
      scrollStyle: 'directional',
      restrictDirectionTo: 'up'
    });
  }
}

function followLink(newWindow = false, selected = getSelected()) {
  if (isPageType('comments') && !selected.element.classList.contains('link')) return;
  const a = selected.getPostLink();
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followLinkByRank(num) {
  const target = Thing_Thing.visibleThings().find(v => v.getRank() === num);
  if (!target) throw new Error(`Could not find visible entry at rank ${num}`);
  selectedEntry_select(target);
  followLink();
}

function followPermalink(newWindow = false) {
  const a = downcast(getFirstElementInThingByQuery('a.bylink', ASSERT), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followComments(newWindow = false, selected = getSelected()) {
  const a = selected.getCommentsLink();
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followLinkAndComments(background = false, selected = getSelected()) {
  openTabs(selected, !background);
}

function vote(way, preventToggle = false, selected = getSelected()) {
  const button = assertElement(way === 'upmod' ? selected.getUpvoteButton() : selected.getDownvoteButton());

  if (button.classList.contains('archived')) {} else if (isVotingBlocked()) {
    notifyNoVote();
  } else if (!preventToggle || !button.classList.contains(way)) {
    click(button);
  }

  if (selected.isComment()) {
    if (keyboardNav_module.options.onVoteCommentMoveDown.value) keyboardNav_module.options.moveDownComment.callback();
  } else {
    if (keyboardNav_module.options.onVoteMoveDown.value) keyboardNav_module.options.moveDown.callback();
  }
}

function reply(selected = getSelected()) {
  if (selected.element.classList.contains('link') && isPageType('comments')) {
    const $target = $('.usertext-edit textarea[name=text]:first');

    if ($target.filter(':visible').length) {
      $target.focus();
      return;
    }
  }

  click(assertElement(getFirstElementInThingByQuery('.buttons a[onclick*=reply]', NOASSERT, selected) || getFirstElementInThingByQuery('.buttons a.comments, .buttons a.bylink', NOASSERT, selected)));
}

function keyboardNav_navigateTo(href, options) {
  if (options.leaveNP && modules_isEnabled(noParticipation_namespaceObject) && noParticipation_module.options.escapeNP.value) {
    href = nonNpLocation(href);
  }

  if (options.newWindow) {
    openNewTab(href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = href;
  }
}

const goModePanel = once_default()(() => {
  const goModes = getActiveCommandOptions().filter(opt => opt.goMode).map(opt => ({
    key: i18n(opt.title),
    niceKeyCode: keycode_niceKeyCode(opt.value)
  }));
  return $(string_namespaceObject.html`
		<div id="goModePanel" class="RESDialogSmall">
			<h3>Press a key to go:</h3>
			<div class="RESCloseButton">&times;</div>
			<div class="RESDialogContents">
				<table>
					${goModes.map(({
    niceKeyCode,
    key
  }) => string_namespaceObject._html`
						<tr>
							<td>${niceKeyCode}</td>
							<td class="arrow">&rarr;</td>
							<td>${key}</td>
						</tr>
					`)}
				</table>
			</div>
		</div>
	`).find('.RESCloseButton').click(toggleGoMode).end();
});

let goModeActive = false;

function toggleGoMode() {
  goModeActive = !goModeActive;

  if (goModeActive) {
    $(document.body).on('keyup', handleGoModeEscapeKey);
    goModePanel().appendTo(document.body).fadeIn();
  } else {
    goModePanel().fadeOut();
    $(document.body).off('keyup', handleGoModeEscapeKey);
  }
}

function handleGoModeEscapeKey(event) {
  if (event.key === NAMED_KEYS.Escape) {
    toggleGoMode();
  }
}

function moveDownFallback() {
  const bump = isRunning(neverEndingReddit_namespaceObject) && (!Thing_Thing.selected || [Thing_Thing.selected, undefined].includes(last_default()(Thing_Thing.visibleThings())));
  if (bump) loadNextPage({
    scrollToLoadWidget: true
  });
}

function nextPage() {
  if (isRunning(neverEndingReddit_namespaceObject)) {
    loadNextPage({
      scrollToLoadWidget: true
    });
  } else {
    const nextPrevLinks = getNextPrevLinks();
    location.href = assertElement(nextPrevLinks.next).getAttribute('href');
  }
}

function prevPage() {
  if (!isRunning(neverEndingReddit_namespaceObject)) {
    const nextPrevLinks = getNextPrevLinks();
    location.href = assertElement(nextPrevLinks.prev).getAttribute('href');
  }
}

function openLink(index, altMode = false) {
  const link = linkAnnotations[index] && linkAnnotations[index].link;
  if (!link) throw Error(`Link annotation ${index} is not available`);
  const expando = getLinkExpando(link);

  if (expando && keyboardNav_module.options.linkToggleExpando.value !== altMode) {
    click(expando.button);
  } else if (isSettingsUrl(link.href)) {
    settingsNavigation_update(link);
  } else if (keyboardNav_module.options.linkNewTab.value) {
    openNewTab(link.href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = link.href;
  }
}
// CONCATENATED MODULE: ./lib/modules/RESTips.js















const RESTips_module = new Module('RESTips');
RESTips_module.moduleName = 'resTipsName';
RESTips_module.category = 'aboutCategory';
RESTips_module.description = 'resTipsDesc';
RESTips_module.options = {
  menuItem: {
    title: 'RESTipsMenuItemTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsMenuItemDesc'
  },
  dailyTip: {
    title: 'RESTipsDailyTipTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsDailyTipDesc'
  },
  newFeatureTips: {
    title: 'RESTipsNewFeatureTipsTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsNewFeatureTipsDesc'
  }
};
RESTips_module.include = ['r2'];
const featureTipsStorage = storage_namespaceObject.wrapPrefix('RESTips.featureTips.', () => ({
  enabled: true
}));
const lastTooltipStorage = storage_namespaceObject.wrap('RESLastToolTip', 0);

RESTips_module.contentStart = () => {
  if (RESTips_module.options.menuItem.value) {
    addMenuItem(() => string_namespaceObject.html`<span>${i18n('tipsAndTricks')}</span>`, () => {
      showOrdinaryTip('random');
    });
  }
};

let allowFeatureTips;
const RESTips_featureTips = new Map();
const featureTipReadyPromise = new Promise(resolve => {
  allowFeatureTips = () => resolve(true);
});

RESTips_module.afterLoad = async () => {
  const showsDailyTip = RESTips_module.options.dailyTip.value && (await dailyTip());
  if (RESTips_module.options.newFeatureTips.value && !showsDailyTip) allowFeatureTips();
};

const newFeatureTipsCheckbox = once_default()(() => $('<label><input type="checkbox" name="disableNewFeatureTipsCheckbox" checked />Show these tips when new features appear</label>').click(e => options_set(RESTips_module, 'newFeatureTips', e.target.checked)));

const addFeatureTip = memoize_default()(async (id, tip) => {
  tip.onHide = () => {
    featureTipsStorage.set(id, {
      enabled: false
    });
  };

  RESTips_featureTips.set(id, tip);
  tips.push(tip);
  if (!tip.quiet && (await featureTipReadyPromise) && (await featureTipsStorage.get(id).then(({
    enabled
  }) => enabled))) showFeatureTip(id);
});
const showFeatureTip = mutex(id => {
  const tip = RESTips_featureTips.get(id);

  if (!tip) {
    console.error('Feature tip is not added', id);
    return;
  }

  if (tip.attachTo instanceof Element && !elementInViewport(tip.attachTo)) {
    console.log('Ignoring feature tip whose attachment element is not visible:', tip);
    return;
  }

  return showTip(tip, {
    title: 'New feature',
    classString: 'res-featureTip',
    buttonCustomHTML: newFeatureTipsCheckbox(),
    buttons: []
  });
});

async function dailyTip() {
  const lastCheck = await lastTooltipStorage.get();
  const now = Date.now();
  const delay = penalizedDelay(RESTips_module.moduleID, 'dailyTip', {
    value: DAY,
    default: DAY
  });

  if (now - lastCheck > delay) {
    lastTooltipStorage.set(now);

    if (lastCheck === 0) {
      await showOrdinaryTip();
    } else {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', clamp_default()(MAX_PENALTY / tips.length, 3, 8));
      await showOrdinaryTip('random');
    }

    return true;
  }

  return false;
}

function generateContent({
  message,
  keyboard,
  options
}) {
  const description = [];
  if (typeof message === 'function') description.push(message());else if (typeof message === 'string') description.push(message);

  if (keyboard) {
    const disabled = !modules_isEnabled(keyboardNav_namespaceObject);
    description.push(`<h2 class="keyboardNav${disabled ? 'keyboardNavDisabled' : ''}">`);
    description.push(`Keyboard Navigation${disabled ? ' (disabled)' : ''}`);
    description.push('</h2>');
    const keyboardTable = createElement_namespaceObject.table(keyboard, generateContentKeyboard);
    if (keyboardTable) description.push(keyboardTable);
  }

  if (options) {
    for (const option of options) {
      description.push('<h2 class="settingsPointer">');
      description.push('<span class="gearIcon"></span> RES Settings');
      description.push('</h2>');
      const optionTable = createElement_namespaceObject.table(option, generateContentOption);
      if (optionTable) description.push(optionTable);
    }
  }

  return $('<div />').html(description.join('\n'));
}

function generateContentKeyboard(keyboardNavOption) {
  const keyCode = keycode_niceKeyCode(keyboardNav_module.options[keyboardNavOption].value);
  if (!keyCode) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td><code>${keyCode.toLowerCase()}</code></td>`);
  description.push(`<td>${keyboardNavOption}</td>`);
  description.push('</tr><tr>');
  description.push('<td>&nbsp;</td>');
  description.push(`<td>${i18n(keyboardNav_module.options[keyboardNavOption].description)}</td>`);
  description.push('</tr>');
  return description;
}

function generateContentOption(option) {
  const mod = getUnchecked(option.moduleID);
  if (!mod) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td>${i18n(mod.category)}</td>`);
  description.push('<td>');
  description.push(makeUrlHashLink(option.moduleID, undefined, i18n(mod.moduleName)));
  description.push('</td>');
  description.push('<td>');
  description.push(option.key ? makeUrlHashLink(option.moduleID, option.key) : '&nbsp;');
  description.push('</td>');

  if (option.key && mod.options[option.key]) {
    description.push('</tr><tr>');
    description.push(`<td colspan="3">${i18n(mod.options[option.key].description)}</td>`);
  }

  description.push('</tr>');
  return description;
}

const tips = [{
  message: `
		Welcome to RES, a community-driven unofficial browser extension for Reddit. You can turn on, turn off, or change options for RES features using the gear icon link at the top right.
		<p>For feature requests, or just help getting a question answered, be sure to subscribe to <a href="/r/Enhancement">/r/Enhancement</a>.</p>
		<p>If RES has enhanced your reddit experience, please show your appreciation by <a href="${RES_SETTINGS_HASH}/contribute">donating or contributing!</a></p>
		`,
  attachTo: '#RESSettingsButton',
  position: 5
}, {
  message: 'Click the tag icon next to a user to tag that user with any name you like - you can also color code the tag.',
  attachTo: '.RESUserTagImage',
  position: 3,
  options: [{
    moduleID: 'userTagger'
  }]
}, {
  message: 'If your RES data gets deleted or you move to a new computer, you can restore it from backup. <br><br><b>Firefox</b> especially sometimes loses your RES settings and data. <br><br><a href="/r/Enhancement/wiki/backing_up_res_settings" target="_blank" rel="noopener noreferer">Learn where RES stores your data and settings</a></p>',
  title: 'Back up your RES data!'
}, {
  message: 'Don\'t forget to subscribe to <a href="/r/Enhancement">/r/Enhancement</a> to keep up to date on the latest versions of RES or suggest features! For bug reports, submit to <a href="/r/RESIssues">/r/RESIssues</a>'
}, {
  message: 'Don\'t want to see posts containing certain keywords? Want to filter out certain subreddits from /r/all? Try the filteReddit module!',
  options: [{
    moduleID: 'filteReddit'
  }]
}, {
  message: 'Keyboard Navigation is one of the most underutilized features in RES. You should try it!',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Did you know you can configure the appearance of a number of things in RES? For example: Selected Entry lets you configure the look of the "selected" box, and commentBoxes lets you configure the borders / shadows.',
  options: [{
    moduleID: 'selectedEntry',
    key: 'setColors'
  }, {
    moduleID: 'commentStyle',
    key: 'commentBoxes'
  }]
}, {
  message: 'Do you subscribe to a ton of subreddits? Give the subreddit tagger a try; it can make your homepage a bit more readable.',
  options: [{
    moduleID: 'subRedditTagger'
  }]
}, {
  message: 'If you haven\'t tried it yet, Keyboard Navigation is great. Just hit ? while browsing for instructions.',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Roll over a user\'s name to get information about them such as their karma, and how long they\'ve been a reddit user.',
  options: [{
    moduleID: 'userInfo',
    key: 'hoverInfo'
  }]
}, {
  message: 'Hover over the "parent" link in comments pages to see the text of the parent being referred to.',
  options: [{
    moduleID: 'showParent'
  }]
}, {
  message: 'You can configure the color and style of the User Highlighter module if you want to change how the highlights look.',
  options: [{
    moduleID: 'userHighlight'
  }]
}, {
  message: 'Not a fan of how comments pages look? You can change the appearance in the Style Tweaks module',
  options: [{
    moduleID: 'styleTweaks'
  }]
}, {
  message: 'Don\'t like the style in a certain subreddit? RES gives you a checkbox to disable styles individually - check the right sidebar!'
}, {
  message: 'Looking for posts by submitter, post with photos, or posts in IAmA form? Try out the comment navigator.'
}, {
  message: 'Have you seen the <a href="/r/Dashboard">RES Dashboard</a>? It allows you to do all sorts of great stuff, like keep track of lower traffic subreddits, and manage your <a href="/r/Dashboard#userTaggerContents">user tags</a> and <a href="/r/Dashboard#newCommentsContents">thread subscriptions</a>!',
  options: [{
    moduleID: 'dashboard'
  }]
}, {
  message: 'Sick of seeing these tips?  They only show up once every 24 hours, but you can disable that in the RES Tips and Tricks preferences.',
  options: [{
    moduleID: 'RESTips'
  }]
}, {
  message: 'Did you know that there is now a "keep me logged in" option in the Account Switcher? Turn it on if you want to stay logged in to Reddit when using the switcher!',
  options: [{
    moduleID: 'accountSwitcher',
    key: 'keepLoggedIn'
  }]
}, {
  message: 'See that little [vw] next to users you\'ve voted on?  That\'s their vote weight - it moves up and down as you vote the same user up / down.',
  options: [{
    moduleID: 'userTagger',
    key: 'vwNumber'
  }]
}];

const dailyTipsCheckbox = once_default()(() => $(`<label> <input type="checkbox" name="disableDailyTipsCheckbox" ${RESTips_module.options.dailyTip.value ? 'checked' : ''} />Show these tips once every 24 hours</label>`).click(e => options_set(RESTips_module, 'dailyTip', e.target.checked)));

let lastTip;

function showOrdinaryTip(change) {
  alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 1);
  let currTipIndex = Math.max(tips.indexOf(lastTip), 0);
  let tip;

  while (!tip || tip.attachTo && !$(tip.attachTo).is(':visible')) {
    if (change === 'random') currTipIndex = random_default()(tips.length);else if (change === 'prev') currTipIndex -= 1;else if (change === 'next') currTipIndex += 1;else change = 'next';
    currTipIndex = positiveModulo(currTipIndex, tips.length);
    tip = tips[currTipIndex];
  }

  return showTip(tip, {
    buttons: [{
      name: 'Prev',
      onclick: () => showOrdinaryTip('prev')
    }, {
      name: 'Next',
      onclick: () => showOrdinaryTip('next')
    }],

    onClose() {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 4);
    },

    classString: 'res-ordinaryTip',
    buttonCustomHTML: dailyTipsCheckbox(),
    title: 'RES Tips and Tricks'
  });
}

function showTip(tip, guiderObj) {
  const {
    continuation
  } = lastTip = tip;

  if (continuation) {
    const origGuiderObj = { ...guiderObj
    };
    guiderObj.buttons = [...guiderObj.buttons, {
      name: 'More',
      onclick: async () => {
        const upcomingId = continuation();
        let nextTip;

        while (!(nextTip = RESTips_featureTips.get(upcomingId))) {
          await new Promise(r => setTimeout(r, 100));
        }

        showTip(nextTip, origGuiderObj);
      }
    }];
  }

  const attachTo = tip.attachTo && $(tip.attachTo).get(0) || null;

  const toggleIncreasedZIndex = state => {
    if (attachTo) attachTo.classList.toggle('restips-increased-z-index', state);
  };

  return new Promise(resolve => {
    jqueryPlugins_guiders.hideAll();
    jqueryPlugins_guiders.createGuider({
      id: `res-guider-${performance.now()}`,
      closeOnEscape: true,
      xButton: true,
      description: generateContent(tip),
      ...guiderObj,
      ...tip,

      onHide() {
        if (tip.onHide) tip.onHide();
        toggleIncreasedZIndex(false);
        resolve();
      },

      attachTo
    });
    toggleIncreasedZIndex(true);
    jqueryPlugins_guiders.show();
  });
}
// CONCATENATED MODULE: ./lib/modules/about.js


const about_module = new Module('about');
about_module.moduleName = 'aboutName';
about_module.category = 'aboutCategory';
about_module.sort = -10;
about_module.alwaysEnabled = true;
about_module.description = 'aboutDesc';
about_module.options = {
  presets: {
    type: 'button',
    description: 'aboutOptionsPresets',
    title: 'aboutOptionsPresetsTitle',
    text: createElement_namespaceObject.icon(0xF142),
    callback: {
      moduleID: 'presets'
    }
  },
  backup: {
    type: 'button',
    description: 'aboutOptionsBackup',
    title: 'aboutOptionsBackupTitle',
    text: createElement_namespaceObject.icon(0xF059),
    callback: {
      moduleID: 'backupAndRestore'
    }
  },
  searchSettings: {
    type: 'button',
    description: 'aboutOptionsSearchSettings',
    title: 'aboutOptionsSearchSettingsTitle',
    text: createElement_namespaceObject.icon(0xF097),
    callback: {
      moduleID: 'search'
    }
  },
  announcements: {
    type: 'button',
    description: 'aboutOptionsAnnouncements',
    title: 'aboutOptionsAnnouncementsTitle',
    text: createElement_namespaceObject.icon(0xF108),
    callback: '/r/RESAnnouncements/new'
  },
  donate: {
    type: 'button',
    description: 'aboutOptionsDonate',
    title: 'aboutOptionsDonateTitle',
    text: createElement_namespaceObject.icon(0xF104),
    callback: 'https://redditenhancementsuite.com/contribute/'
  },
  bugs: {
    type: 'button',
    description: 'aboutOptionsBugs',
    title: 'aboutOptionsBugsTitle',
    text: createElement_namespaceObject.icon(0xF003),
    callback: '/r/RESIssues/wiki/postanissue'
  },
  suggestions: {
    type: 'button',
    description: 'aboutOptionsSuggestions',
    title: 'aboutOptionsSuggestionsTitle',
    text: createElement_namespaceObject.icon(0xF076),
    callback: '/r/Enhancement'
  },
  faq: {
    type: 'button',
    description: 'aboutOptionsFAQ',
    title: 'aboutOptionsFAQTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: '/r/Enhancement/wiki/index'
  },
  code: {
    type: 'button',
    description: 'aboutOptionsCode',
    title: 'aboutOptionsCodeTitle',
    text: createElement_namespaceObject.icon(0xF063),
    callback: 'https://github.com/honestbleeps/Reddit-Enhancement-Suite'
  },
  contributors: {
    type: 'button',
    description: 'aboutOptionsContributors',
    title: 'aboutOptionsContributorsTitle',
    text: createElement_namespaceObject.icon(0xF048),
    callback: 'https://redditenhancementsuite.com/about'
  },
  privacy: {
    type: 'button',
    description: 'aboutOptionsPrivacy',
    title: 'aboutOptionsPrivacyTitle',
    text: createElement_namespaceObject.icon(0xF0C2),
    callback: '/r/Enhancement/wiki/about/privacy'
  },
  license: {
    type: 'button',
    description: 'aboutOptionsLicense',
    title: 'aboutOptionsLicenseTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: 'https://www.gnu.org/licenses/gpl-3.0.html'
  }
};
// CONCATENATED MODULE: ./lib/modules/announcements.js








const announcements_module = new Module('announcements');
announcements_module.moduleName = 'announcementsName';
announcements_module.category = 'coreCategory';
announcements_module.description = 'announcementsDesc';
announcements_module.hidden = true;
const announcements_subreddit = announcementsSubreddit;
const sourceUrl = `/r/${announcements_subreddit}/new.json?limit=1`;
const viewUrl = `/r/${announcements_subreddit}/new`;
const markedReadDate = storage_namespaceObject.wrap('RESmodules.announcement.markedReadDate', 0);
const lastUnreadDate = storage_namespaceObject.wrap('RESmodules.announcement.lastUnreadDate', 0);
const lastID = storage_namespaceObject.wrap('RESModules.announcement.lastAnnouncementID', null);
const archiveAfter = 31 * DAY;
const pizzazzAfter = 29 * DAY;
const recheckPostAfter = HOUR;
const announcements_now = Date.now();
let $biff;

announcements_module.go = async () => {
  if (isCurrentSubreddit(announcements_subreddit)) {
    setMarkedRead();
  } else {
    const post = await postForNotification();

    if (post) {
      notify(post);
    }
  }
};

async function postForNotification() {
  const post = await getLatestPost();

  if (!post) {
    return false;
  }

  cacheLatestPost(post);
  const result = await shouldNotify(post);
  return result ? post : false;
}

async function shouldNotify(post) {
  const createdDate = post.created_utc * 1000;

  if (createdDate + archiveAfter <= announcements_now) {
    return false;
  }

  if (createdDate <= (await markedReadDate.get())) {
    return false;
  }

  if (!isPostRelevant(post)) {
    return false;
  }

  return true;
}

const notify = once_default()(async post => {
  const url = post.id ? `/comments/${post.id}` : viewUrl;
  const withPizzazz = (await lastUnreadDate.get()) + pizzazzAfter < announcements_now;
  const title = post.author ? i18n('announcementsNewPostByUser', announcements_subreddit, post.author) : i18n('announcementsNewPost', announcements_subreddit);
  addAnnouncementBiff(post, url, title, withPizzazz);
  const hasSeenNotification = await lastUnreadDate.has();

  if (hasSeenNotification) {
    addMenuItem(() => createMenuItem(post, url, title), () => {
      openNewTab(url);
    }, -8);
  }
});

async function cacheLatestPost(post) {
  if (post.id !== (await lastID.get())) {
    lastID.set(post.id);
    lastUnreadDate.set(announcements_now);
  }
}

function createMenuItem(post, url, title = '') {
  const menuItem = document.createElement('span');
  $('<span class="RESMenuItemButton"></span>').append(createElement_namespaceObject.icon(0xF076, 'span', '', i18n('announcementsMarkAsRead'))).appendTo(menuItem).on('click', e => {
    e.preventDefault();
    e.stopPropagation();
    setMarkedRead();
    e.target.classList.remove('newNotification');
  });
  $('<a>new announcement!</a>').attr({
    href: url,
    title,
    target: '_blank',
    rel: 'noopener noreferer'
  }).on('click', e => {
    e.stopPropagation();
    setMarkedRead();
  }).appendTo(menuItem);
  return menuItem;
}

function addAnnouncementBiff(post, url, title, withPizzazz) {
  $biff = $('<a id="RESAnnouncementAlert" />').attr({
    href: url,
    target: '_blank'
  }).append(createElement_namespaceObject.icon(0xF076, 'span', '', title)).on('click', setMarkedRead);

  if (isAppType('r2')) {
    $biff.appendTo('#header-bottom-right');
  } else {
    addElement($biff);
  }

  if (withPizzazz) {
    $biff.addClass('important');
  }
}

async function getLatestPost() {
  const {
    data: {
      children: [{
        data
      }]
    }
  } = await ajax({
    url: sourceUrl,
    type: 'json',
    cacheFor: recheckPostAfter
  });
  return data;
}

function setMarkedRead() {
  markedReadDate.set(announcements_now);

  if ($biff) {
    $biff.remove();
  }
}

function isPostRelevant(post) {
  if (!/chrome|safari|firefox|opera|edge/i.test(post.title)) {
    return true;
  }

  if (post.title.toLowerCase().includes("chrome".toLowerCase())) {
    return true;
  }

  return false;
}
// EXTERNAL MODULE: ./node_modules/numeral/numeral.js
var numeral = __webpack_require__(139);
var numeral_default = /*#__PURE__*/__webpack_require__.n(numeral);

// EXTERNAL MODULE: ./node_modules/lodash/mapValues.js
var lodash_mapValues = __webpack_require__(36);
var lodash_mapValues_default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues);

// CONCATENATED MODULE: ./lib/modules/backupAndRestore/serialization.js

function serialize(settings) {
  return JSON.stringify({
    SCHEMA_VERSION: 2,
    data: settings
  });
}
function deserialize(string) {
  const object = JSON.parse(string);

  switch (object.SCHEMA_VERSION) {
    default:
      {
        const {
          SCHEMA_VERSION,
          ...encoded
        } = object;
        return lodash_mapValues_default()(encoded, (v, k) => {
          try {
            return JSON.parse(v);
          } catch (e) {
            console.warn('Could not parse:', k, 'falling back to raw string.');
            return v;
          }
        });
      }

    case 1:
      {
        const {
          SCHEMA_VERSION,
          ...settings
        } = object;
        return settings;
      }

    case 2:
      {
        const {
          data: settings
        } = object;
        return settings;
      }
  }
}
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Provider.js
class Provider {
  init({}) {
    return Promise.resolve(this);
  }

  read() {
    throw new Error('unimplemented');
  }

  write(data) {
    throw new Error('unimplemented');
  }

}
Provider.key = 'abstract';
Provider.text = 'Abstract';
Provider.notifyBackupDone = true;
Provider.supportsAutomaticBackups = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/File.js



class File_File extends Provider {
  read() {
    return new Promise((resolve, reject) => {
      const link = document.createElement('input');
      link.type = 'file';
      link.accept = '.resbackup';
      link.addEventListener('change', () => {
        const file = link.files[0];
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };

        reader.readAsText(file);
      });
      waitForEvent(window, 'mousemove').then(() => setTimeout(() => {
        if (!link.files.length) reject(new Error('No file selected.'));
      }));
      link.click();
    });
  }

  write(data) {
    const blob = new Blob([data], {
      type: 'application/json'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const date = new Date();
    link.download = `RES-${date.getUTCFullYear()}-${date.getMonth() + 1}-${date.getDate()}-${Math.round(date.getTime() / 1000)}-${metadata_version.replace(/\./g, '_')}.resbackup`;
    click(link);
    return Promise.resolve();
  }

}
File_File.key = 'file';
File_File.text = 'backupAndRestoreProvidersFile';
File_File.notifyBackupDone = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/GoogleDrive.js



const FILE = 'res-storage.json';
const FOLDER = 'appDataFolder';
class GoogleDrive_GoogleDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({
    googleLoginHint
  }) {
    this.accessToken = await launchAuthFlow({
      domain: `https://accounts.google.com/o/oauth2/v2/auth?login_hint=${googleLoginHint}`,
      clientId: '568759524377-nv0o2u4afuuulkfcjd7f6guf27qkevpt.apps.googleusercontent.com',
      scope: 'https://www.googleapis.com/auth/drive.appdata',
      permissions: ['https://content.googleapis.com/drive/v3/*', 'https://accounts.google.com/o/oauth2/v2/auth']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Google Drive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getExistingFile() {
    const {
      files: [file]
    } = await ajax({
      method: 'GET',
      url: 'https://content.googleapis.com/drive/v3/files',
      query: {
        fields: 'files(id)',
        q: `name="${FILE}"`,
        spaces: FOLDER
      },
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
    return file;
  }

  async getOrCreateFile() {
    const existingFile = await this.getExistingFile();
    if (existingFile) return existingFile;
    return ajax({
      method: 'POST',
      url: 'https://content.googleapis.com/drive/v3/files',
      query: {
        fields: 'id'
      },
      data: JSON.stringify({
        name: FILE,
        parents: [FOLDER]
      }),
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

  async read() {
    const file = await this.getExistingFile();
    if (!file) throw new Error('Could not find backup.');
    return ajax({
      method: 'GET',
      url: `https://content.googleapis.com/drive/v3/files/${file.id}`,
      query: {
        alt: 'media'
      },
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      }
    });
  }

  async write(data) {
    const {
      id
    } = await this.getOrCreateFile();
    await ajax({
      method: 'PATCH',
      url: `https://content.googleapis.com/upload/drive/v3/files/${id}`,
      query: {
        uploadType: 'media'
      },
      data,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
GoogleDrive_GoogleDrive.key = 'googledrive';
GoogleDrive_GoogleDrive.text = 'Google Drive';
GoogleDrive_GoogleDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/OneDrive.js



const OneDrive_FILE = 'res-storage.json';
class OneDrive_OneDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://login.live.com/oauth20_authorize.srf',
      clientId: 'a1f95f80-0129-475b-9894-dfbb94f5ff1c',
      scope: 'onedrive.appfolder',
      permissions: ['https://login.live.com/oauth20_authorize.srf']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to OneDrive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getMetadata() {
    try {
      return await ajax({
        method: 'GET',
        url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}`,
        query: {
          select: 'id,@content.downloadUrl'
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        },
        type: 'json'
      });
    } catch (e) {
      if (e.status === 404) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async read() {
    const file = await this.getMetadata();
    return ajax({
      method: 'GET',
      url: file['@content.downloadUrl']
    });
  }

  async write(data) {
    await ajax({
      method: 'PUT',
      url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}:/content`,
      data,
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
OneDrive_OneDrive.key = 'onedrive';
OneDrive_OneDrive.text = 'OneDrive';
OneDrive_OneDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Dropbox.js



const Dropbox_FILE = '/res-storage.json';
class Dropbox_Dropbox extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://www.dropbox.com/oauth2/authorize',
      clientId: 'tdevom9o5xn0hnt',
      permissions: ['https://www.dropbox.com/oauth2/authorize']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Dropbox.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async read() {
    try {
      return await ajax({
        method: 'POST',
        url: 'https://content.dropboxapi.com/2/files/download',
        query: {
          arg: JSON.stringify({
            path: Dropbox_FILE
          })
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      });
    } catch (e) {
      if (e.status === 409) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async write(data) {
    await ajax({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/upload',
      query: {
        arg: JSON.stringify({
          path: Dropbox_FILE,
          mode: 'overwrite',
          mute: true
        })
      },
      data,
      headers: {
        'Content-Type': 'application/octet-stream',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
Dropbox_Dropbox.key = 'dropbox';
Dropbox_Dropbox.text = 'Dropbox';
Dropbox_Dropbox.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/index.js




// CONCATENATED MODULE: ./lib/modules/backupAndRestore.js








const backupAndRestore_module = new Module('backupAndRestore');
backupAndRestore_module.moduleName = 'backupName';
backupAndRestore_module.category = 'aboutCategory';
backupAndRestore_module.sort = -8;
backupAndRestore_module.alwaysEnabled = true;
backupAndRestore_module.description = 'backupDesc';
backupAndRestore_module.options = {
  backup: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(backup)
    })),
    description: 'backupAndRestoreBackupDesc',
    title: 'backupAndRestoreBackupTitle'
  },
  restore: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(restore)
    })),
    description: 'backupAndRestoreRestoreDesc',
    title: 'backupAndRestoreRestoreTitle'
  },
  reloadWarning: {
    type: 'enum',
    value: 'warn',
    values: [{
      name: 'backupAndRestoreReloadWarningNone',
      value: 'none'
    }, {
      name: 'backupAndRestoreReloadWarningWarn',
      value: 'warn'
    }, {
      name: 'backupAndRestoreReloadWarningAuto',
      value: 'auto'
    }],
    description: 'backupAndRestoreReloadWarningDesc',
    title: 'backupAndRestoreReloadWarningTitle'
  },
  automaticBackups: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'backupAndRestoreAutomaticBackupsNone',
      value: 'none'
    }, ...Object.values(providers_namespaceObject).filter(p => p.supportsAutomaticBackups).map(p => ({
      name: p.text,
      value: p.key
    }))],
    description: 'backupAndRestoreAutomaticBackupsDesc',
    title: 'backupAndRestoreAutomaticBackupsTitle',

    onChange() {
      lastCheckStorage.set(0);
      handleAutomaticSync();
    }

  },
  warnBeforeAutomaticRestore: {
    type: 'boolean',
    value: true,
    description: 'backupAndRestoreWarnBeforeAutomaticRestoreDesc',
    title: 'backupAndRestoreWarnBeforeAutomaticRestoreTitle',
    dependsOn: options => options.automaticBackups.value !== 'none'
  },
  googleAccount: {
    type: 'text',
    value: '',
    description: 'backupAndRestoreGoogleAccountDesc',
    title: 'backupAndRestoreGoogleAccountTitle',
    advanced: true
  }
};

backupAndRestore_module.afterLoad = async () => {
  await handleAutomaticSync();
};

function getProvider(providerClass) {
  return new providerClass().init({
    googleLoginHint: backupAndRestore_module.options.googleAccount.value
  });
}

const lastModifiedStorage = storage_namespaceObject.wrapPrefix('backup.lastModified.', () => 0);
const lastCheckStorage = storage_namespaceObject.wrap('backup.lastCheck', 0);

async function handleAutomaticSync() {
  const automaticProviderKey = backupAndRestore_module.options.automaticBackups.value;
  if (automaticProviderKey === 'none') return;
  const providerClass = Object.values(providers_namespaceObject).find(p => p.key === automaticProviderKey);
  if (!providerClass) throw new Error(`Can't find provider with key ${automaticProviderKey}`);
  const now = Date.now();
  const lastCheck = await lastCheckStorage.get();
  if (now - lastCheck < 15 * MINUTE) return;
  if (!(await lastCheckStorage.compareAndSet(lastCheck, now))) return;
  const provider = await getProvider(providerClass);
  let remoteBackup;

  const lastModifiedKey = lastModifiedStorage._keyGen(providerClass.key);

  try {
    remoteBackup = deserialize((await provider.read()));
  } catch (e) {
    console.warn('Failed to read automatic backup:', e);
    remoteBackup = {
      [lastModifiedKey]: 0
    };
  }

  if (remoteBackup[lastModifiedKey] > (await lastModifiedStorage.get(providerClass.key))) {
    await restore(provider, backupAndRestore_module.options.warnBeforeAutomaticRestore.value ? 'automatic' : 'none');
  } else {
    await backup(provider);
  }
}

async function backup(provider) {
  const {
    key,
    text,
    notifyBackupDone
  } = provider.constructor;
  await lastModifiedStorage.set(key, Date.now());
  const storage = await storage_namespaceObject.getAll();
  await provider.write(serialize(storage));

  if (notifyBackupDone) {
    notifications_showNotification({
      message: i18n('backupAndRestoreSavedNotification', text),
      notificationID: 'backupAndRestoreSaved',
      moduleID: backupAndRestore_module.moduleID,
      closeDelay: 1000
    });
  }
}

async function restore(provider, alertType = 'normal') {
  const {
    key,
    name
  } = provider.constructor;
  const data = await provider.read();
  const storage = deserialize(data);
  const isAutomatic = alertType === 'automatic';

  if (alertType !== 'none') {
    const lastModifiedKey = lastModifiedStorage._keyGen(key);

    const backupDate = storage[lastModifiedKey];

    try {
      await alert_namespaceObject.open(`
			${isAutomatic ? `
				<p><b>${i18n('backupAndRestoreFoundBackup', name)}</b></p>
				<br>
			` : ''}
			<p>${i18n('backupAndRestoreBackupOverwriteWarning')}</p>
			<br>
			${isAutomatic ? `
				<p>${i18n('backupAndRestoreAfterCancel')}</p>
				<br>
			` : ''}
			${backupDate ? `
				<p>${i18n('backupAndRestoreBackupDate', formatDateTime(new Date(backupDate)))}</p>
			` : ''}
			<p>${i18n('backupAndRestoreBackupSize', numeral_default()(data.length).format('0.0 b'))}</p>
		`, {
        cancelable: true
      });
    } catch (e) {
      if (isAutomatic) {
        settingsNavigation_open(backupAndRestore_module.moduleID, 'automaticBackups');
      }

      return;
    }
  }

  await storage_namespaceObject.setMultiple(storage);
  await lastCheckStorage.set(Date.now());
  postRestore(backupAndRestore_module.options.reloadWarning.value);
  await alert_namespaceObject.open(i18n('backupAndRestoreImported'));
  postRestore.local('auto');
}

const postRestore = multicast(operation => {
  switch (operation) {
    case 'warn':
      alert_namespaceObject.open(i18n('backupAndRestoreImportedOtherTabs'), {
        cancelable: true
      }).then(() => location.reload(), () => {});
      break;

    case 'auto':
      location.reload();
      break;

    case 'none':
    default:
      break;
  }
}, {
  name: 'restore-settings-warning',
  local: false
});
// EXTERNAL MODULE: ./node_modules/lodash/uniqBy.js
var uniqBy = __webpack_require__(30);
var uniqBy_default = /*#__PURE__*/__webpack_require__.n(uniqBy);

// CONCATENATED MODULE: ./lib/modules/subredditManager.js










const subredditManager_module = new Module('subredditManager');
subredditManager_module.moduleName = 'subredditManName';
subredditManager_module.category = 'subredditsCategory';
subredditManager_module.description = 'subredditManDesc';
subredditManager_module.include = ['r2'];
subredditManager_module.options = {
  subredditShortcut: {
    title: 'subredditManagerSubredditShortcutTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerSubredditShortcutDesc'
  },
  shortcutsPerAccount: {
    title: 'subredditManagerShortcutsPerAccountTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerShortcutsPerAccountDesc'
  },
  alwaysApplySuffixToMulti: {
    title: 'subredditManagerAlwaysApplySuffixToMultiTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAlwaysApplySuffixToMultiDesc'
  },
  dropdownEditButton: {
    title: 'subredditManagerDropdownEditButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDropdownEditButtonDesc'
  },
  enableSubredditFilter: {
    title: 'subredditManagerFilterListTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerFilterListDesc'
  },
  shortcutDropdownDelay: {
    title: 'subredditManagerShortcutDropdownDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditManagerShortcutDropdownDelayDesc'
  },
  shortcutEditDropdownDelay: {
    title: 'subredditManagerShortcutEditDropdownDelayTitle',
    dependsOn: options => options.dropdownEditButton.value,
    type: 'text',
    value: '3000',
    description: 'subredditManagerShortcutEditDropdownDelayDesc'
  },
  allowLowercase: {
    title: 'subredditManagerAllowLowercaseTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAllowLowercaseDesc',
    bodyClass: true
  },
  linkDashboard: {
    title: 'subredditManagerLinkDashboardTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkDashboardDesc'
  },
  linkAll: {
    title: 'subredditManagerLinkAllTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkAllDesc'
  },
  linkFront: {
    title: 'subredditManagerLinkFrontTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFrontDesc'
  },
  linkPopular: {
    title: 'subredditManagerLinkPopularTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkPopularDesc'
  },
  linkProfilePosts: {
    title: 'subredditManagerLinkProfilePostsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkProfilePostsDesc'
  },
  linkRandom: {
    title: 'subredditManagerLinkRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkRandomDesc'
  },
  linkMyRandom: {
    title: 'subredditManagerLinkMyRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkMyRandomDesc'
  },
  linkRandNSFW: {
    title: 'subredditManagerLinkRandNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerLinkRandNSFWDesc'
  },
  linkUsers: {
    title: 'subredditManagerLinkUsersTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkUsersDesc'
  },
  linkFriends: {
    title: 'subredditManagerLinkFriendsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFriendsDesc'
  },
  linkMod: {
    title: 'subredditManagerLinkModTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModDesc'
  },
  linkModqueue: {
    title: 'subredditManagerLinkModqueueTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModqueueDesc'
  },
  linkSaved: {
    title: 'subredditManagerLinkSavedTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkSavedDesc'
  },
  buttonEdit: {
    title: 'subredditManagerButtonEditTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerButtonEditDesc'
  },
  lastUpdate: {
    title: 'subredditManagerLastUpdateTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLastUpdateDesc'
  },
  storeSubredditVisit: {
    title: 'subredditManagerStoreSubredditVisitTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerStoreSubredditVisitDesc',
    advanced: true
  },
  storeSubredditVisitIncognito: {
    title: 'subredditManagerStoreSubredditVisitIncognitoTitle',
    dependsOn: options => options.storeSubredditVisit.value,
    type: 'boolean',
    value: false,
    description: 'subredditManagerStoreSubredditVisitIncognitoDesc',
    advanced: true
  },
  dragDropDelete: {
    title: 'subredditManagerDragDropDeleteTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDragDropDeleteDesc',
    advanced: true
  },
  displayMultiCounts: {
    title: 'subredditManagerDisplayMultiCountsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDisplayMultiCountsDesc'
  }
};
let shortCutsContainer, $subredditGroupDropdown, subredditGroupDropdownUL, subredditGroupDropdownRefItem, $srList, $editShortcutDialog, deleteButton, $sortMenu, gettingSubreddits, subredditsLastViewed, sortShortcutsButton;
let mySubredditShortcuts = [];
const subredditsLastViewedStorage = storage_namespaceObject.wrap(() => `RESmodules.subredditManager.subredditsLastViewed.${loggedInUser() || 'null'}`, {});
const subredditShortcutsStorage = storage_namespaceObject.wrap(() => {
  const username = subredditManager_module.options.shortcutsPerAccount.value ? loggedInUser() : null;
  return `RESmodules.subredditManager.subredditShortcuts.${username || 'null'}`;
}, []);

const initialShortcutsLoad = once_default()(getLatestShortcuts);

let shortcutsLoadedPromiseResolve;
const shortcutsLoadedPromise = new Promise(res => {
  shortcutsLoadedPromiseResolve = res;
});

subredditManager_module.beforeLoad = () => {
  waitForDescendant(document.documentElement, '#sr-header-area').then(createSubredditBar);
};

subredditManager_module.contentStart = async () => {
  await initialShortcutsLoad();
  shortcutsLoadedPromiseResolve();
  createSidebarShortcutToggle();
  watchForThings(['subreddit'], thing => {
    const titleElement = thing.getTitleElement();
    const container = thing.element.querySelector('.midcol');
    if (!titleElement || !container) return;
    const [, subreddit] = regexes.subreddit.exec(titleElement.pathname) || [];
    if (!subreddit) return;
    container.append(createShortcutToggleButton(subreddit));
  });
};

subredditManager_module.afterLoad = () => {
  if (subredditManager_module.options.lastUpdate.value && document.getElementsByClassName('listing-chooser').length) {
    subredditManager_lastUpdate();
  }

  const subreddit = currentSubreddit();

  if (subreddit) {
    requestAnimationFrame(() => {
      setLastViewtime(subreddit);
    });
  }
};

function createSidebarShortcutToggle() {
  const subreddit = currentSubreddit();

  if (subreddit && subredditManager_module.options.subredditShortcut.value) {
    const subButtons = document.querySelectorAll('.side .fancy-toggle-button');

    for (const subButton of subButtons) {
      let thisSubredditFragment, isMulti;

      if (!subreddit.includes('+') && !isCurrentSubreddit('mod')) {
        thisSubredditFragment = subreddit;
        isMulti = false;
      } else if ($(subButton).parent().hasClass('subButtons')) {
        thisSubredditFragment = $(subButton).parent().parent().find('a.title').text();
        isMulti = true;
      } else {
        thisSubredditFragment = $(subButton).next().text();
        isMulti = true;
      }

      if ($(`#subButtons-${thisSubredditFragment}`).length === 0) {
        const $subButtonsWrapper = $(`<div id="subButtons-${thisSubredditFragment}" class="subButtons"></div>`);
        $(subButton).wrap($subButtonsWrapper);
        getMultiCounts(thisSubredditFragment).then(multiCount => {
          $(subButton).append(multiCount);
        });

        if (isMulti) {
          const theWrap = $(subButton).parent();
          $(theWrap).appendTo($(theWrap).parent());
        }
      }

      subButton.addEventListener('click', () => {
        ajax.invalidate({
          url: '/subreddits/mine.json',
          query: {
            after: '',
            limit: 100,
            user: loggedInUser()
          }
        });
      });
      const $subButtons = $(`#subButtons-${thisSubredditFragment}`);
      const button = createShortcutToggleButton(subreddit);
      button.classList.add('RESshortcutside');
      $subButtons.append(button);
      const $next = $subButtons.next();

      if ($next.hasClass('title') && !$subButtons.hasClass('swapped')) {
        $subButtons.before($next);
        $subButtons.addClass('swapped');
      }
    }
  }
}

function createShortcutToggleButton(subreddit) {
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveShortcut'), i18n('subredditInfoAddThisSubredditToShortcuts'), mySubredditShortcuts.some(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase()), state => {
    if (state) addSubredditShortcut(subreddit);else removeSubredditShortcut(subreddit);
    redrawShortcuts();
  });
}
let hideSubredditGroupDropdownTimer, showSubredditGroupDropdownTimer;

function redrawShortcuts() {
  shortCutsContainer.textContent = '';
  mySubredditShortcuts.forEach((shortcut, i) => {
    const thisShortCut = document.createElement('a');
    thisShortCut.setAttribute('draggable', 'true');
    thisShortCut.setAttribute('orderIndex', String(i));
    thisShortCut.setAttribute('data-subreddit', shortcut.subreddit);
    thisShortCut.classList.add('subbarlink');

    if (shortcut.subreddit.includes('+')) {
      const currentSub = (currentSubreddit() || '').toLowerCase().split('+').sort().join('+');
      const sortedSubs = shortcut.subreddit.toLowerCase().replace(/\?\+/g, '+').split('+').sort();

      for (const sub of sortedSubs) {
        if (isCurrentSubreddit(sub)) {
          thisShortCut.classList.add('RESShortcutsCurrentSub');
        }
      }

      if (currentSub === sortedSubs.join('+')) {
        thisShortCut.classList.add('RESShortcutsCurrentSub');
      }
    } else if (isCurrentSubreddit(shortcut.subreddit)) {
      thisShortCut.classList.add('RESShortcutsCurrentSub');
    }

    thisShortCut.setAttribute('href', `/r/${shortcut.subreddit.replace(/(?:\?\+.*|\?$)/, '')}`);
    thisShortCut.textContent = shortcut.displayName;
    thisShortCut.addEventListener('click', e => {
      if (e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        return true;
      } else {
        e.preventDefault();
        followSubredditShortcut(e.target.href);
      }
    });
    thisShortCut.addEventListener('dblclick', e => {
      e.preventDefault();
      followSubredditShortcut.cancel();
      hideSubredditGroupDropdown();
      editSubredditShortcut(e.target, e);
    });
    thisShortCut.addEventListener('mouseover', e => {
      clearTimeout(hideSubredditGroupDropdownTimer);
      showSubredditGroupDropdown(e.target);
    });
    thisShortCut.addEventListener('mouseout', () => {
      clearTimeout(showSubredditGroupDropdownTimer);
      hideSubredditGroupDropdownTimer = setTimeout(() => hideSubredditGroupDropdown(), 500);
    });
    thisShortCut.addEventListener('dragstart', subredditDragStart);
    thisShortCut.addEventListener('dragenter', subredditDragEnter);
    thisShortCut.addEventListener('dragover', subredditDragOver);
    thisShortCut.addEventListener('dragleave', subredditDragLeave);
    thisShortCut.addEventListener('drop', subredditDrop);
    thisShortCut.addEventListener('dragend', subredditDragEnd);
    shortCutsContainer.appendChild(thisShortCut);

    if (i < mySubredditShortcuts.length - 1) {
      const sep = document.createElement('span');
      sep.setAttribute('class', 'separator');
      sep.textContent = '-';
      shortCutsContainer.appendChild(sep);
    }

    return shortcut;
  }, this);

  if (mySubredditShortcuts.length === 0) {
    shortCutsContainer.style.textTransform = 'none';
    shortCutsContainer.textContent = 'add shortcuts from the my subreddits menu at left or click the button by the subreddit name, drag and drop to sort';
  } else {
    shortCutsContainer.style.textTransform = '';
  }
}

function showSubredditGroupDropdown(obj) {
  let subreddits = [];
  let suffix = '';

  if (obj.getAttribute && obj.getAttribute('data-subreddit').includes('+')) {
    let cleanSubreddits = obj.getAttribute('data-subreddit');

    if (cleanSubreddits.indexOf('/') > cleanSubreddits.lastIndexOf('+') || subredditManager_module.options.alwaysApplySuffixToMulti.value) {
      let pos;

      if ((pos = cleanSubreddits.lastIndexOf('?')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos);
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }

      if ((pos = cleanSubreddits.lastIndexOf('/')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos) + suffix;
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }
    }

    subreddits = cleanSubreddits.replace(/\?\+/g, '+').split('+');
  }

  if (!(subreddits.length || subredditManager_module.options.dropdownEditButton.value)) {
    return;
  }

  let delay;

  if (subreddits.length) {
    delay = parseInt(subredditManager_module.options.shortcutDropdownDelay.value, 10);
  } else {
    delay = parseInt(subredditManager_module.options.shortcutEditDropdownDelay.value, 10);
  }

  clearTimeout(showSubredditGroupDropdownTimer);
  showSubredditGroupDropdownTimer = setTimeout(() => _showSubredditGroupDropdown(obj, subreddits, suffix), delay);
}

function _showSubredditGroupDropdown(obj, subreddits, suffix) {
  subredditGroupDropdownRefItem = obj;

  if (!$subredditGroupDropdown) {
    $subredditGroupDropdown = $('<div>', {
      id: 'RESSubredditGroupDropdown'
    });
    subredditGroupDropdownUL = document.createElement('ul');
    $subredditGroupDropdown.append(subredditGroupDropdownUL);

    if (subredditManager_module.options.dropdownEditButton.value) {
      $subredditGroupDropdown.append(`
				<div class="RESShortcutsEditButtons">
					<a href="#"  class="delete res-icon" title="delete">&#xF155;</a>
					<a href="#" class="edit res-icon" title="edit">&#xF139;</a>
				</div>
			`);
    }

    $subredditGroupDropdown.appendTo(document.body);
    $subredditGroupDropdown.on('mouseout', () => {
      hideSubredditGroupDropdownTimer = setTimeout(() => {
        hideSubredditGroupDropdown();
      }, 500);
    });
    $subredditGroupDropdown.on('mouseover', () => {
      clearTimeout(hideSubredditGroupDropdownTimer);
    });
    $subredditGroupDropdown.on('click', '.edit', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
    });
    $subredditGroupDropdown.on('click', '.delete', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
      deleteButton.click();
    });
  }

  $(subredditGroupDropdownUL).find('li:not(.RESShortcutsEditButtons)').remove();

  if (subreddits) {
    const $rows = subreddits.reduce(($collection, subreddit) => {
      const $thisLI = $(`<li><a href="/r/${subreddit}${suffix}">${subreddit}<span class="shortcutSuffix">${suffix}</span></a></li>`);

      if (isCurrentSubreddit(subreddit)) {
        $thisLI.addClass('RESShortcutsCurrentSub');
      }

      return $collection.add($thisLI);
    }, $());
    $(subredditGroupDropdownUL).prepend($rows);
  }

  const {
    left
  } = $(obj).offset();
  const {
    bottom
  } = document.querySelector('#sr-header-area').getBoundingClientRect();
  $subredditGroupDropdown.css({
    top: `${bottom}px`,
    left: `${left}px`
  }).show();
}

function hideSubredditGroupDropdown() {
  hideSubredditGroupDropdownTimer = undefined;

  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }
}

function editSubredditShortcut(ele, event) {
  const subreddit = ele.getAttribute('data-subreddit');
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit === subreddit);

  if (!$editShortcutDialog) {
    $editShortcutDialog = $('<div>', {
      id: 'editShortcutDialog'
    }).appendTo(document.body);
  }

  const unsortable = !subreddit.includes('+');
  const thisForm = `
		<form name="editSubredditShortcut">
			<h3>Edit Shortcut</h3>
			<div id="editShortcutClose" class="RESCloseButton">&times;</div>
			<div class="RESFormItem">
				<label for="subreddit">Subreddit:</label>
				<div class="RESFieldItem">
					<input type="text" name="subreddit" value="${subreddit}" id="shortcut-subreddit" class="${unsortable ? 'unsortable' : ''}"><!-- no whitespace
					--><button type="submit" id="sortButton" title="Sort subreddits">A-Z</button>

					<div class="RESDescription">Put a + between subreddits to make a drop-down menu.<br/>Put ?+ to make subreddits after it only show in dropdown.</div>
				</div>
			</div>
			<div class="RESFormItem">
				<label for="displayName">Display Name:</label>
				<div class="RESFieldItem">
					<input type="text" name="displayName" value="${ele.textContent}" id="shortcut-displayname">
				</div>
			</div>
			<input type="hidden" name="idx" value="${idx}">
			<button type="button" name="shortcut-save" id="shortcut-save">save</button>
			<button type="button" name="shortcut-delete" id="shortcut-delete">delete</button>
		</form>
	`;
  $editShortcutDialog.html(thisForm);
  $editShortcutDialog.find('#shortcut-subreddit').on('keyup', throttle_default()(({
    currentTarget: shortcut
  }) => {
    if (!shortcut.value.includes('+')) {
      shortcut.classList.add('unsortable');
    } else {
      shortcut.classList.remove('unsortable');
    }
  }, 500));
  const subredditInput = $editShortcutDialog.find('input[name=subreddit]').get(0);
  const displayNameInput = $editShortcutDialog.find('input[name=displayName]').get(0);
  $editShortcutDialog.find('FORM').on('submit', e => e.preventDefault());
  const saveButton = $editShortcutDialog.find('button[name=shortcut-save]').click(() => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();
    const subreddit = $editShortcutDialog.find('input[name=subreddit]').val();
    const displayName = $editShortcutDialog.find('input[name=displayName]').val();
    saveSubredditShortcut(subreddit, displayName, idx);
    $editShortcutDialog.hide();
  }).get(0);
  deleteButton = $editShortcutDialog.find('button[name=shortcut-delete]').get(0);
  deleteButton.addEventListener('click', () => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();

    if (confirm('Are you sure you want to delete this shortcut?')) {
      saveSubredditShortcut('', '', idx);
      $editShortcutDialog.hide();
    }
  });

  function sortSubmenu(e) {
    const inputEl = $editShortcutDialog.find('input[name=subreddit]').get(0);
    const currStr = inputEl.value;
    const ascArr = currStr.split('+');
    ascArr.sort();
    const ascStr = ascArr.join('+');
    const descArr = ascArr;
    descArr.reverse();
    const descStr = descArr.join('+');
    let btnTxt;

    if (e.target.type === 'submit') {
      inputEl.value = currStr === ascStr ? descStr : ascStr;
      btnTxt = currStr === ascStr ? 'A-Z' : 'Z-A';
    } else {
      btnTxt = currStr === ascStr ? 'Z-A' : 'A-Z';
    }

    $('#sortButton').text(btnTxt);
  }

  $editShortcutDialog.find('#sortButton').click(e => sortSubmenu(e));
  $editShortcutDialog.find('input[name=subreddit]').on('change', e => sortSubmenu(e));
  subredditInput.addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Enter) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  subredditInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      click(saveButton);
    }
  });
  displayNameInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      click(saveButton);
    }
  });
  $editShortcutDialog.find('#editShortcutClose').click(() => {
    $editShortcutDialog.hide();
  });
  $editShortcutDialog.show();
  const thisLeft = Math.min(event.clientX, window.innerWidth - ($editShortcutDialog.get(0).offsetWidth + 20));
  $editShortcutDialog.css('left', `${thisLeft}px`);
  setTimeout(() => subredditInput.focus(), 200);
}

async function saveSubredditShortcut(subreddit, displayName, idx) {
  if (subreddit === '' || displayName === '') {
    subreddit = mySubredditShortcuts[idx].subreddit;
    await removeSubredditShortcut(subreddit);
  } else {
    mySubredditShortcuts[idx] = {
      subreddit,
      displayName,
      addedDate: Date.now()
    };
    saveLatestShortcuts();
  }

  redrawShortcuts();
  await populateSubredditDropdown();
}

const followSubredditShortcut = debounce_default()(url => {
  location.href = url;
}, 300);

let dragSrcEl, srDataTransfer;

function subredditDragStart(e) {
  followSubredditShortcut.cancel();
  this.style.opacity = '0.4';
  dragSrcEl = this;

  if (subredditManager_module.options.dragDropDelete.value) {
    addTrashBin(dragSrcEl);
  }

  e.dataTransfer.effectAllowed = 'move';
  srDataTransfer = `${this.getAttribute('orderIndex')},${$(this).data('subreddit')}`;
}

function subredditDragEnter() {
  this.classList.add('srOver');
  return false;
}

function subredditDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault();
  }

  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }

  e.dataTransfer.dropEffect = 'move';
  return false;
}

function subredditDragLeave() {
  this.classList.remove('srOver');
  return false;
}

function subredditDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }

  e.preventDefault();

  if (dragSrcEl !== this) {
    if (e.target.getAttribute('id') !== 'res-shortcut-trash') {
      const theData = srDataTransfer.split(',');
      const srcOrderIndex = parseInt(theData[0], 10);
      const srcSubreddit = mySubredditShortcuts[srcOrderIndex];
      const destOrderIndex = parseInt(this.getAttribute('orderIndex'), 10);
      const destSubreddit = mySubredditShortcuts[destOrderIndex];
      const rearranged = [];
      let rearrangedI = 0;
      mySubredditShortcuts.forEach((shortcut, i) => {
        if (i !== srcOrderIndex && i !== destOrderIndex) {
          rearranged[rearrangedI] = shortcut;
          rearrangedI++;
        } else if (i === destOrderIndex) {
          if (destOrderIndex > srcOrderIndex) {
            rearranged[rearrangedI] = destSubreddit;
            rearrangedI++;
            rearranged[rearrangedI] = srcSubreddit;
            rearrangedI++;
          } else {
            rearranged[rearrangedI] = srcSubreddit;
            rearrangedI++;
            rearranged[rearrangedI] = destSubreddit;
            rearrangedI++;
          }
        }
      });
      mySubredditShortcuts = rearranged;
      saveLatestShortcuts();
      redrawShortcuts();
    } else {
      const theData = srDataTransfer.split(',');
      const srcSubreddit = theData[1];
      removeSubredditShortcut(srcSubreddit);
    }
  }

  return false;
}

function subredditDragEnd() {
  this.style.opacity = '1';
  this.classList.remove('srOver');

  if (subredditManager_module.options.dragDropDelete.value) {
    removeTrashBin();
  }

  return false;
}

async function createSubredditBar(headerContents) {
  const originalShortcuts = Array.from(document.querySelectorAll('.sr-list a.choice'));
  let myRandomEnabled, myRandomGold;

  if (subredditManager_module.options.linkMyRandom.value) {
    const originalMyRandom = originalShortcuts.find(({
      pathname
    }) => pathname === '/r/myrandom/');

    if (originalMyRandom) {
      myRandomEnabled = true;

      if (originalMyRandom.classList.contains('gold')) {
        myRandomGold = true;
      }
    }
  }

  let usersEnabled;

  if (subredditManager_module.options.linkUsers.value) {
    const originalUsers = originalShortcuts.find(({
      pathname
    }) => pathname === '/users/');

    if (originalUsers) {
      usersEnabled = true;
    }
  }

  const originalFrontpage = originalShortcuts.find(({
    pathname
  }) => pathname === '/');
  const originalPopular = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/popular/');
  const originalProfilePosts = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/profileposts/');
  $(headerContents).html('');
  await shortcutsLoadedPromise;
  const $srLeftContainer = $('<div>', {
    id: 'srLeftContainer',
    class: 'sr-bar'
  });
  const $srDropdown = $('<div>', {
    id: 'srDropdown'
  });
  const $srDropdownContainer = $('<div>', {
    id: 'srDropdownContainer',
    html: '<a href="javascript:void 0">My Subreddits</a>',
    click: toggleSubredditDropdown
  });
  $srDropdown.append($srDropdownContainer);
  $srList = $('<table>', {
    id: 'srList'
  }).appendTo(document.body);
  $srLeftContainer.append($srDropdown);
  const sep = document.createElement('span');
  sep.setAttribute('class', 'srSep');
  sep.textContent = '|';
  $srLeftContainer.append(sep);
  const staticShortCutsContainer = document.createElement('div');
  staticShortCutsContainer.setAttribute('id', 'RESStaticShortcuts');
  $(staticShortCutsContainer).html('');
  const specialButtonSelected = {};
  const selectedShortcut = originalPopular && originalPopular.matches('.selected .choice') ? 'popular' : (currentSubreddit() || 'home').toLowerCase();
  specialButtonSelected[selectedShortcut] = 'RESShortcutsCurrentSub';
  let shortCutsHTML = '';
  if (subredditManager_module.options.linkDashboard.value) shortCutsHTML += `<span class="separator">-</span><a id="RESDashboardLink" class="subbarlink ${specialButtonSelected.dashboard}" href="/r/Dashboard/">Dashboard</a>`;
  if (subredditManager_module.options.linkFront.value && originalFrontpage) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.home}" href="/">${originalFrontpage.textContent}</a>`;
  if (subredditManager_module.options.linkPopular.value && originalPopular) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.popular}" href="/r/popular/">${originalPopular.textContent}</a>`;
  if (subredditManager_module.options.linkProfilePosts.value && originalProfilePosts) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.profileposts}" href="/r/profileposts/">${originalProfilePosts.textContent}</a>`;
  if (subredditManager_module.options.linkAll.value) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.all}" href="/r/all/">All</a>`;
  if (subredditManager_module.options.linkRandom.value) shortCutsHTML += '<span class="separator">-</span><a class="subbarlink" href="/r/random/">Random</a>';
  if (subredditManager_module.options.linkMyRandom.value && myRandomEnabled) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${myRandomGold ? 'gold' : ''}" href="/r/myrandom/">MyRandom</a>`;
  if (subredditManager_module.options.linkUsers.value && usersEnabled) shortCutsHTML += '<span class="separator">-</span><a class="subbarlink" href="/users/">Users</a>';
  if (subredditManager_module.options.linkRandNSFW.value) shortCutsHTML += '<span class="separator over18">-</span><a class="subbarlink over18" href="/r/randnsfw/">RandNSFW</a>';

  if (loggedInUser()) {
    if (subredditManager_module.options.linkFriends.value) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.friends}" href="/r/friends/">Friends</a>`;

    if (isModeratorAnywhere()) {
      if (subredditManager_module.options.linkMod.value) shortCutsHTML += `<span class="separator">-</span><a class="subbarlink ${specialButtonSelected.mod}" href="/r/mod/">Mod</a>`;
      if (subredditManager_module.options.linkModqueue.value) shortCutsHTML += '<span class="separator">-</span><a class="subbarlink" href="/r/mod/about/modqueue">Modqueue</a>';
    }

    if (subredditManager_module.options.linkSaved.value) shortCutsHTML += '<span class="separator">-</span><a class="subbarlink" href="/user/me/saved">Saved</a>';
  }

  if (subredditManager_module.options.buttonEdit.value) shortCutsHTML += `<span class="separator">-</span>${makeUrlHashLink(subredditManager_module.moduleID, '', 'edit', 'subbarlink')}`;
  $(staticShortCutsContainer).append(shortCutsHTML);
  $srLeftContainer.append(staticShortCutsContainer);
  $srLeftContainer.append(sep);
  $srLeftContainer.appendTo(headerContents);
  const shortCutsViewport = document.createElement('div');
  shortCutsViewport.setAttribute('id', 'RESShortcutsViewport');
  headerContents.appendChild(shortCutsViewport);
  shortCutsContainer = document.createElement('div');
  shortCutsContainer.setAttribute('id', 'RESShortcuts');
  shortCutsContainer.setAttribute('class', 'sr-bar');
  shortCutsViewport.appendChild(shortCutsContainer);
  redrawShortcuts();
  const shortCutsEditContainer = document.createElement('div');
  shortCutsEditContainer.setAttribute('id', 'RESShortcutsEditContainer');
  headerContents.appendChild(shortCutsEditContainer);
  sortShortcutsButton = document.createElement('div');
  sortShortcutsButton.setAttribute('id', 'RESShortcutsSort');
  sortShortcutsButton.setAttribute('title', 'sort subreddit shortcuts');
  sortShortcutsButton.textContent = '↑↓';
  sortShortcutsButton.addEventListener('click', showSortMenu);
  shortCutsEditContainer.appendChild(sortShortcutsButton);
  const shortCutsRight = document.createElement('div');
  shortCutsRight.setAttribute('id', 'RESShortcutsRight');
  shortCutsRight.textContent = '>';
  shortCutsRight.addEventListener('click', () => {
    const firstChild = shortCutsContainer.firstChild;
    let marginLeft = firstChild.style.marginLeft;
    marginLeft = parseInt(marginLeft.replace('px', ''), 10);
    if (isNaN(marginLeft)) marginLeft = 0;
    const shiftWidth = $('#RESShortcutsViewport').width() - 80;

    if (shortCutsContainer.offsetWidth > shiftWidth) {
      marginLeft -= shiftWidth;
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
  shortCutsEditContainer.appendChild(shortCutsRight);
  const $shortCutsAdd = $('<div>', {
    id: 'RESShortcutsAdd',
    class: 'res-icon',
    html: '&#xF139;',
    title: 'add shortcut'
  });
  const shortCutsAddFormContainer = document.createElement('div');
  shortCutsAddFormContainer.setAttribute('id', 'RESShortcutsAddFormContainer');
  shortCutsAddFormContainer.style.display = 'none';
  $(shortCutsAddFormContainer).html(`
    <form id="shortCutsAddForm">
      <div><strong>Add Shortcut</strong></div>
      <div class="res-shortcuts-add-tip">Put a &plus; between subreddits to make a multireddit.</div>
      <div><label for="newShortcut">Subreddit:</label><input type="text" id="newShortcut"></div>
      <div><label for="displayName">Display Name:</label><input type="text" id="displayName"></div>
      <input type="submit" name="submit" value="add" id="addSubreddit">
      <div class="res-shortcuts-add-footer"><a href="/subreddits/">manage subscribed</a></div>
    </form>
  `);
  const shortCutsAddFormField = shortCutsAddFormContainer.querySelector('#newShortcut');
  const shortCutsAddFormFieldDisplayName = shortCutsAddFormContainer.querySelector('#displayName');
  shortCutsAddFormField.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      shortCutsAddFormContainer.style.display = 'none';
      shortCutsAddFormField.blur();
    }
  });
  shortCutsAddFormFieldDisplayName.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      shortCutsAddFormContainer.style.display = 'none';
      shortCutsAddFormFieldDisplayName.blur();
    }
  });
  const shortCutsAddForm = shortCutsAddFormContainer.querySelector('#shortCutsAddForm');
  shortCutsAddForm.addEventListener('submit', e => {
    e.preventDefault();
    let subreddit = shortCutsAddFormField.value;
    let displayname = shortCutsAddFormFieldDisplayName.value;
    if (displayname === '') displayname = subreddit;
    subreddit = subreddit.replace(/^\/?r\//i, '');
    shortCutsAddFormField.value = '';
    shortCutsAddFormFieldDisplayName.value = '';
    shortCutsAddFormContainer.style.display = 'none';

    if (subreddit) {
      addSubredditShortcut(subreddit, displayname);
    }
  });
  $shortCutsAdd.click(() => {
    if (shortCutsAddFormContainer.style.display === 'none') {
      shortCutsAddFormContainer.style.display = 'block';
      shortCutsAddFormField.focus();
    } else {
      shortCutsAddFormContainer.style.display = 'none';
      shortCutsAddFormField.blur();
    }
  });
  $shortCutsAdd.appendTo(shortCutsEditContainer);
  document.body.appendChild(shortCutsAddFormContainer);

  if (subredditManager_module.options.dragDropDelete.value) {
    const $trashOpenLink = $('<a>', {
      class: 'res-trash-open',
      href: '#',
      title: 'Choose which shortcuts to remove',
      html: '<span class="res-icon">&#xF155;</span> remove shortcuts...'
    });
    $('#RESShortcutsAddFormContainer .res-shortcuts-add-footer').prepend(' | ').prepend($trashOpenLink);
    $trashOpenLink.click(e => {
      e.preventDefault();
      addTrashBin();
    });
  }

  const shortCutsLeft = document.createElement('div');
  shortCutsLeft.setAttribute('id', 'RESShortcutsLeft');
  shortCutsLeft.textContent = '<';
  shortCutsLeft.addEventListener('click', () => {
    const firstChild = shortCutsContainer.firstChild;
    const containerMargin = parseInt(firstChild.style.marginLeft, 10) || 0;
    const shiftWidth = Math.floor($('#RESShortcutsViewport').width()) - 80;
    const marginLeft = containerMargin + shiftWidth;

    if (marginLeft <= 0) {
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
  shortCutsEditContainer.appendChild(shortCutsLeft);
}

const trashBin = once_default()(() => {
  const $title = $('<div>', {
    class: 'res-shortcut-trash-title'
  });
  const $trashZone = $('<div>', {
    id: 'res-shortcut-trash-zone',
    class: 'res-icon'
  });
  const shortCutsTrash = $trashZone.get(0);
  shortCutsTrash.addEventListener('dragenter', subredditDragEnter);
  shortCutsTrash.addEventListener('dragleave', subredditDragLeave);
  shortCutsTrash.addEventListener('dragover', subredditDragOver);
  shortCutsTrash.addEventListener('drop', subredditDrop);
  const $wrapper = $('<div>', {
    id: 'res-shortcut-trash'
  }).append($title, $trashZone, $('<div>', {
    id: 'res-dragDrop-tip',
    text: 'Did you know? You can arrange shortcuts by dragging them left & right along the top bar.'
  }));
  return {
    $wrapper,
    $trashZone,
    $title
  };
});

const $pageOverlay = once_default()(() => {
  const srHeaderArea = document.querySelector('#sr-header-area');
  return $('<div>', {
    id: 'res-trash-overlay'
  }).css({
    top: `${srHeaderArea.offsetHeight}px`
  }).click(() => removeTrashBin());
});

function addTrashBin(shortcut) {
  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }

  if (shortcut) {
    trashBin().$title.html(string_namespaceObject.escape`Drop here to delete shortcut <strong>${$(shortcut).text()}</strong>`);
  } else {
    trashBin().$title.text('Drag and drop shortcuts to delete them');
  }

  trashBin().$wrapper.appendTo(document.body).show();
  $pageOverlay().appendTo(document.body).show();
}

function removeTrashBin() {
  $pageOverlay().hide();
  trashBin().$wrapper.hide();
  trashBin().$trashZone.removeClass('srOver');
}

function showSortMenu() {
  if (!$sortMenu) {
    $sortMenu = $(`
			<div id="sort-menu" class="drop-choices">
				<p>&nbsp;sort by:</p>
				<a class="choice" data-field="displayName" href="javascript:void 0">display name</a>
				<a class="choice" data-field="addedDate" href="javascript:void 0">added date</a>
			</div>
		`);
    $($sortMenu).find('a').click(sortShortcuts);
    $(document.body).append($sortMenu);
  }

  if ($sortMenu.is(':visible')) {
    $sortMenu.hide();
    return;
  }

  const thisXY = $(sortShortcutsButton).offset();
  thisXY.left = thisXY.left - $sortMenu.width() + $(sortShortcutsButton).width();
  const thisHeight = $(sortShortcutsButton).height();
  $sortMenu.css({
    top: thisXY.top + thisHeight,
    left: thisXY.left
  }).show();
}

function hideSortMenu() {
  $($sortMenu).hide();
}

let currentSort;

function sortShortcuts() {
  hideSortMenu();
  const sortingField = $(this).data('field');
  const asc = !currentSort;
  currentSort = !currentSort;
  mySubredditShortcuts.sort((a, b) => {
    let aField = a[sortingField];
    let bField = b[sortingField];

    if (typeof aField === 'string' && typeof bField === 'string') {
      aField = aField.toLowerCase();
      bField = bField.toLowerCase();
    }

    if (aField === bField) {
      return 0;
    } else if (aField > bField) {
      return asc ? 1 : -1;
    } else {
      return asc ? -1 : 1;
    }
  });
  saveLatestShortcuts();
  redrawShortcuts();
}

let subredditPagesLoaded;

function toggleSubredditDropdown(e) {
  e.stopPropagation();

  if ($srList.css('display') === 'block') {
    $srList.css('display', 'none');
    document.body.removeEventListener('click', toggleSubredditDropdown);
  } else {
    const user = loggedInUser();

    if (user) {
      $srList.html('<tr><td width="360">Loading subreddits (may take a moment)...<div id="subredditPagesLoaded"></div></td></tr>');

      if (!subredditPagesLoaded) {
        subredditPagesLoaded = $srList.find('#subredditPagesLoaded').get(0);
      }

      $srList.css('display', 'block');
      getSubreddits(user);
    } else {
      $srList.html('<tr><td width="360">You must be logged in to load your own list of subreddits. <a style="display: inline; float: left;" href="/subreddits/">browse them all</a></td></tr>');
      $srList.css('display', 'block');
    }

    $srList.click(stopDropDownPropagation);
    document.body.addEventListener('click', toggleSubredditDropdown);
  }
}

function addFilterSearch(theBody) {
  const tableHead = document.createElement('thead');
  const tableRow = document.createElement('tr');
  const tableCol = document.createElement('td');
  const search = document.createElement('input');
  tableCol.setAttribute('colspan', '3');
  search.setAttribute('placeholder', i18n('subredditManagerFilterPlaceholder'));
  tableCol.appendChild(search);
  tableRow.appendChild(tableCol);
  tableHead.appendChild(tableRow);
  requestAnimationFrame(() => {
    search.focus();
  });
  search.addEventListener('keyup', () => {
    for (const row of theBody.children) {
      const subredditName = row.firstChild && row.firstChild.innerText ? row.firstChild.innerText.toLowerCase() : '';

      if (search.value === '' || subredditName.includes(search.value.toLowerCase())) {
        row.style.display = '';
      } else {
        row.style.display = 'none';
      }
    }
  });
  return tableHead;
}

function stopDropDownPropagation(e) {
  e.stopPropagation();
}

let mySubreddits = [];

async function getSubreddits(user) {
  if (gettingSubreddits) return;
  gettingSubreddits = true;
  mySubreddits = [];
  let after = '';
  let page = 0;

  do {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine.json',
      query: {
        after,
        limit: 100,
        user
      },
      type: 'json',
      cacheFor: DAY
    });

    if (data && data.children) {
      subredditPagesLoaded.textContent = `Pages loaded: ${++page}`;
      const subreddits = data.children.map(({
        data
      }) => data);
      mySubreddits.push(...subreddits);
      after = data.after;
    } else {
      populateSubredditDropdown(undefined, true);
      return;
    }
  } while (after);

  mySubreddits = uniqBy_default()(mySubreddits, sr => sr.display_name);
  mySubreddits.sort((a, b) => {
    const adisp = a.display_name.toLowerCase();
    const bdisp = b.display_name.toLowerCase();
    if (adisp > bdisp) return 1;
    if (adisp === bdisp) return 0;
    return -1;
  });
  gettingSubreddits = false;
  populateSubredditDropdown();
}

async function populateSubredditDropdown(sortBy = 'subreddit', badJSON) {
  $srList.html('');
  const tableHead = document.createElement('thead');
  const tableRow = document.createElement('tr');
  const srHeader = document.createElement('td');
  srHeader.addEventListener('click', () => {
    if (sortBy === 'subreddit') {
      populateSubredditDropdown('subredditDesc');
    } else {
      populateSubredditDropdown('subreddit');
    }
  });
  srHeader.textContent = 'subreddit';
  srHeader.setAttribute('width', '200');
  tableRow.appendChild(srHeader);
  const lvHeader = document.createElement('td');

  if (subredditManager_module.options.storeSubredditVisit.value) {
    lvHeader.addEventListener('click', () => {
      if (sortBy === 'lastVisited') {
        populateSubredditDropdown('lastVisitedAsc');
      } else {
        populateSubredditDropdown('lastVisited');
      }
    });
    lvHeader.textContent = 'Last Visited';
    lvHeader.setAttribute('width', '120');
    tableRow.appendChild(lvHeader);
  }

  const scHeader = document.createElement('td');
  $(scHeader).width(50);
  $(scHeader).html('<a style="float: right;" href="/subreddits/">View all &raquo;</a>');
  tableRow.appendChild(scHeader);
  const theBody = document.createElement('tbody');
  tableHead.appendChild(tableRow);

  if (subredditManager_module.options.enableSubredditFilter.value) {
    $srList.append(addFilterSearch(theBody));
  }

  $srList.append(tableHead);

  if (!badJSON) {
    if (typeof subredditsLastViewed === 'undefined') {
      subredditsLastViewed = await subredditsLastViewedStorage.get();
    }

    const sortableSubreddits = mySubreddits.slice();

    if (sortBy === 'lastVisited') {
      $(lvHeader).html('Last Visited <div class="sortAsc"></div>');
      srHeader.textContent = 'subreddit';
      sortableSubreddits.sort((a, b) => {
        const adisp = a.display_name.toLowerCase();
        const bdisp = b.display_name.toLowerCase();
        const alv = typeof subredditsLastViewed[adisp] === 'undefined' ? 0 : parseInt(subredditsLastViewed[adisp].last_visited, 10);
        const blv = typeof subredditsLastViewed[bdisp] === 'undefined' ? 0 : parseInt(subredditsLastViewed[bdisp].last_visited, 10);
        if (alv < blv) return 1;

        if (alv === blv) {
          if (adisp > bdisp) return 1;
          return -1;
        }

        return -1;
      });
    } else if (sortBy === 'lastVisitedAsc') {
      $(lvHeader).html('Last Visited <div class="sortDesc"></div>');
      srHeader.textContent = 'subreddit';
      sortableSubreddits.sort((a, b) => {
        const adisp = a.display_name.toLowerCase();
        const bdisp = b.display_name.toLowerCase();
        const alv = typeof subredditsLastViewed[adisp] === 'undefined' ? 0 : parseInt(subredditsLastViewed[adisp].last_visited, 10);
        const blv = typeof subredditsLastViewed[bdisp] === 'undefined' ? 0 : parseInt(subredditsLastViewed[bdisp].last_visited, 10);
        if (alv > blv) return 1;

        if (alv === blv) {
          if (adisp > bdisp) return 1;
          return -1;
        }

        return -1;
      });
    } else if (sortBy === 'subredditDesc') {
      lvHeader.textContent = 'Last Visited';
      $(srHeader).html('subreddit <div class="sortDesc"></div>');
      sortableSubreddits.sort((a, b) => {
        const adisp = a.display_name.toLowerCase();
        const bdisp = b.display_name.toLowerCase();
        if (adisp < bdisp) return 1;
        if (adisp === bdisp) return 0;
        return -1;
      });
    } else {
      lvHeader.textContent = 'Last Visited';
      $(srHeader).html('subreddit <div class="sortAsc"></div>');
      sortableSubreddits.sort((a, b) => {
        const adisp = a.display_name.toLowerCase();
        const bdisp = b.display_name.toLowerCase();
        if (adisp > bdisp) return 1;
        if (adisp === bdisp) return 0;
        return -1;
      });
    }

    for (const {
      display_name: displayName,
      url
    } of sortableSubreddits) {
      let dateString = 'Never';
      let relativeDateString = '';
      const thisReddit = displayName.toLowerCase();

      if (subredditsLastViewed[thisReddit]) {
        const ts = parseInt(subredditsLastViewed[thisReddit].last_visited, 10);
        const dateVisited = new Date(ts);
        dateString = formatDate(dateVisited);
        relativeDateString = formatRelativeTime(dateVisited);
      }

      const theRow = document.createElement('tr');
      const theSR = document.createElement('td');
      $(theSR).html(string_namespaceObject.escape`<a href="${url}">${displayName}</a>`);
      theRow.appendChild(theSR);

      if (subredditManager_module.options.storeSubredditVisit.value) {
        const theLV = document.createElement('td');

        if (relativeDateString !== '') {
          theLV.textContent = relativeDateString;
          theLV.setAttribute('title', dateString);
        } else {
          theLV.textContent = dateString;
        }

        theLV.setAttribute('class', 'RESvisited');
        theRow.appendChild(theLV);
      }

      const button = createShortcutToggleButton(displayName);
      button.className = '';
      const theSC = document.createElement('td');
      theSC.append(button);
      theRow.appendChild(theSC);
      theBody.appendChild(theRow);
    }
  } else {
    const errorTD = document.createElement('td');
    errorTD.textContent = 'There was an error getting your subreddits. You may have third party cookies disabled by your browser. For this function to work, you\'ll need to add an exception for cookies from reddit.com';
    errorTD.setAttribute('colspan', '3');
    const errorRow = document.createElement('tr');
    errorRow.appendChild(errorTD);
    theBody.appendChild(errorRow);
  }

  $srList.append(theBody);
}

async function getMultiCounts(displayName) {
  if (!subredditManager_module.options.displayMultiCounts.value) return '';
  const user = loggedInUser();
  if (!user) return '';
  const multis = await ajax({
    url: `/api/multi/user/${user}`,
    type: 'json',
    cacheFor: DAY
  });
  const count = multis.filter(multi => multi.data.subreddits.some(sr => sr.name === displayName)).length;
  if (count) return string_namespaceObject.escape`<span class="multi-count" title="${i18n('subredditManagerMultiCountTitle', displayName, count)}">${count}</span>`;else return '';
}

async function getLatestShortcuts() {
  mySubredditShortcuts = await subredditShortcutsStorage.get();
}

function saveLatestShortcuts() {
  subredditShortcutsStorage.set(mySubredditShortcuts || []);
}

async function addSubredditShortcut(subreddit, displayname) {
  await getLatestShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    alert_namespaceObject.open('Whoops, you already have a shortcut for that subreddit');
  } else {
    displayname = displayname || subreddit;
    const subredditObj = {
      subreddit,
      displayName: displayname.toLowerCase(),
      addedDate: Date.now()
    };
    mySubredditShortcuts.push(subredditObj);
    saveLatestShortcuts();
    redrawShortcuts();
    await populateSubredditDropdown();
    notifications_showNotification({
      moduleID: 'subredditManager',
      message: 'Subreddit shortcut added. You can edit by double clicking the shortcut.'
    });
  }
}

async function removeSubredditShortcut(subreddit) {
  await getLatestShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    mySubredditShortcuts.splice(idx, 1);
    saveLatestShortcuts();
    redrawShortcuts();
    await populateSubredditDropdown();
  }
}

async function setLastViewtime(subreddit) {
  if (!subredditManager_module.options.storeSubredditVisit.value) return;
  if (!subredditManager_module.options.storeSubredditVisitIncognito.value && isPrivateBrowsing()) return;
  subredditsLastViewed = await subredditsLastViewedStorage.get();
  subredditsLastViewed[subreddit.toLowerCase()] = {
    last_visited: Date.now()
  };
  subredditsLastViewedStorage.set(subredditsLastViewed);
}

function subscribeToSubreddit(subredditName, subscribe = true) {
  return ajax({
    method: 'POST',
    url: '/api/subscribe',
    data: {
      sr: subredditName,
      action: subscribe ? 'sub' : 'unsub'
    }
  });
}

async function subredditManager_lastUpdate() {
  const mySubredditList = $('.drop-choices.srdrop a').map(function () {
    return this.textContent;
  }).toArray().join();
  const mySubredditListCachedObject = (await session_namespaceObject.get('RESmodules.subredditManager.mySubredditList')) || {};
  const mySubredditListCached = mySubredditListCachedObject[loggedInUser() || 'null'];

  let _lastUpdate;

  if (mySubredditListCached && mySubredditListCached.list === mySubredditList) {
    _lastUpdate = parseInt((new Date().getTime() - mySubredditListCached.time) / 60000, 10);

    if (_lastUpdate > 31) {
      _lastUpdate = false;
      mySubredditListCached.time = new Date().getTime() - 32 * 60000;
    } else {
      _lastUpdate += _lastUpdate > 1 ? ' minutes ago' : ' minute ago';
    }
  } else {
    mySubredditListCachedObject[loggedInUser() || 'null'] = {
      list: mySubredditList,
      time: new Date().getTime()
    };
    _lastUpdate = 'just now';
  }

  if (_lastUpdate !== false && mySubredditListCached) {
    $('.listing-chooser a:first .description').after(`<br /><span class="description"><b>last update:</b><br />${_lastUpdate}</span>`);
  }

  const inactiveThreshold = new Date().getTime() - 2592000000;

  for (const [user, cachedObject] of Object.entries(mySubredditListCachedObject)) {
    if (cachedObject.time < inactiveThreshold) {
      delete mySubredditListCachedObject[user];
    }
  }

  session_namespaceObject.set('RESmodules.subredditManager.mySubredditList', mySubredditListCachedObject);
}
// CONCATENATED MODULE: ./lib/modules/betteReddit.js











const betteReddit_module = new Module('betteReddit');
betteReddit_module.moduleName = 'betteRedditName';
betteReddit_module.category = 'appearanceCategory';
betteReddit_module.description = 'betteRedditDesc';
betteReddit_module.options = {
  commentsLinksNewTabs: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentsLinksNewTabDesc',
    title: 'betteRedditCommentsLinksNewTabTitle'
  },
  fixHideLinks: {
    type: 'boolean',
    value: true,
    description: 'betteRedditFixHideLinksDesc',
    title: 'betteRedditFixHideLinksTitle'
  },
  hideLinkInstant: {
    type: 'boolean',
    value: false,
    description: 'betteRedditHideLinkInstantDesc',
    title: 'betteRedditHideLinkInstantTitle',
    dependsOn: options => options.fixHideLinks.value
  },
  hideLinkFadeDelay: {
    type: 'text',
    value: '5000',
    description: 'betteRedditHideLinkFadeDelayDesc',
    title: 'betteRedditHideLinkFadeDelayTitle',
    advanced: true,
    dependsOn: options => options.fixHideLinks.value && !options.hideLinkInstant.value
  },
  videoTimes: {
    type: 'boolean',
    value: true,
    description: 'betteRedditVideoTimesDesc',
    title: 'betteRedditVideoTimesTitle',
    advanced: true
  },
  videoUploaded: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoUploadedDesc',
    title: 'betteRedditVideoUploadedTitle',
    advanced: true
  },
  videoViewed: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoViewedDesc',
    title: 'betteRedditVideoViewedTitle',
    advanced: true
  },
  pinHeader: {
    type: 'enum',
    values: [{
      name: 'None',
      value: 'none'
    }, {
      name: 'Subreddit Bar only',
      value: 'sub'
    }, {
      name: 'User Bar',
      value: 'userbar'
    }, {
      name: 'Subreddit Bar and User bar',
      value: 'subanduser'
    }, {
      name: 'Full Header',
      value: 'header'
    }],
    value: 'none',
    description: 'betteRedditPinHeaderDesc',
    title: 'betteRedditPinHeaderTitle',
    bodyClass: 'pinHeader'
  },
  showLastEditedTimestamp: {
    type: 'boolean',
    value: true,
    description: 'betteRedditShowLastEditedTimestampDesc',
    title: 'betteRedditShowLastEditedTimestampTitle',
    bodyClass: true
  },
  scoreHiddenTimeLeft: {
    type: 'boolean',
    value: true,
    description: 'betteRedditScoreHiddenTimeLeftDesc',
    title: 'betteRedditScoreHiddenTimeLeftTitle'
  },
  showTimestampPosts: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampPostsDesc',
    title: 'betteRedditShowTimestampPostsTitle',
    bodyClass: true
  },
  showTimestampComments: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampCommentsDesc',
    title: 'betteRedditShowTimestampCommentsTitle',
    bodyClass: true
  },
  showTimestampSidebar: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampSidebarDesc',
    title: 'betteRedditShowTimestampSidebarTitle',
    bodyClass: true
  },
  showTimestampWiki: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampWikiDesc',
    title: 'betteRedditShowTimestampWikiTitle',
    bodyClass: true
  },
  showTimestampModerationLog: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampModerationLogDesc',
    title: 'betteRedditShowTimestampModerationLogTitle',
    bodyClass: true
  },
  restoreSavedTab: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestoreSavedTabDesc',
    title: 'betteRedditRestoreSavedTabTitle'
  },
  doNoCtrlF: {
    type: 'boolean',
    value: false,
    description: 'betteRedditDoNoCtrlFDesc',
    title: 'betteRedditDoNoCtrlFTitle'
  },
  showHiddenSortOptions: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowHiddenSortOptionsDesc',
    title: 'betteRedditShowHiddenSortOptionsTitle',
    bodyClass: true
  },
  truncateLongLinks: {
    type: 'boolean',
    value: false,
    description: 'betteRedditTruncateLongLinksDesc',
    title: 'betteRedditTruncateLongLinksTitle',
    bodyClass: true
  },
  commentCollapseInInbox: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentCollapseInInboxDesc',
    title: 'betteRedditCommentCollapseInInboxTitle',
    bodyClass: true
  },
  restrictScrollEvents: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestrictScrollEventsDesc',
    title: 'betteRedditRestrictScrollEventsTitle',
    advanced: true
  }
};
betteReddit_module.exclude = ['d2x'];

betteReddit_module.beforeLoad = () => {
  if (betteReddit_module.options.commentsLinksNewTabs.value) {
    watchForThings(['comment'], comment => {
      const body = comment.getTextBody();
      if (body) for (const link of body.querySelectorAll('a')) commentsLinksNewTabs(link);
    });
  }

  if (betteReddit_module.options.fixHideLinks.value) {
    watchForThings(['post'], fixHideLinks);
  }

  if (betteReddit_module.options.doNoCtrlF.value) {
    watchForElements(['page'], '.side a.reddit-comment-link', applyNoCtrlF);
    watchForThings(null, thing => {
      for (const link of thing.entry.querySelectorAll('ul.flat-list.buttons li a')) applyNoCtrlF(link);
    });
  }

  if (betteReddit_module.options.videoTimes.value || betteReddit_module.options.videoUploaded.value || betteReddit_module.options.videoViewed.value) {
    watchForThings(['post'], thing => {
      if (thing.isVisible()) fetchVideoData(thing);
    }, {
      immediate: true
    });
    watchForThings(['post'], showVideoData);
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'userbar':
      _addHeaderId('header-bottom-right', true);

      break;

    case 'sub':
      _addHeaderId('sr-header-area');

      break;

    case 'subanduser':
      _addHeaderId('sr-header-area');

      _addHeaderId('header-bottom-right', true);

      break;

    case 'header':
      _addHeaderId('header');

      break;

    case 'none':
    default:
      break;
  }

  if (betteReddit_module.options.restrictScrollEvents.value) {
    const scr = document.createElement('script');
    scr.innerHTML = `{
			// Prevents overzealous Reddit scroll listeners from constantly mutating the DOM while scrolling
			let debounce, lastEvent;
			window.addEventListener('scroll', e => {
				if (!debounce)  debounce = _.debounce(e => window.dispatchEvent(e), 300);
				if (e === lastEvent) return;
				lastEvent = e;
				debounce(e);
				e.stopImmediatePropagation();
			}, true);
		}`;
    document.documentElement.append(scr);
  }
};

betteReddit_module.contentStart = () => {
  if (betteReddit_module.options.scoreHiddenTimeLeft.value && isPageType('comments', 'commentsLinklist')) {
    $('.sitetable').on('mouseenter', '.score-hidden', function () {
      const timeNode = $(this).siblings('time').get(0);

      if (timeNode) {
        if (!this.getAttribute('title').includes('revealed')) {
          const scoreHiddenDuration = parseInt(this.getAttribute('title').match(/[0-9]+/)[0], 10);
          const postTime = new Date(timeNode.getAttribute('datetime')).getTime();
          const minutesLeft = Math.ceil((postTime + scoreHiddenDuration * 60000 - new Date().getTime()) / 60000);

          if (minutesLeft >= 1) {
            this.setAttribute('title', `score will be revealed in ${minutesLeft} minute${minutesLeft > 1 ? 's' : ''}`);
          } else {
            this.setAttribute('title', 'reload page to reveal score');
          }
        }
      }
    });
  }

  const user = loggedInUser();

  if (betteReddit_module.options.restoreSavedTab.value && user && document.querySelector('.with-listing-chooser:not(.profile-page)')) {
    restoreSavedTab(user);
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'header':
      betteReddit_pinHeader();
      break;

    case 'sub':
      pinSubredditBar();
      break;

    case 'subanduser':
      pinSubredditBar();
      pinUserBar();
      break;

    case 'userbar':
      pinUserBar();
      break;

    default:
      break;
  }
};

function commentsLinksNewTabs(link) {
  link.target = '_blank';
  link.rel = 'noopener noreferer';
}

function fixHideLinks(thing) {
  const orig = thing.getHideElement();
  if (!orig) return;
  const a = document.createElement('a');
  a.className = 'noCtrlF';
  a.href = 'javascript:void 0';
  a.setAttribute('action', orig.dataset.eventAction);
  a.textContent = i18n(orig.dataset.eventAction === 'hide' ? 'betteRedditHideLinkLabel' : 'betteRedditUnhideLinkLabel');
  a.addEventListener('click', () => betteReddit_hideLink(a));
  orig.replaceWith(a);
}

const hideTimer = new Map();

function betteReddit_hideLink(clickedLink, action = clickedLink.getAttribute('action')) {
  const timeout = betteReddit_module.options.hideLinkInstant.value ? null : parseInt(betteReddit_module.options.hideLinkFadeDelay.value, 10);
  const thing = Thing_Thing.checkedFrom(clickedLink);

  if (action === 'hide') {
    const expando = expando_Expando.getEntryExpandoFrom(thing);
    if (expando && expando.types.includes('native')) expando.collapse();
    if (timeout === null) $(thing.element).hide();else hideTimer.set(clickedLink, setTimeout(() => $(thing.element).fadeOut(300), timeout));
  }

  try {
    if (action === 'hide') thingHide_hide(thing);else unhide(thing);
  } catch (e) {
    alert_namespaceObject.open(i18n(action === 'hide' ? 'betteRedditHideSubmissionError' : 'betteRedditUnhideSubmissionError'));
    clearTimeout(hideTimer.get(clickedLink));
    $(thing.element).show();
    throw e;
  }
}

const fetchVideoData = memoize_default()(thing => {
  const url = new URL(thing.getPostUrl(), location.origin);
  if (!youtube.domains.some(domain => url.hostname.endsWith(domain))) return;
  const [id] = youtube.detect(url) || [];
  if (id) return youtube.getVideoData && youtube.getVideoData(id);
});

async function showVideoData(thing) {
  const data = await fetchVideoData(thing);
  if (!data) return;
  const {
    title,
    duration,
    publishedAt,
    viewCount
  } = data;
  const link = thing.getPostLink();
  const info = [];

  if (betteReddit_module.options.videoUploaded.value) {
    const uploaded = new Date(publishedAt);
    const dt = `${uploaded.toDateString()} ${uploaded.toTimeString()}`;
    const timeAgo = i18n('submitHelperTimeAgo', formatDateDiff(uploaded));
    info.push(`[<time title="${dt}" datetime="${publishedAt}" class="live-timestamp">${timeAgo}</time>]`);
  }

  if (betteReddit_module.options.videoViewed.value && viewCount) {
    info.push(i18n('betteRedditVideoViewed', viewCount));
  }

  const titleHasTimeRegex = /[\[|\(][0-9]*:[0-9]*[\]|\)]/;
  const getYoutubeStartTimeRegex = /\/?[&|\?]?(?:t|time_continue)=([\w\-][a-z0-9]*)/i;
  const timeMatch = getYoutubeStartTimeRegex.exec(link.href);
  const titleMatch = titleHasTimeRegex.test(link.textContent);
  let startTime;

  if (timeMatch && !titleMatch) {
    const seconds = fromYoutubeTimecodeToSeconds(timeMatch[1]);
    startTime = fromSecondsToTime(seconds);
  }

  if (info.length) {
    link.appendChild(string_namespaceObject.html`<span class="gray pay-link">${string_namespaceObject.safe(info.join(' '))}</span>`);
  }

  link.setAttribute('title', i18n('betteRedditVideoYouTubeTitle', title));

  if (betteReddit_module.options.videoTimes.value) {
    const thumbnail = thing.element.querySelector('a.thumbnail');

    if (thumbnail) {
      thumbnail.appendChild(string_namespaceObject.html`<div class="duration-overlay">${duration}${startTime ? ` (@${startTime})` : ''}</div>`);
    }
  }
}

function fromYoutubeTimecodeToSeconds(tc) {
  let timeSeconds = Number(tc);

  if (Number.isNaN(timeSeconds)) {
    const tcobj = tc.split(/(\d+[hms])/).filter(Boolean).reduce((acc, match) => {
      acc[match.slice(-1)] = Number(match.slice(0, -1));
      return acc;
    }, {});
    timeSeconds = (tcobj.h || 0) * 3600 + (tcobj.m || 0) * 60 + (tcobj.s || 0);
  }

  return timeSeconds;
}

function pinSubredditBar() {
  const sm = isRunning(subredditManager_namespaceObject);
  const sb = document.getElementById('sr-header-area');

  if (!sb) {
    return;
  }

  const header = document.getElementById('header');
  const spacer = document.createElement('div');
  spacer.style.paddingTop = window.getComputedStyle(sb, null).paddingTop;
  spacer.style.paddingBottom = window.getComputedStyle(sb, null).paddingBottom;

  if (sm) {
    spacer.style.height = `${parseInt(window.getComputedStyle(sb, null).height, 10) / 3 - 3}px`;
  } else {
    spacer.style.height = window.getComputedStyle(sb, null).height;
  }

  header.insertBefore(spacer, sb);
  document.body.insertBefore(sb, header);
  addCSS(`
		#header-bottom-left {
			margin-top: 19px;
		}

		div#sr-header-area {
			position: fixed;
			z-index: 10000 !important;
			left: 0;
			right: 0;
		}
	`);
  pinCommonElements(sm);
}

function pinUserBar() {
  const header = document.getElementById('header-bottom-left');
  const userbar = document.getElementById('header-bottom-right');
  window.addEventListener('scroll', debounce_default()(() => {
    if (header.getBoundingClientRect().top > 0) {
      userbar.classList.remove('res-floating-userbar');
    } else {
      userbar.classList.add('res-floating-userbar');
    }
  }, 300));
  pinCommonElements();
}

function betteReddit_pinHeader() {
  const sm = isRunning(subredditManager_namespaceObject);
  const header = document.getElementById('header');

  if (!header) {
    console.error('No element found with ID "header".');
    return;
  }

  const headerHeight = $('#header').outerHeight(true);
  addCSS(`
		#header,
		#RESAccountSwitcherDropdown {
			position: fixed;
		}
	`);
  pinCommonElements(sm);
  addCSS(`
		#header {
			top: 0;
			left: 0;
			right: 0;
			bottom: auto;
		}
	`);
  $('<div>', {
    id: 'RESPinnedHeaderSpacer',
    height: headerHeight
  }).insertBefore(header);
}

function pinCommonElements(sm) {
  if (sm) {
    addCSS(`
			#RESSubredditGroupDropdown,
			#srList,
			#RESShortcutsAddFormContainer,
			#editShortcutDialog {
				position: fixed !important;
			}
		`);
  } else {
    addCSS(`
			#sr-more-link {
				position: fixed;
			}
		`);
  }
}

function restoreSavedTab(user) {
  createElement_namespaceObject.tabMenuItem({
    text: 'saved'
  }).addEventListener('change', () => {
    location.href = `/user/${user}/saved/`;
  });
}

function applyNoCtrlF(element) {
  element.classList.add('noCtrlF');
  element.setAttribute('data-text', element.textContent);
  element.textContent = '';
}
// CONCATENATED MODULE: ./lib/modules/commentDepth.js



const commentDepth_module = new Module('commentDepth');
commentDepth_module.moduleName = 'commentDepthName';
commentDepth_module.category = 'commentsCategory';
commentDepth_module.disabledByDefault = true;
commentDepth_module.description = 'commentDepthDesc';
commentDepth_module.options = {
  defaultCommentDepth: {
    type: 'text',
    value: '4',
    description: 'commentDepthDefaultCommentDepthDesc',
    title: 'commentDepthDefaultCommentDepthTitle'
  },
  defaultMinimumComments: {
    type: 'text',
    value: '50',
    description: 'commentDepthDefaultMinimumCommentsDesc',
    title: 'commentDepthDefaultMinimumCommentsTitle'
  },
  commentPermalinks: {
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermaLinksDesc',
    title: 'commentDepthCommentPermaLinksTitle'
  },
  commentPermalinksContext: {
    dependsOn: options => options.commentPermalinks.value,
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermalinksContextDesc',
    title: 'commentDepthCommentPermalinksContextTitle'
  },
  subredditCommentDepths: {
    type: 'table',
    addRowText: 'commentDepthAddSubreddit',
    fields: [{
      key: 'subreddits',
      name: 'commentDepthSubreddit',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'commentDepth',
      name: 'commentDepthCommentDepth',
      type: 'text',
      value: '4'
    }, {
      key: 'minimumComments',
      name: 'commentDepthMinimumComments',
      type: 'text',
      value: '50'
    }],
    value: [],
    description: 'commentDepthSubredditCommentDepthsDesc',
    title: 'commentDepthSubredditCommentDepthsTitle'
  }
};

commentDepth_module.contentStart = () => {
  $(document.body).on('mousedown', 'a[href*="/comments"]', e => {
    const target = e.target;
    const url = new URL(target.href, location.href);
    if (url.searchParams.has('depth')) return;

    if (regexes.commentPermalink.test(url.pathname)) {
      if (!commentDepth_module.options.commentPermalinks.value) return;
      if (!commentDepth_module.options.commentPermalinksContext.value && url.searchParams.has('context')) return;
    }

    const matches = execRegexes.comments(url.pathname);
    if (!matches) return;
    const subreddit = matches[1].toLowerCase();
    const [, commentDepth, minimumComments] = commentDepth_module.options.subredditCommentDepths.value.find(([subreddits]) => subreddits.toLowerCase().split(',').includes(subreddit)) || [null, commentDepth_module.options.defaultCommentDepth.value, commentDepth_module.options.defaultMinimumComments.value];
    if (!parseInt(commentDepth, 10)) return;
    const minimumCount = parseInt(minimumComments, 10);

    if (minimumCount) {
      const thing = Thing_Thing.from(e.target);
      if (thing && thing.isPost() && (thing.getCommentCount() || 0) < minimumCount) return;
    }

    url.searchParams.set('depth', commentDepth);
    target.removeAttribute('data-inbound-url');
    target.href = url.href;
  });
};
// CONCATENATED MODULE: ./lib/modules/commentHidePersistor.js




const commentHidePersistor_module = new Module('commentHidePersistor');
commentHidePersistor_module.moduleName = 'commentHidePerName';
commentHidePersistor_module.category = 'commentsCategory';
commentHidePersistor_module.description = 'commentHidePerDesc';
commentHidePersistor_module.include = ['comments', 'inbox'];
const COLLAPSE_REASON = 'commentHidePersistor';
const commentHidePersistor_currentId = (execRegexes.comments(location.pathname) || [])[2];
const commentHidePersistor_entryStorage = storage_namespaceObject.wrapPrefix('commentHidePersistor.', () => ({
  updateTime: Date.now()
}));
const commentHidePersistor_initial = commentHidePersistor_currentId && commentHidePersistor_entryStorage.get(commentHidePersistor_currentId);

commentHidePersistor_module.beforeLoad = async () => {
  const {
    collapsedThings
  } = (await commentHidePersistor_initial) || {};
  if (!collapsedThings) return;
  watchForThings(['comment'], thing => {
    if (collapsedThings.hasOwnProperty(thing.getFullname())) thing.setCommentCollapse(true, COLLAPSE_REASON);
  }, {
    immediate: true
  });
};

commentHidePersistor_module.contentStart = () => {
  listenToCommentCollapse();
  maybePruneOldEntries('commentHidePersistor', commentHidePersistor_entryStorage);
};

function listenToCommentCollapse() {
  $(document.body).on('click', 'a.expand', e => {
    const thing = Thing_Thing.checkedFrom(e.target);
    const collapsed = thing.isCollapsed();

    if (collapsed) {
      const currentCollapseReason = e.target.getAttribute('collapse-reason');
      if (currentCollapseReason && currentCollapseReason !== COLLAPSE_REASON) return;
      commentHidePersistor_entryStorage.patch(commentHidePersistor_currentId, {
        collapsedThings: {
          [thing.getFullname()]: true
        },
        updateTime: Date.now()
      });
    } else {
      e.target.removeAttribute('collapse-reason');
      commentHidePersistor_entryStorage.deletePath(commentHidePersistor_currentId, 'collapsedThings', thing.getFullname());
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/commentPreview.js












const commentPreview_module = new Module('commentPreview');
commentPreview_module.moduleName = 'commentPrevName';
commentPreview_module.category = 'commentsCategory';
commentPreview_module.description = 'commentPrevDesc';
commentPreview_module.options = {
  enableBigEditor: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableBigEditorDesc',
    title: 'commentPreviewEnableBigEditorTitle'
  },
  swapBigEditorLayout: {
    type: 'boolean',
    value: false,
    description: 'commentPreviewSwapBigEditorLayoutDesc',
    title: 'commentPreviewSwapBigEditorLayoutTitle',
    bodyClass: true
  },
  openBigEditor: {
    type: 'keycode',
    value: [69, false, true, false, false],
    description: 'commentPreviewOpenBigEditorDesc',
    title: 'commentPreviewOpenBigEditorTitle'
  },
  draftStyle: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewDraftStyleDesc',
    title: 'commentPreviewDraftStyleTitle',
    advanced: true,
    bodyClass: true
  },
  enableForComments: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForCommentsDesc',
    title: 'commentPreviewEnableForCommentsTitle',
    advanced: true
  },
  enableForPosts: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForPostsDesc',
    title: 'commentPreviewEnableForPostsTitle',
    advanced: true
  },
  enableForWiki: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForWikiDesc',
    title: 'commentPreviewEnableForWikiTitle',
    advanced: true
  },
  enableForSubredditConfig: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForSubredditConfigDesc',
    title: 'commentPreviewEnableForSubredditConfigTitle',
    advanced: true
  },
  enableForBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForBanMessagesDesc',
    title: 'commentPreviewEnableForBanMessagesTitle',
    advanced: true
  },
  sidebarPreview: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewSidebarPreviewDesc',
    title: 'commentPreviewSidebarPreviewTitle',
    advanced: true
  }
};
commentPreview_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'wiki'];
commentPreview_module.exclude = ['d2x', /^\/(?:r\/[\-\w\.]+\/)?wiki\/edit\/config\/automoderator\b/i];
const subredditImages = new Map();
let isWiki, isBan;

commentPreview_module.beforeLoad = () => {
  isWiki = isPageType('wiki');
  isBan = /^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned/i.test(location.href);
  const subreddit = currentSubreddit();
  if (isWiki && subreddit) initWikiImages(subreddit);
};

commentPreview_module.contentStart = () => {
  if (commentPreview_module.options.enableBigEditor.value) {
    $(document.body).on('click', '.RESBigEditorPop', showBigEditor);

    if (isRunning(keyboardNav_namespaceObject)) {
      $(document.body).on('keydown', '.usertext-edit textarea, #wiki_page_content', e => {
        if (checkKeysForEvent(e, commentPreview_module.options.openBigEditor.value)) {
          showBigEditor(e);
        }
      });
    }
  }

  if (isWiki) {
    attachWikiPreview();
    addBigEditorButton(document.querySelector('.markhelp'));
  } else {
    $(document.body).on('focus', commentTextareaSelector, e => {
      addBigEditorButton(e.target);
      attachPreview(e.target);
    });
  }
};

async function initWikiImages(subreddit) {
  const {
    data
  } = await ajax({
    url: `/r/${subreddit}/about/stylesheet.json`,
    type: 'json'
  });

  if (data && data.images) {
    for (const {
      name,
      url
    } of data.images) {
      subredditImages.set(name, url);
    }
  }
}

function markdownToHTML(md) {
  if (isBan && md.length) {
    md = generateBanMessage(md, currentSubreddit() || '');
  }

  if (!isWiki) {
    return snudown_es_markdown(md);
  } else {
    const $doc = $('<body>').html(markdownWiki(md));

    for (const img of $doc.find('img')) {
      const src = img.getAttribute('src');
      const imgKey = src && src.startsWith('%%') && src.endsWith('%%') && src.slice('%%'.length, -'%%'.length);
      const resolvedSrc = imgKey && subredditImages.get(imgKey);

      if (resolvedSrc) {
        img.src = resolvedSrc;
      } else {
        img.remove();
      }
    }

    const headerIds = new Map();
    const headers = $doc.find('h1, h2, h3, h4, h5, h6');
    const tocDiv = $('<div>').addClass('toc');
    let $parent = $('<ul>');
    $parent.data('level', 1);
    tocDiv.append($parent);
    let level = 1;
    let previous = 1;
    headers.each(function () {
      const contents = $(this).text();
      let aid = $('<div>').html(contents).text();
      aid = `${'wiki'}_${aid.replace(/ /g, '_').toLowerCase()}`;
      aid = aid.replace(/[^\w\.\-]/g, s => `.${s.charCodeAt(0).toString(16).toUpperCase()}`);
      const idNum = (headerIds.get(aid) || 0) + 1;
      headerIds.set(aid, idNum);

      if (idNum > 1) {
        aid += idNum;
      }

      $(this).attr('id', aid);
      const li = $('<li>').addClass(aid);
      const a = $('<a>').attr('href', `#${aid}`).text(contents);
      li.append(a);
      const thisLevel = +this.tagName.slice(-1);

      if (thisLevel > previous) {
        const $newUL = $('<ul>');
        $newUL.data('level', thisLevel);
        $parent.append($newUL);
        $parent = $newUL;
        level++;
      } else if (thisLevel < previous) {
        while (level > 1 && $parent.data('level') > thisLevel) {
          $parent = $parent.parent();
          level--;
        }
      }

      previous = thisLevel;
      $parent.append(li);
    });
    $doc.prepend(tocDiv);
    return $doc.html();
  }
}

const addBigEditorButton = memoize_default()(ele => {
  if (!commentPreview_module.options.enableBigEditor.value) return;
  const bigEditorButton = preventCloning(string_namespaceObject.html`
		<button type="button" class="RESBigEditorPop" tabIndex="3">
			<span class="res-icon res-icon-12">&#xF0A4;</span> big editor
		</button>
	`);

  if (isBan || isWiki) {
    ele.after(bigEditorButton);
  } else {
    const container = ele.closest('.usertext-edit');
    if (!container) return;
    const bottom = container.querySelector('.bottom-area');
    bottom.prepend(bigEditorButton);
  }
});

const attachPreview = memoize_default()(textarea => {
  if (!commentPreview_module.options.enableForComments.value && textarea.closest('.commentarea, .message') || !commentPreview_module.options.enableForPosts.value && (isPageType('submit') || textarea.closest('.link')) || !commentPreview_module.options.enableForSubredditConfig.value && /^\/r\/[\-\w.]+\/about\/edit/i.test(location.pathname) || !commentPreview_module.options.enableForBanMessages.value && isBan) {
    return;
  }

  const container = textarea.closest('.usertext-edit, #banned');
  if (!container) return;
  const preview = preventCloning(makePreviewBox());
  const elements = [preview.querySelector('.RESDialogContents')];

  if (commentPreview_module.options.sidebarPreview.value && textarea.getAttribute('name') === 'description') {
    elements.push(document.querySelector('.side .usertext-body .md'));
  }

  $(textarea).on('input', debounce_default()(() => onTextareaInput(textarea, preview, elements), 100));
  onTextareaInput(textarea, preview, elements);
  $(textarea.closest('form')).on('submit', () => {
    preview.remove();
  });
  container.append(preview);
});

function attachWikiPreview() {
  if (!commentPreview_module.options.enableForWiki.value) return;
  const preview = makePreviewBox();
  preview.querySelector('.md').classList.add('wiki');
  document.querySelector('#editform > br').after(preview);
  const contents = preview.querySelector('.RESDialogContents');
  $('#wiki_page_content').on('input focus', debounce_default()(e => onTextareaInput(e.target, preview, [contents]), 100));
}

function onTextareaInput(textarea, preview, elements) {
  const markdownText = downcast(textarea, HTMLTextAreaElement).value;

  if (markdownText.length) {
    if (preview) preview.hidden = false;

    for (const ele of elements) ele.innerHTML = markdownToHTML(markdownText);
  } else {
    if (preview) preview.hidden = true;

    for (const ele of elements) empty(ele);
  }
}

function makePreviewBox() {
  return string_namespaceObject.html`
		<div class="RESDialogSmall livePreview">
			<h3>Live Preview</h3>
			${string_namespaceObject.safe(makeUrlHashLink(commentPreview_module.moduleID, undefined, ' ', 'gearIcon'))}
			<div class="md RESDialogContents"></div>
		</div>
	`;
}

let bigTextTarget;

const createBigEditor = once_default()(() => {
  const $editor = $('<div id="BigEditor">');
  const $left = $('<div class="BELeft RESDialogSmall"><h3>Editor</h3></div>');
  const $contents = $('<div class="RESDialogContents"><textarea id="BigText" name="text" class=""></textarea></div>');
  const $textarea = $contents.find('textarea');
  const $foot = $('<div class="BEFoot">');

  if (!isBan) {
    $foot.append($('<button type="button">save</button>').on('click', () => {
      const len = $textarea.val().length;
      const max = $textarea.data('max-length');

      if (len > max) {
        $('#BigEditor .errorList .error').hide().filter('.TOO_LONG').text(`this is too long (max: ${max})`).show();
      } else if (len === 0) {
        $('#BigEditor .errorList .error').hide().filter('.NO_TEXT').show();
      } else if (bigTextTarget) {
        hideBigEditor();
        bigTextTarget.closest('form').find('input[type=submit], button[type=submit]').get(0).click();
      } else {
        $('#BigEditor .errorList .error').hide().filter('.NO_TARGET').show();
      }
    }));
  }

  $foot.append($('<button type="button">close</button>').on('click', hideBigEditor));
  $foot.append($(`
		<span class="errorList">
			<span style="display: none;" class="error NO_TEXT">we need something here</span>
			<span style="display: none;" class="error TOO_LONG">this is too long (max: 10000)</span>
			<span style="display: none;" class="error NO_TARGET">there is no associated textarea</span>
		</span>
	`));
  $contents.append($foot);
  $left.append($contents);
  const $right = $(`
		<div class="BERight RESDialogSmall"><h3>Preview</h3><div class="RESCloseButton">X</div>
		<div class="RESDialogContents"><div id="BigPreview" class=" md"></div></div></div>
	`);
  $editor.append($left).append($right);
  $right.find('.RESCloseButton').on('click', hideBigEditor);
  const $preview = $right.find('#BigPreview');
  $textarea.on('input', debounce_default()(() => onTextareaInput($textarea.get(0), null, [$preview.get(0)]), 100));
  $editor.on('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      hideBigEditor();
      e.preventDefault();
      return false;
    }
  });
  return $editor;
});

function showBigEditor(e) {
  e.preventDefault();
  const $editor = createBigEditor();
  $(document.body).append($editor).addClass('RESScrollLock');
  const $textarea = $editor.find('textarea');
  let $baseText;

  if (!isWiki && !isBan) {
    $baseText = $(e.target).parents('.usertext-edit:first').find('textarea');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    $('#BigPreview').removeClass('wiki');
    $('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else if (isBan) {
    $baseText = $('#ban_message');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    $('#BigPreview').removeClass('wiki');
    $('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else {
    $baseText = $('#wiki_page_content');
    $('#BigPreview').addClass('wiki');
    $('.BERight .RESDialogContents').addClass('wiki-page-content');
  }

  const markdown = $baseText.val();
  const maxLength = $baseText.data('max-length');
  $textarea.data('max-length', maxLength).val(markdown).focus();
  bigTextTarget = $baseText;
  $textarea.get(0).dispatchEvent(new Event('input', {
    bubbles: true,
    cancelable: true
  }));
}

function hideBigEditor() {
  const $editor = createBigEditor();
  const $textarea = $editor.find('textarea');
  $editor.get(0).remove();
  $(document.body).removeClass('RESScrollLock');

  if (bigTextTarget) {
    bigTextTarget.val($textarea.val());
    bigTextTarget.focus();
    bigTextTarget.get(0).dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
    bigTextTarget = null;
  }
}

function generateBanMessage(message, subreddit) {
  return [`you have been banned from posting to [/r/${subreddit}](/r/${subreddit}).`, '', 'note from the moderators:', '', message.replace(/^/gm, '> '), '', 'you can contact the moderators regarding your ban by replying to this message. **warning**: using other accounts to circumvent a subreddit ban is considered a violation of reddit\'s [site rules](/rules) and can result in being banned from reddit entirely.'].join('\r\n');
}
// CONCATENATED MODULE: ./lib/modules/commentQuickCollapse.js





const commentQuickCollapse_module = new Module('commentQuickCollapse');
commentQuickCollapse_module.moduleName = 'commentQuickCollapseName';
commentQuickCollapse_module.category = 'commentsCategory';
commentQuickCollapse_module.description = 'commentQuickCollapseDesc';
commentQuickCollapse_module.options = {
  hideCommentsOnHeaderDoubleClick: {
    type: 'boolean',
    value: true,
    description: 'hideCommentsOnHeaderDoubleClickDesc',
    title: 'hideCommentsOnHeaderDoubleClickTitle'
  },
  toggleCommentsOnClickLeftEdge: {
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsOnClickLeftEdgeDesc',
    title: 'toggleCommentsOnClickLeftEdgeTitle'
  },
  leftEdgeColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#D1D1D1',
    description: 'toggleCommentsLeftEdgeColorDesc',
    title: 'toggleCommentsLeftEdgeColorTitle'
  },
  leftEdgeHoverColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#B1B1B1',
    description: 'toggleCommentsLeftEdgeHoverColorDesc',
    title: 'toggleCommentsLeftEdgeHoverColorTitle'
  },
  leftEdgeCollapsedColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#B1B1B1',
    description: 'toggleCommentsLeftEdgeCollapsedColorDesc',
    title: 'toggleCommentsLeftEdgeCollapsedColorTitle'
  },
  leftEdgeWidth: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'text',
    value: '50',
    description: 'toggleCommentsLeftEdgeWidthDesc',
    title: 'toggleCommentsLeftEdgeWidthTitle'
  },
  hideCollapseButton: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsLeftEdgeHideButtonDesc',
    title: 'toggleCommentsLeftEdgeHideButtonTitle'
  },
  scrollOnCollapse: {
    type: 'boolean',
    value: false,
    description: 'scrollOnCollapseDesc',
    title: 'scrollOnCollapseTitle'
  }
};
commentQuickCollapse_module.include = ['comments'];

commentQuickCollapse_module.beforeLoad = () => {
  if (commentQuickCollapse_module.options.toggleCommentsOnClickLeftEdge.value) {
    toggleCommentsOnClickLeftEdge();
  }
};

commentQuickCollapse_module.contentStart = () => {
  if (commentQuickCollapse_module.options.hideCommentsOnHeaderDoubleClick.value) {
    hideCommentsOnHeaderDoubleClick();
  }

  if (commentQuickCollapse_module.options.scrollOnCollapse.value) {
    scrollOnCollapse();
  }
};

function hideCommentsOnHeaderDoubleClick() {
  $('.commentarea').on('dblclick', '.tagline', e => {
    const thing = Thing_Thing.checkedFrom(e.target);
    thing.setCommentCollapse(!thing.isCollapsed(), 'commentQuickCollapse');

    if (window.getSelection()) {
      window.getSelection().removeAllRanges();
    }
  });
}

function toggleCommentsOnClickLeftEdge() {
  const leftEdgeWidth = clamp_default()(parseInt(commentQuickCollapse_module.options.leftEdgeWidth.value, 10), 0, parseInt(commentQuickCollapse_module.options.leftEdgeWidth.default, 10)) / 100;
  addCSS(`
		.commentarea .comment {
			padding-left: ${2.5 * leftEdgeWidth}em !important;
		}

		.commentarea .comment > .entry > .tagline > .expand:hover {
			background-color: ${commentQuickCollapse_module.options.leftEdgeHoverColor.value};
		}

		.commentarea .entry > .tagline > .expand {
			width: ${2 * leftEdgeWidth}em !important;
			background-color: ${commentQuickCollapse_module.options.leftEdgeColor.value};
		}

		.commentarea .collapsed > .entry > .tagline > .expand {
			background-color: ${commentQuickCollapse_module.options.leftEdgeCollapsedColor.value};
		}
	`);
}

function scrollOnCollapse() {
  $(document.body).on('click', '.expand', event => {
    if (click.isProgrammaticEvent(event)) return;
    const thing = Thing_Thing.checkedFrom(event.target);
    if (thing.element.classList.contains('noncollapsed')) return;
    const target = thing.getClosest(Thing_Thing.prototype.getNextSibling, {
      direction: 'down'
    });
    if (!target) return;
    selectedEntry_select(target, {
      scrollStyle: 'adopt',
      from: thing.entry
    });
  });
}
// CONCATENATED MODULE: ./lib/modules/commentSortBy.js



const commentSortBy_module = new Module('commentSortBy');
commentSortBy_module.moduleName = 'commentSortBy';
commentSortBy_module.category = 'commentsCategory';
commentSortBy_module.disabledByDefault = false;
commentSortBy_module.description = 'addCommentSortPrefMenuItemDesc';
commentSortBy_module.include = ['d2x'];

commentSortBy_module.beforeLoad = () => {
  watchForRedditEvents('postModTools', (element, {
    _: {
      update
    }
  }) => {
    if (update) return;

    const _base = document.querySelector('#CommentSort--SortPicker');

    const base = _base && _base.parentElement;
    if (!base || base.querySelector('.sortByPrefLink')) return;
    base.append(string_namespaceObject.html`
			<a
				class="sortByPrefLink gearIcon"
				style="opacity: 0.3;"
				title="${i18n('addCommentSortPrefMenuItemLinkTitle')}"
				href="https://old.reddit.com/prefs/#default_comment_sort"
				target="_blank"
			>${'\u00A0'}</a>
		`);
  });
};
// CONCATENATED MODULE: ./lib/modules/commentStyle.js


const commentStyle_module = new Module('commentStyle');
commentStyle_module.moduleName = 'commentStyleName';
commentStyle_module.category = 'appearanceCategory';
commentStyle_module.description = 'commentStyleDesc';
commentStyle_module.options = {
  commentBoxes: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentBoxesDesc',
    title: 'commentStyleCommentBoxesTitle',
    bodyClass: 'res-commentBoxes'
  },
  commentRounded: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentRoundedDesc',
    title: 'commentStyleCommentRoundedTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentBoxes-rounded'
  },
  commentHoverBorder: {
    type: 'boolean',
    value: false,
    description: 'commentStyleCommentHoverBorderDesc',
    title: 'commentStyleCommentHoverBorderTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentHoverBorder'
  },
  commentIndent: {
    type: 'text',
    value: '10',
    description: 'commentStyleCommentIndentDesc',
    title: 'commentStyleCommentIndentTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value
  },
  continuity: {
    type: 'boolean',
    value: false,
    description: 'commentStyleContinuityDesc',
    title: 'commentStyleContinuityTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-continuity'
  }
};
commentStyle_module.include = ['comments', 'commentsLinklist'];
commentStyle_module.exclude = ['d2x'];

commentStyle_module.beforeLoad = () => {
  if (commentStyle_module.options.commentBoxes.value && commentStyle_module.options.commentIndent.value) {
    addCSS(`
			.res-commentBoxes .comment {
				margin-left: ${commentStyle_module.options.commentIndent.value}px !important;
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/context.js



const context_module = new Module('context');
context_module.moduleName = 'contextName';
context_module.category = 'commentsCategory';
context_module.description = 'contextDesc';
context_module.options = {
  viewFullContext: {
    type: 'boolean',
    value: true,
    description: 'contextViewFullContextDesc',
    title: 'contextViewFullContextTitle'
  },
  defaultContext: {
    type: 'text',
    value: '3',
    description: 'contextDefaultContextDesc',
    title: 'contextDefaultContextTitle'
  }
};
context_module.include = ['comments', 'commentsLinklist', 'inbox', 'profile', 'modqueue'];

context_module.go = () => {
  if (isPageType('comments') && context_module.options.viewFullContext.value) {
    addViewFullContext();
  }

  const defaultContext = parseInt(context_module.options.defaultContext.value, 10);

  if (isPageType('commentsLinklist', 'inbox', 'profile', 'modqueue') && defaultContext >= 0) {
    setDefaultContext(defaultContext);
  }
};

function addViewFullContext() {
  if (location.search !== '?context=10000') {
    const pInfobar = document.querySelector('.infobar:not(#searchexpando) p');

    if (pInfobar) {
      if ($('.sitetable:eq(1) .buttons:first .bylink').length > 1) {
        pInfobar.append('\u00A0', string_namespaceObject.html`<a href="?context=10000">view the full context</a>`, '\u00A0→');
      }
    }
  }
}

function setDefaultContext(contextDepth) {
  $(document.body).on('mousedown', 'a.bylink', e => {
    const target = e.target;
    target.href = target.href.replace(/(\?|&|;)context=\d+\b/, `$1context=${contextDepth}`);
  });
}
// CONCATENATED MODULE: ./lib/modules/contribute.js




const contribute_module = new Module('contribute');
contribute_module.moduleName = 'contributeName';
contribute_module.category = 'aboutCategory';
contribute_module.sort = -9;
contribute_module.alwaysEnabled = true;
contribute_module.description = 'contributeDesc';

contribute_module.contentStart = () => {
  addMenuItem(() => string_namespaceObject.html`<span>${i18n('donateToRES')} &#8679;</span>`, () => {
    openNewTab('https://redditenhancementsuite.com/contribute/');
  });
};
// CONCATENATED MODULE: ./lib/modules/disableChat.js



const disableChat_module = new Module('disableChat');
disableChat_module.moduleName = 'disableChatName';
disableChat_module.category = 'productivityCategory';
disableChat_module.description = 'disableChatDesc';
disableChat_module.disabledByDefault = true;

disableChat_module.beforeLoad = () => {
  bodyStart.then(() => {
    watchForChildren(document.body, 'script', ele => {
      const script = downcast(ele, HTMLScriptElement);
      if (/^\/_chat/.test(new URL(script.src, location.origin).pathname)) script.remove();
    });
    watchForChildren(document.body, '#chat-app', ele => {
      ele.remove();
    });
  });
};

disableChat_module.contentStart = () => {
  const icon = document.body.querySelector('#chat');

  if (icon) {
    if (icon.nextElementSibling) icon.nextElementSibling.remove();
    icon.remove();
  }
};
// CONCATENATED MODULE: ./lib/modules/localDate.js


const localDate_module = new Module('localDate');
localDate_module.moduleName = 'localDateName';
localDate_module.category = 'myAccountCategory';
localDate_module.description = 'localDateDesc';

localDate_module.contentStart = () => {
  $(document.body).on('mouseenter', 'time', function () {
    const $this = $(this);

    if (!$this.data('originalTitle')) {
      $this.data('originalTitle', $this.attr('title'));
    }

    $this.attr('title', new Date($this.attr('datetime')));
  }).on('mouseleave', 'time', function () {
    const $this = $(this);
    $this.attr('title', $this.data('originalTitle'));
  });
};
// CONCATENATED MODULE: ./lib/modules/logoLink.js


const logoLink_module = new Module('logoLink');
logoLink_module.moduleName = 'logoLinkName';
logoLink_module.category = 'browsingCategory';
logoLink_module.description = 'logoLinkDesc';
logoLink_module.options = {
  redditLogoDestination: {
    type: 'enum',
    value: 'frontpage',
    description: 'logoLinkRedditLogoDestinationDesc',
    title: 'logoLinkRedditLogoDestinationTitle',
    values: [{
      name: 'logoLinkFrontpage',
      value: 'frontpage'
    }, {
      name: 'logoLinkAll',
      value: 'all'
    }, {
      name: 'logoLinkHot',
      value: 'hot'
    }, {
      name: 'logoLinkDashboard',
      value: 'dashboard'
    }, {
      name: 'logoLinkCurrent',
      value: 'subreddit'
    }, {
      name: 'logoLinkMyUserPage',
      value: '/u/me'
    }, {
      name: 'logoLinkInbox',
      value: '/message/inbox'
    }, {
      name: 'logoLinkCustom',
      value: 'custom'
    }]
  },
  customDestination: {
    dependsOn: options => options.redditLogoDestination.value === 'custom',
    type: 'text',
    value: '/',
    description: 'logoLinkCustomDestinationDesc',
    title: 'logoLinkCustomDestinationTitle'
  }
};

logoLink_module.contentStart = () => {
  const redditLogoNode = document.getElementById('header-img-a') || document.getElementById('header-img') || document.querySelector('header a[href="/"]');

  if (redditLogoNode) {
    const url = getLogoLinkUrl();

    if (url) {
      redditLogoNode.href = url;
    }
  }
};

function getLogoLinkUrl() {
  const destination = logoLink_module.options.redditLogoDestination.value;

  switch (destination) {
    case 'frontpage':
      return false;

    case 'all':
      return '/r/all';

    case 'hot':
      return '/hot';

    case 'dashboard':
      return '/r/Dashboard';

    case 'subreddit':
      return $('.redditname > a').attr('href');

    case 'custom':
      return logoLink_module.options.customDestination.value;

    default:
      return destination;
  }
}
// CONCATENATED MODULE: ./lib/modules/messageMenu.js







const messageMenu_module = new Module('messageMenu');
messageMenu_module.moduleName = 'messageMenuName';
messageMenu_module.category = 'browsingCategory';
messageMenu_module.description = 'messageMenuDesc';
messageMenu_module.options = {
  links: {
    type: 'table',
    addRowText: 'messageMenuAddShortcut',
    fields: [{
      key: 'label',
      name: 'messageMenuLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'messageMenuUrl',
      type: 'text'
    }],
    value: [['compose', '/message/compose'], ['all', '/message/inbox'], ['unread', '/message/unread'], ['messages', '/message/messages'], ['comment replies', '/message/comments'], ['post replies', '/message/selfreply'], ['/u/ mentions', '/message/mentions']],
    description: 'messageMenuLinksDesc',
    title: 'messageMenuLinksTitle'
  },
  useQuickMessage: {
    type: 'boolean',
    description: 'messageMenuUseQuickMessageDesc',
    title: 'messageMenuUseQuickMessageTitle',
    value: true
  },
  hoverDelay: {
    type: 'text',
    value: '1000',
    description: 'messageMenuHoverDelayDesc',
    title: 'messageMenuHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    type: 'text',
    value: '200',
    description: 'messageMenuFadeDelayDesc',
    title: 'messageMenuFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    type: 'text',
    value: '0.7',
    description: 'messageMenuFadeSpeedDesc',
    title: 'messageMenuFadeSpeedTitle',
    advanced: true
  }
};

messageMenu_module.contentStart = () => {
  $('#mail, .mail-count, #NREMail, #NREMailCount').on('mouseenter', onMouseEnter);
};

function onMouseEnter(e) {
  dropdownList(messageMenu_module.moduleID).target(e.target).options({
    openDelay: parseFloat(messageMenu_module.options.hoverDelay.value),
    fadeDelay: parseFloat(messageMenu_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(messageMenu_module.options.fadeSpeed.value)
  }).populateWith(populate).begin();
}

const populate = once_default()(() => [messageMenu_module.options.links.value.map(populateItem).reduce((collection, item) => collection.add(item), $()).add(populateItem([`<i>${i18n(messageMenu_module.moduleName)}</i>`, makeUrlHash(messageMenu_module.moduleID)]))]);

function populateItem(link) {
  if (!(link && link.length >= 2)) {
    return $();
  }

  const label = link[0] || '';
  const url = link[1] || '';
  const compose = url.includes('/message/compose');
  const $link = $('<a />').safeHtml(label).attr('href', url);

  if (compose) {
    $link.append('<span class="RESMenuItemButton res-icon">&#xF139;</span>');
  } else if (isSettingsUrl(url)) {
    $link.append('<span class="RESMenuItemButton gearIcon" />');
  }

  if (messageMenu_module.options.useQuickMessage.value && compose) {
    $link.on('click', e => {
      e.target = $(e.target).closest('a').get(0);

      if (onClickMessageLink(e)) {
        e.preventDefault();
      }
    });
  }

  $link.on('click', () => dropdownList(messageMenu_module.moduleID).close());
  return $('<li />').append($link);
}
// CONCATENATED MODULE: ./lib/modules/modhelper.js




const modhelper_module = new Module('modHelper');
modhelper_module.moduleName = 'modhelperName';
modhelper_module.category = 'coreCategory';
modhelper_module.description = 'modhelperDesc';
modhelper_module.hidden = true;
modhelper_module.alwaysEnabled = true;
modhelper_module.include = ['stylesheet'];

modhelper_module.go = () => {
  doStyleSheetCheck();
};

const modhelper_tips = {
  'no-res-styles': 'It appears you haven\'t done any styling specific to RES.  If you are interested in a quick overview on styling for RES users, please see [our wiki article](/r/Enhancement/wiki/subredditstyling)',
  keyNav: 'Styling `RES-keyNav-activeElement`? This is the element RES uses for Keyboard Navigation - it indicates the currently selected post, and is crucial to RES functionality. If you don\'t like the way it looks with your theme, you may style it however you want, as long as Keyboard Navigation remains usable for your visitors.',
  'keyNav-benice': `It appears that you are hiding \`RES-keyNav-activeElement\`. This negatively affects RES users by rendering keyboard navigation unusable. It's understandable that you may not care for the default appearance, but we politely request that you consider styling it to fit your subreddit, perhaps using a particular background color or border. Even just a one-sided border, e.g. \`border-right: 3px solid blue;\` - thank you for your consideration.\n\n For convenience we've included \`RES-keyNav-activeThing\` which can be used as an alternative to \`RES-keyNav-activeElement\`. It applies to elements with the class \`thing\` as opposed to \`entry\`. If you choose to use this, make sure keyboard navigation is usable when [commentBoxes](${makeUrlHash('styleTweaks', 'commentBoxes')}) is turned off.`,
  nightmode: 'Want your subreddit to be night mode friendly? Please have a look at [the night mode section of our wiki](/r/Enhancement/wiki/subredditstyling#wiki_res_night_mode_and_your_subreddit)'
};

function doStyleSheetCheck() {
  const $stylesheetTextarea = $('.stylesheet-customize-container textarea');
  const stylesheet = $stylesheetTextarea.length ? $($stylesheetTextarea).val() : '';
  createTipPane();

  if (stylesheet.length) {
    if (!stylesheet.includes('.res') && !stylesheet.includes('.RES')) {
      addTipToPane('no-res-styles');
    }

    if (!stylesheet.includes('.res-nightmode')) {
      addTipToPane('nightmode');
    }

    const keyNavIdx = stylesheet.indexOf('.RES-keyNav-activeElement');

    if (keyNavIdx !== -1) {
      let keyNavRule = '';
      let i = keyNavIdx;

      while (i < stylesheet.length) {
        const thisChar = stylesheet.charAt(i);
        keyNavRule += thisChar;

        if (thisChar === '}') {
          i = stylesheet.length;
        }

        i++;
      }

      if ((keyNavRule.includes('transparent') || keyNavRule.includes('background: none') || keyNavRule.includes('background-color: none')) && !keyNavRule.includes('border') && !stylesheet.includes('.RES-keyNav-activeThing')) {
        addTipToPane('keyNav-benice');
      } else {
        addTipToPane('keyNav');
      }
    }
  }
}

let $tipPane, $tipPaneHeader, $tipPaneContents, $tipPaneList;

function createTipPane() {
  const $sheetsDiv = $('div.sheets');
  $tipPane = $('<div>', {
    id: 'RESStyleSheetTipPane'
  });
  $tipPaneHeader = $('<div>', {
    id: 'RESStyleSheetTipPane-header',
    class: 'minimized',
    text: 'RES specific styling tips',
    click: toggleTipPane
  });
  const $tipPaneCloseButton = $('<span>', {
    id: 'RESStyleSheetTipPane-close',
    class: 'RESCloseButton',
    html: '&times;',
    title: 'Close for this session',
    click: hideTipPane
  });
  const $tipPaneHeaderSpan = $('<span>', {
    class: 'details',
    text: '[click for details]'
  });
  $tipPaneHeader.append($tipPaneCloseButton).append($tipPaneHeaderSpan);
  $tipPaneContents = $('<div>', {
    id: 'RESStyleSheetTipPane-contents'
  });
  $tipPaneList = $('<ul>', {
    id: 'RESStyleSheetTipPane-list'
  });
  $tipPaneContents.append($tipPaneList);
  $tipPane.append($tipPaneHeader).append($tipPaneContents);
  $sheetsDiv.before($tipPane);
}

function hideTipPane() {
  sessionStorage.setItem('hideTipPane', 'true');
  $tipPane.hide();
}

function toggleTipPane() {
  if ($tipPaneHeader.hasClass('minimized')) {
    openTipPaneContents();
  } else {
    closeTipPaneContents();
  }
}

function openTipPaneContents() {
  $tipPaneHeader.removeClass('minimized');
  $tipPaneContents.slideDown();
}

function closeTipPaneContents() {
  $tipPaneHeader.addClass('minimized');
  $tipPaneContents.slideUp();
}

function addTipToPane(key) {
  const tipText = modhelper_tips[key];
  const $tip = $('<li>', {
    html: snudown_es_markdown(tipText)
  });

  if (!sessionStorage.getItem('hideTipPane')) {
    $tipPane.show();
  }

  $tipPaneList.append($tip);
}
// CONCATENATED MODULE: ./lib/modules/multiredditNavbar.js






const multiredditNavbar_module = new Module('multiredditNavbar');
multiredditNavbar_module.moduleName = 'multiredditNavbarName';
multiredditNavbar_module.description = 'multiredditNavbarDesc';
multiredditNavbar_module.category = 'subredditsCategory';
multiredditNavbar_module.include = ['linklist'];
multiredditNavbar_module.options = {
  sectionMenu: {
    type: 'boolean',
    value: true,
    description: 'multiredditNavbarSectionMenuDesc',
    title: 'multiredditNavbarSectionMenuTitle'
  },
  sectionLinks: {
    dependsOn: options => options.sectionMenu.value,
    type: 'table',
    addRowText: 'multiredditNavbarAddShortcut',
    fields: [{
      key: 'label',
      name: 'multiredditNavbarLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'multiredditNavbarUrl',
      type: 'text'
    }],
    value: [['new', './new'], ['rising', './rising'], ['controversial', './controversial'], ['top', './top'], ['top this month', './top?t=month'], ['gilded', './gilded'], ['promoted', './ads']],
    description: 'multiredditNavbarSectionLinksDesc',
    title: 'multiredditNavbarSectionLinksTitle'
  },
  hoverDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'multiredditNavbarHoverDelayDesc',
    title: 'multiredditNavbarHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'multiredditNavbarFadeDelayDesc',
    title: 'multiredditNavbarFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'multiredditNavbarFadeSpeedDesc',
    title: 'multiredditNavbarFadeSpeedTitle',
    advanced: true
  }
};

multiredditNavbar_module.contentStart = () => {
  if (multiredditNavbar_module.options.sectionMenu.value) {
    $('.listing-chooser .multis').on('mouseenter', 'li', onMouseEnterMultiLink);
  }
};

function onMouseEnterMultiLink(e) {
  const link = e.currentTarget.querySelector('a[href*="/m/"]');

  if (!link) {
    return;
  }

  dropdownList(multiredditNavbar_module.moduleID).target(e.currentTarget).options({
    openDelay: penalizedDelay(multiredditNavbar_module.moduleID, 'sectionMenu', multiredditNavbar_module.options.hoverDelay),
    fadeDelay: parseFloat(multiredditNavbar_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(multiredditNavbar_module.options.fadeSpeed.value),
    pin: pin.right,
    offsetWidth: -10,
    offsetHeight: 1,
    bottomPadding: 0
  }).populateWith(() => populateSectionMenu(link.href)).begin();
}

const populateSectionMenu = baseUrl => {
  alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', 5);
  return [multiredditNavbar_module.options.sectionLinks.value.map(link => populateSectionItem(baseUrl, link)).reduce((prev, curr) => curr ? prev.add(curr) : prev, $()).add(populateSectionItem(baseUrl, [`<i>${i18n(multiredditNavbar_module.moduleName)}</i>`, makeUrlHash(multiredditNavbar_module.moduleID, 'sectionMenu')]))];
};

function populateSectionItem(baseUrl, link) {
  if (!(link && link.length >= 2)) {
    return $();
  }

  const label = link[0] || '';
  const url = link[1] || '';
  const $link = $('<a />').safeHtml(label).attr('href', `${baseUrl}${url}`);

  if (isSettingsUrl(url)) {
    $link.append('<span class="RESMenuItemButton gearIcon" />');
  }

  $link.on('click', () => {
    dropdownList(multiredditNavbar_module.moduleID).close();
    alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', -30);
  });
  return $('<li />').append($link);
}
// CONCATENATED MODULE: ./lib/modules/neverEndingComments.js


const neverEndingComments_module = new Module('neverEndingComments');
neverEndingComments_module.moduleName = 'necName';
neverEndingComments_module.category = 'commentsCategory';
neverEndingComments_module.description = 'necDescription';
neverEndingComments_module.options = {
  loadChildComments: {
    type: 'boolean',
    value: false,
    description: 'necLoadChildCommentsDesc',
    title: 'necLoadChildCommentsTitle'
  }
};
neverEndingComments_module.include = ['comments'];

neverEndingComments_module.afterLoad = () => {
  const context = document.body.querySelector(neverEndingComments_module.options.loadChildComments.value ? '.nestedlisting' : '.nestedlisting > .thing.morechildren');
  if (!context) return;
  const visibleLoaders = new Set();
  const io = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!context.contains(target)) io.unobserve(target);
      if (isIntersecting) visibleLoaders.add(target);else visibleLoaders.delete(target);
    }

    if (visibleLoaders.size) {
      window.addEventListener('scroll', loadFirst);
      loadFirst();
    } else {
      window.removeEventListener('scroll', loadFirst);
    }
  }, {
    rootMargin: '-10% 0px 10% 0px'
  });
  const loadFirst = frameDebounce(mutex(async () => {
    const loader = Array.from(visibleLoaders.values()).sort((a, b) => 3 - (a.compareDocumentPosition(b) & 6)).find(e => {
      const thing = Thing_Thing.from(e);
      return !Thing_Thing.selected || !thing || Thing_Thing.selected.getDirectionOf(thing) === 'down';
    });

    if (loader) {
      loader.click();
      await waitForRemoval(loader, new Promise(res => setTimeout(res, 3000)));
      loadFirst();
    }
  }), 5);
  watchForDescendants(context, '.morecomments a', ele => {
    io.observe(ele);
  });
};
// CONCATENATED MODULE: ./lib/modules/onboarding.js




const onboarding_module = new Module('onboarding');
onboarding_module.moduleName = 'onboardingName';
onboarding_module.category = 'aboutCategory';
onboarding_module.description = 'onboardingDesc';
onboarding_module.alwaysEnabled = true;
onboarding_module.options = {
  updateNotification: {
    title: 'onboardingUpdateNotificationName',
    description: 'onboardingUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'nothing'
    }]
  },
  patchUpdateNotification: {
    title: 'onboardingPatchUpdateNotificationName',
    description: 'onboardingPatchUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  },
  betaUpdateNotification: {
    title: 'onboardingBetaUpdateNotificationName',
    description: 'onboardingBetaUpdateNotificationDescription',
    type: 'enum',
    value: 'releaseNotes',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  }
};
const firstRunStorage = storage_namespaceObject.wrapPrefix('RES.firstRun.', () => null);

onboarding_module.go = async () => {
  if (!(await firstRunStorage.has(metadata_version))) {
    firstRunStorage.set(metadata_version, true);
    const notificationOption = isBeta ? 'betaUpdateNotification' : isPatch ? 'patchUpdateNotification' : 'updateNotification';

    switch (onboarding_module.options[notificationOption].value) {
      case 'releaseNotes':
        openNewTab(updatedURL, false);
        break;

      case 'notification':
        notifications_showNotification({
          moduleID: onboarding_module.moduleID,
          optionKey: notificationOption,
          message: `
						${i18n('onboardingUpgradeMessage', metadata_version)}
						<p><a class="RESNotificationButtonBlue" href="${updatedURL}" target="_blank">
							${i18n('onboardingUpgradeCta')}
						</a></p>
					`.trim(),
          closeDelay: 15000
        });
        break;

      case 'none':
      default:
        console.log(`RES upgraded to v${metadata_version}.`);
        break;
    }
  }
};
// EXTERNAL MODULE: ./node_modules/favico.js/favico.js
var favico = __webpack_require__(140);
var favico_default = /*#__PURE__*/__webpack_require__.n(favico);

// EXTERNAL MODULE: ./lib/images/legacyFavicon.png
var legacyFavicon = __webpack_require__(141);
var legacyFavicon_default = /*#__PURE__*/__webpack_require__.n(legacyFavicon);

// CONCATENATED MODULE: ./lib/modules/orangered.js











const orangered_module = new Module('orangered');
orangered_module.moduleName = 'orangeredName';
orangered_module.category = 'myAccountCategory';
orangered_module.description = 'orangeredDesc';
orangered_module.options = {
  openMailInNewTab: {
    description: 'orangeredOpenMailInNewTabDesc',
    title: 'orangeredOpenMailInNewTabTitle',
    type: 'boolean',
    value: false
  },
  updateCurrentTab: {
    description: 'orangeredUpdateCurrentTabDesc',
    title: 'orangeredUpdateCurrentTabTitle',
    type: 'boolean',
    value: true
  },
  updateOtherTabs: {
    description: 'orangeredUpdateOtherTabsDesc',
    keywords: ['favicon', 'sync'],
    title: 'orangeredUpdateOtherTabsTitle',
    type: 'boolean',
    value: true
  },
  showFloatingEnvelope: {
    description: 'orangeredShowFloatingEnvelopeDesc',
    title: 'orangeredShowFloatingEnvelopeTitle',
    type: 'boolean',
    value: true
  },
  retroUnreadCount: {
    description: 'orangeredRetroUnreadCountDesc',
    title: 'orangeredRetroUnreadCountTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  showUnreadCountInTitle: {
    description: 'orangeredShowUnreadCountInTitleDesc',
    title: 'orangeredShowUnreadCountInTitleTitle',
    type: 'boolean',
    value: false
  },
  faviconUseLegacy: {
    description: 'faviconUseLegacyDesc',
    title: 'faviconUseLegacyTitle',
    type: 'boolean',
    value: false
  },
  showUnreadCountInFavicon: {
    description: 'orangeredShowUnreadCountInFaviconDesc',
    title: 'orangeredShowUnreadCountInFaviconTitle',
    type: 'boolean',
    value: true
  },
  faviconNotificationBGColor: {
    description: 'faviconNotificationBGColorDesc',
    title: 'faviconNotificationBGColorTitle',
    advanced: true,
    type: 'color',
    value: '#5f99cf',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  faviconNotificationTextColor: {
    description: 'faviconNotificationTextColorDesc',
    title: 'faviconNotificationTextColorTitle',
    advanced: true,
    type: 'color',
    value: '#FFFFFF',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  resetFaviconOnLeave: {
    description: 'orangeredResetFaviconOnLeaveDesc',
    title: 'orangeredResetFaviconOnLeaveTitle',
    type: 'boolean',
    value: true,
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  unreadLinksToInbox: {
    description: 'orangeredUnreadLinksToInboxDesc',
    title: 'orangeredUnreadLinksToInboxTitle',
    type: 'boolean',
    value: false,
    advanced: true
  },
  hideEmptyMail: {
    description: 'orangeredHideEmptyMailDesc',
    title: 'orangeredHideEmptyMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideModMail: {
    description: 'orangeredHideModMailDesc',
    title: 'orangeredHideModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyModMail: {
    description: 'orangeredHideEmptyModMailDesc',
    title: 'orangeredHideEmptyModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideModMail.value
  },
  hideNewModMail: {
    description: 'orangeredHideNewModMailDesc',
    title: 'orangeredHideNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyNewModMail: {
    description: 'orangeredHideEmptyNewModMailDesc',
    title: 'orangeredHideEmptyNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideNewModMail.value
  }
};

orangered_module.contentStart = () => {
  if (orangered_module.options.faviconUseLegacy.value) setupFavicon();

  if (!loggedInUser()) {
    return;
  }

  floatingButtons();

  if (orangered_module.options.openMailInNewTab.value) {
    $orangeredElements().attr('target', '_blank').attr('rel', 'noopener noreferer');
  }

  updateFromPage();
};

async function updateFromPage(doc = document.body) {
  if (!isRunning(orangered_module)) return;
  if (!orangered_module.options.updateCurrentTab.value) return;
  if (!loggedInUser()) return;
  const debuginfoElement = doc.querySelector('.debuginfo');
  const timestampRegex = /(\d{4})-(\d{2})-(\d{2}) (\d{2})\:(\d{2})\:(\d{2})\.(\d+)[+-](\d{2})\:(\d{2})/;
  const [timestamp] = debuginfoElement && timestampRegex.exec(debuginfoElement.textContent) || [];

  if (Date.parse(timestamp)) {
    const lastUpdate = await session_namespaceObject.get('orangered.last-update');
    session_namespaceObject.set('orangered.last-update', timestamp);
    if (lastUpdate && new Date(lastUpdate) >= new Date(timestamp)) return;
  }

  setUnreadCount(getUnreadCount(doc));
}
let lastCount = 0;

const _setUnreadCount = multicast(count => {
  if (count === lastCount) return;
  lastCount = count;
  updateFaviconBadge(count);
  updateTitle(count);
  updateInboxElements(count);
  updateMailCountElements(count);

  if (count > 0) {
    window.dispatchEvent(new Event('orangered'));
  }
}, {
  name: 'setUnreadCount',
  crossContext: false
});

function setUnreadCount(count) {
  if (orangered_module.options.updateOtherTabs.value) {
    _setUnreadCount(count);
  } else {
    _setUnreadCount.local(count);
  }
}

function updateTitle(count) {
  if (!orangered_module.options.showUnreadCountInTitle.value) return;

  if (count > 0) {
    document.title = `[${count}] ${document.title.replace(/^\[[\d]+\]\s/, '')}`;
  } else {
    document.title = document.title.replace(/^\[[\d]+\]\s/, '');
  }
}

function updateInboxElements(count) {
  const {
    nativeInboxButton,
    $floatingInboxButton
  } = orangeredElements();
  $().add($floatingInboxButton).add(nativeInboxButton).attr('title', count ? 'new mail!' : 'No new mail').toggleClass('havemail', !!count).toggleClass('nohavemail', !count).attr('href', getInboxLink(count));
}

function updateMailCountElements(count) {
  const {
    nativeInboxCount,
    $floatingInboxCount
  } = orangeredElements();
  $().add($floatingInboxCount).add(nativeInboxCount).css('display', count ? 'inline-block' : 'none').attr('href', getInboxLink(count)).attr('title', count ? 'new mail!' : 'No new mail').text(count).addClass('message-count');
}

function updateFaviconBadge(count) {
  if (orangered_module.options.showUnreadCountInFavicon.value) {
    setupFavicon().badge(count);
  }
}

const setupFavicon = once_default()(() => {
  const favicons = Array.from(document.head.querySelectorAll('link[rel="icon"]'));

  const selectedFavicon = favicons.find(f => f.getAttribute('sizes') === '96x96') || last_default()(favicons);

  for (const f of favicons) {
    if (f !== selectedFavicon) f.remove();
  }

  if (orangered_module.options.faviconUseLegacy.value) {
    selectedFavicon.setAttribute('href', legacyFavicon_default.a);
  }

  const favicon = new favico_default.a({
    bgColor: orangered_module.options.faviconNotificationBGColor.value,
    textColor: orangered_module.options.faviconNotificationTextColor.value
  });

  if (orangered_module.options.resetFaviconOnLeave.value) {
    window.addEventListener('beforeunload', () => favicon.reset());
  }

  return favicon;
});

const orangeredElements = () => ({ ...nativeButtons(),
  ...floatingButtons(),
  modmailButtonSelector: '#modmail'
});

const $orangeredElements = () => Object.values(orangeredElements()).reduce(($all, ele) => $all.add(ele), $());

const nativeButtons = once_default()(() => {
  const nativeInboxButton = document.querySelector('#header-bottom-right #mail');
  let nativeInboxCount = document.querySelector('#header-bottom-right .message-count');

  if (!nativeInboxCount && (orangered_module.options.updateCurrentTab.value || orangered_module.options.updateOtherTabs.value)) {
    nativeInboxCount = document.createElement('a');
    nativeInboxCount.style.display = 'none';
    nativeInboxButton.after(nativeInboxCount);
  }

  return {
    nativeInboxButton,
    nativeInboxCount
  };
});

const floatingButtons = once_default()(() => {
  if (!orangered_module.options.showFloatingEnvelope.value) {
    return {
      $floatingInboxButton: undefined,
      $floatingInboxCount: undefined
    };
  }

  let $floatingInboxButton, $floatingInboxCount;
  const pinHeader = betteReddit_module.options.pinHeader.value;

  if (pinHeader === 'sub' || pinHeader === 'none') {
    $floatingInboxButton = $('<a>', {
      id: 'NREMail',
      class: 'nohavemail'
    });
    addElement($floatingInboxButton);
    $floatingInboxCount = $('<a>', {
      id: 'NREMailCount'
    });
    $floatingInboxCount.css('display', 'none');
    $floatingInboxCount.attr('href', getInboxLink(true));
    addElement($floatingInboxCount);
  }

  return {
    $floatingInboxButton,
    $floatingInboxCount
  };
});

function getInboxLink(havemail) {
  if (havemail && !orangered_module.options.unreadLinksToInbox.value) {
    return '/message/unread/';
  }

  return '/message/inbox/';
}

function getUnreadCount(container) {
  const mailCount = container.querySelector('.message-count');
  return mailCount && parseInt(mailCount.textContent, 10) || 0;
}
// CONCATENATED MODULE: ./lib/modules/pageNavigator.js








const pageNavigator_module = new Module('pageNavigator');
pageNavigator_module.moduleName = 'pageNavName';
pageNavigator_module.category = 'browsingCategory';
pageNavigator_module.description = 'pageNavDesc';
pageNavigator_module.options = {
  toTop: {
    type: 'boolean',
    value: true,
    description: 'pageNavToTopDesc',
    title: 'pageNavToTopTitle'
  },
  toComment: {
    type: 'boolean',
    value: true,
    description: 'pageNavToCommentDesc',
    title: 'pageNavToCommentTitle'
  },
  showLink: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkDesc',
    title: 'pageNavShowLinkTitle'
  },
  showLinkNewTab: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkNewTabDesc',
    title: 'pageNavShowLinkNewTabTitle',
    dependsOn: options => options.showLink.value
  }
};

pageNavigator_module.beforeLoad = () => {
  if (pageNavigator_module.options.showLink.value && isPageType('comments')) {
    watchForThings(['post'], showLinkTitle);
  }
};

pageNavigator_module.contentStart = () => {
  if (pageNavigator_module.options.toComment.value && isPageType('comments')) {
    backToNewCommentArea();
  }

  if (pageNavigator_module.options.toTop.value) {
    backToTop();
  }
};

function backToTop() {
  const $backToTop = $(`<a class="pageNavigator res-icon" data-id="top" href="#header" title="${i18n('pageNavToTopTitle')}">&#xF148;</a>`);
  $backToTop.on('click', e => {
    e.preventDefault();
    window.scrollTo(0, 0);
    move('top');
  });
  addElement($backToTop, {
    order: 9
  });
}

const showLinkTitleTemplate = ({
  thumbnailSrc,
  linkId,
  settingsHash,
  linkHref,
  linkNewTab,
  title,
  domainHref,
  domain,
  time,
  author,
  authorHref
}) => string_namespaceObject.html`
	<div class="res-show-link hide">
		${thumbnailSrc && string_namespaceObject._html`
			<span class="res-show-link-thumb"><img src="${thumbnailSrc}" alt="thumbnail" /></span>
		`}
		<a href="#${linkId}" class="res-icon toTop" title="Jump to title">&#xF148;</a>
		<a href="${settingsHash}" class="gearIcon" title="Configure this widget"></a>
		<div class="res-show-link-content">
			<div class="res-show-link-header">
				<a href="${linkHref}" ${linkNewTab && string_namespaceObject._html`target="_blank" rel="noopener noreferer"`} class="res-show-link-title">${title}</a>
				<a href="${domainHref}" class="res-show-link-domain">(<span>${domain}</span>)</a>
			</div>
			<div class="res-show-link-tagline">
				Submitted ${time} by
				<a href="${authorHref}" class="res-show-link-author">${author}</a>
			</div>
		</div>
	</div>
`;

function backToNewCommentArea() {
  const commentArea = document.querySelector('.commentarea > form.usertext textarea:not([disabled])');
  if (!commentArea) return;
  const $backToNewCommentArea = $(`<a class="pageNavigator res-icon" data-id="addComment" href="#comments" title="${i18n('pageNavToCommentTitle')}">&#xF003;</a>`);
  $backToNewCommentArea.on('click', e => {
    e.preventDefault();
    commentArea.focus();
  });
  addElement($backToNewCommentArea);
}

const showLinkTitle = once_default()(submissionThing => {
  let $widget;
  let belowSubmission = true;
  let baseHeight, hoverHeight;

  function showWidget() {
    $widget.css({
      top: getHeaderOffset(true)
    }).removeClass('hide');
  }

  function hideWidget() {
    $widget.css({
      top: -baseHeight
    }).addClass('hide');
  }

  function renderWidget() {
    return $(showLinkTitleTemplate({
      linkId: submissionThing.element.id,
      thumbnailSrc: submissionThing.getPostThumbnailUrl(),
      linkHref: submissionThing.getTitleUrl(),
      linkNewTab: pageNavigator_module.options.showLinkNewTab.value,
      title: submissionThing.getTitle(),
      domainHref: submissionThing.getPostDomainUrl(),
      domain: submissionThing.getPostDomainText(),
      time: submissionThing.getPostTime(),
      authorHref: submissionThing.getAuthorUrl(),
      author: submissionThing.getAuthor(),
      settingsHash: makeUrlHash(pageNavigator_module.moduleID, 'showLink')
    }));
  }

  const updateWidget = frameThrottle(e => {
    const scrollingUp = e.deltaY < 0;

    if (scrollingUp && belowSubmission) {
      initialize();
      showWidget();
    } else if ($widget) {
      hideWidget();
    }
  });

  const initialize = once_default()(() => {
    $widget = renderWidget().on('mouseenter', () => $widget.css({
      height: hoverHeight
    })).on('mouseleave', () => $widget.css({
      height: baseHeight
    })).appendTo(document.body);
    baseHeight = $widget.get(0).getBoundingClientRect().height;
    hoverHeight = $widget.get(0).scrollHeight;
    new IntersectionObserver(entries => {
      belowSubmission = !entries[0].isIntersecting;
      if (!belowSubmission) hideWidget();
    }, {
      rootMargin: '100px 0px 0px 0px'
    }).observe(submissionThing.element);
    window.addEventListener('scroll', () => {
      if (scrollToElement.isProgrammaticEvent()) hideWidget();
    });
  });

  window.addEventListener('wheel', updateWidget, {
    passive: true
  });
});
// CONCATENATED MODULE: ./lib/modules/troubleshooter.js







const troubleshooter_module = new Module('troubleshooter');
troubleshooter_module.moduleName = 'troubleshooterName';
troubleshooter_module.alwaysEnabled = true;
troubleshooter_module.sort = -7;
troubleshooter_module.description = 'troubleshooterDesc';
troubleshooter_module.category = 'aboutCategory';
troubleshooter_module.options = {
  clearCache: {
    title: 'troubleshooterClearCacheTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearCache,
    description: 'troubleshooterClearCacheDesc'
  },
  clearTags: {
    title: 'troubleshooterClearTagsTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearTags,
    description: 'troubleshooterClearTagsDesc'
  },
  resetToFactory: {
    title: 'troubleshooterResetToFactoryTitle',
    type: 'button',
    text: 'troubleshooterResetLabel',
    callback: resetToFactory,
    description: 'troubleshooterResetToFactoryDesc'
  },
  disableRES: {
    title: 'troubleshooterDisableRESTitle',
    type: 'button',
    text: 'troubleshooterDisableLabel',

    callback() {
      window.top.location = new URL(RES_DISABLED_HASH, context_data.origin);
    },

    description: 'troubleshooterDisableRESDesc'
  },
  breakpoint: {
    title: 'troubleshooterBreakpointTitle',
    type: 'button',
    text: 'troubleshooterBreakpointLabel',

    callback() {
      debugger;
    },

    description: 'troubleshooterBreakpointDesc'
  },
  testEnvironment: {
    title: 'troubleshooterTestEnvironmentTitle',
    type: 'button',
    text: 'troubleshooterTestEnvironmentLabel',
    callback: testEnvironment,
    description: 'troubleshooterTestEnvironmentDesc'
  },
  testNotifications: {
    title: 'troubleshooterTestNotificationsTitle',
    type: 'button',
    text: 'troubleshooterTestNotificationsLabel',
    callback: testNotifications,
    description: 'troubleshooterTestNotificationsDesc'
  }
};

function clearCache() {
  xhrCache_namespaceObject.clear();
  session_namespaceObject.clear();
  localStorage.removeItem(CACHED_LANG_KEY);
  localStorage.removeItem(CACHED_MESSAGES_TOKEN_KEY);
  localStorage.removeItem(CACHED_MESSAGES_KEY);
  notifications_showNotification(i18n('troubleshooterCachesCleared'), 2500);
}

async function clearTags() {
  const confirm = window.confirm(i18n('troubleshooterAreYouPositive'));

  if (confirm) {
    const toDelete = (await userTagger_Tag.getStored()).filter(({
      text,
      votesUp = 0,
      votesDown = 0
    }) => !text && votesUp <= 1 && votesDown <= 1);

    for (const tag of toDelete) tag.delete();

    notifications_showNotification(i18n('troubleshooterEntriesRemoved', toDelete.length), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function resetToFactory() {
  const confirm = window.prompt(i18n('troubleshooterThisWillKillYourSettings', 'trash'));

  if (confirm === 'trash' || confirm === '"trash"') {
    clearCache();
    storage_namespaceObject.clear();
    notifications_showNotification(i18n('troubleshooterSettingsReset'), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function testNotifications() {
  notifications_showNotification({
    moduleID: troubleshooter_module.moduleID,
    header: 'Template test',
    message: '<p>Hello, FakeUsername</p>'
  });
}

const testMulticast = multicast(val => {
  alert_namespaceObject.open(`Multicast: ${val}`);
}, {
  name: 'testMulticast',
  local: false,
  crossContext: false
});

async function testEnvironment() {
  const testKey = '__test__';
  const rows = [];

  try {
    let rand;
    rows.push(`Private browsing: ${String(isPrivateBrowsing())}`, '');
    rand = Math.random();
    rows.push(`Sending multicast: ${rand}`, '');
    testMulticast(rand);
    rand = Math.random();
    rows.push(`Storage.set(): ${rand}`);
    storage_namespaceObject.set(testKey, rand);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`);
    rows.push('Storage.delete()');
    storage_namespaceObject.delete(testKey);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    rows.push(`Session.set(): ${rand}`);
    session_namespaceObject.set(testKey, rand);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`);
    rows.push('Session.delete()');
    session_namespaceObject.delete(testKey);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    const wrapped = storage_namespaceObject.wrap(testKey, 'default');
    rows.push(`wrapped.set(): ${rand}`);
    wrapped.set(rand);
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`);
    rows.push('wrapped.delete()');
    wrapped.delete();
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`, '');
    rand = Math.random();
    const domain = storage_namespaceObject.wrapPrefix(testKey, () => 'default');
    rows.push(`prefix.set(): ${rand}`);
    domain.set('1', rand);
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`);
    rows.push('prefix.delete()');
    domain.delete('1');
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`, '');
    rand = Math.random();
    const blob = storage_namespaceObject.wrapBlob(testKey, () => 'default');
    rows.push(`blob.set(): ${rand}`);
    blob.set('1', rand);
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`);
    rows.push('blob.delete()');
    blob.delete('1');
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`, '');
  } catch (e) {
    rows.push('', `Errored: ${e}`);
    console.error(e);
  }

  alert_namespaceObject.open(rows.join('<br>'));
}
// CONCATENATED MODULE: ./lib/modules/presets.js






const presets_module = new Module('presets');
presets_module.moduleName = 'presetsName';
presets_module.category = 'coreCategory';
presets_module.alwaysEnabled = true;
presets_module.description = 'presetsDesc';
presets_module.options = {
  lite: {
    title: 'presetsLiteTitle',
    description: 'presetsLiteDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(['notifications', 'hover', 'announcements', 'orangered', 'onboarding', 'selectedEntry', 'showImages', 'submitHelper', 'neverEndingReddit', 'accountSwitcher', 'filteReddit', 'quickMessage', 'subredditInfo', 'userInfo', 'userHighlight', 'searchHelper', 'betteReddit', 'styleTweaks', 'pageNavigator', 'commandLine', 'commentHidePersistor', 'commentTools', 'commentPreview', 'localDate', 'noParticipation'], '*'))
  },
  cleanSlate: {
    title: 'presetsCleanSlateTitle',
    description: 'presetsCleanSlateDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(undefined, '*'))
  },
  noPopups: {
    title: 'presetsNoPopupsTitle',
    description: 'presetsNoPopupsDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(async () => {
      await toggleModules(undefined, 'hover RESTips showParent subredditInfo'.split(/[,\s]/));
      await toggleOptions(undefined, 'userTagger.hoverInfo'.split(/[,\s]/));
    })
  },
  resetToFactory: troubleshooter_module.options.resetToFactory
};

function confirmPreset(callback) {
  return async function () {
    const confirmation = prompt(`Are you sure you want to apply the "${i18n(this.title)}" preset? Type "yes" to continue.`);

    if (/^"?yes"?$/.test(confirmation)) {
      await callback();
      const shouldReload = confirm(`Applied preset: ${i18n(this.title)}\nYou must reload the page to see results.\n\nWould you like to reload now?`);

      if (shouldReload) {
        location.reload();
      }
    } else {
      notifications_showNotification({
        moduleID: presets_module.moduleID,
        title: 'Preset cancelled',
        message: 'If you really wanted to apply this preset, make sure to type in "yes" when prompted.'
      });
    }
  };
}

function sanitizeModulesList(unsanitized) {
  let sanitized;

  if (unsanitized === '*') {
    sanitized = allModules();
  } else if (typeof unsanitized === 'string') {
    sanitized = unsanitized.split(/[,\s]/);
  } else if (unsanitized && unsanitized.length) {
    sanitized = unsanitized;
  }

  return sanitized ? [].concat(sanitized) : [];
}

async function toggleModules(requestEnable, requestDisable) {
  let enable = sanitizeModulesList(requestEnable);
  let disable = sanitizeModulesList(requestDisable);
  disable = requestEnable !== '*' ? disable.filter(moduleID => !enable.includes(moduleID)) : disable;
  enable = requestDisable !== '*' ? enable.filter(moduleID => !disable.includes(moduleID)) : enable;

  for (const modId of disable) await setEnabled(modId, false);

  for (const modId of enable) await setEnabled(modId, true);
}

function allModules() {
  return modules_all().map(mod => mod.moduleID);
}

async function toggleOptions(requestEnable, requestDisable) {
  const enable = requestEnable ? [].concat(requestEnable) : [];
  const disable = requestDisable ? [].concat(requestDisable) : [];

  for (const option of enable) await setOptionValue(true, option);

  for (const option of disable) await setOptionValue(false, option);
}

async function setOptionValue(value, path) {
  if (typeof path === 'string') {
    path = path.split('.');
  }

  const [id, optName] = path;
  await options_set(id, optName, value);
}
// CONCATENATED MODULE: ./lib/modules/profileNavigator.js







const profileNavigator_module = new Module('profileNavigator');
profileNavigator_module.moduleName = 'profileNavigatorName';
profileNavigator_module.description = 'profileNavigatorDesc';
profileNavigator_module.category = 'myAccountCategory';
profileNavigator_module.options = {
  sectionMenu: {
    title: 'profileNavigatorSectionMenuTitle',
    type: 'boolean',
    value: true,
    description: 'profileNavigatorSectionMenuDesc'
  },
  sectionLinks: {
    title: 'profileNavigatorSectionLinksTitle',
    dependsOn: options => options.sectionMenu.value,
    description: 'profileNavigatorSectionLinksDesc',
    type: 'table',
    addRowText: '+add profile section shortcut',
    fields: [{
      key: 'label',
      name: 'label',
      type: 'text'
    }, {
      key: 'url',
      name: 'url',
      type: 'text'
    }],
    value: [['saved', './saved'], ['comments', './comments'], ['submitted', './submitted'], ['gilded', './gilded'], ['upvoted', './upvoted'], ['downvoted', './downvoted']]
  },
  hoverDelay: {
    title: 'profileNavigatorHoverDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'profileNavigatorHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'profileNavigatorFadeDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'profileNavigatorFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'profileNavigatorFadeSpeedTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'profileNavigatorFadeSpeedDesc',
    advanced: true
  }
};

profileNavigator_module.contentStart = () => {
  const username = loggedInUser();

  if (profileNavigator_module.options.sectionMenu.value && username) {
    $('#header .user a').on('mouseenter', e => onMouseEnterProfileLink(username, e));
  }
};

function onMouseEnterProfileLink(user, e) {
  dropdownList(profileNavigator_module.moduleID).target(e.target).options({
    openDelay: penalizedDelay(profileNavigator_module.moduleID, 'sectionMenu', profileNavigator_module.options.hoverDelay),
    fadeDelay: parseFloat(profileNavigator_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(profileNavigator_module.options.fadeSpeed.value),
    pin: pin.bottom
  }).populateWith(() => profileNavigator_populateSectionMenu(user)).begin();
}

const profileNavigator_populateSectionMenu = username => {
  alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', 5);
  return [profileNavigator_module.options.sectionLinks.value.map(link => profileNavigator_populateSectionItem(username, link)).reduce((prev, curr) => prev.add(curr), $()).add(profileNavigator_populateSectionItem('..', [`<i>${i18n(profileNavigator_module.moduleName)}</i>`, makeUrlHash(profileNavigator_module.moduleID, 'sectionMenu')]))];
};

function profileNavigator_populateSectionItem(username, link) {
  if (!(link && link.length >= 2)) {
    return $();
  }

  const label = link[0] || '';
  const url = link[1] || '';
  const $link = $('<a />').safeHtml(label).attr('href', `/user/${username}/${url}`);

  if (isSettingsUrl(url)) {
    $link.append('<span class="RESMenuItemButton gearIcon" />');
  }

  $link.on('click', () => {
    dropdownList(profileNavigator_module.moduleID).close();
    alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', -30);
  });
  return $('<li />').append($link);
}
// CONCATENATED MODULE: ./lib/modules/profileRedirect.js






const profileRedirect_module = new Module('profileRedirect');
profileRedirect_module.moduleName = 'profileRedirectName';
profileRedirect_module.category = 'usersCategory';
profileRedirect_module.description = 'profileRedirectDesc';
profileRedirect_module.keywords = ['legacy', 'overview'];
profileRedirect_module.include = ['profile', 'profile2x'];
profileRedirect_module.options = {
  fromLandingPage: {
    title: 'profileRedirectFromLandingPageTitle',
    description: 'profileRedirectFromLandingPageDesc',
    keywords: ['legacy', 'overview'],
    type: 'enum',
    value: 'none',
    values: [{
      name: 'Do nothing',
      value: 'none'
    }, {
      name: 'Overview (legacy)',
      value: 'overview'
    }, {
      name: 'Comments',
      value: 'comments'
    }, {
      name: 'Submitted (legacy)',
      value: 'submitted'
    }, {
      name: 'Gilded',
      value: 'gilded'
    }, {
      name: 'Custom',
      value: 'custom'
    }]
  },
  customFromLandingPage: {
    dependsOn: options => options.fromLandingPage.value === 'custom',
    title: 'profileRedirectCustomFromLandingPageTitle',
    description: 'profileRedirectCustomFromLandingPageDesc',
    type: 'text',
    value: ''
  }
};

profileRedirect_module.beforeLoad = function () {
  const [, username, currentSection] = regexes.profile2x.exec(location.pathname) || [];

  if (username && !currentSection) {
    if (profileRedirect_module.options.fromLandingPage.value !== 'none') {
      const preferredSection = profileRedirect_module.options.fromLandingPage.value === 'custom' ? profileRedirect_module.options.customFromLandingPage.value : profileRedirect_module.options.fromLandingPage.value;
      window.location.replace(`/user/${username}/${preferredSection}`);
    } else if (isPageType('profile2x')) {
      const notificationPromise = notifications_showNotification({
        moduleID: profileRedirect_module.moduleID,
        optionKey: 'fromLandingPage',
        header: i18n('profileRedirectFromLandingPageNotificationTitle'),
        message: string_namespaceObject.html`
					<div>
						<p>${i18n('profileRedirectFromLandingPageNotificationText')}</p>
						<p><a class="RESNotificationButtonBlue" href="${makeUrlHash(profileRedirect_module.moduleID, 'fromLandingPage')}">${i18n('profileRedirectFromLandingPageNotificationButton')}</a></p>
					</div>
				`,
        cooldown: WEEK
      });
      notificationPromise.then(notification => {
        $(notification.element).on('click', '.RESNotificationButtonBlue', () => {
          notification.close();
        });
      });
    }
  }
};
// CONCATENATED MODULE: ./lib/modules/quarantineHide.js




const quarantineHide_module = new Module('quarantineHide');
quarantineHide_module.moduleName = 'quarantineHideName';
quarantineHide_module.category = 'appearanceCategory';
quarantineHide_module.description = 'quarantineHideDesc';
quarantineHide_module.options = {
  hideFlair: {
    title: 'quarantineHideFlairTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideFlairDesc'
  },
  hideQuarantinedInSub: {
    title: 'quarantineHideInSubTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideInSubDesc'
  }
};
quarantineHide_module.include = ['linklist', 'comments', 'wiki'];

quarantineHide_module.contentStart = () => {
  if (quarantineHide_module.options.hideFlair.value) {
    watchForThings(['post'], frameThrottle(() => {
      $('.quarantine-stamp').parent().remove();
    }));
  }

  if (inQuarantinedSubreddit() && quarantineHide_module.options.hideQuarantinedInSub.value) {
    bodyClasses_namespaceObject.remove('quarantine');
    $('.quarantine-notice').hide();
  }
};
// CONCATENATED MODULE: ./lib/modules/redditUserInfo.js

const redditUserInfo_module = new Module('redditUserInfo');
redditUserInfo_module.moduleName = 'redditUserInfoName';
redditUserInfo_module.category = 'usersCategory';
redditUserInfo_module.description = 'redditUserInfoDesc';
redditUserInfo_module.options = {
  hideAuthorTooltip: {
    type: 'boolean',
    value: false,
    description: 'redditUserInfoHideDesc',
    title: 'redditUserInfoHideTitle',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/requestPermissions.js

const requestPermissions_module = new Module('requestPermissions');
requestPermissions_module.moduleName = 'requestPermissionsName';
requestPermissions_module.description = 'requestPermissionsDesc';
requestPermissions_module.category = 'aboutCategory';
requestPermissions_module.disabledByDefault = true;
requestPermissions_module.permissions = {
  requiredPermissions: ['downloads', 'https://api.twitter.com/1/statuses/oembed.json', 'https://backend.deviantart.com/oembed', 'https://api.gyazo.com/api/oembed', 'https://codepen.io/api/oembed', 'https://api.tumblr.com/v2/blog/*/posts', 'https://xkcd.com/*/info.0.json', 'https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/*', 'https://*.googleusercontent.com/download/drive/v3/*', 'https://content.googleapis.com/drive/v3/*', 'https://redditenhancementsuite.com/oauth', 'https://accounts.google.com/o/oauth2/v2/auth', 'https://www.dropbox.com/oauth2/authorize', 'https://login.live.com/oauth20_authorize.srf']
};
// CONCATENATED MODULE: ./lib/modules/search.js










const search_module = new Module('search');
search_module.moduleName = 'searchName';
search_module.category = 'aboutCategory';
search_module.alwaysEnabled = true;
search_module.sort = -9;
search_module.description = `
	<p>Search for settings within RES.</p>
	<div id="SearchRES-results-container">
		<div id="SearchRES-count"></div>
		<ul id="SearchRES-results"></ul>
		<p id="SearchRES-results-hidden">Some results have been hidden because advanced options are currently hidden. <a href="#">Show advanced options.</a></p>
	</div>
	<div id="SearchRES-boilerplate">
		<p>You can search for RES options by module name, option name, and description. For example, try searching for "daily trick" in one of the following ways:</p>
		<ul>
			<li>type <code>daily trick</code> in the search box to the left and click the magnifying glass button</li>
			<li>press <code>.</code> to open the RES console, type in <code>search <em>daily trick</em></code>, and press Enter</li>
		</ul>
	</div>
`;
search_module.descriptionRaw = true;
const PRESERVE_SPACES = true;
function search_search(query = search_input().value) {
  search_input().value = query;

  if (!query) {
    drawSearchResults(query, []);
    return;
  }

  const sanitizedQuery = sanitizeString(query, PRESERVE_SPACES);
  const queryTerms = sanitizedQuery && sanitizedQuery.length ? sanitizedQuery.split(' ') : [];
  let results = [];

  if (queryTerms && queryTerms.length) {
    results = searchDomain().map(item => ({
      rank: item.getRank(queryTerms, item.context),
      context: item.context
    })).filter(item => item.rank !== Infinity).sort((a, b) => b.rank - a.rank).map(item => item.context);
  }

  drawSearchResults(query, results);
}

const searchDomain = once_default()(() => {
  const results = [];

  for (const mod of modules_all()) {
    if (mod === search_module) continue;
    if (mod.hidden) continue;
    const moduleName = i18n(mod.moduleName);
    const category = i18n(mod.category);
    results.push({
      getRank: rankModule,
      context: {
        title: moduleName,
        description: mod.descriptionRaw ? mod.description : snudown_es_markdown(i18n(mod.description)),
        category,
        moduleID: mod.moduleID,
        moduleName,
        keywords: mod.keywords
      }
    });
    if (isEmpty_default()(mod.options)) continue;

    for (const [optionKey, option] of Object.entries(mod.options)) {
      if (option.noconfig) continue;
      const optionName = i18n(option.title);
      results.push({
        getRank: rankOption,
        context: {
          title: optionName,
          description: snudown_es_markdown(i18n(option.description).split('\n')[0]),
          advanced: option.advanced,
          category,
          moduleID: mod.moduleID,
          moduleName,
          optionKey,
          optionName,
          keywords: option.keywords || []
        }
      });
    }
  }

  return results;
});

function rankString(queryTerms, string) {
  if (!queryTerms || !queryTerms.length || !string) {
    return Infinity;
  }

  const indexes = indexesOfSearchTermsInString(queryTerms, sanitizeString(string, false));
  const weighted = indexes.map(item => 100 - item.value * (Math.log(item.matchedIndex + 1) / Math.log(5) + 1));
  return weighted.length ? weighted.reduce((a, b) => a + b, 0) : Infinity;
}

function rankModule(queryTerms, context) {
  const string = [context.moduleID, context.moduleName, context.category, context.description, ...context.keywords].join('~');
  return rankString(queryTerms, string) * 0.9;
}

function rankOption(queryTerms, context) {
  const string = [context.optionKey, context.title, context.description, ...context.keywords, context.moduleID, context.moduleName, context.category].join('~');
  return rankString(queryTerms, string);
}

function indexesOfSearchTermsInString(needles, haystack) {
  if (!haystack || !haystack.length) return [];
  return needles.map((needle, i) => ({
    matchedIndex: i,
    value: haystack.indexOf(needle)
  })).filter(item => item.value !== -1);
}

function sanitizeString(text, preserveSpaces) {
  if (text === undefined || text === null) {
    return '';
  }

  const replaceSpacesWith = preserveSpaces ? ' ' : '';
  return text.toString().toLowerCase().replace(/[,\/\s]+/g, replaceSpacesWith);
}

function onSearchResultSelected(moduleID, optionKey) {
  settingsNavigation_open(moduleID, optionKey);
}

const search_input = once_default()(() => downcast(string_namespaceObject.html`<input id="SearchRES-input" type="text" placeholder="${i18n('searchRESSettings')}">`, HTMLInputElement));

function drawSearchResults(query, results) {
  const $resultsContainer = $('#SearchRES-results-container');
  $resultsContainer.off('click', handleSearchResultClick).on('click', '.SearchRES-result-item', handleSearchResultClick);

  if (!query || !query.length) {
    $resultsContainer.hide();
    return;
  }

  const advancedResults = results.filter(({
    advanced
  }) => advanced).length;
  const count = results.length - advancedResults;
  const plural = count !== 1 ? 's' : '';
  $('#SearchRES-count').text(`${count} result${plural} for ${query}`);
  $resultsContainer.show();
  $resultsContainer.find('#SearchRES-query').text(query);

  if (advancedResults) {
    $resultsContainer.find('#SearchRES-results-hidden').addClass('advancedResults');
    $('#SearchRES-results-hidden a').off('click').on('click', () => {
      $(document.getElementById('RESAllOptions')).click();
      search_search();
      return false;
    });
  } else {
    $resultsContainer.find('#SearchRES-results-hidden').removeClass('advancedResults');
  }

  if (!results.length) {
    $resultsContainer.find('#SearchRES-results').hide();
  } else {
    $resultsContainer.find('#SearchRES-results').show();
    const resultsList = document.getElementById('SearchRES-results');
    empty(resultsList);
    resultsList.append(...results.map(drawSearchResultItem));
  }
}

const searchResultTemplate = ({
  title,
  category,
  description,
  moduleName,
  moduleID,
  optionName,
  optionKey
}) => string_namespaceObject.html`
	<div>
		<div class="SearchRES-result-header">
			<span class="SearchRES-result-title">${title}</span>
			<span class="SearchRES-breadcrumb">${i18n('RESSettingsConsole')}
				→ ${category}
				→ ${moduleName} (${moduleID})
				${optionName && optionKey ? ` → ${optionName} (${optionKey})` : optionKey && ` → ${optionKey}`}
			</span>
		</div>
		<div class="SearchRES-result-description">
			${string_namespaceObject.safe(description)}
		</div>
	</div>
`;

const drawSearchResultItem = memoize_default()(result => {
  const element = document.createElement('li');
  element.classList.add('SearchRES-result-item');

  if (result.advanced) {
    element.classList.add('advanced');
  }

  element.setAttribute('data-module-id', result.moduleID);

  if (result.optionKey) {
    element.setAttribute('data-option-key', result.optionKey);
  }

  element.appendChild(searchResultTemplate(result));
  const copybutton = createElement_namespaceObject.icon(0xF159, 'span', 'SearchRES-result-copybutton res-icon', i18n('searchCopyResultForComment'));
  element.insertBefore(copybutton, element.firstChild);
  return element;
});

function handleSearchResultClick(event) {
  const moduleID = this.getAttribute('data-module-id');
  const optionKey = this.getAttribute('data-option-key');

  if (event.target.classList.contains('SearchRES-result-copybutton')) {
    onSearchResultCopy(moduleID, optionKey);
  } else {
    onSearchResultSelected(moduleID, optionKey);
  }

  event.preventDefault();
}

function onSearchResultCopy(moduleID, optionKey) {
  const markdown = makeOptionSearchResultLink(moduleID, optionKey);
  alert_namespaceObject.open(`<textarea rows="5" cols="50">${markdown}</textarea><p>Copy and paste this into your comment</p>`);
}

const optionLinkTemplate = ({
  title,
  url,
  description,
  settingsUrl,
  category,
  moduleName,
  moduleUrl,
  moduleID,
  optionKey,
  optionUrl
}) => `
**[${title}](${url})** -- [](#gear) [RES settings console](${settingsUrl}) > ${category} > [${moduleName}](${moduleUrl} "${moduleID}")${optionKey ? ` > [${optionKey}](${optionUrl})` : ''}

${description}
`.trim();

function makeOptionSearchResultLink(moduleID, optionKey) {
  const module = modules_get(moduleID);
  const context = {
    moduleID,
    moduleName: i18n(module.moduleName),
    category: i18n(module.category),
    optionKey,
    title: optionKey ? optionKey : i18n(module.moduleName),
    description: optionKey ? i18n(module.options[optionKey].description) : i18n(module.description),
    url: makeUrlHash(moduleID, optionKey),
    settingsUrl: makeUrlHash(),
    moduleUrl: makeUrlHash(moduleID),
    optionUrl: makeUrlHash(moduleID, optionKey)
  };
  return `${optionLinkTemplate(context)}\n\n\n`;
}
// CONCATENATED MODULE: ./lib/modules/searchHelper.js



const searchHelper_module = new Module('searchHelper');
searchHelper_module.moduleName = 'searchHelperName';
searchHelper_module.category = 'browsingCategory';
searchHelper_module.description = 'searchHelperDesc';
searchHelper_module.options = {
  addSearchOptions: {
    title: 'searchHelperAddSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperAddSearchOptionsDesc'
  },
  defaultSortOption: {
    title: 'searchHelperDefaultSortOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'hot',
      value: 'hot'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    description: 'searchHelperDefaultSortOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  defaultTimeOption: {
    title: 'searchHelperDefaultTimeOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'all',
      value: 'all'
    }, {
      name: 'hour',
      value: 'hour'
    }, {
      name: 'day',
      value: 'day'
    }, {
      name: 'week',
      value: 'week'
    }, {
      name: 'month',
      value: 'month'
    }, {
      name: 'year',
      value: 'year'
    }],
    description: 'searchHelperDefaultTimeOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  legacySearch: {
    title: 'searchHelperLegacySearchTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperLegacySearchDesc'
  },
  toggleSearchOptions: {
    title: 'searchHelperToggleSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperToggleSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  hideSearchOptions: {
    title: 'searchHelperHideSearchOptionsTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperHideSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  userFilterBySubreddit: {
    title: 'searchHelperUserFilterBySubredditTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperUserFilterBySubredditDesc'
  },
  searchByFlair: {
    title: 'searchHelperSearchByFlairTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchByFlairDesc'
  },
  searchPageTabs: {
    title: 'searchHelperSearchPageTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchPageTabsDesc',
    bodyClass: true
  },
  defaultSearchTab: {
    title: 'searchHelperDefaultSearchTabTitle',
    type: 'enum',
    value: 'subreddits',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'subreddits',
      value: 'subreddits'
    }, {
      name: 'limit to subreddit',
      value: 'facets'
    }, {
      name: 'refine',
      value: 'options'
    }],
    description: 'searchHelperDefaultSearchTabDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  transitionSearchTabs: {
    title: 'searchHelperTransitionSearchTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperTransitionSearchTabsDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  searchBySubreddit: {
    title: 'searchHelperSearchBySubredditTitle',
    type: 'enum',
    value: 'default',
    values: [{
      name: 'default (let reddit manage it)',
      value: 'default'
    }, {
      name: 'always',
      value: 'always'
    }, {
      name: 'never',
      value: 'never'
    }],
    description: 'searchHelperSearchBySubredditDesc'
  }
};

searchHelper_module.contentStart = () => {
  if (searchHelper_module.options.addSearchOptions.value) {
    const searchExpando = document.getElementById('searchexpando');

    if (searchExpando) {
      let searchOptionsHtml = '<label>Sort:<select name="sort"><option value="relevance">relevance</option><option value="new">new</option><option value="hot">hot</option><option value="top">top</option><option value="comments">comments</option></select></label> <label>Time:<select name="t"><option value="all">all time</option><option value="hour">this hour</option><option value="day">today</option><option value="week">this week</option><option value="month">this month</option><option value="year">this year</option></select></label>';

      if ($(searchExpando).find('input[name=restrict_sr]').length) {
        searchOptionsHtml = `<br />${searchOptionsHtml}`;
      }

      if (searchHelper_module.options.defaultSortOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultSortOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      if (searchHelper_module.options.defaultTimeOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultTimeOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      $(searchExpando).find('#moresearchinfo').before(searchOptionsHtml);
    }
  }

  if (searchHelper_module.options.legacySearch.value) {
    $('form#search').append('<input type="hidden" name="feature" value="legacy_search" />');
  }

  if (searchHelper_module.options.userFilterBySubreddit.value) {
    const [, userProfile] = location.pathname.match(regexes.profile) || [];

    if (userProfile && document.referrer) {
      const referrer = new URL(document.referrer);
      let match, previousPage;

      if (match = referrer.pathname.match(regexes.subreddit)) {
        previousPage = `r/${match[1]}`;
      } else if (match = referrer.pathname.match(regexes.multireddit)) {
        previousPage = match[1];
      }

      if (previousPage) {
        $('.content[role=main]').prepend(`<div class="infobar"><a href="/${previousPage}/search?q=author:${userProfile} nsfw:no&restrict_sr=on">Search post of ${userProfile} on /${previousPage}</a></div>`);
      }
    }
  }

  const isLegacySearch = document.querySelector('#siteTable');

  if (searchHelper_module.options.toggleSearchOptions.value && isPageType('search') && isLegacySearch) {
    if (searchHelper_module.options.hideSearchOptions.value || location.hash === '#res-hide-options') {
      bodyClasses_namespaceObject.add('res-hide-options');
    }

    $('.content .searchpane').append('<a href="#res-hide-options" class="searchpane-toggle-hide">hide search options</a>');
    $('.content .searchpane ~ .menuarea').prepend('<a href="#res-show-options" class="searchpane-toggle-show">show search options</a>');
    $('.searchpane-toggle-hide').on('click', () => bodyClasses_namespaceObject.add('res-hide-options'));
    $('.searchpane-toggle-show').on('click', () => bodyClasses_namespaceObject.remove('res-hide-options'));
  }

  if (searchHelper_module.options.searchByFlair.value) {
    $('#siteTable').on('mouseenter', '.linkflairlabel:not(.res-flairSearch)', e => {
      const subreddit = Thing_Thing.checkedFrom(e.target).getSubreddit();
      const flair = e.target.title.replace(/\s/g, '+');

      if (flair) {
        e.target.classList.add('res-flairSearch');
        e.target.appendChild(string_namespaceObject.html`<a href="${string_namespaceObject.encode`/r/${subreddit}/search?sort=new&restrict_sr=on&q=flair%3A${flair}`}"></a>`);
      }
    });
  }

  if (searchHelper_module.options.searchPageTabs.value && !isLegacySearch) {
    const $searchTabsEle = $('<ul>', {
      class: 'res-search-tabs'
    });
    const searchHeader = document.querySelector('#previoussearch');
    const searchForm = document.querySelector('.content form#search');
    const moreSearchInfo = document.querySelector('#moresearchinfo');
    const searchFacets = document.querySelector('body.search-page .searchfacets');
    const $searchOptions = $('<div>', {
      class: 'res-search-options'
    });

    if (!searchForm) {
      return;
    }

    searchForm.removeChild(searchForm.querySelector('#moresearchinfo + p'));
    $searchTabsEle.appendTo(searchHeader);
    const subredditResultListing = document.querySelectorAll('.search-result-listing');

    if (subredditResultListing.length > 1) {
      subredditResultListing[0].classList.add('res-search-subreddits');
    }

    if (moreSearchInfo) {
      $searchOptions.appendTo(searchHeader);
      $(moreSearchInfo).children().appendTo($searchOptions);
    }

    if (searchFacets) {
      $(searchFacets).appendTo(searchHeader);
    }

    if ($('.res-search-subreddits').length) {
      $('.res-search-subreddits').appendTo(searchHeader);
    }

    const searchTabs = {
      subreddits: {
        label: 'subreddits',
        id: 'subs',
        target: '.res-search-subreddits',
        exists: $('.res-search-subreddits').length
      },
      facets: {
        label: 'limit to subreddit',
        id: 'facets',
        target: '.searchfacets',
        exists: searchFacets
      },
      options: {
        label: 'refine',
        id: 'options',
        target: '.res-search-options',
        exists: $searchOptions.get(0)
      }
    };

    for (const searchTab of Object.values(searchTabs)) {
      if (searchTab.exists) {
        $(searchTab.target).addClass('res-search-pane').slideUp(0);
        const $searchTabLi = $('<li>').attr({
          class: `res-search-tab-${searchTab.id}`
        }).appendTo($searchTabsEle);
        $('<a>').attr({
          href: '#'
        }).text(searchTab.label).appendTo($searchTabLi).click(e => searchTabToggle(searchTab.id, searchTab.target, e.target));
      }
    }

    if (searchHelper_module.options.defaultSearchTab.value !== 'none' && searchTabs[searchHelper_module.options.defaultSearchTab.value].exists) {
      searchTabToggle(searchTabs[searchHelper_module.options.defaultSearchTab.value].id, searchTabs[searchHelper_module.options.defaultSearchTab.value].target, null);
    }
  }
};

searchHelper_module.afterLoad = () => {
  if (searchHelper_module.options.searchBySubreddit.value !== 'default' && !isPageType('search')) {
    const restrictSearch = document.querySelector('input[name=restrict_sr]');

    if (restrictSearch) {
        restrictSearch.checked = searchHelper_module.options.searchBySubreddit.value === 'always';
      }
  }
};

function searchTabToggle(tabID, target, source) {
  const transitionSpd = searchHelper_module.options.transitionSearchTabs.value ? 200 : 0;
  const sourceParent = source ? downcast(source.parentNode, HTMLElement) : null;
  const tab = sourceParent || document.querySelector(`.res-search-tabs .res-search-tab-${tabID}`);
  const activeClass = 'res-search-tab-active';
  const openClass = 'res-search-pane-open';

  if (tab.classList.contains(activeClass)) {
    $(target).removeClass(openClass).slideUp(transitionSpd);
    tab.classList.remove(activeClass);
  } else {
    $('.res-search-pane').addClass(openClass).slideUp(transitionSpd);
    $('.res-search-tabs li').removeClass(activeClass);
    $('.res-search-pane').removeClass(openClass);
    tab.classList.add(activeClass);
    const speed = sourceParent ? transitionSpd : 0;
    $(target).addClass(openClass).slideDown(speed);
  }

  return false;
}
// CONCATENATED MODULE: ./lib/modules/showKarma.js



const showKarma_module = new Module('showKarma');
showKarma_module.moduleName = 'showKarmaName';
showKarma_module.category = 'myAccountCategory';
showKarma_module.description = 'showKarmaDesc';
showKarma_module.options = {
  showCommentKarma: {
    title: 'showKarmaShowCommentKarmaTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaShowCommentKarmaDesc'
  },
  separator: {
    title: 'showKarmaSeparatorTitle',
    type: 'text',
    value: '\u00b7',
    description: 'showKarmaSeparatorDesc',
    advanced: true
  },
  useCommas: {
    title: 'showKarmaUseCommasTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaUseCommasDesc'
  },
  showGold: {
    title: 'showKarmaShowGoldTitle',
    type: 'boolean',
    value: false,
    description: 'showKarmaShowGoldDesc'
  }
};

showKarma_module.contentStart = async () => {
  const username = loggedInUser();

  if (username) {
    if (showKarma_module.options.showCommentKarma.value) {
      await updateKarmaDiv(username);
    } else {
      formatPostKarma();
    }

    if (showKarma_module.options.showGold.value) {
      updateUserSpan();
    }
  }
};

async function updateKarmaDiv(username) {
  const karmaDiv = document.querySelector('#header-bottom-right .userkarma');

  if (karmaDiv) {
    karmaDiv.title = '';
    const {
      data
    } = await getUserInfo();
    let postKarma = data.link_karma;
    let commentKarma = data.comment_karma;

    if (showKarma_module.options.useCommas.value) {
      postKarma = commaNumber(postKarma);
      commentKarma = commaNumber(commentKarma);
    } else {
      postKarma = uncommaNumber(postKarma);
    }

    $(karmaDiv).safeHtml(`<a title="post karma" href="/user/${username}/submitted/">${postKarma}</a>
			${showKarma_module.options.separator.value}
			<a title="comment karma" href="/user/${username}/comments/">${commentKarma}</a>`);
  }
}

async function updateUserSpan() {
  const userSpan = document.querySelector('#header-bottom-right .user');

  if (userSpan) {
    const {
      data
    } = await getUserInfo();

    if (data.is_gold) {
      const $gilded = $('<span>', {
        class: 'gilded-icon'
      });

      if (data.gold_expiration) {
        const today = new Date();
        const expDate = new Date(data.gold_expiration * 1000);
        $gilded.attr('title', `Until ${formatDate(expDate)} (${formatDateDiff(today, expDate)})`);
      }

      $(userSpan).prepend($gilded);
    }
  }
}

function formatPostKarma(value) {
  const container = document.querySelector('#header-bottom-right .user .userkarma');
  value = typeof value !== 'undefined' ? value : container.textContent;

  if (!showKarma_module.options.useCommas.value) {
    container.textContent = uncommaNumber(value);
  }
}

function commaNumber(value) {
  return formatNumber(value);
}

function uncommaNumber(value) {
  const match = String(value || 0).match(/(\w+)/g);
  return match ? match.join('') : '0';
}
// CONCATENATED MODULE: ./lib/modules/sourceSnudown.js





const sourceSnudown_module = new Module('sourceSnudown');
sourceSnudown_module.moduleName = 'sourceSnudownName';
sourceSnudown_module.description = 'sourceSnudownDesc';
sourceSnudown_module.category = 'commentsCategory';

sourceSnudown_module.beforeLoad = () => {
  watchForThings(['post', 'comment', 'message'], attachViewSourceButton);
};

const sourceButton = (e => () => preventCloning(e().cloneNode(true)))(once_default()(() => {
  $(document.body).on('click', 'li.viewSource a', function (e) {
    e.preventDefault();
    viewSource(this);
  }).on('click', '.usertext-edit.viewSource .cancel', function () {
    $(this).parents('.usertext-edit.viewSource').hide();
  });
  return string_namespaceObject.html`
		<li class="viewSource">
			<a class="noCtrlF" href="javascript:void 0" data-text="source"></a>
		</li>
	`;
}));

function attachViewSourceButton(thing) {
  if (thing.isLinkPost()) return;
  const buttons = thing.entry.querySelector('.flat-list.buttons > li.first') || thing.entry.querySelector('.flat-list.buttons > li');
  if (buttons) buttons.after(sourceButton());
}

const viewSource = keyedMutex(async button => {
  const $button = $(button);
  const $buttonList = $button.closest('ul');

  if ($button.data('source-open')) {
    $button.closest('.thing').find('.usertext-edit.viewSource:first').toggle();
  } else {
    const path = $buttonList.find('a.bylink, .first a').get(0).pathname;
    const response = await ajax({
      url: `${path}.json`,
      query: {
        raw_json: 1
      },
      type: 'json'
    });
    const $userTextForm = $('<div class="usertext-edit viewSource"><div><textarea rows="1" cols="1" name="text" readonly></textarea></div><div class="bottom-area"><div class="usertext-buttons"><button type="button" class="cancel">hide</button></div></div></div>');
    $userTextForm.find('textarea').one('dblclick', () => $userTextForm.removeAttr('readonly'));
    let sourceText;

    if (regexes.commentPermalink.test(path)) {
      sourceText = response[1].data.children[0].data.body;
    } else if (regexes.comments.test(path)) {
      sourceText = response[0].data.children[0].data.selftext;
    } else {
      const postId = /\/(\w*)\/?$/.exec(path)[1];
      const data = response.data.children[0].data;

      if (data.id === postId) {
        sourceText = data.body;
      } else {
        sourceText = data.replies.data.children.find(({
          data: {
            id
          }
        }) => id === postId).data.body;
      }
    }

    $userTextForm.find('textarea[name=text]').text(sourceText);
    $buttonList.before($userTextForm);
    $(button).data('source-open', true);
  }
});
// CONCATENATED MODULE: ./lib/modules/spamButton.js



const spamButton_module = new Module('spamButton');
spamButton_module.moduleName = 'spamButtonName';
spamButton_module.category = 'submissionsCategory';
spamButton_module.disabledByDefault = true;
spamButton_module.description = 'spamButtonDesc';

spamButton_module.beforeLoad = () => {
  watchForThings(['post', 'comment'], addSpamButton);
};

function addSpamButton(thing) {
  const authorElement = thing.getAuthorElement();
  const authorName = thing.getAuthor();
  if (!authorElement || !authorName || loggedInUser() === authorName) return;
  const list = thing.entry.querySelector('.buttons');
  const spam = document.createElement('li');
  $(list.lastChild).before(spam);
  const a = document.createElement('a');
  a.setAttribute('class', 'option');
  a.setAttribute('title', 'Report this user as a spammer');
  a.href = `/message/compose?to=/r/reddit.com&subject=spam&message=${authorElement.href}`;
  a.target = '_blank';
  a.rel = 'noopener noreferer';
  a.textContent = 'rts';
  spam.appendChild(a);
}
// CONCATENATED MODULE: ./lib/modules/spoilerTags.js

const spoilerTags_module = new Module('spoilerTags');
spoilerTags_module.moduleName = 'spoilerTagsName';
spoilerTags_module.category = 'appearanceCategory';
spoilerTags_module.description = 'spoilerTagsDesc';
spoilerTags_module.include = ['profile'];
spoilerTags_module.bodyClass = true;
spoilerTags_module.options = {
  transition: {
    title: 'spoilerTagsTransitionTitle',
    type: 'boolean',
    value: true,
    description: 'spoilerTagsTransitionDesc',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/styleTweaks.js


const styleTweaks_module = new Module('styleTweaks');
styleTweaks_module.moduleName = 'styleTweaksName';
styleTweaks_module.category = 'appearanceCategory';
styleTweaks_module.description = 'styleTweaksDesc';
styleTweaks_module.options = {
  navTop: {
    title: 'styleTweaksNavTopTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksNavTopDesc',
    bodyClass: 'res-navTop'
  },
  disableAnimations: {
    title: 'styleTweaksDisableAnimationsTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksDisableAnimationsDesc',
    bodyClass: true
  },
  visitedStyle: {
    title: 'styleTweaksVisitedStyleTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksVisitedStyleDesc',
    bodyClass: true
  },
  showExpandos: {
    title: 'styleTweaksShowExpandosTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksShowExpandosDesc',
    advanced: true,
    bodyClass: true
  },
  hideUnvotable: {
    title: 'styleTweaksHideUnvotableTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksHideUnvotableDesc',
    bodyClass: true
  },
  showFullLinkFlair: {
    title: 'styleTweaksShowFullLinkFlairTitle',
    type: 'enum',
    values: [{
      name: 'Never',
      value: 'never'
    }, {
      name: 'On hover',
      value: 'hover'
    }, {
      name: 'Always',
      value: 'always'
    }],
    value: 'never',
    description: 'styleTweaksShowFullLinkFlairDesc',
    bodyClass: true
  },
  highlightEditedTime: {
    title: 'styleTweaksHighlightEditedTimeTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightEditedTimeDesc',
    bodyClass: true
  },
  colorBlindFriendly: {
    title: 'styleTweaksColorBlindFriendlyTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksColorBlindFriendlyDesc',
    advanced: true,
    bodyClass: 'res-colorblind'
  },
  scrollSubredditDropdown: {
    title: 'styleTweaksScrollSubredditDropdownTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksScrollSubredditDropdownDesc',
    advanced: true,
    bodyClass: true
  },
  highlightTopLevel: {
    title: 'styleTweaksHighlightTopLevelTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightTopLevelDesc'
  },
  highlightTopLevelColor: {
    title: 'styleTweaksHighlightTopLevelColorTitle',
    type: 'color',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelColorDesc',
    value: '#8B0000'
  },
  highlightTopLevelSize: {
    title: 'styleTweaksHighlightTopLevelSizeTitle',
    type: 'text',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelSizeDesc',
    value: '2'
  },
  floatingSideBar: {
    title: 'styleTweaksFloatingSideBarTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksFloatingSideBarDesc',
    advanced: true,
    bodyClass: true
  },
  postTitleCapitalization: {
    title: 'styleTweaksPostTitleCapitalizationTitle',
    description: 'styleTweaksPostTitleCapitalizationDesc',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'do nothing',
      value: 'none'
    }, {
      name: 'Title Case',
      value: 'title'
    }, {
      name: 'Sentence case',
      value: 'sentence'
    }, {
      name: 'lowercase',
      value: 'lowercase'
    }],
    bodyClass: true
  },
  hideDomainLink: {
    title: 'styleTweaksHideDomainLink',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHideDomainLinkDesc',
    bodyClass: true
  }
};

styleTweaks_module.beforeLoad = () => {
  if (styleTweaks_module.options.highlightTopLevel.value) {
    const highlightTopLevelColor = styleTweaks_module.options.highlightTopLevelColor.value || styleTweaks_module.options.highlightTopLevelColor.default;
    const highlightTopLevelSize = parseInt(styleTweaks_module.options.highlightTopLevelSize.value || styleTweaks_module.options.highlightTopLevelSize.default, 10);
    addCSS(`
			.nestedlisting > .comment + .clearleft {
				height: ${highlightTopLevelSize}px !important;
				margin-bottom: 5px;
				background: ${highlightTopLevelColor} !important;
			}
			.Comment.top-level {
				border-top: ${highlightTopLevelSize}px solid ${highlightTopLevelColor};
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/stylesheet.js







const stylesheet_module = new Module('stylesheet');
stylesheet_module.moduleName = 'stylesheetName';
stylesheet_module.description = 'stylesheetDesc';
stylesheet_module.category = 'appearanceCategory';
stylesheet_module.exclude = ['prefs', 'account', 'stylesheet', 'subredditAbout'];
stylesheet_module.options = {
  redditThemes: {
    title: 'stylesheetRedditThemesTitle',
    description: 'stylesheetRedditThemesDesc',
    type: 'button',
    text: 'learn more',

    callback() {
      window.location.href = 'https://www.reddit.com/r/Enhancement/wiki/faq/srstyle#reddit_themes';
    }

  },
  loadStylesheets: {
    title: 'stylesheetLoadStylesheetsTitle',
    type: 'table',
    description: 'stylesheetLoadStylesheetsDesc',
    value: [],
    fields: [{
      key: 'urlOrSubreddit',
      name: 'url or subreddit',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  snippets: {
    title: 'stylesheetSnippetsTitle',
    type: 'table',
    description: 'stylesheetSnippetsDesc',
    value: [],
    fields: [{
      key: 'snippet',
      name: 'snippet',
      type: 'textarea'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  bodyClasses: {
    title: 'stylesheetBodyClassesTitle',
    type: 'table',
    description: 'stylesheetBodyClassesDesc',
    value: [],
    fields: [{
      key: 'classes',
      name: 'classes',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  subredditClass: {
    title: 'stylesheetSubredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetSubredditClassDesc'
  },
  multiredditClass: {
    title: 'stylesheetMultiredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetMultiredditClassDesc'
  },
  usernameClass: {
    title: 'stylesheetUsernameClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetUsernameClassDesc'
  },
  loggedInUserClass: {
    title: 'stylesheetLoggedInUserClassTitle',
    type: 'boolean',
    value: false,
    description: 'stylesheetLoggedInUserClassDesc'
  }
};

stylesheet_module.beforeLoad = () => {
  if (stylesheet_module.options.subredditClass.value) {
    applySubredditClass();
  }

  if (stylesheet_module.options.usernameClass.value) {
    applyUsernameClass();
  }

  if (stylesheet_module.options.multiredditClass.value) {
    applyMultiredditClass();
  }

  $(customToggles_module).on('toggle', applyStyles);
  applyStyles();

  function applyStyles() {
    applyBodyClasses();
    loadStylesheets();
    applyCssSnippets();
  }
};

stylesheet_module.contentStart = () => {
  if (stylesheet_module.options.loggedInUserClass.value) {
    applyLoggedInUserClass();
  }
};

function applySubredditClass() {
  let name = currentSubreddit();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-r-${name}`);
  }
}

function applyMultiredditClass() {
  let name = currentMultireddit();

  if (name) {
    name = name.toLowerCase().replace(/\//g, '-');
    bodyClasses_namespaceObject.add(`res-${name}`);
  }
}

function applyUsernameClass() {
  let name = currentUserProfile();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-user-${name}`);
  }
}

function applyLoggedInUserClass() {
  let name = loggedInUser();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-me-${name}`);
  }
}

function applyBodyClasses() {
  const addClasses = stylesheet_module.options.bodyClasses.value.filter(row => shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  const removeClasses = stylesheet_module.options.bodyClasses.value.filter(row => !shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  bodyClasses_namespaceObject.add(...addClasses);
  bodyClasses_namespaceObject.remove(...removeClasses);
}

const subredditNameRegexp = /^(?:\/?r\/)?([\w_]+)\/?$/;
const urlRegexp = /^(?:https?:\/\/[\w\.]+)?\/\w+/;
const sanitizeStylesheetUrls = filterMap(([url]) => {
  const subredditMatch = subredditNameRegexp.exec(url);

  if (subredditMatch) {
    return [`/r/${subredditMatch[1]}/stylesheet.css`];
  } else if (urlRegexp.test(url)) {
    return [url];
  }
});

function loadStylesheets() {
  const stylesheetUrls = flow_default()(filter_default()(row => shouldApply(row[3], row[1], row[2])), sanitizeStylesheetUrls)(stylesheet_module.options.loadStylesheets.value);

  stylesheetManager.sync(stylesheetUrls);
}

const stylesheetManager = stylesheetElementManager(url => string_namespaceObject.html`<link rel="stylesheet" href="${url}">`);

function applyCssSnippets() {
  const snippets = stylesheet_module.options.snippets.value.filter(row => shouldApply(row[3], row[1], row[2])).map(([css]) => css);
  snippetManager.sync(snippets);
}

const snippetManager = stylesheetElementManager(css => {
  const style = document.createElement('style');
  style.textContent = css;
  return style;
});

function stylesheetElementManager(generateElement) {
  const current = new Map();
  return {
    sync: function (wantedKeys) {
      const currentKeys = Array.from(current.keys());

      difference_default()(wantedKeys, currentKeys).forEach(x => {
        const ele = generateElement(x);
        current.set(x, ele);
        (document.head || document.documentElement).append(ele);
      });

      difference_default()(currentKeys, wantedKeys).forEach(x => {
        const ele = current.get(x);
        current.delete(x);
        if (ele) ele.remove();
      });
    }
  };
}

function shouldApply(toggle, applyTo, applyList) {
  if (toggle && !toggleActive(toggle)) return false;
  let subreddit = currentSubreddit();

  if (!subreddit) {
    return applyTo !== 'include';
  }

  subreddit = subreddit.toLowerCase();
  applyList = typeof applyList === 'string' ? applyList.toLowerCase().split(',') : [];

  switch (applyTo) {
    case 'exclude':
      return !(applyList.includes(subreddit) || applyList.includes('all'));

    case 'include':
      return applyList.includes(subreddit) || applyList.includes('all');

    default:
      return true;
  }
}

function stylesheet_getToggles() {
  return [{
    name: 'No toggle needed',
    value: ''
  }, ...customToggles_getToggles().map(({
    key,
    text
  }) => ({
    name: text,
    value: key
  }))];
}
// CONCATENATED MODULE: ./lib/modules/submitHelper.js








const submitHelper_module = new Module('submitHelper');
submitHelper_module.moduleName = 'submitHelperName';
submitHelper_module.category = 'submissionsCategory';
submitHelper_module.description = 'submitHelperDesc';
submitHelper_module.options = {
  warnAlreadySubmitted: {
    title: 'submitHelperWarnAlreadySubmittedTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperWarnAlreadySubmittedDesc'
  },
  uncheckSendRepliesToInbox: {
    title: 'submitHelperUncheckSendRepliesToInboxTitle',
    type: 'boolean',
    value: false,
    description: 'submitHelperUncheckSendRepliesToInboxDesc'
  },
  focusFormOnLoad: {
    title: 'submitHelperFocusFormOnLoadTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperFocusFormOnLoadDesc'
  }
};

const $repostWarning = once_default()(() => $(string_namespaceObject.html`
	<div class="spacer" style="display: none">
		<div class="roundfield info-notice">
			<a style="float: right" class="gearIcon" href="${makeUrlHash(submitHelper_module.moduleID, 'warnAlreadySubmitted')}"></a>
			<p>This link was submitted to <a class="subredditLink" href="#"></a>:<span class="time"></span><a class="seeMore" href="#" target="_blank" rel="noopener noreferer">(see more)</a></p>
		</div>
	</div>
`));

let urlField, srField;

submitHelper_module.go = () => {
  implementOptions();

  if (!isPageType('submit')) {
    submitHelper_registerCommandLine();
  }
};

async function implementOptions() {
  if (isAppType('d2x')) {
    waitForEvent(document, 'reddit.urlChanged').then(implementOptions);
  }

  if (!isPageType('submit')) {
    return;
  }

  if (submitHelper_module.options.warnAlreadySubmitted.value) {
    const urlFieldDiv = document.querySelector('#url-field');

    if (urlFieldDiv) {
      $(urlFieldDiv).parent().after($repostWarning());
      urlField = urlFieldDiv.querySelector('#url');
      srField = document.querySelector('#sr-autocomplete');
      $([srField, urlField]).on('input keydown', debounce_default()(updateRepostWarning, 300));
      $('#suggested-reddits a, #sr-drop-down').on('click', updateRepostWarning);
      const linkButton = document.querySelector('a.link-button');
      const textButton = document.querySelector('a.text-button');

      if (linkButton && textButton) {
        linkButton.addEventListener('click', () => {
          updateRepostWarning();
        });
        textButton.addEventListener('click', () => {
          $repostWarning().hide();
        });
      }
    }
  }

  if (submitHelper_module.options.uncheckSendRepliesToInbox.value) {
    const selector = isAppType('d2x') ? '[aria-labelledby="send-replies"]' : '#sendreplies';
    const sendReplies = await waitForDescendant(document.documentElement, selector);

    if (sendReplies) {
      sendReplies.click();
    }
  }

  if (submitHelper_module.options.focusFormOnLoad.value) {
    $('form.submit [name=url], form.submit [name=title]').filter(':visible').first().focus();
  }
}

function submitHelper_registerCommandLine() {
  const trailingUrl = /(?:\s+(\w+:\/\/.+))$/;
  const cliParams = /^(?:(?:\/?r\/)?(\w+))?(?:\s+(.*))?$/;

  function commandLineParameters(val) {
    const urlResult = trailingUrl.exec(val);
    const result = cliParams.exec(urlResult ? val.slice(0, val.length - urlResult[0].length) : val);
    return result ? result.slice(1).concat(urlResult ? urlResult[1] : undefined) : [];
  }

  registerCommand(/^p(?:ost)?$/, 'post [subreddit] [title] [url] - submit a post to a subreddit', (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);

    if (!subreddit) {} else if (url) {
      return `Post ${url} to /r/${subreddit}: ${title || ''}`;
    } else if (title) {
      return `Post to /r/${subreddit}: ${title}`;
    } else if (subreddit) {
      return `Post to /r/${subreddit}`;
    }
  }, (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);
    const redirect = subreddit ? string_namespaceObject.encode`/r/${subreddit}/submit?title=${title || ''}&url=${url || ''}` : '/submit';
    window.location = redirect;
  });
}

function showRepostWarning(sr, url, date) {
  $repostWarning().find('.subredditLink').attr('href', `/r/${sr}`).text(`/r/${sr}`).end().find('.seeMore').attr('href', string_namespaceObject.encode`/r/${sr}/search?restrict_sr=on&sort=relevance&q=url%3A${url}`).end().find('.time').text(` ${i18n('submitHelperTimeAgo', formatDateDiff(date))} `).end().fadeIn(300);
}

function hideRepostWarning() {
  $repostWarning().fadeOut(300);
}

async function updateRepostWarning() {
  if (!urlField.value) return;
  const stripUrlRe = /^(?:https?:\/\/)?(?:(?:www|i|m)\.)?(.+?)\/?(?:\.\w+)?(?:#[^\/]*)?$/i;
  const subreddit = srField.value;
  const match = stripUrlRe.exec(urlField.value);

  if (subreddit && match) {
    const [, userUrl] = match;

    try {
      const {
        data
      } = await ajax({
        url: string_namespaceObject.encode`/r/${subreddit}/search.json`,
        query: {
          restrict_sr: 'on',
          sort: 'relevance',
          limit: 1,
          q: `url:${userUrl}`
        },
        type: 'json'
      });

      if (data && data.children.length && data.children[0].data.url.match(stripUrlRe)[1] === userUrl) {
        showRepostWarning(subreddit, userUrl, new Date(data.children[0].data.created_utc * 1000));
      } else {
        hideRepostWarning();
      }
    } catch (e) {
      hideRepostWarning();
      throw e;
    }
  } else {
    hideRepostWarning();
  }
}
// CONCATENATED MODULE: ./lib/modules/subredditInfo.js









const subredditInfo_module = new Module('subredditInfo');
subredditInfo_module.moduleName = 'subredditInfoName';
subredditInfo_module.category = 'subredditsCategory';
subredditInfo_module.description = 'subredditInfoDesc';
subredditInfo_module.options = {
  requireDirectLink: {
    title: 'subredditInfoRequireDirectLinkTitle',
    type: 'boolean',
    value: true,
    description: 'subredditInfoRequireDirectLinkDesc'
  },
  hoverDelay: {
    title: 'subredditInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'subredditInfoHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'subredditInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditInfoFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'subredditInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'subredditInfoFadeSpeedDesc',
    advanced: true
  }
};

subredditInfo_module.contentStart = () => {
  const linkSelector = ['a.subreddit', 'a.search-subreddit-link', '.md a[href^="/r/"]', '.Post a[href^="/r/"]:not([href*="/comments/"])', '.Comment a[href^="/r/"]:not([href*="/comments/"])', 'a[data-click-id="subreddit"]', !subredditInfo_module.options.requireDirectLink.value && '.md a[href*="reddit.com/r/"]'].filter(x => x).join(', ');
  $(document.body).on('mouseenter', linkSelector, subredditInfo_handleMouseEnter);
};

function subredditInfo_handleMouseEnter(e) {
  const target = downcast(e.target, HTMLAnchorElement);
  const match = regexes.subreddit.exec(target.pathname);
  if (!match) return;
  const [, subreddit] = match;
  infocard(subredditInfo_module.moduleID).target(target).options({
    width: 450,
    openDelay: parseFloat(subredditInfo_module.options.hoverDelay.value),
    fadeDelay: parseFloat(subredditInfo_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(subredditInfo_module.options.fadeSpeed.value)
  }).populateWith(card => showSubredditInfo(card, subreddit)).begin();
}

async function showSubredditInfo(card, subreddit) {
  const header = string_namespaceObject.html`<div><a href="/r/${subreddit}">/r/${subreddit}</a></div>`;
  let jsonData;

  try {
    jsonData = await ajax({
      url: `/r/${subreddit.toLowerCase()}/about.json`,
      type: 'json',
      cacheFor: HOUR
    });
  } catch (e) {
    return [null, i18n('subredditInfoErrorLoadingSubredditInfo')];
  }

  if (jsonData.kind !== 't5') {
    return [null, i18n('subredditInfoSubredditNotFound')];
  }

  if (loggedInUser()) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoSubscribe'), '', !!jsonData.data.user_is_subscriber, state => {
      subscribeToSubreddit(jsonData.data.name, state);
      ajax.invalidate({
        url: `/r/${subreddit}/about.json`
      });
    });
    button.style.marginLeft = '12px';
    header.appendChild(button);

    if (modules_isEnabled(subredditManager_namespaceObject)) {
      getMultiCounts(jsonData.data.display_name).then(v => $(button).after(v));
    }
  }

  const d = new Date(jsonData.data.created_utc * 1000);
  const $newBody = $(string_namespaceObject.html`
		<div class="subredditInfoToolTip">
			<div class="subredditLabel">${i18n('subredditInfoSubredditCreated')}</div> <div class="subredditDetail">${formatDate(d)} (${formatDateDiff(d)})</div>
			<div class="subredditLabel">${i18n('subredditInfoSubscribers')}</div> <div class="subredditDetail">${formatNumber(jsonData.data.subscribers)}</div>
			<div class="subredditLabel">${i18n('subredditInfoTitle')}</div> <div class="subredditDetail">${jsonData.data.title}</div>
			<div class="subredditLabel">${i18n('subredditInfoOver18')}</div> <div class="subredditDetail">${jsonData.data.over18 ? i18n('yes') : i18n('no')}</div>
			<div class="clear"></div>
			<div id="subTooltipButtons" class="bottomButtons">
				<div class="clear"></div>
			</div>
		</div>
	`);

  if (isRunning(subredditManager_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createShortcutToggleButton(subreddit));
  }

  if (modules_isEnabled(dashboard_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createSubredditToggleButton(subreddit));
  }

  if (modules_isEnabled(filteReddit_namespaceObject)) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveFilter'), i18n('subredditInfoFilterFromAllAndDomain'), listFilters.subreddits.includesString(subreddit), state => listFilters.subreddits.toggleString(subreddit, state));
    $newBody.find('#subTooltipButtons').append(button);
  }

  return [header, $newBody];
}
// CONCATENATED MODULE: ./lib/modules/subredditTagger.js



const subredditTagger_module = new Module('subRedditTagger');
subredditTagger_module.moduleName = 'subredditTaggerName';
subredditTagger_module.category = 'subredditsCategory';
subredditTagger_module.description = 'subredditTaggerDesc';
subredditTagger_module.options = {
  subReddits: {
    title: 'subRedditTaggerSubRedditsTitle',
    type: 'table',
    addRowText: '+add tag',
    fields: [{
      key: 'subreddit',
      name: 'subreddit',
      type: 'text'
    }, {
      key: 'doesntContain',
      name: 'doesntContain',
      type: 'text'
    }, {
      key: 'tag',
      name: 'tag',
      type: 'text'
    }],
    value: [],
    description: 'subRedditTaggerSubRedditsDesc'
  }
};
const SRTDoesntContain = new Map();
const SRTTagWith = new Map();

subredditTagger_module.beforeLoad = () => {
  if (!subredditTagger_module.options.subReddits.value.length) return;

  for (const [subreddit, doesntContain, tagWith] of subredditTagger_module.options.subReddits.value) {
    SRTDoesntContain.set(subreddit.toLowerCase(), doesntContain);
    SRTTagWith.set(subreddit.toLowerCase(), tagWith);
  }

  watchForThings(['post'], scanTitle);
};

function scanTitle(thing) {
  const tagToAdd = getTag(thing);

  if (tagToAdd !== undefined) {
    const tagText = $('<span>').append(escapeHTML(tagToAdd)).append('&nbsp;');
    $(thing.getTitleElement()).parent().prepend(tagText);
  }
}

function getTag(thing) {
  let hasTag = false;
  const thisSubReddit = (thing.getSubreddit() || '').toLowerCase();

  if (thisSubReddit && SRTTagWith.has(thisSubReddit)) {
    let thisString = SRTDoesntContain.get(thisSubReddit);

    if (thisString === undefined || thisString === '') {
      thisString = `[${thisSubReddit}]`;
      SRTDoesntContain.set(thisSubReddit, thisString);
    }

    hasTag = thing.getTitle().includes(thisString) || thing.getPostFlairText().includes(thisString);
  }

  if (!hasTag) {
    return SRTTagWith.get(thisSubReddit);
  }
}
// CONCATENATED MODULE: ./lib/modules/tableTools.js



const tableTools_module = new Module('tableTools');
tableTools_module.moduleName = 'tableToolsName';
tableTools_module.category = 'productivityCategory';
tableTools_module.description = 'tableToolsDesc';
tableTools_module.options = {
  sort: {
    title: 'tableToolsSortTitle',
    type: 'boolean',
    value: true,
    description: 'tableToolsSortDesc',
    bodyClass: true
  }
};

tableTools_module.shouldRun = () => !isCurrentSubreddit('dashboard');

tableTools_module.contentStart = () => {
  if (tableTools_module.options.sort.value) {
    $(document).on('click', '.md th, .Comment th, .Post th', e => sortTableColumn(e.currentTarget));
  }
};

function sortTableColumn(target) {
  const $columnHeader = $(target);
  const table = $columnHeader.closest('table');
  const rows = table.find('tr:gt(0)').toArray();
  const column = $columnHeader.index();
  rows.sort(sortFunction(column));
  $columnHeader.siblings().removeClass('sort-desc sort-asc');

  if ($columnHeader.hasClass('sort-asc')) {
    rows.reverse();
    $columnHeader.removeClass('sort-asc');
    $columnHeader.addClass('sort-desc');
  } else {
    $columnHeader.removeClass('sort-desc');
    $columnHeader.addClass('sort-asc');
  }

  table.append(rows);
}

function sortFunction(column) {
  return (rowA, rowB) => {
    const a = getCellValue(rowA, column);
    const b = getCellValue(rowB, column);
    return isNumeric(a) && isNumeric(b) ? +a - +b : a.localeCompare(b);
  };
}

function isNumeric(n) {
  const num = parseFloat(n);
  return !Number.isNaN(num) && Number.isFinite(num);
}

function getCellValue(row, column) {
  return $(row).children('td').eq(column).text();
}
// CONCATENATED MODULE: ./lib/modules/temporaryDropdownLinks.js



const temporaryDropdownLinks_module = new Module('temporaryDropdownLinks');
temporaryDropdownLinks_module.moduleName = 'temporaryDropdownLinksName';
temporaryDropdownLinks_module.category = 'browsingCategory';
temporaryDropdownLinks_module.description = 'temporaryDropdownLinksDesc';
temporaryDropdownLinks_module.options = {
  always: {
    type: 'boolean',
    value: false,
    description: 'temporaryDropdownLinksAlwaysDesc',
    title: 'temporaryDropdownLinksAlwaysTitle'
  }
};
temporaryDropdownLinks_module.include = [/\/(?:top|controversial)\/$/];

temporaryDropdownLinks_module.contentStart = () => {
  setupMenu();
};

function setupMenu() {
  const mutateChoice = temporaryDropdownLinks_module.options.always.value ? removeListener : appendTemporaryButton;

  for (const choice of document.querySelectorAll('.menuarea .drop-choices a.choice')) {
    const form = choice.closest('form');
    if (!form) continue;
    const {
      name,
      value
    } = downcast(form.querySelector('input'), HTMLInputElement);

    if (name && value) {
      mutateChoice(choice, name, value);
    }
  }
}

function removeListener(choice, name, value) {
  choice.search = `?${name}=${value}`;
  choice.removeAttribute('onclick');
}

function appendTemporaryButton(choice, name, value) {
  const url = new URL(choice.href);
  url.searchParams.set(name, value);
  const link = string_namespaceObject.html`
		<a class="RES-dropdown-button" href="${url.href}">${i18n('temporaryDropdownLinksTemporarily')}</a>
	`;
  link.addEventListener('click', e => e.stopPropagation());
  choice.appendChild(link);
}
// CONCATENATED MODULE: ./lib/modules/userbarHider.js






const userbarHider_module = new Module('userbarHider');
userbarHider_module.moduleName = 'userbarHiderName';
userbarHider_module.description = 'userbarHiderDesc';
userbarHider_module.category = 'myAccountCategory';
userbarHider_module.disabledByDefault = true;
userbarHider_module.options = {
  userbarState: {
    title: 'userbarHiderUserbarStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderUserbarStateDesc'
  },
  toggleButtonState: {
    title: 'userbarHiderToggleButtonStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderToggleButtonStateDesc',
    advanced: true
  }
};
let userbarHider_userbar, $userbarToggle;

userbarHider_module.contentStart = () => {
  userbarHider();
};

function userbarHider() {
  userbarHider_userbar = document.getElementById('header-bottom-right');

  if (userbarHider_userbar) {
    if (userbarHider_module.options.toggleButtonState.value === 'visible' || userbarHider_module.options.userbarState.value === 'hidden') {
      addToggleButton();
    }

    if (userbarHider_module.options.userbarState.value === 'hidden') {
      updateUserBar();
      notifications_showNotification({
        moduleID: userbarHider_module.moduleID,
        optionKey: 'userbarState',
        cooldown: 24 * 60 * 60 * 1000,
        header: i18n('userbarHiderUserBarHidden'),
        message: i18n('userbarHiderContentHiddenNotification', '«')
      });
    }
  }
}

function toggleUserBar() {
  const userbarHidden = userbarHider_module.options.userbarState.value === 'hidden';
  updateUserbarStateOption(!userbarHidden);
  updateUserBar();
}

function updateUserBar() {
  const userbarHidden = userbarHider_module.options.userbarState.value === 'hidden';
  updateToggleButton(userbarHidden);
  toggleUserbarElementsDisplay(userbarHidden);
}

function addToggleButton() {
  $userbarToggle = $('<div>', {
    id: 'userbarToggle',
    title: i18n('userbarHiderToggleUserbar'),
    click: () => toggleUserBar()
  }).prependTo(userbarHider_userbar);
  document.querySelector('#header-bottom-right').classList.add('res-userbar-toggle');
  updateToggleButton(false);
}

function updateToggleButton(userbarHidden) {
  $userbarToggle.toggleClass('userbarHide', !userbarHidden).toggleClass('userbarShow', userbarHidden).html(userbarHidden ? '&laquo;' : '&raquo;');
}

function toggleUserbarElementsDisplay(userbarHidden) {
  bodyClasses_namespaceObject.toggle(userbarHidden, 'res-hide-userbar');
}

function updateUserbarStateOption(userbarHidden) {
  options_set(userbarHider_module, 'userbarState', userbarHidden ? 'hidden' : 'visible');
}
// CONCATENATED MODULE: ./lib/modules/version.js






const version_module = new Module('version');
version_module.moduleName = 'versionName';
version_module.category = 'aboutCategory';
version_module.description = 'versionDesc';
version_module.alwaysEnabled = true;
version_module.hidden = true;
const concurrentInstallWiki = '/r/Enhancement/wiki/tutorials/concurrent_installs';

version_module.beforeLoad = () => {
  addVersionClasses();
};

version_module.go = () => {
  reportVersion();
};

version_module.afterLoad = () => {
  avoidConcurrentInstalls();
};

function addVersionClasses() {
  bodyClasses_namespaceObject.add('res');
  const versionComponents = metadata_version.split('.');

  for (const i of range(0, versionComponents.length)) {
    bodyClasses_namespaceObject.add(`res-v${versionComponents.slice(0, i + 1).join('-')}`);
  }
}

function reportVersion() {
  $('<div>', {
    id: 'RESConsoleVersion',
    style: 'display: none;',
    text: metadata_version,
    'data-id': getExtensionId()
  }).appendTo(document.body);
}

function avoidConcurrentInstalls() {
  const installs = Array.from(document.querySelectorAll('#RESConsoleVersion'));

  const concurrentInstalls = uniqBy_default()(installs, e => e.getAttribute('data-id') || Math.random()).map(e => e.textContent);

  if (concurrentInstalls.length > 1) {
    bodyClasses_namespaceObject.add('res-concurrent-installs');
    document.body.appendChild(string_namespaceObject.html`
			<div id="res-concurrent-installs">
				<p>You have enabled multiple versions of Reddit Enhancement Suite:</p>
				<ul>
					${concurrentInstalls.map(v => string_namespaceObject._html`
						<li>${v}</li>
					`)}
				</ul>
				<p>You should enable only one. <a href="${concurrentInstallWiki}">Find out how!</a>
			</div>
		`);
  }
}
// EXTERNAL MODULE: ./node_modules/lodash/first.js
var first = __webpack_require__(142);
var first_default = /*#__PURE__*/__webpack_require__.n(first);

// CONCATENATED MODULE: ./lib/modules/voteEnhancements.js





const voteEnhancements_module = new Module('voteEnhancements');
voteEnhancements_module.moduleName = 'voteEnhancementsName';
voteEnhancements_module.category = 'appearanceCategory';
voteEnhancements_module.description = 'voteEnhancementsDesc';
voteEnhancements_module.options = {
  highlightScores: {
    title: 'voteEnhancementsHighlightScoresTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightScoresDesc',
    bodyClass: true
  },
  colorLinkScore: {
    title: 'voteEnhancementsColorLinkScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorLinkScoreDesc',
    bodyClass: true
  },
  userDefinedLinkColoration: {
    title: 'voteEnhancementsUserDefinedLinkColorationTitle',
    dependsOn: options => options.colorLinkScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#F2B035'], [50, '#FF4500'], [100, '#D92B2B']],
    description: 'voteEnhancementsUserDefinedLinkColorationDesc',

    sort(a, b) {
      a[0] = parseInt(a[0], 10);
      b[0] = parseInt(b[0], 10);

      if (a[0] < b[0]) {
        return -1;
      }

      if (a[0] > b[0]) {
        return 1;
      }

      return 0;
    }

  },
  colorCommentScore: {
    title: 'voteEnhancementsColorCommentScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'Reddit Classic',
      value: 'simple'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorCommentScoreDesc'
  },
  userDefinedCommentColoration: {
    title: 'voteEnhancementsUserDefinedCommentColorationTitle',
    dependsOn: options => options.colorCommentScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#F2B035'], [50, '#FF4500'], [100, '#D92B2B']],
    description: 'voteEnhancementsUserDefinedCommentColorationDesc',

    sort(a, b) {
      a[0] = parseInt(a[0], 10);
      b[0] = parseInt(b[0], 10);

      if (a[0] < b[0]) {
        return -1;
      }

      if (a[0] > b[0]) {
        return 1;
      }

      return 0;
    }

  },
  interpolateScoreColor: {
    title: 'voteEnhancementsInterpolateScoreColorTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsInterpolateScoreColorDesc',
    advanced: true
  },
  highlightControversial: {
    title: 'voteEnhancementsHighlightControversialTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightControversialDesc'
  },
  highlightControversialColor: {
    title: 'voteEnhancementsHighlightControversialColorTitle',
    dependsOn: options => options.highlightControversial.value,
    advanced: true,
    type: 'color',
    value: '#cc0000',
    description: 'voteEnhancementsHighlightControversialColorDesc'
  }
};
voteEnhancements_module.include = ['comments', 'commentsLinklist', 'linklist', 'modqueue', 'profile', 'inbox'];

voteEnhancements_module.beforeLoad = () => {
  if (voteEnhancements_module.options.colorLinkScore.value !== 'none') {
    watchForThings(['post'], applyLinkScoreColor);
  }

  if (voteEnhancements_module.options.colorCommentScore.value !== 'none') {
    watchForThings(['comment'], applyCommentScoreColor);
  }

  if (voteEnhancements_module.options.highlightControversial.value) {
    highlightControversial();
  }
};

function interpolateScoreColor(score, colors, defaultColor) {
  if (!colors.length) return defaultColor;
  const augmented = [[-Infinity, first_default()(colors)[1]], ...colors, [Infinity, last_default()(colors)[1]]];

  for (const [[lowBound, lowColor], [highBound, highColor]] of zip(augmented.slice(0, -1), augmented.slice(1))) {
    if (score >= lowBound && score < highBound) {
      if (voteEnhancements_module.options.interpolateScoreColor.value) {
        return colorFromArray(zipWith_default()(colorToArray(lowColor), colorToArray(highColor), (lowVal, highVal) => Math.round(projectInto(lowBound, highBound, lowVal, highVal, score))));
      } else {
        return score < 0 ? highColor : lowColor;
      }
    }
  }

  return defaultColor;
}

function getLinkScoreColor(score) {
  if (voteEnhancements_module.options.colorLinkScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 100 / (150 + score))}, 75%,50%)`;
  } else {
    return interpolateScoreColor(score, voteEnhancements_module.options.userDefinedLinkColoration.value, '#c6c6c6');
  }
}

function getCommentScoreColor(score) {
  if (voteEnhancements_module.options.colorCommentScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 50 / (100 + score))}, 75%,50%)`;
  } else {
    let colors;

    if (voteEnhancements_module.options.colorCommentScore.value === 'user') {
      colors = voteEnhancements_module.options.userDefinedCommentColoration.value;
    } else if (voteEnhancements_module.options.colorCommentScore.value === 'simple') {
      colors = [[0, '#9494FF'], [1, '#888'], [2, '#FF8B60']];
    } else {
      return false;
    }

    return interpolateScoreColor(score, colors, '#888');
  }
}

function applyLinkScoreColor(thing) {
  const score = thing.getScore();
  const rankEle = thing.getRankElement();
  const color = typeof score === 'number' && getLinkScoreColor(score);

  if (rankEle && color) {
    rankEle.style.background = color;
  }
}

function applyCommentScoreColor(thing) {
  for (const [scoreEle, score] of thing.getAllScoreElements()) {
    const color = getCommentScoreColor(score);

    if (color) {
      scoreEle.style.color = color;
    }
  }
}

function highlightControversial() {
  const color = voteEnhancements_module.options.highlightControversialColor.value || voteEnhancements_module.options.highlightControversialColor.default;
  addCSS(`
		.comment.controversial > .entry .score::after {
			color: ${color};
		}
	`);
}
// CONCATENATED MODULE: ./lib/modules/xPostLinks.js




const xPostLinks_module = new Module('xPostLinks');
xPostLinks_module.moduleName = 'xPostLinksName';
xPostLinks_module.category = 'submissionsCategory';
xPostLinks_module.description = 'xPostLinksDesc';
xPostLinks_module.include = ['linklist', 'modqueue', 'comments', 'profile', 'search'];
xPostLinks_module.exclude = ['d2x'];

xPostLinks_module.beforeLoad = () => {
  watchForThings(['post'], createLinks);
};

const xpostRe = /(?:x|cross)[\s-]?post\S*(.+)/i;
const xpostFromRe = /^(?:\s+\S+)?\s+\/?(\w{2,20}\b)(?:[\)\]}]|\S*$)/i;
const subredditRe = /r\/(\w{2,20}\b)/i;

function parseSubreddit(title) {
  const [, xpostString] = xpostRe.exec(title) || [];
  if (!xpostString) return false;
  const [, sub] = subredditRe.exec(xpostString) || xpostFromRe.exec(xpostString) || [];
  return sub;
}

function appendToTagline(sub, thing) {
  $().add($(thing.getSubredditLink()).prev()).add(thing.getUserattrsElement() || '').first().after(string_namespaceObject.escape` ${i18n('xPostLinksXpostedFrom')} `, $('<a>', {
    class: 'subreddit hover',
    href: `/r/${sub}`,
    text: `/r/${sub}`
  }));
}

function createLinks(thing) {
  const sub = parseSubreddit(thing.getTitle());
  if (sub) appendToTagline(sub, thing);
}
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=module!./lib/modules/about.js
/* generated by sibling-loader */


















































































/* harmony default export */ var about = ({ "RESTips.js": RESTips_module, "about.js": about_module, "accountSwitcher.js": accountSwitcher_module, "announcements.js": announcements_module, "backupAndRestore.js": backupAndRestore_module, "betteReddit.js": betteReddit_module, "commandLine.js": commandLine_module, "commentDepth.js": commentDepth_module, "commentHidePersistor.js": commentHidePersistor_module, "commentNavigator.js": commentNavigator_module, "commentPreview.js": commentPreview_module, "commentQuickCollapse.js": commentQuickCollapse_module, "commentSortBy.js": commentSortBy_module, "commentStyle.js": commentStyle_module, "commentTools.js": commentTools_module, "context.js": context_module, "contribute.js": contribute_module, "customToggles.js": customToggles_module, "dashboard.js": dashboard_module, "disableChat.js": disableChat_module, "easterEgg.js": easterEgg_module, "filteReddit.js": filteReddit_module, "floater.js": floater_module, "hideChildComments.js": hideChildComments_module, "hover.js": hover_module, "keyboardNav.js": keyboardNav_module, "localDate.js": localDate_module, "logoLink.js": logoLink_module, "menu.js": menu_module, "messageMenu.js": messageMenu_module, "modhelper.js": modhelper_module, "multiredditNavbar.js": multiredditNavbar_module, "neverEndingComments.js": neverEndingComments_module, "neverEndingReddit.js": neverEndingReddit_module, "newCommentCount.js": newCommentCount_module, "nightMode.js": nightMode_module, "noParticipation.js": noParticipation_module, "notifications.js": notifications_module, "onboarding.js": onboarding_module, "orangered.js": orangered_module, "pageNavigator.js": pageNavigator_module, "penaltyBox.js": penaltyBox_module, "presets.js": presets_module, "profileNavigator.js": profileNavigator_module, "profileRedirect.js": profileRedirect_module, "quarantineHide.js": quarantineHide_module, "quickMessage.js": quickMessage_module, "readComments.js": readComments_module, "redditUserInfo.js": redditUserInfo_module, "requestPermissions.js": requestPermissions_module, "saveComments.js": saveComments_module, "search.js": search_module, "searchHelper.js": searchHelper_module, "selectedEntry.js": selectedEntry_module, "settingsNavigation.js": settingsNavigation_module, "showImages.js": showImages_module, "showKarma.js": showKarma_module, "showParent.js": showParent_module, "singleClick.js": singleClick_module, "sourceSnudown.js": sourceSnudown_module, "spamButton.js": spamButton_module, "spoilerTags.js": spoilerTags_module, "styleTweaks.js": styleTweaks_module, "stylesheet.js": stylesheet_module, "submitHelper.js": submitHelper_module, "submitIssue.js": submitIssue_module, "subredditInfo.js": subredditInfo_module, "subredditManager.js": subredditManager_module, "subredditStyleToggle.js": subredditStyleToggle_module, "subredditTagger.js": subredditTagger_module, "tableTools.js": tableTools_module, "temporaryDropdownLinks.js": temporaryDropdownLinks_module, "troubleshooter.js": troubleshooter_module, "userHighlight.js": userHighlight_module, "userInfo.js": userInfo_module, "userTagger.js": userTagger_module, "userbarHider.js": userbarHider_module, "usernameHider.js": usernameHider_module, "version.js": version_module, "voteEnhancements.js": voteEnhancements_module, "wheelBrowse.js": wheelBrowse_module, "xPostLinks.js": xPostLinks_module });
// CONCATENATED MODULE: ./lib/core/modules/modules.js







const modulePrefsStorage = storage_namespaceObject.wrapBlob('RES.modulePrefs', () => {
  throw new Error('Default module enabled state should never be accessed');
});
const modules_enabled = new Map();

const modules_modules = flow_default()(() => Object.values(about), map_default()(mod => downcast(mod, Module)), keyBy_default()(mod => mod.moduleID))();

const allowedModules = [];
async function _loadModulePrefs() {
  const storedPrefs = await modulePrefsStorage.getAll();

  for (const [id, module] of Object.entries(modules_modules)) {
    if (module.alwaysEnabled) {
      modules_enabled.set(id, true);
    } else if (storedPrefs.hasOwnProperty(id)) {
      modules_enabled.set(id, storedPrefs[id]);
    } else {
      modules_enabled.set(id, !module.disabledByDefault);
    }
  }
}
const ERRORED_KEY = Symbol('errored');
async function _runModuleStage(stage, {
  skipEnabledCheck = false
} = {}) {
  await Promise.all(modules_all().filter(module => module[stage] && !module[ERRORED_KEY] && (skipEnabledCheck || isRunning(module))).map(async module => {
    const tag = markStart();

    try {
      const fn = module[stage];
      await fn();
    } catch (e) {
      module[ERRORED_KEY] = true;
      console.error('Error in module:', module.moduleID, 'during:', stage);
      console.error(e);
    }

    markEnd(tag, `${module.moduleID} (${stage})`);
  }));
}
async function setEnabled(opaqueId, enable) {
  const module = modules_get(opaqueId);
  modules_enabled.set(module.moduleID, enable);
  await modulePrefsStorage.set(module.moduleID, enable);
  module.onToggle(enable);
}
function modules_all() {
  return Object.values(modules_modules);
}
function modules_isEnabled(opaqueId) {
  return !!modules_enabled.get(modules_get(opaqueId).moduleID);
}
function isRunning(opaqueId) {
  const module = modules_get(opaqueId);
  return (!allowedModules.length || allowedModules.includes(module.moduleID)) && modules_isEnabled(module) && matchesPageLocation(module.include, module.exclude) && module.shouldRun();
}
function modules_get(opaqueId) {
  if (!opaqueId) {
    throw new TypeError(`Expected module, moduleID, or namespace; found: ${opaqueId}`);
  }

  if (typeof opaqueId === 'string') {
    return modules_modules_get(opaqueId);
  } else if (opaqueId.module) {
    return modules_modules_get(opaqueId.module.moduleID);
  } else {
    return modules_modules_get(opaqueId.moduleID);
  }
}

function modules_modules_get(id) {
  const mod = getUnchecked(id);
  if (!mod) throw new Error(`Module "${id}" not found.`);
  return mod;
}

function getUnchecked(id) {
  return modules_modules[id];
}
function getByCategory(category) {
  return modules_all().filter(module => !module.hidden).filter(module => module.category === category).sort((a, b) => {
    const sortComparison = (a.sort || 0) - (b.sort || 0);

    if (sortComparison !== 0) {
      return sortComparison;
    }

    return i18n(a.moduleName).toLowerCase() > i18n(b.moduleName).toLowerCase() ? 1 : -1;
  });
}
// CONCATENATED MODULE: ./lib/core/modules/index.js

// CONCATENATED MODULE: ./lib/core/options/options.js









const moduleOptionsStorage = storage_namespaceObject.wrapPrefix('RESoptions.', () => ({}));
function _loadModuleOptions() {
  shouldPrune('RESoptions').then(should => {
    if (should) prune();
  });
  return loadOptions();
}

function loadOptions() {
  return Promise.all(modules_all().map(async module => {
    if (isEmpty_default()(module.options)) return;
    const stored = await moduleOptionsStorage.get(module.moduleID);

    _initOptions(module, stored);
  }));
}

function _initOptions(module, storedOptions) {
  for (const opt of Object.values(module.options)) {
    opt.default = opt.value;
  }

  if (!storedOptions) {
    return;
  }

  for (const [key, storedValue] of Object.entries(storedOptions)) {
    if (!storedValue) continue;
    if (!module.options[key]) continue;
    module.options[key].value = storedValue.value;
  }
}

const loadRaw = flow_default()(opaqueId => modules_get(opaqueId), memoize_default()(module => moduleOptionsStorage.get(module.moduleID), module => module.moduleID));
async function options_get(opaqueId, optionKey) {
  const options = await loadRaw(opaqueId);
  return options && options[optionKey];
}
function options_set(opaqueId, optionKey, value) {
  if (/_[\d]+$/.test(optionKey)) {
    optionKey = optionKey.replace(/_[\d]+$/, '');
  }

  const module = modules_get(opaqueId);

  if (!module.options[optionKey]) {
    console.warn('Could not find option', module.moduleID, optionKey);
    return false;
  }

  module.options[optionKey].value = value;
  moduleOptionsStorage.patch(module.moduleID, {
    [optionKey]: {
      value
    }
  });

  if (module.options[optionKey].onChange) {
    module.options[optionKey].onChange();
  }

  return true;
}
function isDefault(opaqueId, optionKey, optionValue) {
  const module = modules_get(opaqueId);

  if (!module.options[optionKey]) {
    console.warn('Could not find option', module.moduleID, optionKey);
    return true;
  }

  return isEqual_default()(module.options[optionKey].default, optionValue);
}
async function prune() {
  for (const [moduleID, storedOptions] of Object.entries((await moduleOptionsStorage.getAll()))) {
    if (!storedOptions) continue;

    const _def = Object.entries(storedOptions).filter(([key, value]) => isDefault(moduleID, key, value));

    if (_def.length === storedOptions.length) {
      await moduleOptionsStorage.delete(moduleID);
    } else {
      for (const [key] of _def) {
        await moduleOptionsStorage.deletePath(moduleID, key);
      }
    }
  }
}

function getModified() {
  return filterMap(modules_all(), module => {
    const {
      moduleID,
      options
    } = module;
    const enabledByDefault = !module.disabledByDefault;
    const isEnabled = modules_isEnabled(module);
    const moduleStatusChanged = enabledByDefault !== isEnabled;
    const modifiedOptions = isEnabled ? omitBy_default()(options, v => isEqual_default()(v.value, v.default)) : {};

    if (!isEmpty_default()(modifiedOptions) || moduleStatusChanged) {
      return [{
        moduleID,
        modifiedOptions,
        moduleStatus: moduleStatusChanged ? `${enabledByDefault ? 'on' : 'off'} → ${isEnabled ? 'on' : 'off'}` : ''
      }];
    }
  });
}

function getModifiedText(types = ['text', 'boolean', 'enum']) {
  const lines = [];
  let optionMaxLength = 0;
  let moduleMaxLength = 0;

  for (const {
    moduleID,
    modifiedOptions,
    moduleStatus
  } of getModified()) {
    moduleMaxLength = Math.max(moduleMaxLength, moduleID.length);
    optionMaxLength = Math.max(optionMaxLength, ...Object.keys(modifiedOptions).map(v => v.length));
    lines.push(() => [`    ${moduleID.padEnd(moduleMaxLength)} ${moduleStatus}`, ...Object.entries(modifiedOptions).filter(([, {
      type
    }]) => types.includes(type)).map(([key, value]) => `      ${key.padEnd(optionMaxLength)}\t${JSON.stringify(value.default)} → ${JSON.stringify(value.value)}`)]);
  }

  return flatten_default()(lines.map(v => v())).join('\n');
}
// CONCATENATED MODULE: ./lib/core/modules/bodyClasses.js


function _addModuleBodyClasses() {
  for (const module of modules_all()) {
    if (!isRunning(module)) continue;
    if (module.bodyClass) bodyClasses_namespaceObject.add(`res-${module.moduleID}`);

    for (const [optId, opt] of Object.entries(module.options)) {
      if (!(opt.bodyClass && opt.value)) continue;
      if (opt.dependsOn && !opt.dependsOn(module.options)) continue;
      let cls = typeof opt.bodyClass === 'string' ? opt.bodyClass : `res-${module.moduleID}-${optId}`;

      if (opt.type === 'enum') {
        cls += `-${opt.value.replace(/\s/g, '_')}`;
      }

      bodyClasses_namespaceObject.add(cls);
    }
  }
}
// EXTERNAL MODULE: ./node_modules/lodash/takeRightWhile.js
var takeRightWhile = __webpack_require__(143);
var takeRightWhile_default = /*#__PURE__*/__webpack_require__.n(takeRightWhile);

// EXTERNAL MODULE: ./node_modules/lodash/isObject.js
var isObject = __webpack_require__(10);
var isObject_default = /*#__PURE__*/__webpack_require__.n(isObject);

// EXTERNAL MODULE: ./node_modules/lodash/mapKeys.js
var mapKeys = __webpack_require__(58);
var mapKeys_default = /*#__PURE__*/__webpack_require__.n(mapKeys);

// CONCATENATED MODULE: ./lib/core/migrate/migrators.js



async function updateOption(moduleID, optionName, formerDefaultValue, valueOrFunction) {
  try {
    const option = await options_get(moduleID, optionName);
    if (!option) return;
    if (!optionMatchesFormerDefaultValue(option, formerDefaultValue)) return;
    const newValue = updateValue(option.value, valueOrFunction);

    if (typeof newValue !== 'undefined') {
      await options_set(moduleID, optionName, newValue);
    }
  } catch (e) {
    console.error(`Couldn't migrate ${moduleID}::${optionName} from`, formerDefaultValue, 'to/via', valueOrFunction, e);
  }
}
async function forceUpdateOption(moduleID, optionName, valueOrFunction) {
  try {
    const option = await options_get(moduleID, optionName);
    if (!option) return;
    const newValue = updateValue(option.value, valueOrFunction);

    if (typeof newValue !== 'undefined') {
      await options_set(moduleID, optionName, newValue);
    }
  } catch (e) {
    console.error(`Couldn't migrate ${moduleID}::${optionName} to`, valueOrFunction, e);
  }
}
async function moveOption(oldModuleID, oldOptionName, newModuleID, newOptionName, valueOrFunction) {
  try {
    const option = await options_get(oldModuleID, oldOptionName);
    if (!option) return;
    const newValue = updateValue(option.value, valueOrFunction);

    if (typeof newValue !== 'undefined') {
      await options_set(newModuleID, newOptionName, newValue);
    }
  } catch (e) {
    console.error(`Couldn't migrate ${oldModuleID}::${oldOptionName} to ${newModuleID}::${newOptionName} via`, valueOrFunction, e);
  }
}
async function moveStorageToOption(oldKey, newModuleID, newOptionName, valueOrFunction) {
  const oldValue = await storage_namespaceObject.get(oldKey);

  if (oldValue === null) {
    return;
  }

  const newValue = updateValue(oldValue, valueOrFunction);

  try {
    if (typeof newValue !== 'undefined') {
      await options_set(newModuleID, newOptionName, newValue);
    }
  } catch (e) {
    console.error(`Couldn't migrate storage ${oldKey} to ${newModuleID}::${newOptionName} via`, valueOrFunction, e);
  }
}

function optionMatchesFormerDefaultValue(option, formerDefaultValue) {
  if (!option) {
    option = {
      type: 'legacy',
      value: undefined
    };
  }

  const oldValue = option.value;

  if (oldValue && option.type === 'keycode' && option.value.length === 4) {
    oldValue.push(false);
  }

  return isEqual_default()(formerDefaultValue, oldValue);
}

function updateValue(oldValue, valueOrFunction) {
  if (typeof valueOrFunction === 'function') {
    return valueOrFunction(oldValue);
  } else if (typeof valueOrFunction !== 'undefined') {
    return valueOrFunction;
  } else {
    return oldValue;
  }
}
// CONCATENATED MODULE: ./lib/core/migrate/migrate.js











const migrate_migrations = [{
  versionNumber: 'legacyMigrators',

  async go() {
    await moveStorageToOption('RESmodules.styleTweaks.userbarState', 'userbarHider', 'userbarState');
    const macroVersion = await storage_namespaceObject.get('RESmodules.commentTools.macroDataVersion');

    if (macroVersion === null || macroVersion === 0) {
      const previewOptions = await storage_namespaceObject.get('RESoptions.commentPreview');

      if (previewOptions !== null) {
        if (typeof previewOptions.commentingAs !== 'undefined') {
          await forceUpdateOption('commentTools', 'commentingAs', previewOptions.commentingAs.value);
        }

        if (typeof previewOptions.keyboardShortcuts !== 'undefined') {
          await forceUpdateOption('commentTools', 'keyboardShortcuts', previewOptions.keyboardShortcuts.value);
        }

        if (typeof previewOptions.subredditAutocomplete !== 'undefined') {
          await forceUpdateOption('commentTools', 'subredditAutocomplete', previewOptions.subredditAutocomplete.value);
        }

        if (typeof previewOptions.macros !== 'undefined') {
          previewOptions.macros.value.forEach(macro => {
            while (macro.length < 4) {
              macro.push('');
            }
          });
          await forceUpdateOption('commentTools', 'macros', previewOptions.macros.value);
        }
      }
    }

    if (macroVersion === 1) {
      await forceUpdateOption('commentTools', 'macros', macros => (macros || []).map(macro => {
        while (macro.length < 4) {
          macro.push('');
        }

        return macro;
      }));
    }

    const storedComments = await storage_namespaceObject.get('RESmodules.saveComments.savedComments');

    if (Array.isArray(storedComments)) {
      const newFormat = {};

      for (const storedComment of storedComments) {
        const urlSplit = storedComment.href.split('/');
        const thisID = urlSplit[urlSplit.length - 1];
        newFormat[thisID] = storedComment;
      }

      storage_namespaceObject.set('RESmodules.saveComments.savedComments', newFormat);
    }
  }

}, {
  versionNumber: '4.5.0.0',

  async go() {
    await moveOption('betteReddit', 'searchSubredditByDefault', 'searchHelper', 'searchSubredditByDefault');
    await moveOption('styleTweaks', 'lightSwitch', 'nightMode', 'nightSwitch');
    await moveOption('styleTweaks', 'lightOrDark', 'nightMode', 'nightModeOn', value => value === 'dark');
    await moveOption('styleTweaks', 'useSubredditStyleInDarkMode', 'nightMode', 'useSubredditStyles');
    await moveStorageToOption('RESmodules.styleTweaks.nightModeWhitelist', 'nightMode', 'subredditStylesWhitelist', value => {
      try {
        return JSON.parse(value || '').join(',');
      } catch (e) {
        return '';
      }
    });

    try {
      const userTags = (await storage_namespaceObject.get('RESmodules.userTagger.tags')) || {};
      updateTagStorageCaseInsensitive(userTags);
    } catch (e) {
      console.error('Could not migrate user tags, please post this error to /r/RESissues', e);
    }

    await forceUpdateOption('filteReddit', 'subreddits', subreddits => (subreddits || []).map(subreddit => {
      const check = subreddit[0];

      if (check.startsWith('/r/')) {
        subreddit[0] = check.substr(3);
      }

      return subreddit;
    }));

    function updateTagStorageCaseInsensitive(tags) {
      const usernames = Object.keys(tags);

      for (const username of usernames) {
        const lower = username.toLowerCase();
        if (lower === username) continue;
        const destination = tags[lower] = tags[lower] || {};
        const source = tags[username];

        if (source.votes) {
          destination.votes = (parseInt(destination.votes, 10) || 0) + (parseInt(source.votes, 10) || 0);
        }

        if (source.color && (!destination.color || destination.color === 'none')) {
          destination.color = source.color;
        }

        if (source.tag) {
          destination.tag = destination.tag ? `${destination.tag} | ` : '';
          destination.tag += source.tag;
        }

        if (source.ignore) {
          destination.ignore = source.ignore;
        }

        if (source.link) {
          if (destination.link) {
            destination.tag = destination.tag ? `${destination.tag} | ` : '';
            destination.tag += source.link;
          } else {
            destination.link = source.link;
          }
        }

        delete tags[username];
      }

      storage_namespaceObject.set('RESmodules.userTagger.tags', tags);
      storage_namespaceObject.set('RESmodules.userTagger.casefix', true);
    }
  }

}, {
  versionNumber: '4.5.0.2',

  async go() {
    await updateOption('keyboardNav', 'imageMoveUp', [38, false, false, true, false], [38, false, true, false, false]);
    await updateOption('keyboardNav', 'imageMoveDown', [40, false, false, true, false], [40, false, true, false, false]);
    await updateOption('keyboardNav', 'imageMoveLeft', [37, false, false, true, false], [37, false, true, false, false]);
    await updateOption('keyboardNav', 'imageMoveRight', [39, false, false, true, false], [39, false, true, false, false]);
  }

}, {
  versionNumber: '4.5.0.3',

  go() {}

}, {
  versionNumber: '4.5.1',

  async go() {
    await forceUpdateOption('voteEnhancements', 'colorCommentScore', value => {
      if (typeof value === 'string') {
        return value;
      }

      return value ? 'automatic' : 'none';
    });
    const notificationsOptions = await loadRaw('notifications');
    const sticky = notificationsOptions && notificationsOptions.sticky.value;
    const keyNavOptions = await loadRaw('keyboardNav');
    const fg = keyNavOptions && keyNavOptions.focusFGColorNight.value;
    const bg = keyNavOptions && keyNavOptions.focusBGColorNight.value;
    const test = document.createElement('div');

    if (sticky === 'perNotification') {
      await forceUpdateOption('notifications', 'sticky', 'notificationType');
    }

    test.style.color = fg || '';
    test.style.backgroundColor = bg || '';
    const fgCalculated = test.style.color;
    const bgCalculated = test.style.backgroundColor;

    if (fg === bg || fgCalculated === bgCalculated) {
      await forceUpdateOption('keyboardNav', 'focusBGColorNight', '#373737');
      await forceUpdateOption('keyboardNav', 'focusFGColorNight', '#DDDDDD');
    }

    await moveOption('settingsNavigation', 'showAdvancedOptions', 'settingsNavigation', 'showAllOptions', true);
    await moveOption('settingsNavigation', 'showAdvancedOptionsAlert', 'settingsNavigation', 'showAllOptionsAlert');
  }

}, {
  versionNumber: '4.5.3',

  async go() {
    await updateOption('searchHelper', 'addSubmitButton', true, false);
    await moveOption('keyboardNav', 'save', 'keyboardNav', 'savePost');
    await moveOption('keyboardNav', 'save', 'keyboardNav', 'saveRES');
  }

}, {
  versionNumber: '4.5.4',

  async go() {
    await forceUpdateOption('filteReddit', 'keywords', values => {
      for (const value of values || []) {
        if (value && value[3] === 'undefined') {
          value[3] = '';
        }
      }

      return values;
    });
    await updateOption('quickMessage', 'quickModeratorMessage', false, true);
  }

}, {
  versionNumber: '4.5.5',

  async go() {
    const keyNavOptions = await loadRaw('keyboardNav');

    if (keyNavOptions && keyNavOptions.scrollTop && keyNavOptions.scrollTop.value) {
      await updateOption('keyboardNav', 'scrollStyle', 'directional', 'top');
    }

    await moveOption('betteReddit', 'uncheckSendRepliesToInbox', 'submitHelper', 'uncheckSendRepliesToInbox');
    await moveOption('keyboardNav', 'openBigEditor', 'commentPreview', 'openBigEditor');
    await moveOption('keyboardNav', 'autoSelectOnScroll', 'selectedEntry', 'autoSelectOnScroll');
    await moveOption('keyboardNav', 'clickFocus', 'selectedEntry', 'selectOnClick');
    await moveOption('keyboardNav', 'addFocusBGColor', 'selectedEntry', 'addFocusBGColor');
    await moveOption('keyboardNav', 'focusBGColor', 'selectedEntry', 'focusBGColor');
    await moveOption('keyboardNav', 'focusBGColorNight', 'selectedEntry', 'focusBGColorNight');
    await moveOption('keyboardNav', 'focusFGColorNight', 'selectedEntry', 'focusFGColorNight');
    await moveOption('keyboardNav', 'addFocusBorder', 'selectedEntry', 'addFocusBorder');
    await moveOption('keyboardNav', 'focusBorder', 'selectedEntry', 'focusBorder');
    await moveOption('keyboardNav', 'focusBorderNight', 'selectedEntry', 'focusBorderNight');

    function updateFadeSpeed(value) {
      if (value === undefined || value === null || isNaN(value) || value < 0 || value > 1) {
        return '0.7';
      } else {
        return (1 - value).toFixed(2);
      }
    }

    await forceUpdateOption('hover', 'fadeSpeed', updateFadeSpeed);
    await forceUpdateOption('showParent', 'fadeSpeed', updateFadeSpeed);
    await forceUpdateOption('subredditInfo', 'fadeSpeed', updateFadeSpeed);
    await forceUpdateOption('userTagger', 'fadeSpeed', updateFadeSpeed);
    await forceUpdateOption('commentTools', 'macros', value => [['reddiquette', '[reddiquette](/wiki/reddiquette) '], ['Promote RES', '[Reddit Enhancement Suite](https://redditenhancementsuite.com "also /r/Enhancement") '], ['Current timestamp', '{{now}} '], ...(value || [])]);
    await moveOption('betteReddit', 'showUnreadCount', 'orangered', 'showUnreadCount');
    await moveOption('betteReddit', 'retroUnreadCount', 'orangered', 'retroUnreadCount');
    await moveOption('betteReddit', 'showUnreadCountInFavicon', 'orangered', 'showUnreadCountInFavicon');
    await moveOption('betteReddit', 'unreadLinksToInbox', 'orangered', 'unreadLinksToInbox');
    await moveOption('betteReddit', 'hideModMail', 'orangered', 'hideModMail');
    await moveOption('quickMessage', 'quickModeratorMessage', 'quickMessage', 'handleSideLinks');
    await updateOption('showKarma', 'useCommas', false, true);
    await moveOption('keyboardNav', 'moveDown', 'keyboardNav', 'moveDownComment');
    await moveOption('keyboardNav', 'moveUp', 'keyboardNav', 'moveUpComment');
    await moveOption('userTagger', 'hoverInfo', 'userInfo', 'hoverInfo');
    await moveOption('userTagger', 'useQuickMessage', 'userInfo', 'useQuickMessage');
    await moveOption('userTagger', 'hoverDelay', 'userInfo', 'hoverDelay');
    await moveOption('userTagger', 'fadeDelay', 'userInfo', 'fadeDelay');
    await moveOption('userTagger', 'fadeSpeed', 'userInfo', 'fadeSpeed');
    await moveOption('userTagger', 'gildComments', 'userInfo', 'gildComments');
    await moveOption('userTagger', 'highlightButton', 'userInfo', 'highlightButton');
    await moveOption('userTagger', 'highlightColor', 'userInfo', 'highlightColor');
    await moveOption('userTagger', 'highlightColorHover', 'userInfo', 'highlightColorHover');
    await moveOption('userTagger', 'USDateFormat', 'userInfo', 'USDateFormat');
    await forceUpdateOption('notifications', 'notificationTypes', rows => uniqBy_default()(rows, ([modId, notificationId]) => `${modId}###${notificationId}`));
  }

}, {
  versionNumber: '4.7.0-scrubCaches',

  async go() {
    const cacheKeyParts = ['RESmodules.neverEndingReddit.lastPage', 'RESmodules.neverEndingReddit.lastVisibleIndex', 'RESUtils.cache', 'RESUtils.moderatedSubCache', 'RESUtils.sendFromCache', 'RESUtils.userInfoCache', 'RESmodules.keyboardNavLastIndex', 'RESmodules.selectedThing.lastSelectedCache', 'TBCache.', 'Toolbox.', 'RESmodules.betteReddit.msgCount.lastCheck', 'RESmodules.subredditManager.subreddits.', 'RESmodules.subredditManager.mySubredditList'];
    await (await storage_namespaceObject.keys()).filter(key => cacheKeyParts.some(part => key.includes(part))).map(key => storage_namespaceObject.delete(key));
  }

}, {
  versionNumber: '4.7.0-voteWeight',

  async go() {
    await moveOption('userTagger', 'colorUser', 'userTagger', 'trackVoteWeight');
  }

}, {
  versionNumber: '4.7.0-commentStyle',

  async go() {
    await moveOption('styleTweaks', 'commentBoxes', 'commentStyle', 'commentBoxes');
    await moveOption('styleTweaks', 'commentRounded', 'commentStyle', 'commentRounded');
    await moveOption('styleTweaks', 'commentHoverBorder', 'commentStyle', 'commentHoverBorder');
    await moveOption('styleTweaks', 'commentIndent', 'commentStyle', 'commentIndent');
    await moveOption('styleTweaks', 'continuity', 'commentStyle', 'continuity');
  }

}, {
  versionNumber: '4.7.0-keyboardNav-scrollStyle-better-name',

  async go() {
    await moveOption('keyboardNav', 'scrollStyle', 'keyboardNav', 'linearScrollStyle');
  }

}, {
  versionNumber: '4.7.0-hideLEC',

  async go() {
    await updateOption('singleClick', 'hideLEC', false, true);
  }

}, {
  versionNumber: '4.7.0-showImages-siteModuleIDs',

  async go() {
    await moveOption('showImages', 'display uploadly', 'showImages', 'display_uploadly');
    await moveOption('showImages', 'display eroshare', 'showImages', 'display_eroshare');
    await moveOption('showImages', 'display iLoopit - gif maker', 'showImages', 'display_iloopit');
    await moveOption('showImages', 'display Coub', 'showImages', 'display_coub');
    await moveOption('showImages', 'display LiveCap', 'showImages', 'display_livecap');
    await moveOption('showImages', 'display twitter', 'showImages', 'display_twitter');
    await moveOption('showImages', 'display futurism', 'showImages', 'display_futurism');
    await moveOption('showImages', 'display gfycat', 'showImages', 'display_gfycat');
    await moveOption('showImages', 'display gifyoutube', 'showImages', 'display_gifs');
    await moveOption('showImages', 'display vidble', 'showImages', 'display_vidble');
    await moveOption('showImages', 'display fitbamob', 'showImages', 'display_fitbamob');
    await moveOption('showImages', 'display giflike', 'showImages', 'display_giflike');
    await moveOption('showImages', 'display CtrlV.in', 'showImages', 'display_ctrlv');
    await moveOption('showImages', 'display snag.gy', 'showImages', 'display_snag');
    await moveOption('showImages', 'display picshd', 'showImages', 'display_picshd');
    await moveOption('showImages', 'display min.us', 'showImages', 'display_minus');
    await moveOption('showImages', 'display fiveHundredPx', 'showImages', 'display_fiveHundredPx');
    await moveOption('showImages', 'display flickr', 'showImages', 'display_flickr');
    await moveOption('showImages', 'display steam', 'showImages', 'display_steam');
    await moveOption('showImages', 'display deviantART', 'showImages', 'display_deviantart');
    await moveOption('showImages', 'display tumblr', 'showImages', 'display_tumblr');
    await moveOption('showImages', 'display memecrunch', 'showImages', 'display_memecrunch');
    await moveOption('showImages', 'display imgflip', 'showImages', 'display_imgflip');
    await moveOption('showImages', 'display livememe', 'showImages', 'display_livememe');
    await moveOption('showImages', 'display makeameme', 'showImages', 'display_makeameme');
    await moveOption('showImages', 'display memegen', 'showImages', 'display_memegen');
    await moveOption('showImages', 'display redditbooru', 'showImages', 'display_redditbooru');
    await moveOption('showImages', 'display youtube', 'showImages', 'display_youtube');
    await moveOption('showImages', 'display vimeo', 'showImages', 'display_vimeo');
    await moveOption('showImages', 'display soundcloud', 'showImages', 'display_soundcloud');
    await moveOption('showImages', 'display clyp', 'showImages', 'display_clyp');
    await moveOption('showImages', 'display memedad', 'showImages', 'display_memedad');
    await moveOption('showImages', 'display ridewithgps', 'showImages', 'display_ridewithgps');
    await moveOption('showImages', 'display photobucket', 'showImages', 'display_photobucket');
    await moveOption('showImages', 'display giphy', 'showImages', 'display_giphy');
    await moveOption('showImages', 'display streamable', 'showImages', 'display_streamable');
    await moveOption('showImages', 'display qwipit', 'showImages', 'display_qwipit');
    await moveOption('showImages', 'display radd.it', 'showImages', 'display_raddit');
    await moveOption('showImages', 'display pastebin', 'showImages', 'display_pastebin');
    await moveOption('showImages', 'display github gists', 'showImages', 'display_github');
    await moveOption('showImages', 'display Microsoft OneDrive', 'showImages', 'display_onedrive');
    await moveOption('showImages', 'display Oddshot', 'showImages', 'display_oddshot');
    await moveOption('showImages', 'display Miiverse', 'showImages', 'display_miiverse');
    await moveOption('showImages', 'display swirl', 'showImages', 'display_swirl');
  }

}, {
  versionNumber: '4.7.1-changeDefaultImageMaxSizeRetry',

  async go() {
    await updateOption('showImages', 'maxWidth', 640, '100%');
    await updateOption('showImages', 'maxHeight', 480, '80%');
    await updateOption('showImages', 'maxWidth', '640', '100%');
    await updateOption('showImages', 'maxHeight', '480', '80%');
  }

}, {
  versionNumber: '4.7.4-galleryFilmstripGranularity',

  async go() {
    await moveOption('showImages', 'dontLoadAlbumsBiggerThan', 'showImages', 'filmstripLoadIncrement');
  }

}, {
  versionNumber: '4.7.8-ner-hide-dupes',

  async go() {
    await updateOption('neverEndingReddit', 'hideDupes', 'fade', 'hide');
  }

}, {
  versionNumber: '5.0.1-disable-redditmedia-lookup',

  async go() {
    await forceUpdateOption('showImages', 'expandoCommentRedirects', 'nothing');
  }

}, {
  versionNumber: '5.0.2-reenable-redditmedia-expando',

  async go() {
    await updateOption('showImages', 'expandoCommentRedirects', 'nothing', 'expando');
  }

}, {
  versionNumber: '5.1.1-remove-multiredditnavbar-sectionlinks-workaround',

  async go() {
    await forceUpdateOption('multiredditNavbar', 'sectionLinks', sectionLinks => {
      if (!sectionLinks) return;

      for (const row of sectionLinks) {
        row[1] = row[1].replace(/^\.\.\//, './');
      }
    });
  }

}, {
  versionNumber: '5.3.1-enable-hardIgnore',

  async go() {
    await forceUpdateOption('userTagger', 'hardIgnore', true);
  }

}, {
  versionNumber: '5.3.5-remove-updates-css',

  async go() {
    await forceUpdateOption('stylesheet', 'loadStylesheets', rows => rows && rows.filter(row => row[0] !== 'https://cdn.redditenhancementsuite.com/updates.css'));
    const hideFloatingPauseButton = 'res-neverEndingReddit-hideFloatingPauseButton';
    await moveOption('stylesheet', 'bodyClasses', 'neverEndingReddit', 'showPauseButton', rows => !!rows && rows.every(row => row[0] !== hideFloatingPauseButton));
    await forceUpdateOption('stylesheet', 'bodyClasses', rows => rows && rows.filter(row => row[0] !== hideFloatingPauseButton));
    let shouldHideTagline = false;
    await forceUpdateOption('stylesheet', 'bodyClasses', rows => {
      if (!rows) return [];
      const filteredRows = rows.filter(row => row[0] !== 'res-hide-tagline-frontpage');
      shouldHideTagline = filteredRows.length < rows.length;
      return filteredRows;
    });

    if (shouldHideTagline) {
      forceUpdateOption('stylesheet', 'snippets', rows => [...(rows || []), ['/* migrated from res-hide-tagline-frontpage */ .front-page .tagline { display: none; }', 'everywhere']]);
    }
  }

}, {
  versionNumber: '5.3.6-enable-hideUnvotable',

  async go() {
    await forceUpdateOption('styleTweaks', 'hideUnvotable', true);
  }

}, {
  versionNumber: '5.3.7-automaticNightMode-to-enum',

  async go() {
    await forceUpdateOption('nightMode', 'automaticNightMode', value => value === true ? 'user' : 'none');
  }

}, {
  versionNumber: '5.5.0-commentLinks-rename',

  async go() {
    await moveOption('keyboardNav', 'commentsLinkNumbers', 'keyboardNav', 'linkNumbers');
    await moveOption('keyboardNav', 'commentsLinkNumberPosition', 'keyboardNav', 'linkNumberPosition');
    await moveOption('keyboardNav', 'commentsLinkToggleExpando', 'keyboardNav', 'linkToggleExpando');
    await moveOption('keyboardNav', 'commentsLinkNewTab', 'keyboardNav', 'linkNewTab');
  }

}, {
  versionNumber: '5.5.1-maxSize-to-string',

  async go() {
    const toString = x => x ? String(x) : '';

    await forceUpdateOption('showImages', 'maxWidth', toString);
    await forceUpdateOption('showImages', 'maxHeight', toString);
  }

}, {
  versionNumber: '5.5.3-disable-userbarHider',

  async go() {
    const notificationsOptions = await loadRaw('notifications');

    if (!notificationsOptions || !notificationsOptions.notificationTypes || !notificationsOptions.notificationTypes.value || !notificationsOptions.notificationTypes.value.some(([modId, notificationId]) => modId === 'userbarHider' && notificationId === 'userbarState')) {
      setEnabled('userbarHider', false);
    }
  }

}, {
  versionNumber: '5.5.11-update-notifications',

  async go() {
    await updateOption('onboarding', 'updateNotification', 'releaseNotes', 'notification');
  }

}, {
  versionNumber: '5.6.1-shard-tags',

  async go() {
    const tags = (await storage_namespaceObject.get('RESmodules.userTagger.tags')) || {};

    const remappedTags = mapKeys_default()(tags, (v, k) => `tag.${k.toLowerCase()}`);

    await storage_namespaceObject.setMultiple(remappedTags);
  }

}, {
  versionNumber: '5.6.2-remove-old-tags',

  async go() {
    await storage_namespaceObject.delete('RESmodules.userTagger.tags');
  }

}, {
  versionNumber: '5.7.0-keyboardNav-showImages-decoupling',

  async go() {
    await moveOption('keyboardNav', 'mediaBrowseMode', 'showImages', 'mediaBrowse');
  }

}, {
  versionNumber: '5.7.1-shard-newCommentCount',

  async go() {
    const entries = (await storage_namespaceObject.get('RESmodules.newCommentCount.counts')) || {};

    const remappedEntries = mapKeys_default()(entries, (v, k) => `newCommentCount.${k}`);

    await storage_namespaceObject.setMultiple(remappedEntries);
    await storage_namespaceObject.delete('RESmodules.newCommentCount.counts');
  }

}, {
  versionNumber: '5.7.3-commandLine-menu-opening',

  async go() {
    await moveOption('commandLine', 'launchFromMenuButton', 'RESMenu', 'gearIconClickAction', launchFromMenu => launchFromMenu ? 'openCommandLine' : 'toggleMenuNoHover');
  }

}, {
  versionNumber: '5.7.4-shard-commentHidePersistor',

  async go() {
    const {
      hiddenThings
    } = (await storage_namespaceObject.get('RESmodules.commentHidePersistor.hidePersistor')) || {};
    if (!hiddenThings) return;
    const remappedEntries = Object.entries(hiddenThings).reduce((acc, [k, v]) => {
      const page = (execRegexes.comments(k) || [])[2];
      const collapsedThings = v.reduce((acc, k) => (acc[k] = true) && acc, {});
      if (page && v.length) acc[`commentHidePersistor.${page}`] = {
        updateTime: Date.now(),
        collapsedThings
      };
      return acc;
    }, {});
    await storage_namespaceObject.setMultiple(remappedEntries);
    await storage_namespaceObject.delete('RESmodules.commentHidePersistor.hidePersistor');
  }

}, {
  versionNumber: '5.8.2-unshard-newCommentCount-subscriptions',

  async go() {
    const subscriptions = {};

    for (const [key, val] of Object.entries((await storage_namespaceObject.getAll()))) {
      if (!key.startsWith('newCommentCount.')) continue;
      if (val.subscriptionDate) subscriptions[key] = val;
    }

    storage_namespaceObject.set('RESmodules.newCommentCount.subscriptions', subscriptions);
  }

}, {
  versionNumber: '5.9.1-userTagger-refresh',

  async go() {
    let tags = await storage_namespaceObject.wrapPrefix('tag.', () => ({})).getAll();

    for (const tag of Object.values(tags)) {
      if (tag.votes > 0) tag.votesUp = tag.votes;
      if (tag.votes < 0) tag.votesDown = -tag.votes;
      Reflect.deleteProperty(tag, 'votes');
      if (tag.tag) tag.text = tag.tag;
      Reflect.deleteProperty(tag, 'tag');
      if (tag.ignore) tag.ignored = tag.ignore;
      Reflect.deleteProperty(tag, 'ignore');
    }

    tags = mapKeys_default()(tags, (v, k) => `tag.${k}`);
    await storage_namespaceObject.setMultiple(tags);
  }

}, {
  versionNumber: '5.9.1-selectedEntry',

  async go() {
    await moveOption('selectedEntry', 'addFocusBGColor', 'selectedEntry', 'setColors');
    await moveOption('selectedEntry', 'focusBGColor', 'selectedEntry', 'backgroundColor');
    await moveOption('selectedEntry', 'focusBGColorNight', 'selectedEntry', 'backgroundColorNight');
    await moveOption('selectedEntry', 'focusFGColorNight', 'selectedEntry', 'textColorNight');
    await moveOption('selectedEntry', 'addFocusBorder', 'selectedEntry', 'addOutline');
    await moveOption('selectedEntry', 'focusBorder', 'selectedEntry', 'outlineStyle');
    await moveOption('selectedEntry', 'focusBorderNight', 'selectedEntry', 'outlineStyleNight');

    if (((await storage_namespaceObject.get('RES.modulePrefs')) || {
      selectedEntry: true
    }).selectedEntry === false) {
      await options_set('selectedEntry', 'setColors', false);
      await options_set('selectedEntry', 'addLine', true);
    }
  }

}, {
  versionNumber: '5.9-no-option-spaces',

  async go() {
    await moveOption('showImages', 'prefer RES albums', 'showImages', 'preferResAlbums');
  }

}, {
  versionNumber: '5.9.2-numbers-to-strings',

  async go() {
    function stringify(x) {
      if (typeof x === 'number') return x.toString();
      return x;
    }

    await forceUpdateOption('betteReddit', 'hideLinkFadeDelay', stringify);
    await forceUpdateOption('commentDepth', 'defaultCommentDepth', stringify);
    await forceUpdateOption('commentDepth', 'defaultMinimumComments', stringify);
    await forceUpdateOption('commentStyle', 'commentIndent', stringify);
    await forceUpdateOption('context', 'defaultContext', stringify);
    await forceUpdateOption('dashboard', 'defaultPosts', stringify);
    await forceUpdateOption('dashboard', 'tagsPerPage', stringify);
    await forceUpdateOption('hover', 'openDelay', stringify);
    await forceUpdateOption('hover', 'fadeDelay', stringify);
    await forceUpdateOption('hover', 'fadeSpeed', stringify);
    await forceUpdateOption('hover', 'width', stringify);
    await forceUpdateOption('messageMenu', 'hoverDelay', stringify);
    await forceUpdateOption('messageMenu', 'fadeDelay', stringify);
    await forceUpdateOption('messageMenu', 'fadeSpeed', stringify);
    await forceUpdateOption('multiredditNavbar', 'hoverDelay', stringify);
    await forceUpdateOption('multiredditNavbar', 'fadeDelay', stringify);
    await forceUpdateOption('multiredditNavbar', 'fadeSpeed', stringify);
    await forceUpdateOption('neverEndingReddit', 'pauseAfterEvery', stringify);
    await forceUpdateOption('newCommentCount', 'cleanComments', stringify);
    await forceUpdateOption('newCommentCount', 'subscriptionLength', stringify);
    await forceUpdateOption('nightMode', 'nightModeOverrideHours', stringify);
    await forceUpdateOption('notifications', 'closeDelay', stringify);
    await forceUpdateOption('notifications', 'fadeOutLength', stringify);
    await forceUpdateOption('profileNavigator', 'hoverDelay', stringify);
    await forceUpdateOption('profileNavigator', 'fadeDelay', stringify);
    await forceUpdateOption('profileNavigator', 'fadeSpeed', stringify);
    await forceUpdateOption('showImages', 'browsePreloadCount', stringify);
    await forceUpdateOption('showImages', 'galleryPreloadCount', stringify);
    await forceUpdateOption('showImages', 'bufferScreens', stringify);
    await forceUpdateOption('showImages', 'selfTextMaxHeight', stringify);
    await forceUpdateOption('showImages', 'commentMaxHeight', stringify);
    await forceUpdateOption('showImages', 'filmstripLoadIncrement', stringify);
    await forceUpdateOption('showImages', 'useSlideshowWhenLargerThan', stringify);
    await forceUpdateOption('showImages', 'maxSimultaneousPlaying', stringify);
    await forceUpdateOption('showParent', 'hoverDelay', stringify);
    await forceUpdateOption('showParent', 'fadeDelay', stringify);
    await forceUpdateOption('showParent', 'fadeSpeed', stringify);
    await forceUpdateOption('styleTweaks', 'highlightTopLevelSize', stringify);
    await forceUpdateOption('subredditInfo', 'hoverDelay', stringify);
    await forceUpdateOption('subredditInfo', 'fadeDelay', stringify);
    await forceUpdateOption('subredditInfo', 'fadeSpeed', stringify);
    await forceUpdateOption('subredditManager', 'shortcutDropdownDelay', stringify);
    await forceUpdateOption('subredditManager', 'shortcutEditDropdownDelay', stringify);
    await forceUpdateOption('userInfo', 'hoverDelay', stringify);
    await forceUpdateOption('userInfo', 'fadeDelay', stringify);
    await forceUpdateOption('userInfo', 'fadeSpeed', stringify);
  }

}, {
  versionNumber: '5.9-filteReddit-customFilter',

  async go() {
    function convertPatt(type, patt, key) {
      if (typeof patt !== 'string' || !patt.length || /^\/(.*)\/([gim]+)?$/.test(patt)) return;

      if (type === 'postTitle') {
        return {
          [key]: `/${patt}/i`
        };
      } else if (['subreddit', 'domain', 'userFlair', 'linkFlair', 'username'].includes(type)) {
        return {
          [key]: `/^(${patt})\$/i`
        };
      }
    }

    const entries = {};
    const f = await storage_namespaceObject.wrapPrefix('RESmodules.filteReddit.', () => ({})).getAll();

    for (const [k, v] of Object.entries(f)) {
      if (typeof v === 'boolean') continue;
      const visible = f[`filterlineVisibility.${k}`] || false;
      const entry = entries[`filterline.${k}`] = {
        filters: {},
        visible
      };

      for (const [id, {
        criterion,
        state,
        key
      }] of Object.entries(v.filters || {})) {
        const type = key;
        entry.filters[id] = {
          type,
          state,
          criterion,
          ...convertPatt(type, criterion, 'criterion')
        };
      }
    }

    await storage_namespaceObject.setMultiple(entries);
    const {
      customFilters
    } = (await loadRaw('filteReddit')) || {};

    if (customFilters) {
      for (const {
        body
      } of customFilters.value || []) {
        body.of.forEach(function traverseAndUpdate(v) {
          if (v.type === 'group') v.of.forEach(traverseAndUpdate);else Object.assign(v, convertPatt(v.type, v.patt, 'patt'));
        });
      }

      await options_set('filteReddit', 'customFiltersP', customFilters.value);
    }
  }

}, {
  versionNumber: '5.11.1-settingsConsole-builder-tweak',

  async go() {
    const {
      customFiltersP,
      customFiltersC
    } = (await loadRaw('filteReddit')) || {};
    let i = Date.now();

    for (const v of [...(customFiltersP && customFiltersP.value || []), ...(customFiltersC && customFiltersC.value || [])]) {
      const {
        body: {
          name
        },
        ondemand
      } = v;
      v.opts = {
        ondemand,
        name
      };
      v.id = `customFilter-${String(i++)}`;
    }

    if (customFiltersP) await options_set('filteReddit', 'customFiltersP', customFiltersP.value);
    if (customFiltersC) await options_set('filteReddit', 'customFiltersC', customFiltersC.value);
  }

}, {
  versionNumber: '5.13.3-userTagger-ignored-to-filteReddit',

  async go() {
    const ignoredUsers = Object.entries((await storage_namespaceObject.wrapPrefix('tag.', () => ({})).getAll())).filter(([, {
      ignored
    }]) => ignored).map(([username]) => [username]);
    await options_set('filteReddit', 'users', ignoredUsers);
  }

}, {
  versionNumber: '5.13.3-filterline-effects-and-clean',

  async go() {
    function migrateFilters(filters = {}) {
      for (const [id, filter] of Object.entries(filters)) {
        if (!isObject_default()(filter)) {
          delete filters[id];
          continue;
        }

        filter.effects = {
          hide: filter.state !== null,
          ...filter.sideEffects
        };
        if (filter.state === null) filter.state = true;
      }
    }

    let f = storage_namespaceObject.wrapPrefix('RESmodules.filteReddit.', () => ({}));

    for (const [k, v] of Object.entries((await f.getAll()))) {
      if (k.startsWith('commentDefault') || k.startsWith('postDefault')) {
        migrateFilters(v);
        await f.set(k, v);
      } else {
        await f.delete(k);
      }
    }

    f = storage_namespaceObject.wrapPrefix('filterline.', () => ({}));

    for (const [k, v] of Object.entries((await f.getAll()))) {
      if (v) {
        if (v.effects) continue;
        migrateFilters(v.filters);
        v.lastUsed = Date.now();
        await f.set(k, v);
      } else {
        await f.delete(k);
      }
    }
  }

}, {
  versionNumber: '5.14.1-filteReddit-user-hardIgnore',

  async go() {}

}, {
  versionNumber: '5.14.2-filteReddit-user-hide-soft',

  async go() {}

}, {
  versionNumber: '5.14.2-filteReddit-migration-repair',

  async go() {
    function migrateRepair(filters) {
      const allHidden = filters.every(([, filter]) => filter.effects && Object.keys(filter.effects).length === 1 && filter.effects.hide);

      if (allHidden) {
        for (const [id, filter] of filters) {
          if (['users', 'subreddits', 'keywords', 'domains', 'flair'].includes(id)) continue;
          filter.effects = {
            hide: false
          };
        }

        return true;
      }
    }

    let f = storage_namespaceObject.wrapPrefix('RESmodules.filteReddit.', () => ({}));

    for (const [k, v] of Object.entries((await f.getAll()))) {
      if (migrateRepair(Object.entries(v))) await f.set(k, v);
    }

    f = storage_namespaceObject.wrapPrefix('filterline.', () => ({}));

    for (const [k, v] of Object.entries((await f.getAll()))) {
      const filters = v && v.filters && Object.entries(v.filters);

      if (filters && filters.length) {
        if (migrateRepair(filters)) await f.set(k, v);
      } else {
        await f.delete(k);
      }
    }
  }

}, {
  versionNumber: '5.14.3-filteReddit-user-action-collapse',

  async go() {
    const hardIgnoreOption = (await options_get('userTagger', 'hardIgnore')) || (await options_get('filteReddit', 'hardIgnoreUsers'));
    let hardIgnore = hardIgnoreOption ? hardIgnoreOption.value : true;
    const usersMatchAction = await options_get('filteReddit', 'usersMatchAction');
    if (usersMatchAction && usersMatchAction.value === 'placeholder') hardIgnore = false;
    await options_set('filteReddit', 'usersMatchAction', hardIgnore ? 'hide' : 'placeholder');
  }

}, {
  versionNumber: '5.14.4-new-module-subredditStyleToggle',

  async go() {
    await moveOption('styleTweaks', 'subredditStyleBrowserToolbarButton', 'subredditStyleToggle', 'browserToolbarButton');
    await moveOption('styleTweaks', 'subredditStyleCheckbox', 'subredditStyleToggle', 'checkbox');
    const ignored = await storage_namespaceObject.get('RESmodules.styleTweaks.ignoredSubredditStyles');

    if (ignored) {
      await storage_namespaceObject.set('RESmodules.subredditStyleToggle.ignored', ignored);
      await storage_namespaceObject.delete('RESmodules.styleTweaks.ignoredSubredditStyles');
    }
  }

}, {
  versionNumber: '5.14.4-prune-interface',

  async go() {
    await updateOption('newCommentCount', 'cleanComments', '7', '30');
    await storage_namespaceObject.delete('RESmodules.readComments.lastClean');
    await storage_namespaceObject.delete('RESmodules.newCommentCount.lastClean');
    await storage_namespaceObject.delete('RESmodules.commentHidePersistor.lastClean');
  }

}];

const _migrationsToRun = getMigrationsToRun();

async function migrate() {
  const migrations = await _migrationsToRun;
  if (!migrations.length) return;
  await forEachSeq(migrations, async currentMigration => {
    if (!(await sendMessage('requestMigrateLock'))) throw new Error('Tab could not retain migration lock');
    document.documentElement.setAttribute('res-warning', 'Reddit Enhancement Suite is migrating your preferences');
    await currentMigration.go();
    storage_namespaceObject.set('RESOptionsVersion', currentMigration.versionNumber);
  });
  document.documentElement.removeAttribute('res-warning');
}

async function getMigrationsToRun() {
  const lastMigratedVersion = await getLastMigratedVersion();

  if (lastMigratedVersion === false) {
    storage_namespaceObject.set('RESOptionsVersion', last_default()(migrate_migrations).versionNumber);
    return [];
  }

  return takeRightWhile_default()(migrate_migrations, ({
    versionNumber
  }) => versionNumber !== lastMigratedVersion);
}

async function getLastMigratedVersion() {
  const RESOptionsVersion = await storage_namespaceObject.get('RESOptionsVersion');

  if (typeof RESOptionsVersion === 'undefined') {
    console.warn('RESOptionsVersion was undefined');
    return false;
  } else if (RESOptionsVersion !== null) {
    if (/^\d$/.test(RESOptionsVersion)) {
      return ['4.5.0.0', '4.5.0.1'][RESOptionsVersion - 1];
    } else if (!migrate_migrations.map(m => m.versionNumber).includes(RESOptionsVersion)) {
      console.warn(`Couldn't find a migration matching RESOptionsVersion = ${RESOptionsVersion}`);
      return false;
    } else {
      return RESOptionsVersion;
    }
  } else if (await storage_namespaceObject.has('RES.firstRun.4.5.0.2')) {
    return '4.5.0.2';
  } else if ((await storage_namespaceObject.has('RES.firstRun.4.3.2.1')) || (await storage_namespaceObject.has('RES.firstRun.4.3.1.2')) || (await storage_namespaceObject.has('RES.firstRun.4.3.0.3')) || (await storage_namespaceObject.has('RES.firstRun.4.2.0.2')) || (await storage_namespaceObject.has('RES.firstRun.4.1.5'))) {
    return null;
  } else {
    return false;
  }
}
// CONCATENATED MODULE: ./lib/core/migrate/index.js

// CONCATENATED MODULE: ./lib/core/init.js








let init_start;
function init() {
  if (location.hash === RES_DISABLED_HASH) return;

  if (document.documentElement && document.documentElement.classList.contains('res')) {
    document.documentElement.setAttribute('res-warning', 'This page must be reloaded for Reddit Enhancement Suite to function correctly');
    throw new Error('RES has already been loaded on this page.');
  }

  if (location.hash.startsWith(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH)) {
    location.href = getURL(`options.html${location.hash.replace(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH, RES_SETTINGS_HASH)}`);
    return;
  }

  init_start();
}
const sourceLoaded = new Promise(resolve => init_start = resolve);
const bodyStart = sourceLoaded.then(() => waitForChild(document.documentElement, 'body')).then(() => waitFor(() => document.body, 10));
const sitetableStarted = bodyStart.then(() => Promise.race([waitForDescendant(document.body, isPageType('comments') ? '.sitetable.nestedlisting' : '#siteTable'), contentLoaded]));
const contentLoaded = bodyStart.then(() => Promise.race([waitForEvent(window, 'DOMContentLoaded', 'load'), waitFor(() => document.readyState === 'interactive' || document.readyState === 'complete', 500)]));
const loadComplete = bodyStart.then(() => Promise.race([waitForEvent(window, 'load'), waitFor(() => document.readyState === 'complete', 500)]));
const loadI18n = sourceLoaded.then(() => _loadI18n());
const runMigrations = loadI18n.then(() => migrate());
const onInit = loadI18n.then(() => _runModuleStage('onInit', {
  skipEnabledCheck: true
}));
const init_loadOptions = onInit.then(() => Promise.all([_loadModuleOptions(), _loadModulePrefs()]));
const addModuleBodyClasses = init_loadOptions.then(() => _addModuleBodyClasses());
const init_always = init_loadOptions.then(() => _runModuleStage('always', {
  skipEnabledCheck: true
}));
const beforeLoad = init_loadOptions.then(() => _runModuleStage('beforeLoad'));
const init_contentStart = Promise.all([beforeLoad, sitetableStarted]).then(() => Promise.all([_runModuleStage('contentStart'), isAppType('r2') ? r2WatcherSitetableStart() : undefined]));
const go = Promise.all([beforeLoad, sitetableStarted]).then(() => {
  const run = fp_once_default()(() => Promise.all([isAppType('d2x') ? initD2xWatcher() : r2WatcherContentLoaded(), _runModuleStage('go')]));

  window.addEventListener('DOMContentLoaded', run, true);
  return contentLoaded.then(run);
});
const afterLoad = Promise.all([go, loadComplete]).then(() => _runModuleStage('afterLoad'));
bodyStart.then(bodyClasses_namespaceObject.addMissing);
const font = new FontFace('Batch', `url(${getURL('batch-icons-webfont.woff')})`, {
  style: 'normal',
  weight: 'normal'
});
sourceLoaded.then(() => font.load().then(() => document.fonts.add(font)));
// EXTERNAL MODULE: ./node_modules/lodash/fp/groupBy.js
var fp_groupBy = __webpack_require__(144);
var fp_groupBy_default = /*#__PURE__*/__webpack_require__.n(fp_groupBy);

// EXTERNAL MODULE: ./node_modules/lodash/matchesProperty.js
var matchesProperty = __webpack_require__(85);
var matchesProperty_default = /*#__PURE__*/__webpack_require__.n(matchesProperty);

// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __webpack_require__(86);
var find_default = /*#__PURE__*/__webpack_require__.n(find);

// CONCATENATED MODULE: ./lib/options/templates.js



const consoleContainerTemplate = ({
  name,
  version,
  gitDescription
}) => string_namespaceObject.html`
	<div id="RESConsoleContainer">
		<div id="RESConsoleHeader">
			<div id="RESConsoleTopBar" class="RESDialogTopBar">
				<a class="res-logo" href="${RES_SETTINGS_HASH}"></a>
				<h1>${name}</h1>
				<div id="RESConsoleVersionDisplay" title="${gitDescription}">v${version}</div>


				<button id="moduleOptionsSave">${i18n('saveOptions')}</button>
				<div id="moduleOptionsSaveStatus" class="saveStatus" style="display: none;">Options have been saved...</div>
				<a id="RESConsoleSubredditLink" href="/r/Enhancement" alt="The RES Subreddit">/r/Enhancement</a>
				<span id="RESClose" class="RESCloseButton">×</span>
			</div>
		</div>

		<div id="RESConsoleContent">
			<div id="RESConfigPanelModulesPane">
				<div id="SearchRES-input-container"></div>

				<div id="RESConfigPanelModulesList"></div>

				<label id="RESAllOptionsSpan">
					<input id="RESAllOptions" type="checkbox">
					<span>${i18n('showAdvancedOptions')}</span>
				</label>
			</div>
			<div id="RESConfigPanelOptions">
				<div class="moduleHeader">
					<span class="moduleName">Module Name</span>
					<div class="moduleToggle toggleButton enabled" moduleID="moduleID">
						<span class="toggleThumb"></span>
						<div class="toggleLabel" data-enabled-text="${i18n('toggleOn')}" data-disabled-text="${i18n('toggleOff')}"></div>
					</div>

					<div class="moduleDescription"></div>
				</div>
				<div id="allOptionsContainer"></div>
				<div id="noOptions" class="optionContainer">
					There are no configurable options for this module.
				</div>
			</div>
		</div>
	</div>
`;
const moduleSelectorTemplate = categories => string_namespaceObject.html`
	<ul>
		${categories.map(({
  name,
  translatedName,
  modules
}) => string_namespaceObject._html`
			<li class="RESConfigPanelCategory" data-category="${name}">
				<h3 class="categoryButton">${translatedName}</h3>
				<ul>
					${modules.map(({
  isEnabled,
  moduleID,
  translatedName,
  description,
  shortDescription
}) => string_namespaceObject._html`
						<li class="moduleButton ${isEnabled && 'enabled'}" data-module="${moduleID}" title="${description}">
							${translatedName}
							<small>
								${shortDescription}
							</small>
						</li>
					`)}
				</ul>
			</li>
		`)}
	</ul>
`;
// CONCATENATED MODULE: ./lib/options/settingsConsole.js




















const DEFAULT_MODULE = about_module;
const CATEGORY_SORT = ['aboutCategory', 'myAccountCategory', 'usersCategory', 'commentsCategory', 'submissionsCategory', 'subredditsCategory', 'appearanceCategory', 'browsingCategory', 'productivityCategory', 'coreCategory'];
let $moduleOptionsScrim;
let RESConfigPanelOptions;
let RESConsoleContainer;
let RESConsoleContent;
let currentModule;
let moduleToggle;
let settingsConsole_saveButton;
function settingsConsole_start() {
  create();
  window.addEventListener('hashchange', loadFromHash);
  window.addEventListener('message', ({
    data
  }) => {
    if (data.close) {
      settingsConsole_close();
    } else if (load) {
      const {
        moduleID,
        optionKey
      } = data.load;
      load(moduleID, optionKey);
    }
  });
  loadFromHash();
  watchForDescendants(document.body, 'a', e => {
    const a = downcast(e, HTMLAnchorElement);
    if (isSettingsUrl(a.href)) return;
    a.href = new URL(e.getAttribute('href'), context_data.origin).href;
    if (!a.target.includes('_blank')) a.target += ' _parent';
  });
}

function loadFromHash() {
  const {
    moduleID,
    optionKey
  } = parseHash(location.hash);
  load(moduleID, optionKey);
}

function load(moduleID, optionKey) {
  const mod = moduleID && (getUnchecked(moduleID) || getByCategory(moduleID)[0]) || DEFAULT_MODULE;

  if (mod !== currentModule) {
    currentModule = mod;
    drawConfigOptions(mod);
    updateSelectedModule(mod);
    requestAnimationFrame(() => {
      RESConsoleContent.scrollTop = 0;
    });
  }

  if (optionKey && mod.options.hasOwnProperty(optionKey)) {
    highlightOption(mod, optionKey);
  }

  if (mod === search_module) {
    search_search(optionKey);
    requestAnimationFrame(() => search_input().focus());
  } else {
    search_input().blur();
  }

  setHash(makeUrlHash(moduleID, optionKey));
}

function highlightOption(mod, optionKey) {
  const optionElement = RESConfigPanelOptions.querySelector(`#optionContainer-${mod.moduleID}-${optionKey}`);
  if (!optionElement) return;
  optionElement.classList.add('highlight');
  optionElement.style.display = '';
  requestAnimationFrame(() => {
    RESConfigPanelOptions.scrollTop = optionElement.offsetTop - 10;
  });

  if (optionElement.classList.contains('advanced') && !settingsNavigation_module.options.showAllOptions.value) {
    document.getElementById('RESConsoleContent').classList.remove('advanced-options-disabled');

    if (settingsNavigation_module.options.showAllOptionsAlert.value) {
      alert_namespaceObject.open('You opened a link to an advanced option, but not all options are shown. These options will be shown until you leave or refresh the page. If you want to see all options in the future, check the <i>Show all options</i> checkbox in the settings console title bar above.<br /><br /><label><input type="checkbox" class="disableAlert" checked="" style="margin:1px 5px 0px 0px;"> Always show this type of notification</label>');
      $('#alert_message .disableAlert').click(function () {
        options_set(settingsNavigation_module, 'showAllOptionsAlert', this.checked);
      });
    }
  }
}

function create() {
  RESConsoleContainer = consoleContainerTemplate({
    name: metadata_name,
    version: metadata_version,
    gitDescription: metadata_gitDescription
  });
  requestAnimationFrame(() => document.querySelector('.res-logo').focus());
  const RESClose = RESConsoleContainer.querySelector('#RESClose');
  RESClose.addEventListener('click', e => {
    e.preventDefault();
    settingsConsole_close();
  }, true);
  const RESAdvOptionsSpan = RESConsoleContainer.querySelector('#RESAllOptionsSpan');
  RESAdvOptionsSpan.setAttribute('title', i18n(settingsNavigation_module.options.showAllOptions.description));
  const RESAdvOptions = RESAdvOptionsSpan.querySelector('input');
  RESAdvOptions.addEventListener('change', function () {
    options_set(settingsNavigation_namespaceObject, 'showAllOptions', this.checked);
    updateAdvancedOptionsVisibility();
  }, true);
  RESConsoleContainer.querySelector('#RESConfigPanelModulesList').appendChild(renderModulesSelector());
  $(RESConsoleContainer).find('#RESConfigPanelModulesPane').on('click', '.moduleButton', function (e) {
    const id = $(this).data('module');

    if (id) {
      e.preventDefault();
      load(id);
    }
  }).on('click', '.categoryButton', function (e) {
    const id = $(this).parent().data('category');

    if (id) {
      e.preventDefault();
      openCategoryPanel(id);
    }
  });
  RESConsoleContent = RESConsoleContainer.querySelector('#RESConsoleContent');

  if (settingsNavigation_module.options.showAllOptions.value) {
    RESAdvOptions.checked = true;
  } else {
    RESConsoleContent.classList.add('advanced-options-disabled');
  }

  RESConfigPanelOptions = RESConsoleContainer.querySelector('#RESConfigPanelOptions');
  $(RESConsoleContainer).find('#SearchRES-input-container').append(search_input());

  const search = () => load(search_module.moduleID, search_input().value);

  search_input().addEventListener('input', frameThrottle(search));
  search_input().addEventListener('click', search);
  drawSettingsConsole();
  document.body.append(RESConsoleContainer);
}

const createKeyCodeModal = once_default()(() => {
  const $keyCodeModal = $('<div>', {
    id: 'keyCodeModal',
    text: 'Press a key (or combination with shift, alt and/or ctrl) to assign this action.'
  }).appendTo(document.body);
  let captureKey, captureKeyID;
  window.addEventListener('keydown', e => {
    if (captureKey && ![NAMED_KEYS.Shift, NAMED_KEYS.Control, NAMED_KEYS.Alt].includes(e.key)) {
      e.preventDefault();
      let keyArray;

      if (e.key === NAMED_KEYS.Backspace) {
        keyArray = [-1, false, false, false, false];
      } else {
        keyArray = [e.keyCode, e.altKey, e.ctrlKey, e.shiftKey, e.metaKey];
      }

      RESConfigPanelOptions.querySelector(`[id="${captureKeyID}"]`).value = keyArray.join(',');
      RESConfigPanelOptions.querySelector(`[id="${captureKeyID}-display"]`).value = keycode_niceKeyCode(keyArray);
      $keyCodeModal.css('display', 'none');
      captureKey = false;
    }
  });
  $(RESConsoleContent).on({
    focus(e) {
      const $target = $(e.target);
      const {
        top,
        left
      } = $target.offset();
      $keyCodeModal.css({
        display: 'block',
        top: top + $target.height(),
        left
      });
      captureKey = true;
      captureKeyID = $target.attr('capturefor');
    },

    blur() {
      $keyCodeModal.css('display', 'none');
    }

  }, '.keycode + input[type=text][displayonly]');
  return $keyCodeModal;
});

function renderModulesSelector() {
  function compareModules(a, b) {
    if (a.sort === b.sort) {
      return i18n(a.moduleName).toLocaleLowerCase().localeCompare(i18n(b.moduleName).toLocaleLowerCase());
    } else {
      return (a.sort || 0) - (b.sort || 0);
    }
  }

  const categories = flow_default()(() => modules_all(), filter_default()(mod => !mod.hidden), fp_groupBy_default()(mod => mod.category), obj => Object.entries(obj).map(([category, modules]) => ({
    name: category,
    translatedName: i18n(category),
    modules: modules.sort(compareModules).map(mod => {
      const description = $(`<p>${mod.descriptionRaw ? mod.description : snudown_es_markdown(i18n(mod.description))}</p>`).text().replace(/\s+/g, ' ');
      return {
        moduleID: mod.moduleID,
        translatedName: i18n(mod.moduleName),
        description,
        shortDescription: description.split(/[!?.]/)[0],
        isEnabled: modules_isEnabled(mod)
      };
    })
  })), fp_sortBy_default()(({
    name
  }) => CATEGORY_SORT.indexOf(name)))();

  return moduleSelectorTemplate(categories);
}

function updateSelectedModule(mod) {
  const items = $(RESConsoleContainer).find('.moduleButton');
  const selected = items.filter(function () {
    return $(this).data('module') === mod.moduleID;
  });
  items.not(selected).removeClass('active');
  selected.addClass('active');
  openCategoryPanel(mod.category);
}

function drawOptionInput(mod, optionName, optionObject, isTable) {
  let $thisOptionFormEle;

  switch (optionObject.type) {
    case 'textarea':
      $thisOptionFormEle = $('<textarea>', {
        id: optionName,
        type: 'textarea',
        moduleID: mod.moduleID,
        html: escapeHTML(optionObject.value)
      });
      break;

    case 'list':
    case 'text':
      $thisOptionFormEle = $('<input>', {
        id: optionName,
        type: 'text',
        moduleID: mod.moduleID
      });

      if (typeof optionObject.value !== 'undefined') {
        $thisOptionFormEle.attr('value', optionObject.value);
      }

      break;

    case 'color':
      $thisOptionFormEle = $('<input>', {
        id: optionName,
        type: 'color',
        moduleID: mod.moduleID
      });

      if (typeof optionObject.value !== 'undefined') {
        $thisOptionFormEle.get(0).value = optionObject.value;
      }

      break;

    case 'button':
      const {
        values = [],
        callback,
        text
      } = optionObject;
      if (callback && text) values.push({
        callback,
        text
      });
      const buttonsContainer = $thisOptionFormEle = $('<div>', {
        id: optionName
      });

      for (const option of values) {
        let $thisOptionFormEle;

        if (typeof option.callback === 'string' || option.callback.moduleID) {
          $thisOptionFormEle = $('<a>');
        } else {
          $thisOptionFormEle = $('<button>');
        }

        $thisOptionFormEle.addClass('RESConsoleButton');
        $thisOptionFormEle.attr('moduleID', mod.moduleID);

        if (option.text.tagName || option.text.jquery) {
          $thisOptionFormEle.append(option.text);
        } else if (typeof option.text === 'string') {
          $thisOptionFormEle.text(i18n(option.text));
        } else {
          $thisOptionFormEle.append(createElement_namespaceObject.icon(0xF141));
        }

        if (option.callback.moduleID) {
          $thisOptionFormEle.attr('href', makeUrlHash(option.callback.moduleID, option.callback.optionKey));
        } else if (typeof option.callback === 'string') {
          $thisOptionFormEle.attr('href', option.callback);
          $thisOptionFormEle.attr('target', '_blank');
          $thisOptionFormEle.attr('rel', 'noopener noreferer');
        } else if (typeof option.callback === 'function') {
          $thisOptionFormEle.click(async function () {
            if (this.classList.contains('csspinner')) return;
            this.classList.add('csspinner');

            try {
              await option.callback(optionName, optionObject);
            } catch (e) {
              if (e.message) alert_namespaceObject.open(e.message);
              console.error(e);
            }

            this.classList.remove('csspinner');
          });
        }

        buttonsContainer.append($thisOptionFormEle);
      }

      break;

    case 'password':
      $thisOptionFormEle = $('<input>', {
        id: optionName,
        type: 'password',
        moduleID: mod.moduleID
      });

      if (typeof optionObject.value !== 'undefined') {
        $thisOptionFormEle.attr('value', optionObject.value);
      }

      break;

    case 'boolean':
      $thisOptionFormEle = $(createElement_namespaceObject.toggleButton(() => {
        $(RESConsoleContainer).trigger('change');
      }, optionName, optionObject.value, undefined, undefined, isTable));
      break;

    case 'enum':
      $thisOptionFormEle = $('<div>', {
        id: optionName,
        class: 'enum'
      });

      if (optionObject.value && !find_default()(optionObject.values, matchesProperty_default()('value', optionObject.value))) {
        optionObject.values.push({
          name: `${optionObject.value} (not available)`,
          value: optionObject.value
        });
      }

      optionObject.values.forEach((optionValue, index) => {
        const thisId = `${optionName}-${index}`;
        const $thisOptionFormSubEle = $('<input>', {
          id: thisId,
          type: 'radio',
          name: optionName,
          moduleID: mod.moduleID,
          value: optionValue.value
        });
        if (isTable) $thisOptionFormSubEle.attr('tableOption', 'true');
        const nullEqualsEmpty = optionObject.value === null && optionValue.value === '';

        if (optionObject.value === optionValue.value || nullEqualsEmpty) {
          $thisOptionFormSubEle.attr('checked', 'checked');
        }

        const thisLabel = document.createElement('label');
        thisLabel.setAttribute('for', thisId);
        thisLabel.textContent = ` ${i18n(optionValue.name)} `;
        $thisOptionFormEle.append($thisOptionFormSubEle);
        $thisOptionFormEle.append(thisLabel);
        $thisOptionFormEle.append('<br>');
      });
      break;

    case 'keycode':
      createKeyCodeModal();
      const realOptionFormEle = $('<input>').attr({
        id: optionName,
        type: 'text',
        class: 'keycode',
        moduleID: mod.moduleID
      }).css({
        border: '1px solid red',
        display: 'none'
      }).val(optionObject.value);
      if (isTable) realOptionFormEle.attr('tableOption', 'true');
      const thisKeyCodeDisplay = $('<input>').attr({
        id: `${optionName}-display`,
        type: 'text',
        capturefor: optionName,
        displayonly: 'true'
      }).val(keycode_niceKeyCode(optionObject.value));
      $thisOptionFormEle = $('<div>').append(realOptionFormEle).append(thisKeyCodeDisplay);
      break;

    case 'select':
      $thisOptionFormEle = $('<select>').attr({
        id: optionName,
        class: 'select',
        value: optionObject.value
      });

      if (optionObject.value && !find_default()(optionObject.values, matchesProperty_default()('value', optionObject.value))) {
        optionObject.values.push({
          name: `${optionObject.value} (not available)`,
          value: optionObject.value
        });
      }

      optionObject.values.forEach((optionValue, index) => {
        const $thisOptionFormSubEle = $('<option />', {
          id: `${optionName}-${index}`,
          class: 'select-option',
          value: optionValue.value,
          moduleID: mod.moduleID,
          style: optionValue.style
        }).text(optionValue.name);
        const nullEqualsEmpty = optionObject.value === null && optionValue.value === '';

        if (optionObject.value === optionValue.value || nullEqualsEmpty) {
          $thisOptionFormSubEle.attr('selected', 'selected');
        }

        $thisOptionFormEle.append($thisOptionFormSubEle);
      });
      break;

    default:
      throw new Error(`modules.${mod.moduleID}.options.${optionName} has invalid type: ${optionObject.type}`);
  }

  if (isTable) {
    $thisOptionFormEle.attr('tableOption', 'true');
  }

  return $thisOptionFormEle.get(0);
}

function drawSettingsConsole() {
  const thisToggle = RESConsoleContainer.querySelector('.moduleToggle');
  moduleToggle = thisToggle;
  thisToggle.addEventListener('click', toggleModuleEnabledState, true);

  async function toggleModuleEnabledState() {
    const moduleID = $(this).data('module');
    const $moduleButton = $(RESConsoleContainer).find('.moduleButton').filter(function () {
      return $(this).data('module') === moduleID;
    });
    const enabled = this.classList.contains('enabled');
    const enable = !enabled;

    if (enable) {
      const {
        requiredPermissions: permissions,
        message
      } = modules_get(moduleID).permissions;

      if (permissions.length && !(await permissions_namespaceObject.has(permissions))) {
        if (message) {
          notifications_showNotification({
            header: 'Permission required',
            moduleID,
            closeDelay: 20000,
            message
          });
        }

        await permissions_namespaceObject.request(permissions);
      }
    }

    $(thisToggle).add($moduleButton).add(this.classList).toggleClass('enabled', enable);
    updateSaveButton();
    if ($moduleOptionsScrim) $moduleOptionsScrim.toggleClass('visible', !enable);
    setEnabled(moduleID, !enabled);
  }

  settingsConsole_saveButton = RESConsoleContainer.querySelector('#moduleOptionsSave');
  settingsConsole_saveButton.addEventListener('click', function (e) {
    e.preventDefault();
    saveCurrentModuleOptions();
  }, true);
  $(document.body).on('keyup', handleEscapeKey);
  $(window).on('beforeunload', handleBeforeUnload);
  $(RESConsoleContainer).on('input change', autostageDebounce);
}

function drawConfigOptions(mod) {
  if (mod.hidden) return;
  const thisOptions = settingsConsole_getOptions(mod);
  let optCount = 0;
  const thisModuleName = RESConsoleContainer.querySelector('.moduleName');
  $(thisModuleName).html(`${i18n(mod.moduleName)} <span class="moduleKey">(${mod.moduleID})</span>`);
  $(moduleToggle).toggle(!mod.alwaysEnabled).toggleClass('enabled', modules_isEnabled(mod)).data('module', mod.moduleID);
  updateSaveButton();
  const thisDescription = RESConsoleContainer.querySelector('.moduleDescription');
  $(thisDescription).html(mod.descriptionRaw ? mod.description : snudown_es_markdown(i18n(mod.description)));
  const allOptionsContainer = RESConsoleContainer.querySelector('#allOptionsContainer');
  $(allOptionsContainer).empty();
  allOptionsContainer.append(...Object.entries(thisOptions).map(([optionKey, option]) => {
    if (option.noconfig) return;
    let thisOptionFormEle;
    optCount++;
    const containerID = `optionContainer-${mod.moduleID}-${optionKey}`;
    const $thisOptionContainer = $('<div>', {
      id: containerID,
      class: 'optionContainer'
    });

    if (option.dependsOn && !option.dependsOn(thisOptions)) {
      $thisOptionContainer.css('display', 'none');
    }

    if (option.advanced) {
      $thisOptionContainer.addClass('advanced');
    }

    const optionTitle = i18n(option.title);
    const $thisLabel = $('<label>', {
      class: 'optionTitle',
      for: optionKey,
      html: `${optionTitle}<br /><span class="optionKey">${optionKey}</span>`
    });
    let niceDefaultOption = null;

    switch (option.type) {
      case 'textarea':
      case 'text':
      case 'password':
      case 'list':
        niceDefaultOption = option.default;
        break;

      case 'color':
        niceDefaultOption = option.default;

        if (option.default.startsWith('#')) {
          niceDefaultOption += ` (R:${parseInt(option.default.substr(1, 2), 16)}, G:${parseInt(option.default.substr(3, 2), 16)}, B:${parseInt(option.default.substr(5, 2), 16)})`;
        }

        break;

      case 'boolean':
        niceDefaultOption = option.default ? 'on' : 'off';
        break;

      case 'enum':
      case 'select':
        const matchingOption = option.values.find(({
          value
        }) => option.default === value);
        niceDefaultOption = matchingOption && i18n(matchingOption.name);
        break;

      case 'keycode':
        niceDefaultOption = keycode_niceKeyCode(option.default);
        break;

      default:
        break;
    }

    if (niceDefaultOption !== null) {
      $thisLabel.attr('title', `Default: ${niceDefaultOption}`);
    }

    const $thisOptionDescription = $('<div>', {
      class: 'optionDescription',
      html: snudown_es_markdown(i18n(option.description))
    });
    const $thisOptionSetting = $('<div>', {
      class: 'optionSetting'
    });
    $thisOptionContainer.append($thisLabel);
    $thisOptionContainer.append($thisOptionSetting);

    if (option.type === 'table') {
      const isFixed = option.addRowText === false;
      $thisOptionContainer.addClass('table');
      const thisTbody = document.createElement('tbody');
      const thisTable = document.createElement('table');
      thisTable.setAttribute('moduleID', mod.moduleID);
      thisTable.setAttribute('optionName', optionKey);
      thisTable.setAttribute('class', 'optionsTable');
      const thisThead = document.createElement('thead');
      const thisTableHeader = document.createElement('tr');
      let thisTH;
      thisTable.appendChild(thisThead);
      option.fields.forEach(field => {
        thisTH = document.createElement('th');
        $(thisTH).text(i18n(field.name));
        thisTableHeader.appendChild(thisTH);
      });

      if (!isFixed) {
        thisTH = document.createElement('th');
        thisTableHeader.appendChild(thisTH);
        thisTH = document.createElement('th');
        $(thisTableHeader).prepend(thisTH);
      }

      thisThead.appendChild(thisTableHeader);
      thisTable.appendChild(thisThead);
      thisTbody.setAttribute('id', `tbody_${optionKey}`);

      if (option.value) {
        thisTbody.append(...option.value.map((thisValue, j) => {
          const thisTR = document.createElement('tr');
          option.fields.forEach((field, k) => {
            const thisTD = document.createElement('td');
            thisTD.className = 'hasTableOption';
            const thisOpt = { ...field,
              value: thisValue[k]
            };
            const thisFullOpt = `${optionKey}_${thisOpt.name}`;
            const thisTableEle = drawOptionInput(mod, `${thisFullOpt}_${j}`, thisOpt, true);
            thisTD.appendChild(thisTableEle);
            thisTR.appendChild(thisTD);
          });

          if (!isFixed) {
            addTableButtons(thisTR);
          }

          return thisTR;
        }));
      }

      thisTable.appendChild(thisTbody);
      thisOptionFormEle = thisTable;
      $thisOptionDescription.insertAfter($thisLabel);

      if (!isFixed) {
        const addRowButton = $('<button class="addRowButton"></button>').text(i18n(option.addRowText || 'settingsConsoleDefaultAddRowText')).get(0);
        addRowButton.setAttribute('optionName', optionKey);
        addRowButton.setAttribute('moduleID', mod.moduleID);
        addRowButton.addEventListener('click', e => {
          const optionName = e.target.getAttribute('optionName');
          const thisTbody = document.getElementById(`tbody_${optionName}`);
          const newRow = document.createElement('tr');
          const rowCount = thisTbody.querySelectorAll('tr') ? thisTbody.querySelectorAll('tr').length + 1 : 1;
          mod.options[optionName].fields.forEach(thisOpt => {
            const newCell = document.createElement('td');
            newCell.className = 'hasTableOption';
            const optionNameWithRow = `${optionName}_${thisOpt.name}_${rowCount}`;
            const thisInput = drawOptionInput(mod, optionNameWithRow, thisOpt, true);
            newCell.appendChild(thisInput);
            newRow.appendChild(newCell);
            const firstText = newRow.querySelector('input[type=text], textarea');
            if (firstText) setTimeout(() => firstText.focus());
          });
          addTableButtons(newRow);
          thisTbody.appendChild(newRow);
          $(thisTbody).trigger('change');
        }, true);
        $(addRowButton).insertAfter($thisOptionSetting);
        makeOptionTableSortable(thisTbody);
      }
    } else if (option.type === 'builder') {
      $thisOptionContainer.addClass('specialOptionType');
      $thisOptionDescription.insertAfter($thisLabel);
      thisOptionFormEle = caseBuilder_namespaceObject.drawOptionBuilder(thisOptions, mod, optionKey);
    } else {
      if (option.type === 'text' || option.type === 'password' || option.type === 'keycode') {
        $thisOptionDescription.addClass('textInput');
      }

      thisOptionFormEle = drawOptionInput(mod, optionKey, option);
      $thisOptionContainer.append($thisOptionDescription);
    }

    $thisOptionSetting.append(thisOptionFormEle);
    return $thisOptionContainer.get(0);
  }).filter(Boolean));
  RESConfigPanelOptions.querySelector('#noOptions').style.display = 'none';

  if (!optCount && mod.alwaysEnabled) {} else if (optCount === 0) {
    RESConfigPanelOptions.querySelector('#noOptions').style.display = 'block';
  } else {
    $moduleOptionsScrim = $('<div>', {
      id: 'moduleOptionsScrim'
    }).toggleClass('visible', !modules_isEnabled(mod)).appendTo(allOptionsContainer);
  }

  function addTableButtons(thisTR) {
    let thisTD = document.createElement('td');
    const thisDeleteButton = document.createElement('div');
    thisDeleteButton.className = 'res-icon-button res-icon deleteButton';
    thisDeleteButton.textContent = '\uF056';
    thisDeleteButton.title = 'remove this row';
    thisDeleteButton.addEventListener('click', e => {
      if (!confirm('Are you sure you want to delete this row?')) {
        e.preventDefault();
        return;
      }

      deleteOptionRow(e);
    });
    thisTD.appendChild(thisDeleteButton);
    thisTR.appendChild(thisTD);
    thisTD = document.createElement('td');
    const thisHandle = document.createElement('div');
    thisHandle.className = 'res-icon-button res-icon handle';
    thisHandle.textContent = '\uF0AA';
    thisHandle.title = 'drag and drop to move this row';
    thisTD.appendChild(thisHandle);
    thisTR.prepend(thisTD);
  }
}

function showOption(moduleID, fieldID) {
  $(`#optionContainer-${moduleID}-${fieldID}`).slideDown();
}

function hideOption(moduleID, fieldID) {
  $(`#optionContainer-${moduleID}-${fieldID}`).slideUp();
}

function deleteOptionRow(e) {
  const thisRow = e.target.parentNode.parentNode;
  $(thisRow).trigger('change').remove();
}

const autostageDebounce = frameDebounce(stageCurrentModuleOptions);

function stageCurrentModuleOptions() {
  const panelOptionsDiv = RESConfigPanelOptions;
  $(panelOptionsDiv).find('.optionContainer:not(.specialOptionType)').find('input, select, textarea').each((i, e) => {
    const input = e;

    if (input.getAttribute('type') !== 'button' && input.getAttribute('displayonly') !== 'true' && input.getAttribute('tableOption') !== 'true') {
      let optionName;

      if (input.getAttribute('type') === 'radio') {
        optionName = input.getAttribute('name');
      } else {
        optionName = input.getAttribute('id');
      }

      let optionValue;

      if (input.getAttribute('type') === 'checkbox') {
        optionValue = !!input.checked;
      } else if (input.getAttribute('type') === 'radio') {
        if (input.checked) {
          optionValue = input.value;
        }
      } else if (input.getAttribute('class') && input.getAttribute('class').includes('keycode')) {
        const tempArray = input.value.split(',');
        optionValue = [parseInt(tempArray[0], 10), tempArray[1] === 'true', tempArray[2] === 'true', tempArray[3] === 'true', tempArray[4] === 'true'];
      } else {
        optionValue = input.value;
      }

      if (typeof optionValue !== 'undefined') {
        stage_namespaceObject.add(currentModule.moduleID, optionName, optionValue);
      }
    }
  });
  const optionsTables = panelOptionsDiv.querySelectorAll('.optionsTable');

  for (const table of optionsTables) {
    const moduleID = table.getAttribute('moduleID');
    const optionName = table.getAttribute('optionName');
    const thisTBODY = table.querySelector('tbody');
    const thisRows = thisTBODY.querySelectorAll('tr');
    const optionMulti = Array.from(thisRows).map(row => {
      const cells = row.querySelectorAll('td.hasTableOption');
      let notAllBlank = false;
      const optionRow = Array.from(cells).map(cell => {
        const inputs = cell.querySelectorAll('input[tableOption=true], select[tableOption=true], textarea[tableOption=true]');
        let optionValue = null;

        for (const input of inputs) {
          if (input.getAttribute('type') === 'checkbox') {
            optionValue = input.checked;
          } else if (input.getAttribute('type') === 'radio') {
            if (input.checked) {
              optionValue = input.value;
            }
          } else if (input.getAttribute('class') && input.getAttribute('class').includes('keycode')) {
            const tempArray = input.value.split(',');
            optionValue = [parseInt(tempArray[0], 10), tempArray[1] === 'true', tempArray[2] === 'true', tempArray[3] === 'true'];
          } else {
            optionValue = input.value;
          }

          if (optionValue !== '' && input.getAttribute('type') !== 'radio' && !(Array.isArray(optionValue) && isNaN(optionValue[0]))) {
            notAllBlank = true;
          }
        }

        return optionValue;
      });

      if (notAllBlank) {
        return optionRow;
      }
    }).filter(optionRow => Array.isArray(optionRow) && optionRow.length > 0);
    const mod = modules_get(moduleID);

    if (typeof mod.options[optionName].sort === 'function') {
      optionMulti.sort(mod.options[optionName].sort);
    }

    stage_namespaceObject.add(moduleID, optionName, optionMulti);
  }

  $(panelOptionsDiv).find('.optionBuilder').each(function (i, builder) {
    const moduleId = this.dataset.moduleId;
    const optionName = this.dataset.optionName;
    const {
      customOptionsFields,
      cases
    } = modules_get(moduleId).options[optionName];
    const items = [];
    $(builder).find('.builderItem').each(function () {
      try {
        items.push(caseBuilder_namespaceObject.readBuilderItem(this, customOptionsFields, cases));
      } catch (e) {
        console.error('Ignoring invalid item.', e);
      }
    });
    stage_namespaceObject.add(moduleId, optionName, items);
  });
  updateSaveButton();
  updateDependsOn(currentModule);
}

function saveCurrentModuleOptions() {
  stageCurrentModuleOptions();
  stage_namespaceObject.commit();
  updateSaveButton();
  notifyOptionsSaved();
}

function updateSaveButton() {
  const unsavedOptions = stage_namespaceObject.isDirty();
  $(settingsConsole_saveButton).toggleClass('optionsSaved', !unsavedOptions);
}

function updateDependsOn(mod) {
  const thisOptions = settingsConsole_getOptions(mod);

  for (const [optionKey, option] of Object.entries(thisOptions)) {
    if (option.dependsOn) {
      if (option.dependsOn(thisOptions)) {
        showOption(mod.moduleID, optionKey);
      } else {
        hideOption(mod.moduleID, optionKey);
      }
    }
  }
}

function handleEscapeKey(event) {
  if (event.key === NAMED_KEYS.Escape) {
    settingsConsole_close();
  }
}

function handleBeforeUnload() {
  if (stage_namespaceObject.isDirty()) {
    return abandonChangesConfirmation;
  }
}

function settingsConsole_close({
  promptIfStagedOptions = true
} = {}) {
  if (promptIfStagedOptions && stage_namespaceObject.isDirty()) {
    const abandonChanges = confirm(abandonChangesConfirmation);
    if (!abandonChanges) return;
  }

  settingsNavigation_close();
}

function openCategoryPanel(category) {
  const items = $(RESConsoleContainer).find('#RESConfigPanelModulesList .RESConfigPanelCategory');
  const selected = items.filter(`[data-category=${category}]`);
  items.not(selected).removeClass('active');
  selected.addClass('active');
}

function updateAdvancedOptionsVisibility() {
  if (settingsNavigation_module.options.showAllOptions.value) {
    document.getElementById('RESConsoleContent').classList.remove('advanced-options-disabled');
  } else {
    document.getElementById('RESConsoleContent').classList.add('advanced-options-disabled');
  }
}

function makeOptionTableSortable(tableBody) {
  const edgeScroll = new dom_EdgeScroll(tableBody);
  $(tableBody).sortable({
    nested: false,
    handle: '.handle',
    placeholderClass: 'RESSortPlaceholder',
    placeholder: '<tr class="RESSortPlaceholder"><td></td></tr>',
    containerSelector: 'tbody',
    itemSelector: 'tr',

    onDrop($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.stop();
      $item.trigger('change');
    },

    onDragStart($item, container, _super, event) {
      _super($item, container, _super, event);

      edgeScroll.start();
    }

  });
}

function settingsConsole_getOptions(mod) {
  const staged = stage_namespaceObject.get(mod.moduleID);
  return lodash_mapValues_default()(mod.options, (stored, key) => ({ ...stored,
    ...(staged && staged[key])
  }));
}

const abandonChangesConfirmation = 'Abandon your changes to RES settings?';

function notifyOptionsSaved() {
  const statusEle = RESConsoleContainer.querySelector('#moduleOptionsSaveStatus');

  if (statusEle) {
    statusEle.setAttribute('style', 'display: block; opacity: 1');
    setTimeout(() => $(statusEle).fadeOut(1000), 500);
  }
}
// CONCATENATED MODULE: ./node_modules/sibling-loader!./lib/environment/foreground/messaging.js
/* generated by sibling-loader */
















/* harmony default export */ var messaging = ({ "ajax.js": ajax_namespaceObject, "auth.js": auth_namespaceObject, "context.js": context_namespaceObject, "download.js": download_namespaceObject, "history.js": history_namespaceObject, "i18n.js": i18n_namespaceObject, "id.js": id_namespaceObject, "messaging.js": foreground_messaging_namespaceObject, "multicast.js": multicast_namespaceObject, "pageAction.js": pageAction_namespaceObject, "permissions.js": permissions_namespaceObject, "privateBrowsing.js": privateBrowsing_namespaceObject, "session.js": session_namespaceObject, "storage.js": storage_namespaceObject, "tabs.js": tabs_namespaceObject, "xhrCache.js": xhrCache_namespaceObject });
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--5-0!./lib/options/options.entry.js






new Promise(res => {
  if (window === window.top) {
    res();
  } else {
    window.addEventListener('message', function waitForContext({
      data: {
        context
      }
    }) {
      Object.assign(context_data, context);
      window.removeEventListener('message', waitForContext, true);
      res();
    }, true);
  }
}).then(async () => {
  allowedModules.push('nightMode', 'notifications');
  init();
  await init_loadOptions;
  settingsConsole_start();

  if (window !== window.top) {
    window.parent.postMessage({
      loadSuccess: true
    }, '*');
  }
}).catch(() => {
  window.parent.postMessage({
    failedToLoad: true
  }, '*');
});

/***/ })
/******/ ]);
//# sourceMappingURL=options.entry.js.map